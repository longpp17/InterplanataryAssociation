// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"agbMw":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "de54e247da5c3d91";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"judLg":[function(require,module,exports) {
// Creating a libp2p node with:
//   transport: websockets + tcp
//   stream-muxing: mplex
//   crypto-channel: noise
//   discovery: multicast-dns
//   dht: kad-dht
//   pubsub: gossipsub
// milestones:
// stage 1
// 1. create a libp2p node
// 2. create a always on relay node on the server
// 3. create agent on local machines to default use that relay node as bootstrap node
// 4. connect with other node in other NAT (requires punching holes)
// 5. sending messages
// 6. broadcast messages
// 7. capture local sound
// 8. broadcast sound
// 9. merge sound together
// todo: peer routing
// DO NOT COMMIT PEER LINK INTO GIT!!!
var _libp2P = require("libp2p");
var _bootstrap = require("@libp2p/bootstrap");
var _libp2PNoise = require("@chainsafe/libp2p-noise");
var _libp2PYamux = require("@chainsafe/libp2p-yamux");
var _circuitRelayV2 = require("@libp2p/circuit-relay-v2");
var _identify = require("@libp2p/identify");
var _upnpNat = require("@libp2p/upnp-nat");
var _autonat = require("@libp2p/autonat");
var _webrtc = require("@libp2p/webrtc");
var _tcp = require("@libp2p/tcp");
async function setupLibp2p() {
    const libp2p = await (0, _libp2P.createLibp2p)({
        transports: [
            (0, _tcp.tcp)(),
            (0, _webrtc.webRTC)(),
            (0, _circuitRelayV2.circuitRelayTransport)({
                discoverRelays: 2
            })
        ],
        connectionEncryption: [
            (0, _libp2PNoise.noise)()
        ],
        streamMuxers: [
            (0, _libp2PYamux.yamux)
        ],
        services: {
            upnpNAT: (0, _upnpNat.uPnPNAT)(),
            identify: (0, _identify.identify)(),
            autoNAT: (0, _autonat.autoNAT)()
        },
        peerDiscovery: [
            (0, _bootstrap.bootstrap)({
                list: [
                    // a list of bootstrap peer multiaddrs to connect to on node startup
                    // adding relay node in here
                    "/ip4/136.244.110.156/tcp/39611/p2p/12D3KooWRMZL7XG5SLFjNqVgwMjrkJc2yvqAwgBtPjgUng7Makma",
                    "/ip4/127.0.0.1/tcp/54323/p2p/12D3KooWHk7WDTK27Bkx2GzB2mfowQvcuU7pHwRByFK6Eo3u5yxn",
                    "/ip4/104.131.131.82/tcp/4001/ipfs/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ",
                    "/dnsaddr/bootstrap.libp2p.io/ipfs/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
                    "/dnsaddr/bootstrap.libp2p.io/ipfs/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa"
                ]
            })
        ]
    });
    libp2p.addEventListener("peer:discovery", (evt)=>{
        console.log("found peer: ", evt.detail.id.toString());
    });
    libp2p.addEventListener("self:peer:update", (evt)=>{
        console.log(`Advertising with a relay address of ${libp2p.getMultiaddrs()[0].toString()}`);
    });
    return libp2p;
}
setupLibp2p().then((libp2p)=>{
    console.log("Libp2p has been set up");
    // Here you can start libp2p or do other operations with it
    libp2p.getMultiaddrs().forEach((addr)=>{
        console.log(`libp2p node is listening on address ${addr.toString()}`);
        console.log("Peer Id: ", libp2p.peerId.toString());
    });
});

},{"libp2p":"pJhyA","@libp2p/bootstrap":"l5BsY","@chainsafe/libp2p-noise":"eSsJA","@chainsafe/libp2p-yamux":"7mg3b","@libp2p/circuit-relay-v2":"hZ6qV","@libp2p/identify":"ddGSU","@libp2p/upnp-nat":"ifKPW","@libp2p/autonat":"iDsuH","@libp2p/webrtc":"efL9w","@libp2p/tcp":"aE1n7"}],"pJhyA":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Use the `createLibp2p` function to create a libp2p node.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 *
 * const node = await createLibp2p({
 *   // ...other options
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a new instance of the Libp2p interface, generating a new PeerId
 * if one is not passed as part of the options.
 *
 * The node will be started unless `start: false` is passed as an option.
 *
 * @example
 *
 * ```js
 * import { createLibp2p } from 'libp2p'
 * import { tcp } from '@libp2p/tcp'
 * import { mplex } from '@libp2p/mplex'
 * import { noise } from '@chainsafe/libp2p-noise'
 * import { yamux } from '@chainsafe/libp2p-yamux'
 *
 * // specify options
 * const options = {
 *   transports: [tcp()],
 *   streamMuxers: [yamux(), mplex()],
 *   connectionEncryption: [noise()]
 * }
 *
 * // create libp2p
 * const libp2p = await createLibp2p(options)
 * ```
 */ parcelHelpers.export(exports, "createLibp2p", ()=>createLibp2p);
var _libp2PJs = require("./libp2p.js");
async function createLibp2p(options = {}) {
    const node = await (0, _libp2PJs.createLibp2pNode)(options);
    if (options.start !== false) await node.start();
    return node;
}

},{"./libp2p.js":"6m06w","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6m06w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Libp2pNode", ()=>Libp2pNode);
/**
 * Returns a new Libp2pNode instance - this exposes more of the internals than the
 * libp2p interface and is useful for testing and debugging.
 */ parcelHelpers.export(exports, "createLibp2pNode", ()=>createLibp2pNode);
var _keys = require("@libp2p/crypto/keys");
var _interface = require("@libp2p/interface");
var _logger = require("@libp2p/logger");
var _peerCollections = require("@libp2p/peer-collections");
var _peerId = require("@libp2p/peer-id");
var _peerIdFactory = require("@libp2p/peer-id-factory");
var _peerStore = require("@libp2p/peer-store");
var _multiaddr = require("@multiformats/multiaddr");
var _memory = require("datastore-core/memory");
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
var _indexJs = require("./address-manager/index.js");
var _componentsJs = require("./components.js");
var _connectionGaterJs = require("./config/connection-gater.js");
var _configJs = require("./config.js");
var _indexJs1 = require("./connection-manager/index.js");
var _contentRoutingJs = require("./content-routing.js");
var _errorsJs = require("./errors.js");
var _peerRoutingJs = require("./peer-routing.js");
var _registrarJs = require("./registrar.js");
var _transportManagerJs = require("./transport-manager.js");
var _upgraderJs = require("./upgrader.js");
var _versionJs = require("./version.js");
class Libp2pNode extends (0, _interface.TypedEventEmitter) {
    peerId;
    peerStore;
    contentRouting;
    peerRouting;
    metrics;
    services;
    logger;
    status;
    components;
    log;
    constructor(init){
        super();
        this.status = "stopped";
        // event bus - components can listen to this emitter to be notified of system events
        // and also cause them to be emitted
        const events = new (0, _interface.TypedEventEmitter)();
        const originalDispatch = events.dispatchEvent.bind(events);
        events.dispatchEvent = (evt)=>{
            const internalResult = originalDispatch(evt);
            const externalResult = this.dispatchEvent(new (0, _interface.CustomEvent)(evt.type, {
                detail: evt.detail
            }));
            return internalResult || externalResult;
        };
        // This emitter gets listened to a lot
        (0, _interface.setMaxListeners)(Infinity, events);
        this.peerId = init.peerId;
        this.logger = init.logger ?? (0, _logger.defaultLogger)();
        this.log = this.logger.forComponent("libp2p");
        // @ts-expect-error {} may not be of type T
        this.services = {};
        const components = this.components = (0, _componentsJs.defaultComponents)({
            peerId: init.peerId,
            privateKey: init.privateKey,
            nodeInfo: init.nodeInfo ?? {
                name: _versionJs.name,
                version: _versionJs.version
            },
            logger: this.logger,
            events,
            datastore: init.datastore ?? new (0, _memory.MemoryDatastore)(),
            connectionGater: (0, _connectionGaterJs.connectionGater)(init.connectionGater)
        });
        this.peerStore = this.configureComponent("peerStore", new (0, _peerStore.PersistentPeerStore)(components, {
            addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
            ...init.peerStore
        }));
        // Create Metrics
        if (init.metrics != null) this.metrics = this.configureComponent("metrics", init.metrics(this.components));
        components.events.addEventListener("peer:update", (evt)=>{
            // if there was no peer previously in the peer store this is a new peer
            if (evt.detail.previous == null) {
                const peerInfo = {
                    id: evt.detail.peer.id,
                    multiaddrs: evt.detail.peer.addresses.map((a)=>a.multiaddr)
                };
                components.events.safeDispatchEvent("peer:discovery", {
                    detail: peerInfo
                });
            }
        });
        // Set up connection protector if configured
        if (init.connectionProtector != null) this.configureComponent("connectionProtector", init.connectionProtector(components));
        // Set up the Upgrader
        this.components.upgrader = new (0, _upgraderJs.DefaultUpgrader)(this.components, {
            connectionEncryption: (init.connectionEncryption ?? []).map((fn, index)=>this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
            muxers: (init.streamMuxers ?? []).map((fn, index)=>this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
            inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
        });
        // Setup the transport manager
        this.configureComponent("transportManager", new (0, _transportManagerJs.DefaultTransportManager)(this.components, init.transportManager));
        // Create the Connection Manager
        this.configureComponent("connectionManager", new (0, _indexJs1.DefaultConnectionManager)(this.components, init.connectionManager));
        // Create the Registrar
        this.configureComponent("registrar", new (0, _registrarJs.DefaultRegistrar)(this.components));
        // Addresses {listen, announce, noAnnounce}
        this.configureComponent("addressManager", new (0, _indexJs.DefaultAddressManager)(this.components, init.addresses));
        // Peer routers
        const peerRouters = (init.peerRouters ?? []).map((fn, index)=>this.configureComponent(`peer-router-${index}`, fn(this.components)));
        this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new (0, _peerRoutingJs.DefaultPeerRouting)(this.components, {
            routers: peerRouters
        }));
        // Content routers
        const contentRouters = (init.contentRouters ?? []).map((fn, index)=>this.configureComponent(`content-router-${index}`, fn(this.components)));
        this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new (0, _contentRoutingJs.CompoundContentRouting)(this.components, {
            routers: contentRouters
        }));
        (init.peerDiscovery ?? []).forEach((fn, index)=>{
            const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
            service.addEventListener("peer", (evt)=>{
                this.#onDiscoveryPeer(evt);
            });
        });
        // Transport modules
        init.transports?.forEach((fn, index)=>{
            this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
        });
        // User defined modules
        if (init.services != null) for (const name of Object.keys(init.services)){
            const createService = init.services[name];
            const service = createService(this.components);
            if (service == null) {
                this.log.error("service factory %s returned null or undefined instance", name);
                continue;
            }
            this.services[name] = service;
            this.configureComponent(name, service);
            if (service[0, _interface.contentRoutingSymbol] != null) {
                this.log("registering service %s for content routing", name);
                contentRouters.push(service[0, _interface.contentRoutingSymbol]);
            }
            if (service[0, _interface.peerRoutingSymbol] != null) {
                this.log("registering service %s for peer routing", name);
                peerRouters.push(service[0, _interface.peerRoutingSymbol]);
            }
            if (service[0, _interface.peerDiscoverySymbol] != null) {
                this.log("registering service %s for peer discovery", name);
                service[0, _interface.peerDiscoverySymbol].addEventListener?.("peer", (evt)=>{
                    this.#onDiscoveryPeer(evt);
                });
            }
        }
    }
    configureComponent(name, component) {
        if (component == null) this.log.error("component %s was null or undefined", name);
        this.components[name] = component;
        return component;
    }
    /**
     * Starts the libp2p node and all its subsystems
     */ async start() {
        if (this.status !== "stopped") return;
        this.status = "starting";
        this.log("libp2p is starting");
        try {
            await this.components.beforeStart?.();
            await this.components.start();
            await this.components.afterStart?.();
            this.status = "started";
            this.safeDispatchEvent("start", {
                detail: this
            });
            this.log("libp2p has started");
        } catch (err) {
            this.log.error("An error occurred starting libp2p", err);
            // set status to 'started' so this.stop() will stop any running components
            this.status = "started";
            await this.stop();
            throw err;
        }
    }
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */ async stop() {
        if (this.status !== "started") return;
        this.log("libp2p is stopping");
        this.status = "stopping";
        await this.components.beforeStop?.();
        await this.components.stop();
        await this.components.afterStop?.();
        this.status = "stopped";
        this.safeDispatchEvent("stop", {
            detail: this
        });
        this.log("libp2p has stopped");
    }
    getConnections(peerId) {
        return this.components.connectionManager.getConnections(peerId);
    }
    getDialQueue() {
        return this.components.connectionManager.getDialQueue();
    }
    getPeers() {
        const peerSet = new (0, _peerCollections.PeerSet)();
        for (const conn of this.components.connectionManager.getConnections())peerSet.add(conn.remotePeer);
        return Array.from(peerSet);
    }
    async dial(peer, options = {}) {
        return this.components.connectionManager.openConnection(peer, {
            // ensure any userland dials take top priority in the queue
            priority: 75,
            ...options
        });
    }
    async dialProtocol(peer, protocols, options = {}) {
        if (protocols == null) throw new (0, _interface.CodeError)("no protocols were provided to open a stream", (0, _errorsJs.codes).ERR_INVALID_PROTOCOLS_FOR_STREAM);
        protocols = Array.isArray(protocols) ? protocols : [
            protocols
        ];
        if (protocols.length === 0) throw new (0, _interface.CodeError)("no protocols were provided to open a stream", (0, _errorsJs.codes).ERR_INVALID_PROTOCOLS_FOR_STREAM);
        const connection = await this.dial(peer, options);
        return connection.newStream(protocols, options);
    }
    getMultiaddrs() {
        return this.components.addressManager.getAddresses();
    }
    getProtocols() {
        return this.components.registrar.getProtocols();
    }
    async hangUp(peer, options = {}) {
        if ((0, _multiaddr.isMultiaddr)(peer)) peer = (0, _peerId.peerIdFromString)(peer.getPeerId() ?? "");
        await this.components.connectionManager.closeConnections(peer, options);
    }
    /**
     * Get the public key for the given peer id
     */ async getPublicKey(peer, options = {}) {
        this.log("getPublicKey %p", peer);
        if (peer.publicKey != null) return peer.publicKey;
        try {
            const peerInfo = await this.peerStore.get(peer);
            if (peerInfo.id.publicKey != null) return peerInfo.id.publicKey;
        } catch (err) {
            if (err.code !== (0, _errorsJs.codes).ERR_NOT_FOUND) throw err;
        }
        const peerKey = (0, _concat.concat)([
            (0, _fromString.fromString)("/pk/"),
            peer.multihash.digest
        ]);
        // search any available content routing methods
        const bytes = await this.contentRouting.get(peerKey, options);
        // ensure the returned key is valid
        (0, _keys.unmarshalPublicKey)(bytes);
        await this.peerStore.patch(peer, {
            publicKey: bytes
        });
        return bytes;
    }
    async handle(protocols, handler, options) {
        if (!Array.isArray(protocols)) protocols = [
            protocols
        ];
        await Promise.all(protocols.map(async (protocol)=>{
            await this.components.registrar.handle(protocol, handler, options);
        }));
    }
    async unhandle(protocols) {
        if (!Array.isArray(protocols)) protocols = [
            protocols
        ];
        await Promise.all(protocols.map(async (protocol)=>{
            await this.components.registrar.unhandle(protocol);
        }));
    }
    async register(protocol, topology) {
        return this.components.registrar.register(protocol, topology);
    }
    unregister(id) {
        this.components.registrar.unregister(id);
    }
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */ #onDiscoveryPeer(evt) {
        const { detail: peer } = evt;
        if (peer.id.toString() === this.peerId.toString()) {
            this.log.error(new Error((0, _errorsJs.codes).ERR_DISCOVERED_SELF));
            return;
        }
        this.components.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
        }).catch((err)=>{
            this.log.error(err);
        });
    }
}
async function createLibp2pNode(options = {}) {
    const peerId = options.peerId ??= await (0, _peerIdFactory.createEd25519PeerId)();
    if (peerId.privateKey == null) throw new (0, _interface.CodeError)("peer id was missing private key", "ERR_MISSING_PRIVATE_KEY");
    options.privateKey ??= await (0, _keys.unmarshalPrivateKey)(peerId.privateKey);
    return new Libp2pNode(await (0, _configJs.validateConfig)(options));
}

},{"@libp2p/crypto/keys":"LlEWq","@libp2p/interface":"b14bx","@libp2p/logger":"aeh5U","@libp2p/peer-collections":"jqBHH","@libp2p/peer-id":"8wBUr","@libp2p/peer-id-factory":"7WdjB","@libp2p/peer-store":"3z6QI","@multiformats/multiaddr":"7Qpz2","datastore-core/memory":"ipHme","uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","./address-manager/index.js":"e0oKn","./components.js":"2f57U","./config/connection-gater.js":"2AmjA","./config.js":"iJ0mm","./connection-manager/index.js":"5sare","./content-routing.js":"fgLfY","./errors.js":"ayaP8","./peer-routing.js":"6qx0B","./registrar.js":"1YGrc","./transport-manager.js":"lE30Z","./upgrader.js":"2Ewxj","./version.js":"7zAVS","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"LlEWq":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * **Supported Key Types**
 *
 * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.
 *
 * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.
 *
 * For encryption / decryption support, RSA keys should be used.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RsaPrivateKey", ()=>(0, _rsaClassJs.RsaPrivateKey));
parcelHelpers.export(exports, "RsaPublicKey", ()=>(0, _rsaClassJs.RsaPublicKey));
parcelHelpers.export(exports, "MAX_RSA_KEY_SIZE", ()=>(0, _rsaClassJs.MAX_RSA_KEY_SIZE));
parcelHelpers.export(exports, "Ed25519PrivateKey", ()=>(0, _ed25519ClassJs.Ed25519PrivateKey));
parcelHelpers.export(exports, "Ed25519PublicKey", ()=>(0, _ed25519ClassJs.Ed25519PublicKey));
parcelHelpers.export(exports, "Secp256k1PrivateKey", ()=>(0, _secp256K1ClassJs.Secp256k1PrivateKey));
parcelHelpers.export(exports, "Secp256k1PublicKey", ()=>(0, _secp256K1ClassJs.Secp256k1PublicKey));
parcelHelpers.export(exports, "keyStretcher", ()=>(0, _keyStretcherJs.keyStretcher));
parcelHelpers.export(exports, "generateEphemeralKeyPair", ()=>(0, _ephemeralKeysJsDefault.default));
parcelHelpers.export(exports, "keysPBM", ()=>_keysJs);
parcelHelpers.export(exports, "supportedKeys", ()=>supportedKeys);
/**
 * Generates a keypair of the given type and bitsize
 *
 * @param type
 * @param bits -  Minimum of 1024
 */ parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
/**
 * Generates a keypair of the given type and bitsize.
 *
 * Seed is a 32 byte uint8array
 */ parcelHelpers.export(exports, "generateKeyPairFromSeed", ()=>generateKeyPairFromSeed);
/**
 * Converts a protobuf serialized public key into its representative object
 */ parcelHelpers.export(exports, "unmarshalPublicKey", ()=>unmarshalPublicKey);
/**
 * Converts a public key object into a protobuf serialized public key
 */ parcelHelpers.export(exports, "marshalPublicKey", ()=>marshalPublicKey);
/**
 * Converts a protobuf serialized private key into its representative object
 */ parcelHelpers.export(exports, "unmarshalPrivateKey", ()=>unmarshalPrivateKey);
/**
 * Converts a private key object into a protobuf serialized private key
 */ parcelHelpers.export(exports, "marshalPrivateKey", ()=>marshalPrivateKey);
/**
 * Converts an exported private key into its representative object.
 *
 * Supported formats are 'pem' (RSA only) and 'libp2p-key'.
 */ parcelHelpers.export(exports, "importKey", ()=>importKey);
var _interface = require("@libp2p/interface");
var _ed25519ClassJs = require("./ed25519-class.js");
var _ephemeralKeysJs = require("./ephemeral-keys.js");
var _ephemeralKeysJsDefault = parcelHelpers.interopDefault(_ephemeralKeysJs);
var _importerJs = require("./importer.js");
var _keyStretcherJs = require("./key-stretcher.js");
var _keysJs = require("./keys.js");
var _rsaClassJs = require("./rsa-class.js");
var _rsaUtilsJs = require("./rsa-utils.js");
var _secp256K1ClassJs = require("./secp256k1-class.js");
const supportedKeys = {
    rsa: _rsaClassJs,
    ed25519: _ed25519ClassJs,
    secp256k1: _secp256K1ClassJs
};
function unsupportedKey(type) {
    const supported = Object.keys(supportedKeys).join(" / ");
    return new (0, _interface.CodeError)(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
    type = type.toLowerCase();
    if (type === "rsa" || type === "ed25519" || type === "secp256k1") return supportedKeys[type];
    throw unsupportedKey(type);
}
async function generateKeyPair(type, bits) {
    return typeToKey(type).generateKeyPair(bits ?? 2048);
}
async function generateKeyPairFromSeed(type, seed, bits) {
    if (type.toLowerCase() !== "ed25519") throw new (0, _interface.CodeError)("Seed key derivation is unimplemented for RSA or secp256k1", "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
    return _ed25519ClassJs.generateKeyPairFromSeed(seed);
}
function unmarshalPublicKey(buf) {
    const decoded = _keysJs.PublicKey.decode(buf);
    const data = decoded.Data ?? new Uint8Array();
    switch(decoded.Type){
        case _keysJs.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPublicKey(data);
        case _keysJs.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
        case _keysJs.KeyType.Secp256k1:
            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
        default:
            throw unsupportedKey(decoded.Type ?? "unknown");
    }
}
function marshalPublicKey(key, type) {
    type = (type ?? "rsa").toLowerCase();
    typeToKey(type); // check type
    return key.bytes;
}
async function unmarshalPrivateKey(buf) {
    const decoded = _keysJs.PrivateKey.decode(buf);
    const data = decoded.Data ?? new Uint8Array();
    switch(decoded.Type){
        case _keysJs.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
        case _keysJs.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
        case _keysJs.KeyType.Secp256k1:
            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
        default:
            throw unsupportedKey(decoded.Type ?? "RSA");
    }
}
function marshalPrivateKey(key, type) {
    type = (type ?? "rsa").toLowerCase();
    typeToKey(type); // check type
    return key.bytes;
}
async function importKey(encryptedKey, password) {
    try {
        const key = await (0, _importerJs.importer)(encryptedKey, password);
        return await unmarshalPrivateKey(key);
    } catch (_) {
    // Ignore and try the old pem decrypt
    }
    if (!encryptedKey.includes("BEGIN")) throw new (0, _interface.CodeError)("Encrypted key was not a libp2p-key or a PEM file", "ERR_INVALID_IMPORT_FORMAT");
    return (0, _rsaUtilsJs.importFromPem)(encryptedKey, password);
}

},{"@libp2p/interface":"b14bx","./ed25519-class.js":"lY7j2","./ephemeral-keys.js":false,"./importer.js":"9qjoY","./key-stretcher.js":false,"./keys.js":"fwqFh","./rsa-class.js":"5oJln","./rsa-utils.js":"kGDMT","./secp256k1-class.js":"e3TYG","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"b14bx":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Exports a `Libp2p` type for modules to use as a type argument.
 *
 * @example
 *
 * ```typescript
 * import type { Libp2p } from '@libp2p/interface'
 *
 * function doSomethingWithLibp2p (node: Libp2p) {
 *   // ...
 * }
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./connection/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var _indexJs1 = require("./connection-encrypter/index.js");
parcelHelpers.exportAll(_indexJs1, exports);
var _indexJs2 = require("./connection-gater/index.js");
parcelHelpers.exportAll(_indexJs2, exports);
var _indexJs3 = require("./content-routing/index.js");
parcelHelpers.exportAll(_indexJs3, exports);
var _indexJs4 = require("./keys/index.js");
parcelHelpers.exportAll(_indexJs4, exports);
var _indexJs5 = require("./metrics/index.js");
parcelHelpers.exportAll(_indexJs5, exports);
var _indexJs6 = require("./peer-discovery/index.js");
parcelHelpers.exportAll(_indexJs6, exports);
var _indexJs7 = require("./peer-id/index.js");
parcelHelpers.exportAll(_indexJs7, exports);
var _indexJs8 = require("./peer-info/index.js");
parcelHelpers.exportAll(_indexJs8, exports);
var _indexJs9 = require("./peer-routing/index.js");
parcelHelpers.exportAll(_indexJs9, exports);
var _indexJs10 = require("./peer-store/index.js");
parcelHelpers.exportAll(_indexJs10, exports);
var _tagsJs = require("./peer-store/tags.js");
parcelHelpers.exportAll(_tagsJs, exports);
var _indexJs11 = require("./pubsub/index.js");
parcelHelpers.exportAll(_indexJs11, exports);
var _indexJs12 = require("./record/index.js");
parcelHelpers.exportAll(_indexJs12, exports);
var _indexJs13 = require("./stream-handler/index.js");
parcelHelpers.exportAll(_indexJs13, exports);
var _indexJs14 = require("./stream-muxer/index.js");
parcelHelpers.exportAll(_indexJs14, exports);
var _indexJs15 = require("./topology/index.js");
parcelHelpers.exportAll(_indexJs15, exports);
var _indexJs16 = require("./transport/index.js");
parcelHelpers.exportAll(_indexJs16, exports);
var _errorsJs = require("./errors.js");
parcelHelpers.exportAll(_errorsJs, exports);
var _eventTargetJs = require("./event-target.js");
parcelHelpers.exportAll(_eventTargetJs, exports);
var _eventsJs = require("./events.js");
parcelHelpers.exportAll(_eventsJs, exports);
var _startableJs = require("./startable.js");
parcelHelpers.exportAll(_startableJs, exports);

},{"./connection/index.js":"hqhQn","./connection-encrypter/index.js":"b7vSZ","./connection-gater/index.js":"anbrG","./content-routing/index.js":"3V06V","./keys/index.js":"9HQPP","./metrics/index.js":"a1BO7","./peer-discovery/index.js":"1Zo3G","./peer-id/index.js":"4VlDi","./peer-info/index.js":"1xEta","./peer-routing/index.js":"id53c","./peer-store/index.js":"6tFOD","./peer-store/tags.js":"eJQbE","./pubsub/index.js":"9GwoN","./record/index.js":"l7qf8","./stream-handler/index.js":"4K7mT","./stream-muxer/index.js":"74866","./topology/index.js":"8aROj","./transport/index.js":"79P2l","./errors.js":"2FSSK","./event-target.js":"7NYfR","./events.js":"1BFM6","./startable.js":"hlP4J","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hqhQn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "connectionSymbol", ()=>connectionSymbol);
parcelHelpers.export(exports, "isConnection", ()=>isConnection);
const connectionSymbol = Symbol.for("@libp2p/connection");
function isConnection(other) {
    return other != null && Boolean(other[connectionSymbol]);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fD7H8":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"b7vSZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"anbrG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3V06V":[function(require,module,exports) {
/**
 * Any object that implements this Symbol as a property should return a
 * ContentRouting instance as the property value, similar to how
 * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.
 *
 * @example
 *
 * ```js
 * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'
 *
 * class MyContentRouter implements ContentRouting {
 *   get [contentRoutingSymbol] () {
 *     return this
 *   }
 *
 *   // ...other methods
 * }
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "contentRoutingSymbol", ()=>contentRoutingSymbol);
const contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9HQPP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Ed25519", ()=>Ed25519);
parcelHelpers.export(exports, "RSA", ()=>RSA);
parcelHelpers.export(exports, "secp256k1", ()=>secp256k1);
const Ed25519 = "Ed25519";
const RSA = "RSA";
const secp256k1 = "secp256k1";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"a1BO7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1Zo3G":[function(require,module,exports) {
/**
 * Any object that implements this Symbol as a property should return a
 * PeerDiscovery instance as the property value, similar to how
 * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.
 *
 * @example
 *
 * ```js
 * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'
 *
 * class MyPeerDiscoverer implements PeerDiscovery {
 *   get [peerDiscovery] () {
 *     return this
 *   }
 *
 *   // ...other methods
 * }
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "peerDiscoverySymbol", ()=>peerDiscoverySymbol);
const peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4VlDi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "peerIdSymbol", ()=>peerIdSymbol);
parcelHelpers.export(exports, "isPeerId", ()=>isPeerId);
const peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
    return other != null && Boolean(other[peerIdSymbol]);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1xEta":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"id53c":[function(require,module,exports) {
/**
 * Any object that implements this Symbol as a property should return a
 * PeerRouting instance as the property value, similar to how
 * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.
 *
 * @example
 *
 * ```js
 * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'
 *
 * class MyPeerRouter implements PeerRouting {
 *   get [peerRouting] () {
 *     return this
 *   }
 *
 *   // ...other methods
 * }
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "peerRoutingSymbol", ()=>peerRoutingSymbol);
const peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6tFOD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eJQbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KEEP_ALIVE", ()=>KEEP_ALIVE);
const KEEP_ALIVE = "keep-alive";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9GwoN":[function(require,module,exports) {
/**
 * On the producing side:
 * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.
 *
 * On the consuming side:
 * * Enforce the fields to be present, reject otherwise.
 * * Propagate only if the fields are valid and signature can be verified, reject otherwise.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StrictSign", ()=>StrictSign);
parcelHelpers.export(exports, "StrictNoSign", ()=>StrictNoSign);
parcelHelpers.export(exports, "TopicValidatorResult", ()=>TopicValidatorResult);
const StrictSign = "StrictSign";
const StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult) {
    /**
     * The message is considered valid, and it should be delivered and forwarded to the network
     */ TopicValidatorResult["Accept"] = "accept";
    /**
     * The message is neither delivered nor forwarded to the network
     */ TopicValidatorResult["Ignore"] = "ignore";
    /**
     * The message is considered invalid, and it should be rejected
     */ TopicValidatorResult["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"l7qf8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4K7mT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"74866":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8aROj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"79P2l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transportSymbol", ()=>transportSymbol);
parcelHelpers.export(exports, "isTransport", ()=>isTransport);
parcelHelpers.export(exports, "FaultTolerance", ()=>FaultTolerance);
const transportSymbol = Symbol.for("@libp2p/transport");
function isTransport(other) {
    return other != null && Boolean(other[transportSymbol]);
}
var FaultTolerance;
(function(FaultTolerance) {
    /**
     * should be used for failing in any listen circumstance
     */ FaultTolerance[FaultTolerance["FATAL_ALL"] = 0] = "FATAL_ALL";
    /**
     * should be used for not failing when not listening
     */ FaultTolerance[FaultTolerance["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2FSSK":[function(require,module,exports) {
/**
 * When this error is thrown it means an operation was aborted,
 * usually in response to the `abort` event being emitted by an
 * AbortSignal.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
parcelHelpers.export(exports, "CodeError", ()=>CodeError);
parcelHelpers.export(exports, "AggregateCodeError", ()=>AggregateCodeError);
parcelHelpers.export(exports, "UnexpectedPeerError", ()=>UnexpectedPeerError);
parcelHelpers.export(exports, "InvalidCryptoExchangeError", ()=>InvalidCryptoExchangeError);
parcelHelpers.export(exports, "InvalidCryptoTransmissionError", ()=>InvalidCryptoTransmissionError);
parcelHelpers.export(exports, "ERR_TIMEOUT", ()=>ERR_TIMEOUT);
parcelHelpers.export(exports, "ERR_INVALID_PARAMETERS", ()=>ERR_INVALID_PARAMETERS);
parcelHelpers.export(exports, "ERR_NOT_FOUND", ()=>ERR_NOT_FOUND);
parcelHelpers.export(exports, "ERR_INVALID_MESSAGE", ()=>ERR_INVALID_MESSAGE);
class AbortError extends Error {
    code;
    type;
    constructor(message = "The operation was aborted"){
        super(message);
        this.code = AbortError.code;
        this.type = AbortError.type;
    }
    static code = "ABORT_ERR";
    static type = "aborted";
}
class CodeError extends Error {
    code;
    props;
    constructor(message, code, props){
        super(message);
        this.code = code;
        this.name = props?.name ?? "CodeError";
        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions
    }
}
class AggregateCodeError extends AggregateError {
    code;
    props;
    constructor(errors, message, code, props){
        super(errors, message);
        this.code = code;
        this.name = props?.name ?? "AggregateCodeError";
        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions
    }
}
class UnexpectedPeerError extends Error {
    code;
    constructor(message = "Unexpected Peer"){
        super(message);
        this.code = UnexpectedPeerError.code;
    }
    static code = "ERR_UNEXPECTED_PEER";
}
class InvalidCryptoExchangeError extends Error {
    code;
    constructor(message = "Invalid crypto exchange"){
        super(message);
        this.code = InvalidCryptoExchangeError.code;
    }
    static code = "ERR_INVALID_CRYPTO_EXCHANGE";
}
class InvalidCryptoTransmissionError extends Error {
    code;
    constructor(message = "Invalid crypto transmission"){
        super(message);
        this.code = InvalidCryptoTransmissionError.code;
    }
    static code = "ERR_INVALID_CRYPTO_TRANSMISSION";
}
const ERR_TIMEOUT = "ERR_TIMEOUT";
const ERR_INVALID_PARAMETERS = "ERR_INVALID_PARAMETERS";
const ERR_NOT_FOUND = "ERR_NOT_FOUND";
const ERR_INVALID_MESSAGE = "ERR_INVALID_MESSAGE";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7NYfR":[function(require,module,exports) {
/**
 * An implementation of a typed event target
 * etc
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypedEventEmitter", ()=>TypedEventEmitter);
parcelHelpers.export(exports, "CustomEvent", ()=>CustomEvent);
class TypedEventEmitter extends EventTarget {
    #listeners = new Map();
    listenerCount(type) {
        const listeners = this.#listeners.get(type);
        if (listeners == null) return 0;
        return listeners.length;
    }
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
        let list = this.#listeners.get(type);
        if (list == null) {
            list = [];
            this.#listeners.set(type, list);
        }
        list.push({
            callback: listener,
            once: (options !== true && options !== false && options?.once) ?? false
        });
    }
    removeEventListener(type, listener, options) {
        super.removeEventListener(type.toString(), listener ?? null, options);
        let list = this.#listeners.get(type);
        if (list == null) return;
        list = list.filter(({ callback })=>callback !== listener);
        this.#listeners.set(type, list);
    }
    dispatchEvent(event) {
        const result = super.dispatchEvent(event);
        let list = this.#listeners.get(event.type);
        if (list == null) return result;
        list = list.filter(({ once })=>!once);
        this.#listeners.set(event.type, list);
        return result;
    }
    safeDispatchEvent(type, detail = {}) {
        return this.dispatchEvent(new CustomEvent(type, detail));
    }
}
/**
 * CustomEvent is a standard event but it's not supported by node.
 *
 * Remove this when https://github.com/nodejs/node/issues/40678 is closed.
 *
 * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
 */ class CustomEventPolyfill extends Event {
    /** Returns any custom data event was created with. Typically used for synthetic events. */ detail;
    constructor(message, data){
        super(message, data);
        // @ts-expect-error could be undefined
        this.detail = data?.detail;
    }
}
const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1BFM6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setMaxListeners", ()=>setMaxListeners);
var _events = require("events");
const setMaxListeners = (n, ...eventTargets)=>{
    try {
        (0, _events.setMaxListeners)(n, ...eventTargets);
    } catch  {
    // swallow error, gulp
    }
};

},{"events":"llbzd","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"llbzd":[function(require,module,exports) {
/** Noop for browser compatibility */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setMaxListeners", ()=>setMaxListeners);
function setMaxListeners() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hlP4J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isStartable", ()=>isStartable);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "stop", ()=>stop);
function isStartable(obj) {
    return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
    const startables = [];
    for (const obj of objs)if (isStartable(obj)) startables.push(obj);
    await Promise.all(startables.map(async (s)=>{
        if (s.beforeStart != null) await s.beforeStart();
    }));
    await Promise.all(startables.map(async (s)=>{
        await s.start();
    }));
    await Promise.all(startables.map(async (s)=>{
        if (s.afterStart != null) await s.afterStart();
    }));
}
async function stop(...objs) {
    const startables = [];
    for (const obj of objs)if (isStartable(obj)) startables.push(obj);
    await Promise.all(startables.map(async (s)=>{
        if (s.beforeStop != null) await s.beforeStop();
    }));
    await Promise.all(startables.map(async (s)=>{
        await s.stop();
    }));
    await Promise.all(startables.map(async (s)=>{
        if (s.afterStop != null) await s.afterStop();
    }));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lY7j2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Ed25519PublicKey", ()=>Ed25519PublicKey);
parcelHelpers.export(exports, "Ed25519PrivateKey", ()=>Ed25519PrivateKey);
parcelHelpers.export(exports, "unmarshalEd25519PrivateKey", ()=>unmarshalEd25519PrivateKey);
parcelHelpers.export(exports, "unmarshalEd25519PublicKey", ()=>unmarshalEd25519PublicKey);
parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
parcelHelpers.export(exports, "generateKeyPairFromSeed", ()=>generateKeyPairFromSeed);
var _interface = require("@libp2p/interface");
var _base58 = require("multiformats/bases/base58");
var _identity = require("multiformats/hashes/identity");
var _sha2 = require("multiformats/hashes/sha2");
var _equals = require("uint8arrays/equals");
var _utilJs = require("../util.js");
var _ed25519Js = require("./ed25519.js");
var _exporterJs = require("./exporter.js");
var _keysJs = require("./keys.js");
class Ed25519PublicKey {
    _key;
    constructor(key){
        this._key = ensureKey(key, _ed25519Js.publicKeyLength);
    }
    verify(data, sig) {
        return _ed25519Js.hashAndVerify(this._key, sig, data);
    }
    marshal() {
        return this._key;
    }
    get bytes() {
        return _keysJs.PublicKey.encode({
            Type: _keysJs.KeyType.Ed25519,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        if ((0, _utilJs.isPromise)(p)) return p.then(({ bytes })=>bytes);
        return p.bytes;
    }
}
class Ed25519PrivateKey {
    _key;
    _publicKey;
    // key       - 64 byte Uint8Array containing private key
    // publicKey - 32 byte Uint8Array containing public key
    constructor(key, publicKey){
        this._key = ensureKey(key, _ed25519Js.privateKeyLength);
        this._publicKey = ensureKey(publicKey, _ed25519Js.publicKeyLength);
    }
    sign(message) {
        return _ed25519Js.hashAndSign(this._key, message);
    }
    get public() {
        return new Ed25519PublicKey(this._publicKey);
    }
    marshal() {
        return this._key;
    }
    get bytes() {
        return _keysJs.PrivateKey.encode({
            Type: _keysJs.KeyType.Ed25519,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    async hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        let bytes;
        if ((0, _utilJs.isPromise)(p)) ({ bytes } = await p);
        else bytes = p.bytes;
        return bytes;
    }
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the identity multihash containing its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     *
     * @returns {Promise<string>}
     */ async id() {
        const encoding = (0, _identity.identity).digest(this.public.bytes);
        return (0, _base58.base58btc).encode(encoding.bytes).substring(1);
    }
    /**
     * Exports the key into a password protected `format`
     */ async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") return (0, _exporterJs.exporter)(this.bytes, password);
        else throw new (0, _interface.CodeError)(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
}
function unmarshalEd25519PrivateKey(bytes) {
    // Try the old, redundant public key version
    if (bytes.length > _ed25519Js.privateKeyLength) {
        bytes = ensureKey(bytes, _ed25519Js.privateKeyLength + _ed25519Js.publicKeyLength);
        const privateKeyBytes = bytes.subarray(0, _ed25519Js.privateKeyLength);
        const publicKeyBytes = bytes.subarray(_ed25519Js.privateKeyLength, bytes.length);
        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
    }
    bytes = ensureKey(bytes, _ed25519Js.privateKeyLength);
    const privateKeyBytes = bytes.subarray(0, _ed25519Js.privateKeyLength);
    const publicKeyBytes = bytes.subarray(_ed25519Js.publicKeyLength);
    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes) {
    bytes = ensureKey(bytes, _ed25519Js.publicKeyLength);
    return new Ed25519PublicKey(bytes);
}
async function generateKeyPair() {
    const { privateKey, publicKey } = _ed25519Js.generateKey();
    return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed) {
    const { privateKey, publicKey } = _ed25519Js.generateKeyFromSeed(seed);
    return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length) throw new (0, _interface.CodeError)(`Key must be a Uint8Array of length ${length}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
    return key;
}

},{"@libp2p/interface":"b14bx","multiformats/bases/base58":"9K4Ju","multiformats/hashes/identity":"fYS82","multiformats/hashes/sha2":"9qYCS","uint8arrays/equals":"CKVqX","../util.js":"kswAQ","./ed25519.js":"cUZKV","./exporter.js":"87Mdx","./keys.js":"fwqFh","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9K4Ju":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base58btc", ()=>base58btc);
parcelHelpers.export(exports, "base58flickr", ()=>base58flickr);
var _baseJs = require("./base.js");
const base58btc = (0, _baseJs.baseX)({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = (0, _baseJs.baseX)({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eLJUA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "or", ()=>or);
parcelHelpers.export(exports, "Codec", ()=>Codec);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "baseX", ()=>baseX);
/**
 * RFC4648 Factory
 */ parcelHelpers.export(exports, "rfc4648", ()=>rfc4648);
var _bytesJs = require("../bytes.js");
var _baseXJs = require("../vendor/base-x.js");
var _baseXJsDefault = parcelHelpers.interopDefault(_baseXJs);
/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */ class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) return `${this.prefix}${this.baseEncode(bytes)}`;
        else throw Error("Unknown type, must be binary type");
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */ class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        /* c8 ignore next 3 */ if (prefix.codePointAt(0) === undefined) throw new Error("Invalid prefix character");
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(text.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) return decoder.decode(input);
        else throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
}
function or(left, right) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return new ComposedDecoder({
        ...left.decoders ?? {
            [left.prefix]: left
        },
        ...right.decoders ?? {
            [right.prefix]: right
        }
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function baseX({ name, prefix, alphabet }) {
    const { encode, decode } = (0, _baseXJsDefault.default)(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>(0, _bytesJs.coerce)(decode(text))
    });
}
function decode(string, alphabet, bitsPerChar, name) {
    // Build the character lookup table:
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i)codes[alphabet[i]] = i;
    // Count the padding bytes:
    let end = string.length;
    while(string[end - 1] === "=")--end;
    // Allocate the output:
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for(let i = 0; i < end; ++i){
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) throw new SyntaxError(`Non-${name} character`);
        // Append the bits to the buffer:
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & buffer >> bits;
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & buffer << 8 - bits) !== 0) throw new SyntaxError("Unexpected end of data");
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for(let i = 0; i < data.length; ++i){
        // Slurp data into the buffer:
        buffer = buffer << 8 | data[i];
        bits += 8;
        // Write out as much as we can:
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    // Partial character:
    if (bits !== 0) out += alphabet[mask & buffer << bitsPerChar - bits];
    // Add padding characters until we hit a byte boundary:
    if (pad) while((out.length * bitsPerChar & 7) !== 0)out += "=";
    return out;
}
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
}

},{"../bytes.js":"2v9ug","../vendor/base-x.js":"6GSI4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2v9ug":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "toHex", ()=>toHex);
parcelHelpers.export(exports, "fromHex", ()=>fromHex);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "isBinary", ()=>isBinary);
parcelHelpers.export(exports, "fromString", ()=>fromString);
parcelHelpers.export(exports, "toString", ()=>toString);
const empty = new Uint8Array(0);
function toHex(d) {
    return d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, "0"), "");
}
function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) return false;
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) return false;
    }
    return true;
}
function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    throw new Error("Unknown type, must be binary type");
}
function isBinary(o) {
    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
    return new TextEncoder().encode(str);
}
function toString(b) {
    return new TextDecoder().decode(b);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6GSI4":[function(require,module,exports) {
/* eslint-disable */ // base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    /**
     * @param {any[] | Iterable<number>} source
     */ function encode(source) {
        // @ts-ignore
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        else if (Array.isArray(source)) source = Uint8Array.from(source);
        if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (source.length === 0) return "";
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    /**
     * @param {string | string[]} source
     */ function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return new Uint8Array();
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === " ") return;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === " ") return;
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    /**
     * @param {string | string[]} string
     */ function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
exports.default = _brrp__multiformats_scope_baseX;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fYS82":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
var _bytesJs = require("../bytes.js");
var _digestJs = require("./digest.js");
const code = 0x0;
const name = "identity";
const encode = (0, _bytesJs.coerce);
function digest(input) {
    return _digestJs.create(code, encode(input));
}
const identity = {
    code,
    name,
    encode,
    digest
};

},{"../bytes.js":"2v9ug","./digest.js":"cZirI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cZirI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a multihash digest.
 */ parcelHelpers.export(exports, "create", ()=>create);
/**
 * Turns bytes representation of multihash digest into an instance.
 */ parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Represents a multihash digest which carries information about the
 * hashing algorithm and an actual hash digest.
 */ parcelHelpers.export(exports, "Digest", ()=>Digest);
var _bytesJs = require("../bytes.js");
var _varintJs = require("../varint.js");
function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = _varintJs.encodingLength(code);
    const digestOffset = sizeOffset + _varintJs.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    _varintJs.encodeTo(code, bytes, 0);
    _varintJs.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
}
function decode(multihash) {
    const bytes = (0, _bytesJs.coerce)(multihash);
    const [code, sizeOffset] = _varintJs.decode(bytes);
    const [size, digestOffset] = _varintJs.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) throw new Error("Incorrect length");
    return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
    if (a === b) return true;
    else {
        const data = b;
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && (0, _bytesJs.equals)(a.bytes, data.bytes);
    }
}
class Digest {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */ constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}

},{"../bytes.js":"2v9ug","../varint.js":"intAR","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"intAR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encodeTo", ()=>encodeTo);
parcelHelpers.export(exports, "encodingLength", ()=>encodingLength);
var _varintJs = require("./vendor/varint.js");
var _varintJsDefault = parcelHelpers.interopDefault(_varintJs);
function decode(data, offset = 0) {
    const code = (0, _varintJsDefault.default).decode(data, offset);
    return [
        code,
        (0, _varintJsDefault.default).decode.bytes
    ];
}
function encodeTo(int, target, offset = 0) {
    (0, _varintJsDefault.default).encode(int, target, offset);
    return target;
}
function encodingLength(int) {
    return (0, _varintJsDefault.default).encodingLength(int);
}

},{"./vendor/varint.js":"k4wua","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"k4wua":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var encode_1 = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */ function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    // @ts-ignore
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 0x80, REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */ function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            // @ts-ignore
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1);
    // @ts-ignore
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(/** @type {number} */ value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
exports.default = _brrp_varint;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9qYCS":[function(require,module,exports) {
/* global crypto */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha512", ()=>sha512);
var _hasherJs = require("./hasher.js");
function sha(name) {
    return async (data)=>new Uint8Array(await crypto.subtle.digest(name, data));
}
const sha256 = (0, _hasherJs.from)({
    name: "sha2-256",
    code: 0x12,
    encode: sha("SHA-256")
});
const sha512 = (0, _hasherJs.from)({
    name: "sha2-512",
    code: 0x13,
    encode: sha("SHA-512")
});

},{"./hasher.js":"8OSBQ","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8OSBQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "from", ()=>from);
/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 */ parcelHelpers.export(exports, "Hasher", ()=>Hasher);
var _digestJs = require("./digest.js");
function from({ name, code, encode }) {
    return new Hasher(name, code, encode);
}
class Hasher {
    name;
    code;
    encode;
    constructor(name, code, encode){
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? _digestJs.create(this.code, result) : result.then((digest)=>_digestJs.create(this.code, digest));
        } else throw Error("Unknown type, must be binary type");
    }
}

},{"./digest.js":"cZirI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"CKVqX":[function(require,module,exports) {
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equals", ()=>equals);
function equals(a, b) {
    if (a === b) return true;
    if (a.byteLength !== b.byteLength) return false;
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kswAQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64urlToBuffer", ()=>base64urlToBuffer);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
function base64urlToBuffer(str, len) {
    let buf = (0, _fromString.fromString)(str, "base64urlpad");
    if (len != null) {
        if (buf.length > len) throw new Error("byte array longer than desired length");
        buf = (0, _concat.concat)([
            new Uint8Array(len - buf.length),
            buf
        ]);
    }
    return buf;
}
function isPromise(thing) {
    if (thing == null) return false;
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

},{"uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"byG2b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a new Uint8Array created by concatenating the passed Uint8Arrays
 */ parcelHelpers.export(exports, "concat", ()=>concat);
var _allocJs = require("./alloc.js");
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function concat(arrays, length) {
    if (globalThis.Buffer != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.concat(arrays, length));
    if (length == null) length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    const output = (0, _allocJs.allocUnsafe)(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, _asUint8ArrayJs.asUint8Array)(output);
}

},{"./alloc.js":"9stB1","./util/as-uint8array.js":"lTef0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9stB1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ parcelHelpers.export(exports, "alloc", ()=>alloc);
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */ parcelHelpers.export(exports, "allocUnsafe", ()=>allocUnsafe);
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function alloc(size = 0) {
    if (globalThis.Buffer?.alloc != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.alloc(size));
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    if (globalThis.Buffer?.allocUnsafe != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.allocUnsafe(size));
    return new Uint8Array(size);
}

},{"./util/as-uint8array.js":"lTef0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lTef0":[function(require,module,exports) {
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asUint8Array", ()=>asUint8Array);
function asUint8Array(buf) {
    if (globalThis.Buffer != null) return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    return buf;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3YvUV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
var _asUint8ArrayJs = require("./util/as-uint8array.js");
var _basesJs = require("./util/bases.js");
var _basesJsDefault = parcelHelpers.interopDefault(_basesJs);
function fromString(string, encoding = "utf8") {
    const base = (0, _basesJsDefault.default)[encoding];
    if (base == null) throw new Error(`Unsupported encoding "${encoding}"`);
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.from(string, "utf-8"));
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
}

},{"./util/as-uint8array.js":"lTef0","./util/bases.js":"aUh7X","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aUh7X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basics = require("multiformats/basics");
var _allocJs = require("../alloc.js");
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec("utf8", "u", (buf)=>{
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf)=>{
    let string = "a";
    for(let i = 0; i < buf.length; i++)string += String.fromCharCode(buf[i]);
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, _allocJs.allocUnsafe)(str.length);
    for(let i = 0; i < str.length; i++)buf[i] = str.charCodeAt(i);
    return buf;
});
const BASES = {
    utf8: string,
    "utf-8": string,
    hex: (0, _basics.bases).base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...(0, _basics.bases)
};
exports.default = BASES;

},{"multiformats/basics":"W6yRG","../alloc.js":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"W6yRG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bases", ()=>bases);
parcelHelpers.export(exports, "hashes", ()=>hashes);
parcelHelpers.export(exports, "codecs", ()=>codecs);
parcelHelpers.export(exports, "CID", ()=>(0, _indexJs.CID));
parcelHelpers.export(exports, "hasher", ()=>(0, _indexJs.hasher));
parcelHelpers.export(exports, "digest", ()=>(0, _indexJs.digest));
parcelHelpers.export(exports, "varint", ()=>(0, _indexJs.varint));
parcelHelpers.export(exports, "bytes", ()=>(0, _indexJs.bytes));
var _base10Js = require("./bases/base10.js");
var _base16Js = require("./bases/base16.js");
var _base2Js = require("./bases/base2.js");
var _base256EmojiJs = require("./bases/base256emoji.js");
var _base32Js = require("./bases/base32.js");
var _base36Js = require("./bases/base36.js");
var _base58Js = require("./bases/base58.js");
var _base64Js = require("./bases/base64.js");
var _base8Js = require("./bases/base8.js");
var _identityJs = require("./bases/identity.js");
var _jsonJs = require("./codecs/json.js");
var _rawJs = require("./codecs/raw.js");
var _identityJs1 = require("./hashes/identity.js");
var _sha2Js = require("./hashes/sha2.js");
var _indexJs = require("./index.js");
const bases = {
    ..._identityJs,
    ..._base2Js,
    ..._base8Js,
    ..._base10Js,
    ..._base16Js,
    ..._base32Js,
    ..._base36Js,
    ..._base58Js,
    ..._base64Js,
    ..._base256EmojiJs
};
const hashes = {
    ..._sha2Js,
    ..._identityJs1
};
const codecs = {
    raw: _rawJs,
    json: _jsonJs
};

},{"./bases/base10.js":"2ZBir","./bases/base16.js":"gL4wa","./bases/base2.js":"ne7kg","./bases/base256emoji.js":"9puk1","./bases/base32.js":"dpCMu","./bases/base36.js":"kqmdQ","./bases/base58.js":"9K4Ju","./bases/base64.js":"2m5sV","./bases/base8.js":"2N7RH","./bases/identity.js":"hwYPp","./codecs/json.js":"euyt1","./codecs/raw.js":"h9Wzm","./hashes/identity.js":"fYS82","./hashes/sha2.js":"9qYCS","./index.js":"g7jI4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2ZBir":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base10", ()=>base10);
var _baseJs = require("./base.js");
const base10 = (0, _baseJs.baseX)({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gL4wa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base16", ()=>base16);
parcelHelpers.export(exports, "base16upper", ()=>base16upper);
var _baseJs = require("./base.js");
const base16 = (0, _baseJs.rfc4648)({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
});
const base16upper = (0, _baseJs.rfc4648)({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ne7kg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base2", ()=>base2);
var _baseJs = require("./base.js");
const base2 = (0, _baseJs.rfc4648)({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9puk1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base256emoji", ()=>base256emoji);
var _baseJs = require("./base.js");
const alphabet = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    p[c.codePointAt(0)] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, "");
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) throw new Error(`Non-base256emoji character: ${char}`);
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0, _baseJs.from)({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode,
    decode
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dpCMu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base32", ()=>base32);
parcelHelpers.export(exports, "base32upper", ()=>base32upper);
parcelHelpers.export(exports, "base32pad", ()=>base32pad);
parcelHelpers.export(exports, "base32padupper", ()=>base32padupper);
parcelHelpers.export(exports, "base32hex", ()=>base32hex);
parcelHelpers.export(exports, "base32hexupper", ()=>base32hexupper);
parcelHelpers.export(exports, "base32hexpad", ()=>base32hexpad);
parcelHelpers.export(exports, "base32hexpadupper", ()=>base32hexpadupper);
parcelHelpers.export(exports, "base32z", ()=>base32z);
var _baseJs = require("./base.js");
const base32 = (0, _baseJs.rfc4648)({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
});
const base32upper = (0, _baseJs.rfc4648)({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
});
const base32pad = (0, _baseJs.rfc4648)({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
});
const base32padupper = (0, _baseJs.rfc4648)({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
});
const base32hex = (0, _baseJs.rfc4648)({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
});
const base32hexupper = (0, _baseJs.rfc4648)({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
});
const base32hexpad = (0, _baseJs.rfc4648)({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
});
const base32hexpadupper = (0, _baseJs.rfc4648)({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
});
const base32z = (0, _baseJs.rfc4648)({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kqmdQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base36", ()=>base36);
parcelHelpers.export(exports, "base36upper", ()=>base36upper);
var _baseJs = require("./base.js");
const base36 = (0, _baseJs.baseX)({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = (0, _baseJs.baseX)({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2m5sV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64", ()=>base64);
parcelHelpers.export(exports, "base64pad", ()=>base64pad);
parcelHelpers.export(exports, "base64url", ()=>base64url);
parcelHelpers.export(exports, "base64urlpad", ()=>base64urlpad);
var _baseJs = require("./base.js");
const base64 = (0, _baseJs.rfc4648)({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
});
const base64pad = (0, _baseJs.rfc4648)({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
});
const base64url = (0, _baseJs.rfc4648)({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
});
const base64urlpad = (0, _baseJs.rfc4648)({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2N7RH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base8", ()=>base8);
var _baseJs = require("./base.js");
const base8 = (0, _baseJs.rfc4648)({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});

},{"./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hwYPp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
var _bytesJs = require("../bytes.js");
var _baseJs = require("./base.js");
const identity = (0, _baseJs.from)({
    prefix: "\x00",
    name: "identity",
    encode: (buf)=>(0, _bytesJs.toString)(buf),
    decode: (str)=>(0, _bytesJs.fromString)(str)
});

},{"../bytes.js":"2v9ug","./base.js":"eLJUA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"euyt1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "name", ()=>name);
parcelHelpers.export(exports, "code", ()=>code);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = "json";
const code = 0x0200;
function encode(node) {
    return textEncoder.encode(JSON.stringify(node));
}
function decode(data) {
    return JSON.parse(textDecoder.decode(data));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"h9Wzm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "name", ()=>name);
parcelHelpers.export(exports, "code", ()=>code);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _bytesJs = require("../bytes.js");
const name = "raw";
const code = 0x55;
function encode(node) {
    return (0, _bytesJs.coerce)(node);
}
function decode(data) {
    return (0, _bytesJs.coerce)(data);
}

},{"../bytes.js":"2v9ug","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"g7jI4":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.
 *
 * This library provides implementations for most basics and many others can be found in linked repositories.
 *
 * ```TypeScript
 * import { CID } from 'multiformats/cid'
 * import * as json from 'multiformats/codecs/json'
 * import { sha256 } from 'multiformats/hashes/sha2'
 *
 * const bytes = json.encode({ hello: 'world' })
 *
 * const hash = await sha256.digest(bytes)
 * const cid = CID.create(1, json.code, hash)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Creating Blocks
 *
 * ```TypeScript
 * import * as Block from 'multiformats/block'
 * import * as codec from '@ipld/dag-cbor'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * const value = { hello: 'world' }
 *
 * // encode a block
 * let block = await Block.encode({ value, codec, hasher })
 *
 * block.value // { hello: 'world' }
 * block.bytes // Uint8Array
 * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec
 *
 * // you can also decode blocks from their binary state
 * block = await Block.decode({ bytes: block.bytes, codec, hasher })
 *
 * // if you have the cid you can also verify the hash on decode
 * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })
 * ```
 *
 * ## Multibase Encoders / Decoders / Codecs
 *
 * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:
 *
 * ```TypeScript
 * import { base64 } from "multiformats/bases/base64"
 * cid.toString(base64.encoder)
 * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'
 * ```
 *
 * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:
 *
 * ```TypeScript
 * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * Dual of multibase encoder & decoder is defined as multibase codec and it exposes
 * them as `encoder` and `decoder` properties. For added convenience codecs also
 * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be
 * used as either or both:
 *
 * ```TypeScript
 * cid.toString(base64)
 * CID.parse(cid.toString(base64), base64)
 * ```
 *
 * **Note:** CID implementation comes bundled with `base32` and `base58btc`
 * multibase codecs so that CIDs can be base serialized to (version specific)
 * default base encoding and parsed without having to supply base encoders/decoders:
 *
 * ```TypeScript
 * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')
 * v1.toString()
 * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'
 *
 * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')
 * v0.toString()
 * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
 * v0.toV1().toString()
 * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'
 * ```
 *
 * ## Multicodec Encoders / Decoders / Codecs
 *
 * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).
 * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.
 * Here is an example implementation of JSON `BlockCodec`.
 *
 * ```TypeScript
 * export const { name, code, encode, decode } = {
 *   name: 'json',
 *   code: 0x0200,
 *   encode: json => new TextEncoder().encode(JSON.stringify(json)),
 *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
 * }
 * ```
 *
 * ## Multihash Hashers
 *
 * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:
 *
 * ```TypeScript
 * import * as hasher from 'multiformats/hashes/hasher'
 *
 * const sha256 = hasher.from({
 *   // As per multiformats table
 *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9
 *   name: 'sha2-256',
 *   code: 0x12,
 *
 *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())
 * })
 *
 * const hash = await sha256.digest(json.encode({ hello: 'world' }))
 * CID.create(1, json.code, hash)
 *
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Traversal
 *
 * This library contains higher-order functions for traversing graphs of data easily.
 *
 * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.
 *
 * ```TypeScript
 * import { walk } from 'multiformats/traversal'
 * import * as Block from 'multiformats/block'
 * import * as codec from 'multiformats/codecs/json'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * // build a DAG (a single block for this simple example)
 * const value = { hello: 'world' }
 * const block = await Block.encode({ value, codec, hasher })
 * const { cid } = block
 * console.log(cid)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 *
 * // create a loader function that also collects CIDs of blocks in
 * // their traversal order
 * const load = (cid, blocks) => async (cid) => {
 *   // fetch a block using its cid
 *   // e.g.: const block = await fetchBlockByCID(cid)
 *   blocks.push(cid)
 *   return block
 * }
 *
 * // collect blocks in this DAG starting from the root `cid`
 * const blocks = []
 * await walk({ cid, load: load(cid, blocks) })
 *
 * console.log(blocks)
 * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]
 * ```
 *
 * ## Legacy interface
 *
 * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an
 * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.
 *
 * ## Implementations
 *
 * By default, no base encodings (other than base32 & base58btc), hash functions,
 * or codec implementations are exposed by `multiformats`, you need to
 * import the ones you need yourself.
 *
 * ### Multibase codecs
 *
 * | bases                                                         | import                      | repo                                                                                              |
 * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |
 * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 *
 * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.
 *
 * ### Multihash hashers
 *
 * | hashes                                                                                                                          | import                         | repo                                                                                                               |
 * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
 * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |
 * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |
 * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |
 * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |
 * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |
 *
 * ### IPLD codecs (multicodec)
 *
 * | codec      | import                     | repo                                                                                                   |
 * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |
 * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |
 * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |
 * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |
 * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CID", ()=>(0, _cidJs.CID));
parcelHelpers.export(exports, "hasher", ()=>_hasherJs);
parcelHelpers.export(exports, "digest", ()=>_digestJs);
parcelHelpers.export(exports, "varint", ()=>_varintJs);
parcelHelpers.export(exports, "bytes", ()=>_bytesJs);
var _bytesJs = require("./bytes.js");
var _cidJs = require("./cid.js");
var _digestJs = require("./hashes/digest.js");
var _hasherJs = require("./hashes/hasher.js");
var _varintJs = require("./varint.js");
// This way TS will also expose all the types from module
var _interfaceJs = require("./interface.js");
parcelHelpers.exportAll(_interfaceJs, exports);

},{"./bytes.js":"2v9ug","./cid.js":"1oUcK","./hashes/digest.js":"cZirI","./hashes/hasher.js":"8OSBQ","./varint.js":"intAR","./interface.js":"g8Ze6","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1oUcK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "toJSON", ()=>toJSON);
parcelHelpers.export(exports, "fromJSON", ()=>fromJSON);
parcelHelpers.export(exports, "CID", ()=>CID);
var _base32Js = require("./bases/base32.js");
var _base58Js = require("./bases/base58.js");
var _bytesJs = require("./bytes.js");
var _digestJs = require("./hashes/digest.js");
var _varintJs = require("./varint.js");
// This way TS will also expose all the types from module
var _interfaceJs = require("./link/interface.js");
parcelHelpers.exportAll(_interfaceJs, exports);
function format(link, base) {
    const { bytes, version } = link;
    switch(version){
        case 0:
            return toStringV0(bytes, baseCache(link), base ?? (0, _base58Js.base58btc).encoder);
        default:
            return toStringV1(bytes, baseCache(link), base ?? (0, _base32Js.base32).encoder);
    }
}
function toJSON(link) {
    return {
        "/": format(link)
    };
}
function fromJSON(json) {
    return CID.parse(json["/"]);
}
const cache = new WeakMap();
function baseCache(cid) {
    const baseCache = cache.get(cid);
    if (baseCache == null) {
        const baseCache = new Map();
        cache.set(cid, baseCache);
        return baseCache;
    }
    return baseCache;
}
class CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */ constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        // flag to serializers that this is a CID and
        // should be treated specially
        this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */ get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    toV0() {
        switch(this.version){
            case 0:
                return this;
            case 1:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                    // sha2-256
                    if (multihash.code !== SHA_256_CODE) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                    return CID.createV0(multihash);
                }
            default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = _digestJs.create(code, digest);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                return this;
            default:
                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
    }
    equals(other) {
        return CID.equals(this, other);
    }
    static equals(self, other) {
        const unknown = other;
        return unknown != null && self.code === unknown.code && self.version === unknown.version && _digestJs.equals(self.multihash, unknown.multihash);
    }
    toString(base) {
        return format(this, base);
    }
    toJSON() {
        return {
            "/": format(this)
        };
    }
    link() {
        return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */ static asCID(input) {
        if (input == null) return null;
        const value = input;
        if (value instanceof CID) // If value is instance of CID then we're all set.
        return value;
        else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
            // If value isn't instance of this CID class but `this.asCID === this` or
            // `value['/'] === value.bytes` is true it is CID instance coming from a
            // different implementation (diff version or duplicate). In that case we
            // rebase it to this `CID` implementation so caller is guaranteed to get
            // instance with expected API.
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));
        } else if (value[cidSymbol] === true) {
            // If value is a CID from older implementation that used to be tagged via
            // symbol we still rebase it to the this `CID` implementation by
            // delegating that to a constructor.
            const { version, multihash, code } = value;
            const digest = _digestJs.decode(multihash);
            return CID.create(version, code, digest);
        } else // Otherwise value is not a CID (or an incompatible version of it) in
        // which case we return `null`.
        return null;
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */ static create(version, code, digest) {
        if (typeof code !== "number") throw new Error("String codecs are no longer supported");
        if (!(digest.bytes instanceof Uint8Array)) throw new Error("Invalid digest");
        switch(version){
            case 0:
                if (code !== DAG_PB_CODE) throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                else return new CID(version, code, digest, digest.bytes);
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                throw new Error("Invalid version");
        }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */ static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */ static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */ static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length !== 0) throw new Error("Incorrect length");
        return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */ static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0, _bytesJs.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) throw new Error("Incorrect length");
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new _digestJs.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
            cid,
            bytes.subarray(specs.size)
        ];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */ static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = _varintJs.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            // CIDv0
            version = 0;
            offset = 0;
        } else codec = next();
        if (version !== 0 && version !== 1) throw new RangeError(`Invalid CID version ${version}`);
        const prefixSize = offset;
        const multihashCode = next(); // multihash code
        const digestSize = next(); // multihash length
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */ static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") throw Error("Version 0 CID string must not include multibase prefix");
        // Cache string representation to avoid computing it on `this.toString()`
        baseCache(cid).set(prefix, source);
        return cid;
    }
}
function parseCIDtoBytes(source, base) {
    switch(source[0]){
        // CIDv0 is parsed differently
        case "Q":
            {
                const decoder = base ?? (0, _base58Js.base58btc);
                return [
                    (0, _base58Js.base58btc).prefix,
                    decoder.decode(`${(0, _base58Js.base58btc).prefix}${source}`)
                ];
            }
        case (0, _base58Js.base58btc).prefix:
            {
                const decoder = base ?? (0, _base58Js.base58btc);
                return [
                    (0, _base58Js.base58btc).prefix,
                    decoder.decode(source)
                ];
            }
        case (0, _base32Js.base32).prefix:
            {
                const decoder = base ?? (0, _base32Js.base32);
                return [
                    (0, _base32Js.base32).prefix,
                    decoder.decode(source)
                ];
            }
        default:
            if (base == null) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            return [
                source[0],
                base.decode(source)
            ];
    }
}
function toStringV0(bytes, cache, base) {
    const { prefix } = base;
    if (prefix !== (0, _base58Js.base58btc).prefix) throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else return cid;
}
function toStringV1(bytes, cache, base) {
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else return cid;
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
    const codeOffset = _varintJs.encodingLength(version);
    const hashOffset = codeOffset + _varintJs.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    _varintJs.encodeTo(version, bytes, 0);
    _varintJs.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
}
const cidSymbol = Symbol.for("@ipld/js-cid/CID");

},{"./bases/base32.js":"dpCMu","./bases/base58.js":"9K4Ju","./bytes.js":"2v9ug","./hashes/digest.js":"cZirI","./varint.js":"intAR","./link/interface.js":"Fc5ti","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"Fc5ti":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */ /* eslint-disable no-use-before-define */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"g8Ze6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _interfaceJs = require("./bases/interface.js");
parcelHelpers.exportAll(_interfaceJs, exports);
var _interfaceJs1 = require("./hashes/interface.js");
parcelHelpers.exportAll(_interfaceJs1, exports);
var _interfaceJs2 = require("./codecs/interface.js");
parcelHelpers.exportAll(_interfaceJs2, exports);
var _interfaceJs3 = require("./link/interface.js");
parcelHelpers.exportAll(_interfaceJs3, exports);
var _interfaceJs4 = require("./block/interface.js");
parcelHelpers.exportAll(_interfaceJs4, exports);

},{"./bases/interface.js":"bwsrI","./hashes/interface.js":"4ZBJn","./codecs/interface.js":"jJ7vh","./link/interface.js":"Fc5ti","./block/interface.js":"gh5o3","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bwsrI":[function(require,module,exports) {
// Base encoders / decoders just base encode / decode between binary and
// textual representation. They are unaware of multibase.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4ZBJn":[function(require,module,exports) {
// # Multihash
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jJ7vh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gh5o3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cUZKV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publicKeyLength", ()=>PUBLIC_KEY_BYTE_LENGTH);
parcelHelpers.export(exports, "privateKeyLength", ()=>PRIVATE_KEY_BYTE_LENGTH);
parcelHelpers.export(exports, "generateKey", ()=>generateKey);
/**
 * Generate keypair from a 32 byte uint8array
 */ parcelHelpers.export(exports, "generateKeyFromSeed", ()=>generateKeyFromSeed);
parcelHelpers.export(exports, "hashAndSign", ()=>hashAndSign);
parcelHelpers.export(exports, "hashAndVerify", ()=>hashAndVerify);
var _ed25519 = require("@noble/curves/ed25519");
const PUBLIC_KEY_BYTE_LENGTH = 32;
const PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys
const KEYS_BYTE_LENGTH = 32;
function generateKey() {
    // the actual private key (32 bytes)
    const privateKeyRaw = (0, _ed25519.ed25519).utils.randomPrivateKey();
    const publicKey = (0, _ed25519.ed25519).getPublicKey(privateKeyRaw);
    // concatenated the public key to the private key
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
        privateKey,
        publicKey
    };
}
function generateKeyFromSeed(seed) {
    if (seed.length !== KEYS_BYTE_LENGTH) throw new TypeError('"seed" must be 32 bytes in length.');
    else if (!(seed instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
    // based on node forges algorithm, the seed is used directly as private key
    const privateKeyRaw = seed;
    const publicKey = (0, _ed25519.ed25519).getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
        privateKey,
        publicKey
    };
}
function hashAndSign(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
    return (0, _ed25519.ed25519).sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
function hashAndVerify(publicKey, sig, msg) {
    return (0, _ed25519.ed25519).verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
    for(let i = 0; i < KEYS_BYTE_LENGTH; i++){
        privateKey[i] = privateKeyRaw[i];
        privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
    }
    return privateKey;
}

},{"@noble/curves/ed25519":"c62gb","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"c62gb":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ED25519_TORSION_SUBGROUP", ()=>ED25519_TORSION_SUBGROUP);
parcelHelpers.export(exports, "ed25519", ()=>ed25519);
parcelHelpers.export(exports, "ed25519ctx", ()=>ed25519ctx);
parcelHelpers.export(exports, "ed25519ph", ()=>ed25519ph);
parcelHelpers.export(exports, "x25519", ()=>x25519);
/**
 * Converts ed25519 public key to x25519 public key. Uses formula:
 * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
 * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
 * @example
 *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());
 *   const aPriv = x25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))
 */ parcelHelpers.export(exports, "edwardsToMontgomeryPub", ()=>edwardsToMontgomeryPub);
parcelHelpers.export(exports, "edwardsToMontgomery", ()=>edwardsToMontgomery);
/**
 * Converts ed25519 secret key to x25519 secret key.
 * @example
 *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());
 *   const aPriv = ed25519.utils.randomPrivateKey();
 *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)
 */ parcelHelpers.export(exports, "edwardsToMontgomeryPriv", ()=>edwardsToMontgomeryPriv);
parcelHelpers.export(exports, "hashToCurve", ()=>hashToCurve);
parcelHelpers.export(exports, "encodeToCurve", ()=>encodeToCurve);
parcelHelpers.export(exports, "RistrettoPoint", ()=>RistrettoPoint);
parcelHelpers.export(exports, "hashToRistretto255", ()=>hashToRistretto255);
parcelHelpers.export(exports, "hash_to_ristretto255", ()=>hash_to_ristretto255);
var _sha512 = require("@noble/hashes/sha512");
var _utils = require("@noble/hashes/utils");
var _edwardsJs = require("./abstract/edwards.js");
var _montgomeryJs = require("./abstract/montgomery.js");
var _modularJs = require("./abstract/modular.js");
var _utilsJs = require("./abstract/utils.js");
var _hashToCurveJs = require("./abstract/hash-to-curve.js");
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 */ const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
// √(-1) aka √(a) aka 2^((p-1)/4)
const ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);
// prettier-ignore
const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
function ed25519_pow_2_252_3(x) {
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P; // x^3, 11
    const b4 = (0, _modularJs.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111
    const b5 = (0, _modularJs.pow2)(b4, _1n, P) * x % P; // x^31
    const b10 = (0, _modularJs.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, _modularJs.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, _modularJs.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, _modularJs.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, _modularJs.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, _modularJs.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, _modularJs.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, _modularJs.pow2)(b250, _2n, P) * x % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return {
        pow_p_5_8,
        b2
    };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = (0, _modularJs.mod)(v * v * v, P); // v³
    const v7 = (0, _modularJs.mod)(v3 * v3 * v, P); // v⁷
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, _modularJs.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8
    const vx2 = (0, _modularJs.mod)(v * x * x, P); // vx²
    const root1 = x; // First root candidate
    const root2 = (0, _modularJs.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, _modularJs.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, _modularJs.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time
    if ((0, _modularJs.isNegativeLE)(x, P)) x = (0, _modularJs.mod)(-x, P);
    return {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}
const ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
];
const Fp = (0, _modularJs.Field)(ED25519_P, undefined, true);
const ed25519Defaults = {
    // Param: a
    a: BigInt(-1),
    // d is equal to -121665/121666 over finite field.
    // Negative number is P - number, and division is invert(number, P)
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
    Fp,
    // Subgroup order: how many points curve has
    // 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    // Cofactor
    h: BigInt(8),
    // Base point (x, y) aka generator point
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: (0, _sha512.sha512),
    randomBytes: (0, _utils.randomBytes),
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio
};
const ed25519 = /* @__PURE__ */ (0, _edwardsJs.twistedEdwards)(ed25519Defaults);
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255) throw new Error("Context is too big");
    return (0, _utils.concatBytes)((0, _utils.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([
        phflag ? 1 : 0,
        ctx.length
    ]), ctx, data);
}
const ed25519ctx = /* @__PURE__ */ (0, _edwardsJs.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain
});
const ed25519ph = /* @__PURE__ */ (0, _edwardsJs.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
    prehash: (0, _sha512.sha512)
});
const x25519 = /* @__PURE__ */ (()=>(0, _montgomeryJs.montgomery)({
        P: ED25519_P,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x)=>{
            const P = ED25519_P;
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, _modularJs.mod)((0, _modularJs.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes,
        randomBytes: (0, _utils.randomBytes)
    }))();
function edwardsToMontgomeryPub(edwardsPub) {
    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);
    const _1n = BigInt(1);
    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));
}
const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated
function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
}
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1
const ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)
const ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic
const ELL2_J = BigInt(486662);
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return {
        xMn: xn,
        xMd: xd,
        yMn: y,
        yMd: _1n
    }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = (0, _modularJs.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const inv = Fp.invertBatch([
        xd,
        yd
    ]); // batch division
    return {
        x: Fp.mul(xn, inv[0]),
        y: Fp.mul(yn, inv[1])
    }; //  13. return (xn, xd, yn, yd)
}
const htf = /* @__PURE__ */ (()=>(0, _hashToCurveJs.createHasher)(ed25519.ExtendedPoint, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: (0, _sha512.sha512)
    }))();
const hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();
const encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)();
function assertRstPoint(other) {
    if (!(other instanceof RistPoint)) throw new Error("RistrettoPoint expected");
}
// √(-1) aka √(a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// √(ad - 1)
const SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
// 1 / √(a-d)
const INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
// 1-d²
const ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
// (d-1)²
const D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
// Calculates 1/√(number)
const invertSqrt = (number)=>uvRatio(_1n, number);
const MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const bytes255ToNumberLE = (bytes)=>ed25519.CURVE.Fp.create((0, _utilsJs.bytesToNumberLE)(bytes) & MAX_255B);
// Computes Elligator map for Ristretto
// https://ristretto.group/formulas/elligator.html
function calcElligatorRistrettoMap(r0) {
    const { d } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod = ed25519.CURVE.Fp.create;
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, _modularJs.isNegativeLE)(s_, P)) s_ = mod(-s_);
    if (!Ns_D_is_sq) s = s_; // 7
    if (!Ns_D_is_sq) c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
/**
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448
 */ class RistPoint {
    // Private property to discourage combining ExtendedPoint + RistrettoPoint
    // Always use Ristretto encoding/decoding instead.
    constructor(ep){
        this.ep = ep;
    }
    static fromAffine(ap) {
        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
    }
    /**
     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
     * The hash-to-group operation applies Elligator twice and adds the results.
     * **Note:** this is one-way map, there is no conversion from point to hash.
     * https://ristretto.group/formulas/elligator.html
     * @param hex 64-byte output of a hash function
     */ static hashToCurve(hex) {
        hex = (0, _utilsJs.ensureBytes)("ristrettoHash", hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new RistPoint(R1.add(R2));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * https://ristretto.group/formulas/decoding.html
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */ static fromHex(hex) {
        hex = (0, _utilsJs.ensureBytes)("ristrettoHex", hex, 32);
        const { a, d } = ed25519.CURVE;
        const P = ed25519.CURVE.Fp.ORDER;
        const mod = ed25519.CURVE.Fp.create;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, _utilsJs.equalBytes)((0, _utilsJs.numberToBytesLE)(s, 32), hex) || (0, _modularJs.isNegativeLE)(s, P)) throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, _modularJs.isNegativeLE)(x, P)) x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, _modularJs.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);
        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * https://ristretto.group/formulas/encoding.html
     */ toRawBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = ed25519.CURVE.Fp.ORDER;
        const mod = ed25519.CURVE.Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y)); // 1
        const u2 = mod(x * y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * t); // 6
        let D; // 7
        if ((0, _modularJs.isNegativeLE)(t * zInv, P)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        } else D = D2; // 8
        if ((0, _modularJs.isNegativeLE)(x * zInv, P)) y = mod(-y); // 9
        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, _modularJs.isNegativeLE)(s, P)) s = mod(-s);
        return (0, _utilsJs.numberToBytesLE)(s, 32); // 11
    }
    toHex() {
        return (0, _utilsJs.bytesToHex)(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    // Compare one point to another.
    equals(other) {
        assertRstPoint(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = ed25519.CURVE.Fp.create;
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return new RistPoint(this.ep.double());
    }
    negate() {
        return new RistPoint(this.ep.negate());
    }
}
const RistrettoPoint = /* @__PURE__ */ (()=>{
    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
    return RistPoint;
})();
const hashToRistretto255 = (msg, options)=>{
    const d = options.DST;
    const DST = typeof d === "string" ? (0, _utils.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, _hashToCurveJs.expand_message_xmd)(msg, DST, 64, (0, _sha512.sha512));
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
};
const hash_to_ristretto255 = hashToRistretto255; // legacy

},{"@noble/hashes/sha512":"V7q1R","@noble/hashes/utils":"eYkBB","./abstract/edwards.js":"d3Uel","./abstract/montgomery.js":"61N39","./abstract/modular.js":"aWzDR","./abstract/utils.js":"6xA5w","./abstract/hash-to-curve.js":"xT4Ur","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"V7q1R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SHA512", ()=>SHA512);
parcelHelpers.export(exports, "sha512", ()=>sha512);
parcelHelpers.export(exports, "sha512_224", ()=>sha512_224);
parcelHelpers.export(exports, "sha512_256", ()=>sha512_256);
parcelHelpers.export(exports, "sha384", ()=>sha384);
var _sha2Js = require("./_sha2.js");
var _u64Js = require("./_u64.js");
var _u64JsDefault = parcelHelpers.interopDefault(_u64Js);
var _utilsJs = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (()=>(0, _u64JsDefault.default).split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
    ].map((n)=>BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends (0, _sha2Js.SHA2) {
    constructor(){
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 1779033703;
        this.Al = -205731576;
        this.Bh = -1150833019;
        this.Bl = -2067093701;
        this.Ch = 1013904242;
        this.Cl = -23791573;
        this.Dh = -1521486534;
        this.Dl = 1595750129;
        this.Eh = 1359893119;
        this.El = -1377402159;
        this.Fh = -1694144372;
        this.Fl = 725511199;
        this.Gh = 528734635;
        this.Gl = -79577749;
        this.Hh = 1541459225;
        this.Hl = 327033209;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = (0, _u64JsDefault.default).rotrSH(W15h, W15l, 1) ^ (0, _u64JsDefault.default).rotrSH(W15h, W15l, 8) ^ (0, _u64JsDefault.default).shrSH(W15h, W15l, 7);
            const s0l = (0, _u64JsDefault.default).rotrSL(W15h, W15l, 1) ^ (0, _u64JsDefault.default).rotrSL(W15h, W15l, 8) ^ (0, _u64JsDefault.default).shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = (0, _u64JsDefault.default).rotrSH(W2h, W2l, 19) ^ (0, _u64JsDefault.default).rotrBH(W2h, W2l, 61) ^ (0, _u64JsDefault.default).shrSH(W2h, W2l, 6);
            const s1l = (0, _u64JsDefault.default).rotrSL(W2h, W2l, 19) ^ (0, _u64JsDefault.default).rotrBL(W2h, W2l, 61) ^ (0, _u64JsDefault.default).shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = (0, _u64JsDefault.default).add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = (0, _u64JsDefault.default).add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = (0, _u64JsDefault.default).rotrSH(Eh, El, 14) ^ (0, _u64JsDefault.default).rotrSH(Eh, El, 18) ^ (0, _u64JsDefault.default).rotrBH(Eh, El, 41);
            const sigma1l = (0, _u64JsDefault.default).rotrSL(Eh, El, 14) ^ (0, _u64JsDefault.default).rotrSL(Eh, El, 18) ^ (0, _u64JsDefault.default).rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = (0, _u64JsDefault.default).add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = (0, _u64JsDefault.default).add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = (0, _u64JsDefault.default).rotrSH(Ah, Al, 28) ^ (0, _u64JsDefault.default).rotrBH(Ah, Al, 34) ^ (0, _u64JsDefault.default).rotrBH(Ah, Al, 39);
            const sigma0l = (0, _u64JsDefault.default).rotrSL(Ah, Al, 28) ^ (0, _u64JsDefault.default).rotrBL(Ah, Al, 34) ^ (0, _u64JsDefault.default).rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = (0, _u64JsDefault.default).add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = (0, _u64JsDefault.default).add3L(T1l, sigma0l, MAJl);
            Ah = (0, _u64JsDefault.default).add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = (0, _u64JsDefault.default).add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = (0, _u64JsDefault.default).add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = (0, _u64JsDefault.default).add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = (0, _u64JsDefault.default).add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = (0, _u64JsDefault.default).add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = (0, _u64JsDefault.default).add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = (0, _u64JsDefault.default).add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = (0, _u64JsDefault.default).add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA512_224 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = -1942145080;
        this.Al = 424955298;
        this.Bh = 1944164710;
        this.Bl = -1982016298;
        this.Ch = 502970286;
        this.Cl = 855612546;
        this.Dh = 1738396948;
        this.Dl = 1479516111;
        this.Eh = 258812777;
        this.El = 2077511080;
        this.Fh = 2011393907;
        this.Fl = 79989058;
        this.Gh = 1067287976;
        this.Gl = 1780299464;
        this.Hh = 286451373;
        this.Hl = -1848208735;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 573645204;
        this.Al = -64227540;
        this.Bh = -1621794909;
        this.Bl = -934517566;
        this.Ch = 596883563;
        this.Cl = 1867755857;
        this.Dh = -1774684391;
        this.Dl = 1497426621;
        this.Eh = -1775747358;
        this.El = -1467023389;
        this.Fh = -1101128155;
        this.Fl = 1401305490;
        this.Gh = 721525244;
        this.Gl = 746961066;
        this.Hh = 246885852;
        this.Hl = -2117784414;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor(){
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = -876896931;
        this.Al = -1056596264;
        this.Bh = 1654270250;
        this.Bl = 914150663;
        this.Ch = -1856437926;
        this.Cl = 812702999;
        this.Dh = 355462360;
        this.Dl = -150054599;
        this.Eh = 1731405415;
        this.El = -4191439;
        this.Fh = -1900787065;
        this.Fl = 1750603025;
        this.Gh = -619958771;
        this.Gl = 1694076839;
        this.Hh = 1203062813;
        this.Hl = -1090891868;
        this.outputLen = 48;
    }
}
const sha512 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA512());
const sha512_224 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA512_224());
const sha512_256 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA512_256());
const sha384 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA384());

},{"./_sha2.js":"klWn8","./_u64.js":"23WBG","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"klWn8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Base SHA2 class (RFC 6234)
parcelHelpers.export(exports, "SHA2", ()=>SHA2);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
class SHA2 extends (0, _utilsJs.Hash) {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, _utilsJs.createView)(this.buffer);
    }
    update(data) {
        (0, _assertJs.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, _utilsJs.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, _utilsJs.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assertJs.exists)(this);
        (0, _assertJs.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, _utilsJs.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
}

},{"./_assert.js":"5Bz9G","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5Bz9G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "bool", ()=>bool);
parcelHelpers.export(exports, "bytes", ()=>bytes);
parcelHelpers.export(exports, "hash", ()=>hash);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "output", ()=>output);
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`Expected boolean, not ${b}`);
}
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== "function" || typeof hash.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eYkBB":[function(require,module,exports) {
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u8", ()=>u8);
parcelHelpers.export(exports, "u32", ()=>u32);
parcelHelpers.export(exports, "createView", ()=>createView);
parcelHelpers.export(exports, "rotr", ()=>rotr);
parcelHelpers.export(exports, "isLE", ()=>isLE);
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
// Returns control to thread each 'tick' ms to avoid blocking
parcelHelpers.export(exports, "asyncLoop", ()=>asyncLoop);
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
// For runtime check if class implements interface
parcelHelpers.export(exports, "Hash", ()=>Hash);
parcelHelpers.export(exports, "checkOpts", ()=>checkOpts);
parcelHelpers.export(exports, "wrapConstructor", ()=>wrapConstructor);
parcelHelpers.export(exports, "wrapConstructorWithOpts", ()=>wrapConstructorWithOpts);
parcelHelpers.export(exports, "wrapXOFConstructorWithOpts", ()=>wrapXOFConstructorWithOpts);
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */ parcelHelpers.export(exports, "randomBytes", ()=>randomBytes);
var _crypto = require("@noble/hashes/crypto");
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
if (!isLE) throw new Error("Non little-endian hardware is not supported");
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!isBytes(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        if (!isBytes(a)) throw new Error("Uint8Array expected");
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]") throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function randomBytes(bytesLength = 32) {
    if ((0, _crypto.crypto) && typeof (0, _crypto.crypto).getRandomValues === "function") return (0, _crypto.crypto).getRandomValues(new Uint8Array(bytesLength));
    throw new Error("crypto.getRandomValues must be defined");
}

},{"@noble/hashes/crypto":"1zMk1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1zMk1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "crypto", ()=>crypto);
const crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"23WBG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// prettier-ignore
parcelHelpers.export(exports, "fromBig", ()=>fromBig);
parcelHelpers.export(exports, "split", ()=>split);
parcelHelpers.export(exports, "toBig", ()=>toBig);
parcelHelpers.export(exports, "shrSH", ()=>shrSH);
parcelHelpers.export(exports, "shrSL", ()=>shrSL);
parcelHelpers.export(exports, "rotrSH", ()=>rotrSH);
parcelHelpers.export(exports, "rotrSL", ()=>rotrSL);
parcelHelpers.export(exports, "rotrBH", ()=>rotrBH);
parcelHelpers.export(exports, "rotrBL", ()=>rotrBL);
parcelHelpers.export(exports, "rotr32H", ()=>rotr32H);
parcelHelpers.export(exports, "rotr32L", ()=>rotr32L);
parcelHelpers.export(exports, "rotlSH", ()=>rotlSH);
parcelHelpers.export(exports, "rotlSL", ()=>rotlSL);
parcelHelpers.export(exports, "rotlBH", ()=>rotlBH);
parcelHelpers.export(exports, "rotlBL", ()=>rotlBL);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "add3L", ()=>add3L);
parcelHelpers.export(exports, "add3H", ()=>add3H);
parcelHelpers.export(exports, "add4L", ()=>add4L);
parcelHelpers.export(exports, "add4H", ()=>add4H);
parcelHelpers.export(exports, "add5H", ()=>add5H);
parcelHelpers.export(exports, "add5L", ()=>add5L);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for(let i = 0; i < lst.length; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
const rotr32L = (h, _l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"d3Uel":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// It is not generic twisted curve for now, but ed25519/ed448 generic implementation
parcelHelpers.export(exports, "twistedEdwards", ()=>twistedEdwards);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
var _curveJs = require("./curve.js");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
const VERIFY_DEFAULT = {
    zip215: true
};
function validateOpts(curve) {
    const opts = (0, _curveJs.validateBasic)(curve);
    _utilsJs.validateObject(curve, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    });
    // Set defaults
    return Object.freeze({
        ...opts
    });
}
function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n << BigInt(nByteLength * 8) - _1n;
    const modP = Fp.create; // Function overrides
    // sqrt(u/v)
    const uvRatio = CURVE.uvRatio || ((u, v)=>{
        try {
            return {
                isValid: true,
                value: Fp.sqrt(u * Fp.inv(v))
            };
        } catch (e) {
            return {
                isValid: false,
                value: _0n
            };
        }
    });
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes); // NOOP
    const domain = CURVE.domain || ((data, ctx, phflag)=>{
        if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
        return data;
    }); // NOOP
    const inBig = (n)=>typeof n === "bigint" && _0n < n; // n in [1..]
    const inRange = (n, max)=>inBig(n) && inBig(max) && n < max; // n in [1..max-1]
    const in0MaskRange = (n)=>n === _0n || inRange(n, MASK); // n in [0..MASK-1]
    function assertInRange(n, max) {
        // n in [1..max-1]
        if (inRange(n, max)) return n;
        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
        // n in [0..CURVE_ORDER-1]
        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group
    }
    const pointPrecomputes = new Map();
    function isPoint(other) {
        if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
    }
    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(ex, ey, ez, et){
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex)) throw new Error("x required");
            if (!in0MaskRange(ey)) throw new Error("y required");
            if (!in0MaskRange(ez)) throw new Error("z required");
            if (!in0MaskRange(et)) throw new Error("t required");
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point) throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error("invalid affine point");
            return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p)=>p.ez));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
            const { a, d } = CURVE;
            if (this.is0()) throw new Error("bad point: ZERO"); // TODO: optimize, with vars below?
            // Equation in affine coordinates: ax² + y² = 1 + dx²y²
            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X); // X²
            const Y2 = modP(Y * Y); // Y²
            const Z2 = modP(Z * Z); // Z²
            const Z4 = modP(Z2 * Z2); // Z⁴
            const aX2 = modP(X2 * a); // aX²
            const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²
            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²
            if (left !== right) throw new Error("bad point: equation left != right (1)");
            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
        }
        // Compare one point to another.
        equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            // Faster algo for adding 2 Extended Points when curve's a=-1.
            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4
            // Cost: 8M + 8add + 2*2.
            // Note: It does not check whether the `other` point is valid.
            if (a === BigInt(-1)) {
                const A = modP((Y1 - X1) * (Y2 + X2));
                const B = modP((Y1 + X1) * (Y2 - X2));
                const F = modP(B - A);
                if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing
                const C = modP(Z1 * _2n * T2);
                const D = modP(T1 * _2n * Z2);
                const E = D + C;
                const G = B + A;
                const H = D - C;
                const X3 = modP(E * F);
                const Y3 = modP(G * H);
                const T3 = modP(E * H);
                const Z3 = modP(F * G);
                return new Point(X3, Y3, Z3, T3);
            }
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
        }
        // Constant-time multiplication.
        multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([
                p,
                f
            ])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        multiplyUnsafe(scalar) {
            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n
            if (n === _0n) return I;
            if (this.equals(I) || n === _1n) return this;
            if (this.equals(G)) return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0) return {
                x: _0n,
                y: _1n
            };
            if (zz !== _1n) throw new Error("invZ was invalid");
            return {
                x: ax,
                y: ay
            };
        }
        clearCofactor() {
            const { h: cofactor } = CURVE;
            if (cofactor === _1n) return this;
            return this.multiplyUnsafe(cofactor);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp.BYTES;
            hex = (0, _utilsJs.ensureBytes)("pointHex", hex, len); // copy hex to a new array
            const normed = hex.slice(); // copy again, we'll manipulate it
            const lastByte = hex[len - 1]; // select last byte
            normed[len - 1] = lastByte & -129; // clear last bit
            const y = _utilsJs.bytesToNumberLE(normed);
            if (y === _0n) ;
            else // RFC8032 prohibits >= p, but ZIP215 doesn't
            if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)
            else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)
            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:
            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y² - 1
            const v = modP(d * y2 - a); // v = d y² + 1.
            let { isValid, value: x } = uvRatio(u, v); // √(u/v)
            if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail
            throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({
                x,
                y
            });
        }
        static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
        }
        toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes = _utilsJs.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y
            return bytes; // and use the last byte to encode sign of x
        }
        toHex() {
            return _utilsJs.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    const { BASE: G, ZERO: I } = Point;
    const wnaf = (0, _curveJs.wNAF)(Point, nByteLength * 8);
    function modN(a) {
        return (0, _modularJs.mod)(a, CURVE_ORDER);
    }
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return modN(_utilsJs.bytesToNumberLE(hash));
    }
    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */ function getExtendedPublicKey(key) {
        const len = nByteLength;
        key = (0, _utilsJs.ensureBytes)("private key", key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, _utilsJs.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        const point = G.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toRawBytes(); // Uint8Array representation
        return {
            head,
            prefix,
            scalar,
            point,
            pointBytes
        };
    }
    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared
    function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
        const msg = _utilsJs.concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, (0, _utilsJs.ensureBytes)("context", context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, privKey, options = {}) {
        msg = (0, _utilsJs.ensureBytes)("message", msg);
        if (prehash) msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = G.multiply(r).toRawBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = modN(r + k * scalar); // S = (r + k * s) mod L
        assertGE0(s); // 0 <= s < l
        const res = _utilsJs.concatBytes(R, _utilsJs.numberToBytesLE(s, Fp.BYTES));
        return (0, _utilsJs.ensureBytes)("result", res, nByteLength * 2); // 64-byte signature
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
        sig = (0, _utilsJs.ensureBytes)("signature", sig, 2 * len); // An extended group equation is checked.
        msg = (0, _utilsJs.ensureBytes)("message", msg);
        if (prehash) msg = prehash(msg); // for ed25519ph, etc
        const s = _utilsJs.bytesToNumberLE(sig.slice(len, 2 * len));
        // zip215: true is good for consensus-critical apps and allows points < 2^256
        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p
        let A, R, SB;
        try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside
        } catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder()) return false;
        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    const utils = {
        getExtendedPublicKey,
        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
        randomPrivateKey: ()=>randomBytes(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
        }
    };
    return {
        CURVE,
        getPublicKey,
        sign,
        verify,
        ExtendedPoint: Point,
        utils
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","./curve.js":"37yfg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aWzDR":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Calculates a modulo b
parcelHelpers.export(exports, "mod", ()=>mod);
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
parcelHelpers.export(exports, "pow", ()=>pow);
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
parcelHelpers.export(exports, "pow2", ()=>pow2);
// Inverses number over modulo
parcelHelpers.export(exports, "invert", ()=>invert);
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ parcelHelpers.export(exports, "tonelliShanks", ()=>tonelliShanks);
parcelHelpers.export(exports, "FpSqrt", ()=>FpSqrt);
parcelHelpers.export(exports, "isNegativeLE", ()=>isNegativeLE);
parcelHelpers.export(exports, "validateField", ()=>validateField);
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ parcelHelpers.export(exports, "FpPow", ()=>FpPow);
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ parcelHelpers.export(exports, "FpInvertBatch", ()=>FpInvertBatch);
parcelHelpers.export(exports, "FpDiv", ()=>FpDiv);
// This function returns True whenever the value x is a square in the field F.
parcelHelpers.export(exports, "FpIsSquare", ()=>FpIsSquare);
// CURVE.n lengths
parcelHelpers.export(exports, "nLength", ()=>nLength);
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ parcelHelpers.export(exports, "Field", ()=>Field);
parcelHelpers.export(exports, "FpSqrtOdd", ()=>FpSqrtOdd);
parcelHelpers.export(exports, "FpSqrtEven", ()=>FpSqrtEven);
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ parcelHelpers.export(exports, "hashToPrivateScalar", ()=>hashToPrivateScalar);
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ parcelHelpers.export(exports, "getFieldBytesLength", ()=>getFieldBytesLength);
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ parcelHelpers.export(exports, "getMinHashLength", ()=>getMinHashLength);
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ parcelHelpers.export(exports, "mapHashToField", ()=>mapHashToField);
var _utilsJs = require("./utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error("Expected power/modulo > 0");
    if (modulo === _1n) return _0n;
    let res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
function pow2(x, power, modulo) {
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error("invert: does not exist");
    return mod(x, modulo);
}
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ≡ 1    if a is a square (mod p)
    // (a | p) ≡ -1   if a is not a square (mod p)
    // (a | p) ≡ 0    if a ≡ 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error("Cannot find square root");
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for(let t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ≡ 3 (mod 4)
    // √n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // P ≡ 9 (mod 16)
    _9n;
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
const isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;
// prettier-ignore
const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function validateField(field) {
    const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val)=>{
        map[val] = "function";
        return map;
    }, initial);
    return (0, _utilsJs.validateObject)(field, opts);
}
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error("Expected power > 0");
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    let p = f.ONE;
    let d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
}
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x)=>{
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength
    };
}
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, _utilsJs.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num)=>mod(num, ORDER),
        isValid: (num)=>{
            if (typeof num !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num)=>num === _0n,
        isOdd: (num)=>(num & _1n) === _1n,
        neg: (num)=>mod(-num, ORDER),
        eql: (lhs, rhs)=>lhs === rhs,
        sqr: (num)=>mod(num * num, ORDER),
        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),
        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),
        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),
        pow: (num, power)=>FpPow(f, num, power),
        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num)=>num * num,
        addN: (lhs, rhs)=>lhs + rhs,
        subN: (lhs, rhs)=>lhs - rhs,
        mulN: (lhs, rhs)=>lhs * rhs,
        inv: (num)=>invert(num, ORDER),
        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),
        invertBatch: (lst)=>FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c)=>c ? b : a,
        toBytes: (num)=>isLE ? (0, _utilsJs.numberToBytesLE)(num, BYTES) : (0, _utilsJs.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes)=>{
            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, _utilsJs.bytesToNumberLE)(bytes) : (0, _utilsJs.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, _utilsJs.ensureBytes)("privateHash", hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, _utilsJs.bytesToNumberLE)(hash) : (0, _utilsJs.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, _utilsJs.bytesToNumberBE)(key) : (0, _utilsJs.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, _utilsJs.numberToBytesLE)(reduced, fieldLen) : (0, _utilsJs.numberToBytesBE)(reduced, fieldLen);
}

},{"./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6xA5w":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBytes", ()=>isBytes);
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
parcelHelpers.export(exports, "numberToHexUnpadded", ()=>numberToHexUnpadded);
parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
// BE: Big Endian, LE: Little Endian
parcelHelpers.export(exports, "bytesToNumberBE", ()=>bytesToNumberBE);
parcelHelpers.export(exports, "bytesToNumberLE", ()=>bytesToNumberLE);
parcelHelpers.export(exports, "numberToBytesBE", ()=>numberToBytesBE);
parcelHelpers.export(exports, "numberToBytesLE", ()=>numberToBytesLE);
// Unpadded, rarely used
parcelHelpers.export(exports, "numberToVarBytesBE", ()=>numberToVarBytesBE);
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ parcelHelpers.export(exports, "ensureBytes", ()=>ensureBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
// Compares 2 u8a-s in kinda constant time
parcelHelpers.export(exports, "equalBytes", ()=>equalBytes);
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ parcelHelpers.export(exports, "bitLen", ()=>bitLen);
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ parcelHelpers.export(exports, "bitGet", ()=>bitGet);
parcelHelpers.export(exports, "bitSet", ()=>bitSet);
parcelHelpers.export(exports, "bitMask", ()=>bitMask);
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ parcelHelpers.export(exports, "createHmacDrbg", ()=>createHmacDrbg);
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
parcelHelpers.export(exports, "validateObject", ()=>validateObject) // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
;
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!isBytes(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    // Big Endian
    return BigInt(hex === "" ? "0" : `0x${hex}`);
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    if (!isBytes(bytes)) throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
    else if (isBytes(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(`${title} must be hex string or Uint8Array`);
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        if (!isBytes(a)) throw new Error("Uint8Array expected");
        sum += a.length;
    }
    let res = new Uint8Array(sum);
    let pad = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
const bitSet = (n, pos, value)=>{
    return n | (value ? _1n : _0n) << BigInt(pos);
};
const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;
// DRBG
const u8n = (data)=>new Uint8Array(data); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n())=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === "bigint",
    function: (val)=>typeof val === "function",
    boolean: (val)=>typeof val === "boolean",
    string: (val)=>typeof val === "string",
    stringOrUint8Array: (val)=>typeof val === "string" || isBytes(val),
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"37yfg":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
parcelHelpers.export(exports, "wNAF", ()=>wNAF);
parcelHelpers.export(exports, "validateBasic", ()=>validateBasic);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function wNAF(c, bits) {
    const constTimeNegate = (condition, item)=>{
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W)=>{
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return {
            windows,
            windowSize
        };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder (elm, n) {
            let p = c.ZERO;
            let d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow (elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for(let window = 0; window < windows; window++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(let i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF (W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for(let window = 0; window < windows; window++){
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) // The most important part for const-time getPublicKey
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p,
                f
            };
        },
        wNAFCached (P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) precomputesMap.set(P, transform(comp));
            }
            return this.wNAF(W, comp, n);
        }
    };
}
function validateBasic(curve) {
    (0, _modularJs.validateField)(curve.Fp);
    (0, _utilsJs.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    });
    // Set defaults
    return Object.freeze({
        ...(0, _modularJs.nLength)(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"61N39":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)
// Uses only one coordinate instead of two
parcelHelpers.export(exports, "montgomery", ()=>montgomery);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function validateOpts(curve) {
    (0, _utilsJs.validateObject)(curve, {
        a: "bigint"
    }, {
        montgomeryBits: "isSafeInteger",
        nByteLength: "isSafeInteger",
        adjustScalarBytes: "function",
        domain: "function",
        powPminus2: "function",
        Gu: "bigint"
    });
    // Set defaults
    return Object.freeze({
        ...curve
    });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P } = CURVE;
    const modP = (n)=>(0, _modularJs.mod)(n, P);
    const montgomeryBits = CURVE.montgomeryBits;
    const montgomeryBytes = Math.ceil(montgomeryBits / 8);
    const fieldLen = CURVE.nByteLength;
    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes)=>bytes);
    const powPminus2 = CURVE.powPminus2 || ((x)=>(0, _modularJs.pow)(x, P - BigInt(2), P));
    // cswap from RFC7748. But it is not from RFC7748!
    /*
      cswap(swap, x_2, x_3):
           dummy = mask(swap) AND (x_2 XOR x_3)
           x_2 = x_2 XOR dummy
           x_3 = x_3 XOR dummy
           Return (x_2, x_3)
    Where mask(swap) is the all-1 or all-0 word of the same length as x_2
     and x_3, computed, e.g., as mask(swap) = 0 - swap.
    */ function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return [
            x_2,
            x_3
        ];
    }
    // Accepts 0 as well
    function assertFieldElement(n) {
        if (typeof n === "bigint" && _0n <= n && n < P) return n;
        throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
    }
    // x25519 from 4
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519
    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
    /**
     *
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */ function montgomeryLadder(pointU, scalar) {
        const u = assertFieldElement(pointU);
        // Section 5: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.
        const k = assertFieldElement(scalar);
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        let sw;
        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){
            const k_t = k >> t & _1n;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        // (x_2, x_3) = cswap(swap, x_2, x_3)
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        // (z_2, z_3) = cswap(swap, z_2, z_3)
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        // z_2^(p - 2)
        const z2 = powPminus2(z_2);
        // Return x_2 * (z_2^(p - 2))
        return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
        return (0, _utilsJs.numberToBytesLE)(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
        // Section 5: When receiving such an array, implementations of X25519
        // MUST mask the most significant bit in the final byte.
        const u = (0, _utilsJs.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
        if (fieldLen === 32) u[31] &= 127; // 0b0111_1111
        return (0, _utilsJs.bytesToNumberLE)(u);
    }
    function decodeScalar(n) {
        const bytes = (0, _utilsJs.ensureBytes)("scalar", n);
        const len = bytes.length;
        if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
        return (0, _utilsJs.bytesToNumberLE)(adjustScalarBytes(bytes));
    }
    function scalarMult(scalar, u) {
        const pointU = decodeUCoordinate(u);
        const _scalar = decodeScalar(scalar);
        const pu = montgomeryLadder(pointU, _scalar);
        // The result was not contributory
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n) throw new Error("Invalid private or public key received");
        return encodeUCoordinate(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    const GuBytes = encodeUCoordinate(CURVE.Gu);
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey)=>scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey)=>scalarMultBase(privateKey),
        utils: {
            randomPrivateKey: ()=>CURVE.randomBytes(CURVE.nByteLength)
        },
        GuBytes: GuBytes
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"xT4Ur":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
parcelHelpers.export(exports, "expand_message_xmd", ()=>expand_message_xmd);
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
parcelHelpers.export(exports, "expand_message_xof", ()=>expand_message_xof);
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ parcelHelpers.export(exports, "hash_to_field", ()=>hash_to_field);
parcelHelpers.export(exports, "isogenyMap", ()=>isogenyMap);
parcelHelpers.export(exports, "createHasher", ()=>createHasher);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
function validateDST(dst) {
    if ((0, _utilsJs.isBytes)(dst)) return dst;
    if (typeof dst === "string") return (0, _utilsJs.utf8ToBytes)(dst);
    throw new Error("DST must be Uint8Array or string");
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = (0, _utilsJs.bytesToNumberBE);
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    const res = Array.from({
        length
    }).fill(0);
    for(let i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];
    return arr;
}
function abytes(item) {
    if (!(0, _utilsJs.isBytes)(item)) throw new Error("Uint8Array expected");
}
function isNum(item) {
    if (!Number.isSafeInteger(item)) throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, _utilsJs.concatBytes)((0, _utilsJs.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255) throw new Error("Invalid xmd length");
    const DST_prime = (0, _utilsJs.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, _utilsJs.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, _utilsJs.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(let i = 1; i <= ell; i++){
        const args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H((0, _utilsJs.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, _utilsJs.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    abytes(msg);
    abytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen
        }).update((0, _utilsJs.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
    (0, _utilsJs.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    abytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === "xmd") prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    else if (expand === "xof") prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    else if (expand === "_internal_pass") // for internal tests only
    prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for(let i = 0; i < count; i++){
        const e = new Array(m);
        for(let j = 0; j < m; j++){
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, _modularJs.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i)=>Array.from(i).reverse());
    return (x, y)=>{
        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return {
            x,
            y
        };
    };
}
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve (msg, options) {
            const u = hash_to_field(msg, 2, {
                ...def,
                DST: def.DST,
                ...options
            });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve (msg, options) {
            const u = hash_to_field(msg, 1, {
                ...def,
                DST: def.encodeDST,
                ...options
            });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        }
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"87Mdx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Exports the given PrivateKey as a base64 encoded string.
 * The PrivateKey is encrypted via a password derived PBKDF2 key
 * leveraging the aes-gcm cipher algorithm.
 */ parcelHelpers.export(exports, "exporter", ()=>exporter);
var _base64 = require("multiformats/bases/base64");
var _aesGcmJs = require("../ciphers/aes-gcm.js");
async function exporter(privateKey, password) {
    const cipher = _aesGcmJs.create();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return (0, _base64.base64).encode(encryptedKey);
}

},{"multiformats/bases/base64":"2m5sV","../ciphers/aes-gcm.js":"5nLhA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5nLhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "derivedEmptyPasswordKey", ()=>derivedEmptyPasswordKey);
// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples
parcelHelpers.export(exports, "create", ()=>create);
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
var _webcryptoJs = require("../webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
const derivedEmptyPasswordKey = {
    alg: "A128GCM",
    ext: true,
    k: "scm9jmO_4BJAgdwWGVulLg",
    key_ops: [
        "encrypt",
        "decrypt"
    ],
    kty: "oct"
};
function create(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto = (0, _webcryptoJsDefault.default).get();
    keyLength *= 8; // Browser crypto uses bits instead of bytes
    /**
     * Uses the provided password to derive a pbkdf2 key. The key
     * will then be used to encrypt the data.
     */ async function encrypt(data, password) {
        const salt = crypto.getRandomValues(new Uint8Array(saltLength));
        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));
        const aesGcm = {
            name: algorithm,
            iv: nonce
        };
        if (typeof password === "string") password = (0, _fromString.fromString)(password);
        let cryptoKey;
        if (password.length === 0) {
            cryptoKey = await crypto.subtle.importKey("jwk", derivedEmptyPasswordKey, {
                name: "AES-GCM"
            }, true, [
                "encrypt"
            ]);
            try {
                const deriveParams = {
                    name: "PBKDF2",
                    salt,
                    iterations,
                    hash: {
                        name: digest
                    }
                };
                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey("raw", password, {
                    name: "PBKDF2"
                }, false, [
                    "deriveKey"
                ]);
                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, {
                    name: algorithm,
                    length: keyLength
                }, true, [
                    "encrypt"
                ]);
            } catch  {
                cryptoKey = await crypto.subtle.importKey("jwk", derivedEmptyPasswordKey, {
                    name: "AES-GCM"
                }, true, [
                    "encrypt"
                ]);
            }
        } else {
            // Derive a key using PBKDF2.
            const deriveParams = {
                name: "PBKDF2",
                salt,
                iterations,
                hash: {
                    name: digest
                }
            };
            const rawKey = await crypto.subtle.importKey("raw", password, {
                name: "PBKDF2"
            }, false, [
                "deriveKey"
            ]);
            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {
                name: algorithm,
                length: keyLength
            }, true, [
                "encrypt"
            ]);
        }
        // Encrypt the string.
        const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);
        return (0, _concat.concat)([
            salt,
            aesGcm.iv,
            new Uint8Array(ciphertext)
        ]);
    }
    /**
     * Uses the provided password to derive a pbkdf2 key. The key
     * will then be used to decrypt the data. The options used to create
     * this decryption cipher must be the same as those used to create
     * the encryption cipher.
     */ async function decrypt(data, password) {
        const salt = data.subarray(0, saltLength);
        const nonce = data.subarray(saltLength, saltLength + nonceLength);
        const ciphertext = data.subarray(saltLength + nonceLength);
        const aesGcm = {
            name: algorithm,
            iv: nonce
        };
        if (typeof password === "string") password = (0, _fromString.fromString)(password);
        let cryptoKey;
        if (password.length === 0) try {
            const deriveParams = {
                name: "PBKDF2",
                salt,
                iterations,
                hash: {
                    name: digest
                }
            };
            const runtimeDerivedEmptyPassword = await crypto.subtle.importKey("raw", password, {
                name: "PBKDF2"
            }, false, [
                "deriveKey"
            ]);
            cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, {
                name: algorithm,
                length: keyLength
            }, true, [
                "decrypt"
            ]);
        } catch  {
            cryptoKey = await crypto.subtle.importKey("jwk", derivedEmptyPasswordKey, {
                name: "AES-GCM"
            }, true, [
                "decrypt"
            ]);
        }
        else {
            // Derive the key using PBKDF2.
            const deriveParams = {
                name: "PBKDF2",
                salt,
                iterations,
                hash: {
                    name: digest
                }
            };
            const rawKey = await crypto.subtle.importKey("raw", password, {
                name: "PBKDF2"
            }, false, [
                "deriveKey"
            ]);
            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {
                name: algorithm,
                length: keyLength
            }, true, [
                "decrypt"
            ]);
        }
        // Decrypt the string.
        const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
        return new Uint8Array(plaintext);
    }
    const cipher = {
        encrypt,
        decrypt
    };
    return cipher;
}

},{"uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","../webcrypto.js":"lOvMh","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lOvMh":[function(require,module,exports) {
/* eslint-env browser */ // Check native crypto exists and is enabled (In insecure context `self.crypto`
// exists but `self.crypto.subtle` does not).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    get (win = globalThis) {
        const nativeCrypto = win.crypto;
        if (nativeCrypto == null || nativeCrypto.subtle == null) throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api"), {
            code: "ERR_MISSING_WEB_CRYPTO"
        });
        return nativeCrypto;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fwqFh":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KeyType", ()=>KeyType);
parcelHelpers.export(exports, "PublicKey", ()=>PublicKey);
parcelHelpers.export(exports, "PrivateKey", ()=>PrivateKey);
var _protonsRuntime = require("protons-runtime");
var KeyType;
(function(KeyType) {
    KeyType["RSA"] = "RSA";
    KeyType["Ed25519"] = "Ed25519";
    KeyType["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues) {
    __KeyTypeValues[__KeyTypeValues["RSA"] = 0] = "RSA";
    __KeyTypeValues[__KeyTypeValues["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues[__KeyTypeValues["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType) {
    KeyType.codec = ()=>{
        return (0, _protonsRuntime.enumeration)(__KeyTypeValues);
    };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey) {
    let _codec;
    PublicKey.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.Type != null) {
                w.uint32(8);
                KeyType.codec().encode(obj.Type, w);
            }
            if (obj.Data != null) {
                w.uint32(18);
                w.bytes(obj.Data);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.Type = KeyType.codec().decode(reader);
                        break;
                    case 2:
                        obj.Data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    PublicKey.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, PublicKey.codec());
    };
    PublicKey.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, PublicKey.codec());
    };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey) {
    let _codec;
    PrivateKey.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.Type != null) {
                w.uint32(8);
                KeyType.codec().encode(obj.Type, w);
            }
            if (obj.Data != null) {
                w.uint32(18);
                w.bytes(obj.Data);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.Type = KeyType.codec().decode(reader);
                        break;
                    case 2:
                        obj.Data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    PrivateKey.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, PrivateKey.codec());
    };
    PrivateKey.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, PrivateKey.codec());
    };
})(PrivateKey || (PrivateKey = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iJEgs":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module contains serialization/deserialization code used when encoding/decoding protobufs.
 *
 * It should be declared as a dependency of your project:
 *
 * ```console
 * npm i protons-runtime
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeMessage", ()=>(0, _decodeJs.decodeMessage));
parcelHelpers.export(exports, "encodeMessage", ()=>(0, _encodeJs.encodeMessage));
parcelHelpers.export(exports, "enumeration", ()=>(0, _enumJs.enumeration));
parcelHelpers.export(exports, "message", ()=>(0, _messageJs.message));
parcelHelpers.export(exports, "reader", ()=>(0, _readerJs.createReader));
parcelHelpers.export(exports, "writer", ()=>(0, _writerJs.createWriter));
parcelHelpers.export(exports, "CodeError", ()=>CodeError);
var _decodeJs = require("./decode.js");
var _encodeJs = require("./encode.js");
var _enumJs = require("./codecs/enum.js");
var _messageJs = require("./codecs/message.js");
var _readerJs = require("./utils/reader.js");
var _writerJs = require("./utils/writer.js");
class CodeError extends Error {
    code;
    constructor(message, code, options){
        super(message, options);
        this.code = code;
    }
}

},{"./decode.js":"kqCHV","./encode.js":"9XLnn","./codecs/enum.js":"kRpk8","./codecs/message.js":"7Bfyi","./utils/reader.js":"62ZrY","./utils/writer.js":"jqHn1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kqCHV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeMessage", ()=>decodeMessage);
var _readerJs = require("./utils/reader.js");
function decodeMessage(buf, codec, opts) {
    const reader = (0, _readerJs.createReader)(buf);
    return codec.decode(reader, undefined, opts);
}

},{"./utils/reader.js":"62ZrY","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"62ZrY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Constructs a new reader instance using the specified buffer.
 */ parcelHelpers.export(exports, "Uint8ArrayReader", ()=>Uint8ArrayReader);
parcelHelpers.export(exports, "createReader", ()=>createReader);
var _uint8Varint = require("uint8-varint");
var _floatJs = require("./float.js");
var _longbitsJs = require("./longbits.js");
var _utf8Js = require("./utf8.js");
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
class Uint8ArrayReader {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer){
        /**
         * Read buffer
         */ this.buf = buffer;
        /**
         * Read buffer position
         */ this.pos = 0;
        /**
         * Read buffer length
         */ this.len = buffer.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */ uint32() {
        let value = 4294967295;
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */ int32() {
        return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */ sint32() {
        const value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */ bool() {
        return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */ fixed32() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        const res = readFixed32End(this.buf, this.pos += 4);
        return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */ sfixed32() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        const res = readFixed32End(this.buf, this.pos += 4) | 0;
        return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */ float() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        const value = (0, _floatJs.readFloatLE)(this.buf, this.pos);
        this.pos += 4;
        return value;
    }
    /**
     * Reads a double (64 bit float) as a number
     */ double() {
        /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
        const value = (0, _floatJs.readDoubleLE)(this.buf, this.pos);
        this.pos += 8;
        return value;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */ bytes() {
        const length = this.uint32();
        const start = this.pos;
        const end = this.pos + length;
        /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
         ? new Uint8Array(0) : this.buf.subarray(start, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */ string() {
        const bytes = this.bytes();
        return _utf8Js.read(bytes, 0, bytes.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */ skip(length) {
        if (typeof length === "number") {
            /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
            this.pos += length;
        } else do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while ((this.buf[this.pos++] & 128) !== 0);
        return this;
    }
    /**
     * Skips the next element of the specified wire type
     */ skipType(wireType) {
        switch(wireType){
            case 0:
                this.skip();
                break;
            case 1:
                this.skip(8);
                break;
            case 2:
                this.skip(this.uint32());
                break;
            case 3:
                while((wireType = this.uint32() & 7) !== 4)this.skipType(wireType);
                break;
            case 5:
                this.skip(4);
                break;
            /* istanbul ignore next */ default:
                throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
        }
        return this;
    }
    readLongVarint() {
        // tends to deopt with local vars for octet etc.
        const bits = new (0, _longbitsJs.LongBits)(0, 0);
        let i = 0;
        if (this.len - this.pos > 4) {
            for(; i < 4; ++i){
                // 1st..4th
                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                if (this.buf[this.pos++] < 128) return bits;
            }
            // 5th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
            i = 0;
        } else {
            for(; i < 3; ++i){
                /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
                // 1st..3th
                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                if (this.buf[this.pos++] < 128) return bits;
            }
            // 4th
            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
            return bits;
        }
        if (this.len - this.pos > 4) for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        else for(; i < 5; ++i){
            if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        throw Error("invalid varint encoding");
    }
    readFixed64() {
        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
        const lo = readFixed32End(this.buf, this.pos += 4);
        const hi = readFixed32End(this.buf, this.pos += 4);
        return new (0, _longbitsJs.LongBits)(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */ int64() {
        return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */ int64Number() {
        return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */ int64String() {
        return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */ uint64() {
        return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */ uint64Number() {
        const value = (0, _uint8Varint.decodeUint8Array)(this.buf, this.pos);
        this.pos += (0, _uint8Varint.encodingLength)(value);
        return value;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */ uint64String() {
        return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */ sint64() {
        return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */ sint64Number() {
        return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */ sint64String() {
        return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */ fixed64() {
        return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */ fixed64Number() {
        return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */ fixed64String() {
        return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */ sfixed64() {
        return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */ sfixed64Number() {
        return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */ sfixed64String() {
        return this.readFixed64().toString();
    }
}
function createReader(buf) {
    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
}

},{"uint8-varint":"3o84q","./float.js":"8eACB","./longbits.js":"dkeOl","./utf8.js":"iMowT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3o84q":[function(require,module,exports) {
/* eslint-disable no-fallthrough */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodingLength", ()=>encodingLength);
parcelHelpers.export(exports, "encodeUint8Array", ()=>encodeUint8Array);
parcelHelpers.export(exports, "encodeUint8ArrayList", ()=>encodeUint8ArrayList);
parcelHelpers.export(exports, "decodeUint8Array", ()=>decodeUint8Array);
parcelHelpers.export(exports, "decodeUint8ArrayList", ()=>decodeUint8ArrayList);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _alloc = require("uint8arrays/alloc");
const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
/** Most significant bit of a byte */ const MSB = 0x80;
/** Rest of the bits in a byte */ const REST = 0x7f;
function encodingLength(value) {
    if (value < N1) return 1;
    if (value < N2) return 2;
    if (value < N3) return 3;
    if (value < N4) return 4;
    if (value < N5) return 5;
    if (value < N6) return 6;
    if (value < N7) return 7;
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) throw new RangeError("Could not encode varint");
    return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            buf[offset++] = value & 0xFF | MSB;
            value /= 128;
        case 7:
            buf[offset++] = value & 0xFF | MSB;
            value /= 128;
        case 6:
            buf[offset++] = value & 0xFF | MSB;
            value /= 128;
        case 5:
            buf[offset++] = value & 0xFF | MSB;
            value /= 128;
        case 4:
            buf[offset++] = value & 0xFF | MSB;
            value >>>= 7;
        case 3:
            buf[offset++] = value & 0xFF | MSB;
            value >>>= 7;
        case 2:
            buf[offset++] = value & 0xFF | MSB;
            value >>>= 7;
        case 1:
            buf[offset++] = value & 0xFF;
            value >>>= 7;
            break;
        default:
            throw new Error("unreachable");
    }
    return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            buf.set(offset++, value & 0xFF | MSB);
            value /= 128;
        case 7:
            buf.set(offset++, value & 0xFF | MSB);
            value /= 128;
        case 6:
            buf.set(offset++, value & 0xFF | MSB);
            value /= 128;
        case 5:
            buf.set(offset++, value & 0xFF | MSB);
            value /= 128;
        case 4:
            buf.set(offset++, value & 0xFF | MSB);
            value >>>= 7;
        case 3:
            buf.set(offset++, value & 0xFF | MSB);
            value >>>= 7;
        case 2:
            buf.set(offset++, value & 0xFF | MSB);
            value >>>= 7;
        case 1:
            buf.set(offset++, value & 0xFF);
            value >>>= 7;
            break;
        default:
            throw new Error("unreachable");
    }
    return buf;
}
function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) return res;
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) return res;
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) return res;
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) return res;
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) return res;
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) return res;
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) return res;
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) return res;
    throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) return res;
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) return res;
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) return res;
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) return res;
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) return res;
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) return res;
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) return res;
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) return res;
    throw new RangeError("Could not decode varint");
}
function encode(value, buf, offset = 0) {
    if (buf == null) buf = (0, _alloc.allocUnsafe)(encodingLength(value));
    if (buf instanceof Uint8Array) return encodeUint8Array(value, buf, offset);
    else return encodeUint8ArrayList(value, buf, offset);
}
function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) return decodeUint8Array(buf, offset);
    else return decodeUint8ArrayList(buf, offset);
}

},{"uint8arrays/alloc":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8eACB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Writes a 32 bit float to a buffer using little endian byte order
 */ parcelHelpers.export(exports, "writeFloatLE", ()=>writeFloatLE);
/**
 * Writes a 32 bit float to a buffer using big endian byte order
 */ parcelHelpers.export(exports, "writeFloatBE", ()=>writeFloatBE);
/**
 * Reads a 32 bit float from a buffer using little endian byte order
 */ parcelHelpers.export(exports, "readFloatLE", ()=>readFloatLE);
/**
 * Reads a 32 bit float from a buffer using big endian byte order
 */ parcelHelpers.export(exports, "readFloatBE", ()=>readFloatBE);
/**
 * Writes a 64 bit double to a buffer using little endian byte order
 */ parcelHelpers.export(exports, "writeDoubleLE", ()=>writeDoubleLE);
/**
 * Writes a 64 bit double to a buffer using big endian byte order
 */ parcelHelpers.export(exports, "writeDoubleBE", ()=>writeDoubleBE);
/**
 * Reads a 64 bit double from a buffer using little endian byte order
 */ parcelHelpers.export(exports, "readDoubleLE", ()=>readDoubleLE);
/**
 * Reads a 64 bit double from a buffer using big endian byte order
 */ parcelHelpers.export(exports, "readDoubleBE", ()=>readDoubleBE);
const f32 = new Float32Array([
    -0
]);
const f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf, pos) {
    f32[0] = val;
    buf[pos] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
}
function writeFloatBE(val, buf, pos) {
    f32[0] = val;
    buf[pos] = f8b[3];
    buf[pos + 1] = f8b[2];
    buf[pos + 2] = f8b[1];
    buf[pos + 3] = f8b[0];
}
function readFloatLE(buf, pos) {
    f8b[0] = buf[pos];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    return f32[0];
}
function readFloatBE(buf, pos) {
    f8b[3] = buf[pos];
    f8b[2] = buf[pos + 1];
    f8b[1] = buf[pos + 2];
    f8b[0] = buf[pos + 3];
    return f32[0];
}
const f64 = new Float64Array([
    -0
]);
const d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf, pos) {
    f64[0] = val;
    buf[pos] = d8b[0];
    buf[pos + 1] = d8b[1];
    buf[pos + 2] = d8b[2];
    buf[pos + 3] = d8b[3];
    buf[pos + 4] = d8b[4];
    buf[pos + 5] = d8b[5];
    buf[pos + 6] = d8b[6];
    buf[pos + 7] = d8b[7];
}
function writeDoubleBE(val, buf, pos) {
    f64[0] = val;
    buf[pos] = d8b[7];
    buf[pos + 1] = d8b[6];
    buf[pos + 2] = d8b[5];
    buf[pos + 3] = d8b[4];
    buf[pos + 4] = d8b[3];
    buf[pos + 5] = d8b[2];
    buf[pos + 6] = d8b[1];
    buf[pos + 7] = d8b[0];
}
function readDoubleLE(buf, pos) {
    d8b[0] = buf[pos];
    d8b[1] = buf[pos + 1];
    d8b[2] = buf[pos + 2];
    d8b[3] = buf[pos + 3];
    d8b[4] = buf[pos + 4];
    d8b[5] = buf[pos + 5];
    d8b[6] = buf[pos + 6];
    d8b[7] = buf[pos + 7];
    return f64[0];
}
function readDoubleBE(buf, pos) {
    d8b[7] = buf[pos];
    d8b[6] = buf[pos + 1];
    d8b[5] = buf[pos + 2];
    d8b[4] = buf[pos + 3];
    d8b[3] = buf[pos + 4];
    d8b[2] = buf[pos + 5];
    d8b[1] = buf[pos + 6];
    d8b[0] = buf[pos + 7];
    return f64[0];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dkeOl":[function(require,module,exports) {
// the largest BigInt we can safely downcast to a Number
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Constructs new long bits.
 *
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @function Object() { [native code] }
 * @param {number} lo - Low 32 bits, unsigned
 * @param {number} hi - High 32 bits, unsigned
 */ parcelHelpers.export(exports, "LongBits", ()=>LongBits);
const MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
const MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
class LongBits {
    lo;
    hi;
    constructor(lo, hi){
        // note that the casts below are theoretically unnecessary as of today, but older statically
        // generated converter code might still call the ctor with signed 32bits. kept for compat.
        /**
         * Low bits
         */ this.lo = lo | 0;
        /**
         * High bits
         */ this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */ toNumber(unsigned = false) {
        if (!unsigned && this.hi >>> 31 > 0) {
            const lo = ~this.lo + 1 >>> 0;
            let hi = ~this.hi >>> 0;
            if (lo === 0) hi = hi + 1 >>> 0;
            return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */ toBigInt(unsigned = false) {
        if (unsigned) return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
        if (this.hi >>> 31 !== 0) {
            const lo = ~this.lo + 1 >>> 0;
            let hi = ~this.hi >>> 0;
            if (lo === 0) hi = hi + 1 >>> 0;
            return -(BigInt(lo) + (BigInt(hi) << 32n));
        }
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */ toString(unsigned = false) {
        return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */ zzEncode() {
        const mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
    }
    /**
     * Zig-zag decodes this long bits
     */ zzDecode() {
        const mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */ length() {
        const part0 = this.lo;
        const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
        const part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */ static fromBigInt(value) {
        if (value === 0n) return zero;
        if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) return this.fromNumber(Number(value));
        const negative = value < 0n;
        if (negative) value = -value;
        let hi = value >> 32n;
        let lo = value - (hi << 32n);
        if (negative) {
            hi = ~hi | 0n;
            lo = ~lo | 0n;
            if (++lo > TWO_32) {
                lo = 0n;
                if (++hi > TWO_32) hi = 0n;
            }
        }
        return new LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */ static fromNumber(value) {
        if (value === 0) return zero;
        const sign = value < 0;
        if (sign) value = -value;
        let lo = value >>> 0;
        let hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
            hi = ~hi >>> 0;
            lo = ~lo >>> 0;
            if (++lo > 4294967295) {
                lo = 0;
                if (++hi > 4294967295) hi = 0;
            }
        }
        return new LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */ static from(value) {
        if (typeof value === "number") return LongBits.fromNumber(value);
        if (typeof value === "bigint") return LongBits.fromBigInt(value);
        if (typeof value === "string") return LongBits.fromBigInt(BigInt(value));
        return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }
}
const zero = new LongBits(0, 0);
zero.toBigInt = function() {
    return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
const TWO_32 = 4294967296n;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iMowT":[function(require,module,exports) {
/**
 * Calculates the UTF8 byte length of a string
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "length", ()=>length);
/**
 * Reads UTF8 bytes as a string
 */ parcelHelpers.export(exports, "read", ()=>read);
/**
 * Writes a string as UTF8 bytes
 */ parcelHelpers.export(exports, "write", ()=>write);
function length(string) {
    let len = 0;
    let c = 0;
    for(let i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
}
function read(buffer, start, end) {
    const len = end - start;
    if (len < 1) return "";
    let parts;
    const chunk = [];
    let i = 0; // char offset
    let t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts != null) {
        if (i > 0) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
}
function write(string, buffer, offset) {
    const start = offset;
    let c1; // character 1
    let c2; // character 2
    for(let i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) buffer[offset++] = c1;
        else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9XLnn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeMessage", ()=>encodeMessage);
var _writerJs = require("./utils/writer.js");
function encodeMessage(message, codec) {
    const w = (0, _writerJs.createWriter)();
    codec.encode(message, w, {
        lengthDelimited: false
    });
    return w.finish();
}

},{"./utils/writer.js":"jqHn1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jqHn1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a new writer
 */ parcelHelpers.export(exports, "createWriter", ()=>createWriter);
var _uint8Varint = require("uint8-varint");
var _alloc = require("uint8arrays/alloc");
var _fromString = require("uint8arrays/from-string");
var _floatJs = require("./float.js");
var _longbitsJs = require("./longbits.js");
var _poolJs = require("./pool.js");
var _poolJsDefault = parcelHelpers.interopDefault(_poolJs);
var _utf8Js = require("./utf8.js");
/**
 * Constructs a new writer operation instance.
 *
 * @classdesc Scheduled writer operation
 */ class Op {
    /**
     * Function to call
     */ fn;
    /**
     * Value byte length
     */ len;
    /**
     * Next operation
     */ next;
    /**
     * Value to write
     */ val;
    constructor(fn, len, val){
        this.fn = fn;
        this.len = len;
        this.next = undefined;
        this.val = val; // type varies
    }
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance
 */ class State {
    /**
     * Current head
     */ head;
    /**
     * Current tail
     */ tail;
    /**
     * Current buffer length
     */ len;
    /**
     * Next state
     */ next;
    constructor(writer){
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
    }
}
const bufferPool = (0, _poolJsDefault.default)();
/**
 * Allocates a buffer of the specified size
 */ function alloc(size) {
    if (globalThis.Buffer != null) return (0, _alloc.allocUnsafe)(size);
    return bufferPool(size);
}
/**
 * When a value is written, the writer calculates its byte length and puts it into a linked
 * list of operations to perform when finish() is called. This both allows us to allocate
 * buffers of the exact required size and reduces the amount of work we have to do compared
 * to first calculating over objects and then encoding over objects. In our case, the encoding
 * part is just a linked list walk calling operations with already prepared values.
 */ class Uint8ArrayWriter {
    /**
     * Current length
     */ len;
    /**
     * Operations head
     */ head;
    /**
     * Operations tail
     */ tail;
    /**
     * Linked forked states
     */ states;
    constructor(){
        this.len = 0;
        this.head = new Op(noop, 0, 0);
        this.tail = this.head;
        this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */ _push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */ uint32(value) {
        // here, the call to this.push has been inlined and a varint specific Op subclass is used.
        // uint32 is by far the most frequently used operation and benefits significantly from this.
        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */ int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, (0, _longbitsJs.LongBits).fromNumber(value)) // 10 bytes per spec
         : this.uint32(value);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */ sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */ uint64(value) {
        const bits = (0, _longbitsJs.LongBits).fromBigInt(value);
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */ uint64Number(value) {
        return this._push((0, _uint8Varint.encodeUint8Array), (0, _uint8Varint.encodingLength)(value), value);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */ uint64String(value) {
        return this.uint64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */ int64(value) {
        return this.uint64(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */ int64Number(value) {
        return this.uint64Number(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */ int64String(value) {
        return this.uint64String(value);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */ sint64(value) {
        const bits = (0, _longbitsJs.LongBits).fromBigInt(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */ sint64Number(value) {
        const bits = (0, _longbitsJs.LongBits).fromNumber(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */ sint64String(value) {
        return this.sint64(BigInt(value));
    }
    /**
     * Writes a boolish value as a varint
     */ bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */ fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */ sfixed32(value) {
        return this.fixed32(value);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */ fixed64(value) {
        const bits = (0, _longbitsJs.LongBits).fromBigInt(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */ fixed64Number(value) {
        const bits = (0, _longbitsJs.LongBits).fromNumber(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */ fixed64String(value) {
        return this.fixed64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */ sfixed64(value) {
        return this.fixed64(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */ sfixed64Number(value) {
        return this.fixed64Number(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */ sfixed64String(value) {
        return this.fixed64String(value);
    }
    /**
     * Writes a float (32 bit)
     */ float(value) {
        return this._push((0, _floatJs.writeFloatLE), 4, value);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */ double(value) {
        return this._push((0, _floatJs.writeDoubleLE), 8, value);
    }
    /**
     * Writes a sequence of bytes
     */ bytes(value) {
        const len = value.length >>> 0;
        if (len === 0) return this._push(writeByte, 1, 0);
        return this.uint32(len)._push(writeBytes, len, value);
    }
    /**
     * Writes a string
     */ string(value) {
        const len = _utf8Js.length(value);
        return len !== 0 ? this.uint32(len)._push(_utf8Js.write, len, value) : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */ fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
    }
    /**
     * Resets this instance to the last state
     */ reset() {
        if (this.states != null) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
        } else {
            this.head = this.tail = new Op(noop, 0, 0);
            this.len = 0;
        }
        return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */ ldelim() {
        const head = this.head;
        const tail = this.tail;
        const len = this.len;
        this.reset().uint32(len);
        if (len !== 0) {
            this.tail.next = head.next; // skip noop
            this.tail = tail;
            this.len += len;
        }
        return this;
    }
    /**
     * Finishes the write operation
     */ finish() {
        let head = this.head.next; // skip noop
        const buf = alloc(this.len);
        let pos = 0;
        while(head != null){
            head.fn(head.val, buf, pos);
            pos += head.len;
            head = head.next;
        }
        // this.head = this.tail = null;
        return buf;
    }
}
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 *
 * @classdesc Scheduled varint writer operation
 */ class VarintOp extends Op {
    next;
    constructor(len, val){
        super(writeVarint32, len, val);
        this.next = undefined;
    }
}
function writeVarint64(val, buf, pos) {
    while(val.hi !== 0){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeBytes(val, buf, pos) {
    buf.set(val, pos);
}
if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function(value) {
        const len = value.length >>> 0;
        this.uint32(len);
        if (len > 0) this._push(writeBytesBuffer, len, value);
        return this;
    };
    Uint8ArrayWriter.prototype.string = function(value) {
        const len = globalThis.Buffer.byteLength(value);
        this.uint32(len);
        if (len > 0) this._push(writeStringBuffer, len, value);
        return this;
    };
}
function writeBytesBuffer(val, buf, pos) {
    buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
// also works for plain array values
}
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
    _utf8Js.write(val, buf, pos);
    else if (buf.utf8Write != null) // @ts-expect-error buf isn't a Uint8Array?
    buf.utf8Write(val, pos);
    else buf.set((0, _fromString.fromString)(val), pos);
}
function createWriter() {
    return new Uint8ArrayWriter();
}

},{"uint8-varint":"3o84q","uint8arrays/alloc":"9stB1","uint8arrays/from-string":"3YvUV","./float.js":"8eACB","./longbits.js":"dkeOl","./pool.js":"cIpTt","./utf8.js":"iMowT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cIpTt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pool);
var _alloc = require("uint8arrays/alloc");
function pool(size) {
    const SIZE = size ?? 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size) {
        if (size < 1 || size > MAX) return (0, _alloc.allocUnsafe)(size);
        if (offset + size > SIZE) {
            slab = (0, _alloc.allocUnsafe)(SIZE);
            offset = 0;
        }
        const buf = slab.subarray(offset, offset += size);
        if ((offset & 7) !== 0) // align to 32 bit
        offset = (offset | 7) + 1;
        return buf;
    };
}

},{"uint8arrays/alloc":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kRpk8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enumeration", ()=>enumeration);
var _codecJs = require("../codec.js");
function enumeration(v) {
    function findValue(val) {
        // Use the reverse mapping to look up the enum key for the stored value
        // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
        if (v[val.toString()] == null) throw new Error("Invalid enum value");
        return v[val];
    }
    const encode = function enumEncode(val, writer) {
        const enumValue = findValue(val);
        writer.int32(enumValue);
    };
    const decode = function enumDecode(reader) {
        const val = reader.int32();
        return findValue(val);
    };
    // @ts-expect-error yeah yeah
    return (0, _codecJs.createCodec)("enum", (0, _codecJs.CODEC_TYPES).VARINT, encode, decode);
}

},{"../codec.js":"7JVXc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7JVXc":[function(require,module,exports) {
// https://developers.google.com/protocol-buffers/docs/encoding#structure
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CODEC_TYPES", ()=>CODEC_TYPES);
parcelHelpers.export(exports, "createCodec", ()=>createCodec);
var CODEC_TYPES;
(function(CODEC_TYPES) {
    CODEC_TYPES[CODEC_TYPES["VARINT"] = 0] = "VARINT";
    CODEC_TYPES[CODEC_TYPES["BIT64"] = 1] = "BIT64";
    CODEC_TYPES[CODEC_TYPES["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES[CODEC_TYPES["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES[CODEC_TYPES["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES[CODEC_TYPES["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(name, type, encode, decode) {
    return {
        name,
        type,
        encode,
        decode
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7Bfyi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "message", ()=>message);
var _codecJs = require("../codec.js");
function message(encode, decode) {
    return (0, _codecJs.createCodec)("message", (0, _codecJs.CODEC_TYPES).LENGTH_DELIMITED, encode, decode);
}

},{"../codec.js":"7JVXc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9qjoY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Attempts to decrypt a base64 encoded PrivateKey string
 * with the given password. The privateKey must have been exported
 * using the same password and underlying cipher (aes-gcm)
 */ parcelHelpers.export(exports, "importer", ()=>importer);
var _base64 = require("multiformats/bases/base64");
var _aesGcmJs = require("../ciphers/aes-gcm.js");
async function importer(privateKey, password) {
    const encryptedKey = (0, _base64.base64).decode(privateKey);
    const cipher = _aesGcmJs.create();
    return cipher.decrypt(encryptedKey, password);
}

},{"multiformats/bases/base64":"2m5sV","../ciphers/aes-gcm.js":"5nLhA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5oJln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_RSA_KEY_SIZE", ()=>MAX_RSA_KEY_SIZE);
parcelHelpers.export(exports, "RsaPublicKey", ()=>RsaPublicKey);
parcelHelpers.export(exports, "RsaPrivateKey", ()=>RsaPrivateKey);
parcelHelpers.export(exports, "unmarshalRsaPrivateKey", ()=>unmarshalRsaPrivateKey);
parcelHelpers.export(exports, "unmarshalRsaPublicKey", ()=>unmarshalRsaPublicKey);
parcelHelpers.export(exports, "fromJwk", ()=>fromJwk);
parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
var _interface = require("@libp2p/interface");
var _sha2 = require("multiformats/hashes/sha2");
var _equals = require("uint8arrays/equals");
var _toString = require("uint8arrays/to-string");
var _utilJs = require("../util.js");
var _exporterJs = require("./exporter.js");
var _keysJs = require("./keys.js");
var _rsaJs = require("./rsa.js");
const MAX_RSA_KEY_SIZE = 8192;
class RsaPublicKey {
    _key;
    constructor(key){
        this._key = key;
    }
    verify(data, sig) {
        return _rsaJs.hashAndVerify(this._key, sig, data);
    }
    marshal() {
        return _rsaJs.utils.jwkToPkix(this._key);
    }
    get bytes() {
        return _keysJs.PublicKey.encode({
            Type: _keysJs.KeyType.RSA,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        if ((0, _utilJs.isPromise)(p)) return p.then(({ bytes })=>bytes);
        return p.bytes;
    }
}
class RsaPrivateKey {
    _key;
    _publicKey;
    constructor(key, publicKey){
        this._key = key;
        this._publicKey = publicKey;
    }
    genSecret() {
        return _rsaJs.getRandomValues(16);
    }
    sign(message) {
        return _rsaJs.hashAndSign(this._key, message);
    }
    get public() {
        if (this._publicKey == null) throw new (0, _interface.CodeError)("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
        return new RsaPublicKey(this._publicKey);
    }
    marshal() {
        return _rsaJs.utils.jwkToPkcs1(this._key);
    }
    get bytes() {
        return _keysJs.PrivateKey.encode({
            Type: _keysJs.KeyType.RSA,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        if ((0, _utilJs.isPromise)(p)) return p.then(({ bytes })=>bytes);
        return p.bytes;
    }
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the SHA-256 multihash of its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     */ async id() {
        const hash = await this.public.hash();
        return (0, _toString.toString)(hash, "base58btc");
    }
    /**
     * Exports the key as libp2p-key - a aes-gcm encrypted value with the key
     * derived from the password.
     *
     * To export it as a password protected PEM file, please use the `exportPEM`
     * function from `@libp2p/rsa`.
     */ async export(password, format = "pkcs-8") {
        if (format === "pkcs-8") return _rsaJs.utils.exportToPem(this, password);
        else if (format === "libp2p-key") return (0, _exporterJs.exporter)(this.bytes, password);
        else throw new (0, _interface.CodeError)(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
}
async function unmarshalRsaPrivateKey(bytes) {
    const jwk = _rsaJs.utils.pkcs1ToJwk(bytes);
    if (_rsaJs.keySize(jwk) > MAX_RSA_KEY_SIZE) throw new (0, _interface.CodeError)("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    const keys = await _rsaJs.unmarshalPrivateKey(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes) {
    const jwk = _rsaJs.utils.pkixToJwk(bytes);
    if (_rsaJs.keySize(jwk) > MAX_RSA_KEY_SIZE) throw new (0, _interface.CodeError)("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
    if (_rsaJs.keySize(jwk) > MAX_RSA_KEY_SIZE) throw new (0, _interface.CodeError)("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    const keys = await _rsaJs.unmarshalPrivateKey(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair(bits) {
    if (bits > MAX_RSA_KEY_SIZE) throw new (0, _interface.CodeError)("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
    const keys = await _rsaJs.generateKey(bits);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}

},{"@libp2p/interface":"b14bx","multiformats/hashes/sha2":"9qYCS","uint8arrays/equals":"CKVqX","uint8arrays/to-string":"63irA","../util.js":"kswAQ","./exporter.js":"87Mdx","./keys.js":"fwqFh","./rsa.js":"era6t","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"63irA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
var _basesJs = require("./util/bases.js");
var _basesJsDefault = parcelHelpers.interopDefault(_basesJs);
function toString(array, encoding = "utf8") {
    const base = (0, _basesJsDefault.default)[encoding];
    if (base == null) throw new Error(`Unsupported encoding "${encoding}"`);
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}

},{"./util/bases.js":"aUh7X","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"era6t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "utils", ()=>_rsaUtilsJs);
parcelHelpers.export(exports, "generateKey", ()=>generateKey);
// Takes a jwk key
parcelHelpers.export(exports, "unmarshalPrivateKey", ()=>unmarshalPrivateKey);
parcelHelpers.export(exports, "getRandomValues", ()=>(0, _randomBytesJsDefault.default));
parcelHelpers.export(exports, "hashAndSign", ()=>hashAndSign);
parcelHelpers.export(exports, "hashAndVerify", ()=>hashAndVerify);
parcelHelpers.export(exports, "keySize", ()=>keySize);
var _interface = require("@libp2p/interface");
var _fromString = require("uint8arrays/from-string");
var _randomBytesJs = require("../random-bytes.js");
var _randomBytesJsDefault = parcelHelpers.interopDefault(_randomBytesJs);
var _webcryptoJs = require("../webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _rsaUtilsJs = require("./rsa-utils.js");
async function generateKey(bits) {
    const pair = await (0, _webcryptoJsDefault.default).get().subtle.generateKey({
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: bits,
        publicExponent: new Uint8Array([
            0x01,
            0x00,
            0x01
        ]),
        hash: {
            name: "SHA-256"
        }
    }, true, [
        "sign",
        "verify"
    ]);
    const keys = await exportKey(pair);
    return {
        privateKey: keys[0],
        publicKey: keys[1]
    };
}
async function unmarshalPrivateKey(key) {
    const privateKey = await (0, _webcryptoJsDefault.default).get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    }, true, [
        "sign"
    ]);
    const pair = [
        privateKey,
        await derivePublicFromPrivate(key)
    ];
    const keys = await exportKey({
        privateKey: pair[0],
        publicKey: pair[1]
    });
    return {
        privateKey: keys[0],
        publicKey: keys[1]
    };
}
async function hashAndSign(key, msg) {
    const privateKey = await (0, _webcryptoJsDefault.default).get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    }, false, [
        "sign"
    ]);
    const sig = await (0, _webcryptoJsDefault.default).get().subtle.sign({
        name: "RSASSA-PKCS1-v1_5"
    }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
    return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify(key, sig, msg) {
    const publicKey = await (0, _webcryptoJsDefault.default).get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    }, false, [
        "verify"
    ]);
    return (0, _webcryptoJsDefault.default).get().subtle.verify({
        name: "RSASSA-PKCS1-v1_5"
    }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
}
async function exportKey(pair) {
    if (pair.privateKey == null || pair.publicKey == null) throw new (0, _interface.CodeError)("Private and public key are required", "ERR_INVALID_PARAMETERS");
    return Promise.all([
        (0, _webcryptoJsDefault.default).get().subtle.exportKey("jwk", pair.privateKey),
        (0, _webcryptoJsDefault.default).get().subtle.exportKey("jwk", pair.publicKey)
    ]);
}
async function derivePublicFromPrivate(jwKey) {
    return (0, _webcryptoJsDefault.default).get().subtle.importKey("jwk", {
        kty: jwKey.kty,
        n: jwKey.n,
        e: jwKey.e
    }, {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    }, true, [
        "verify"
    ]);
}
function keySize(jwk) {
    if (jwk.kty !== "RSA") throw new (0, _interface.CodeError)("invalid key type", "ERR_INVALID_KEY_TYPE");
    else if (jwk.n == null) throw new (0, _interface.CodeError)("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
    const bytes = (0, _fromString.fromString)(jwk.n, "base64url");
    return bytes.length * 8;
}

},{"@libp2p/interface":"b14bx","uint8arrays/from-string":"3YvUV","../random-bytes.js":"kzV30","../webcrypto.js":"lOvMh","./rsa-utils.js":"kGDMT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kzV30":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>randomBytes);
var _interface = require("@libp2p/interface");
var _utils = require("@noble/hashes/utils");
function randomBytes(length) {
    if (isNaN(length) || length <= 0) throw new (0, _interface.CodeError)("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
    return (0, _utils.randomBytes)(length);
}

},{"@libp2p/interface":"b14bx","@noble/hashes/utils":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kGDMT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert a PKCS#1 in ASN1 DER format to a JWK key
 */ parcelHelpers.export(exports, "pkcs1ToJwk", ()=>pkcs1ToJwk);
/**
 * Convert a JWK key into PKCS#1 in ASN1 DER format
 */ parcelHelpers.export(exports, "jwkToPkcs1", ()=>jwkToPkcs1);
/**
 * Convert a PKCIX in ASN1 DER format to a JWK key
 */ parcelHelpers.export(exports, "pkixToJwk", ()=>pkixToJwk);
/**
 * Convert a JWK key to PKCIX in ASN1 DER format
 */ parcelHelpers.export(exports, "jwkToPkix", ()=>jwkToPkix);
parcelHelpers.export(exports, "exportToPem", ()=>exportToPem);
parcelHelpers.export(exports, "importFromPem", ()=>importFromPem);
var _interface = require("@libp2p/interface");
var _pbkdf2 = require("@noble/hashes/pbkdf2");
var _sha512 = require("@noble/hashes/sha512");
var _asn1Js = require("asn1js");
var _fromString = require("uint8arrays/from-string");
var _toString = require("uint8arrays/to-string");
var _randomBytesJs = require("../random-bytes.js");
var _randomBytesJsDefault = parcelHelpers.interopDefault(_randomBytesJs);
var _webcryptoJs = require("../webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _rsaClassJs = require("./rsa-class.js");
function pkcs1ToJwk(bytes) {
    const { result } = _asn1Js.fromBER(bytes);
    // @ts-expect-error this looks fragile but DER is a canonical format so we are
    // safe to have deeply property chains like this
    const values = result.valueBlock.value;
    const key = {
        n: (0, _toString.toString)(bnToBuf(values[1].toBigInt()), "base64url"),
        e: (0, _toString.toString)(bnToBuf(values[2].toBigInt()), "base64url"),
        d: (0, _toString.toString)(bnToBuf(values[3].toBigInt()), "base64url"),
        p: (0, _toString.toString)(bnToBuf(values[4].toBigInt()), "base64url"),
        q: (0, _toString.toString)(bnToBuf(values[5].toBigInt()), "base64url"),
        dp: (0, _toString.toString)(bnToBuf(values[6].toBigInt()), "base64url"),
        dq: (0, _toString.toString)(bnToBuf(values[7].toBigInt()), "base64url"),
        qi: (0, _toString.toString)(bnToBuf(values[8].toBigInt()), "base64url"),
        kty: "RSA",
        alg: "RS256"
    };
    return key;
}
function jwkToPkcs1(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) throw new (0, _interface.CodeError)("JWK was missing components", "ERR_INVALID_PARAMETERS");
    const root = new _asn1Js.Sequence({
        value: [
            new _asn1Js.Integer({
                value: 0
            }),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.n, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.e, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.d, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.p, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.q, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.dp, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.dq, "base64url"))),
            _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.qi, "base64url")))
        ]
    });
    const der = root.toBER();
    return new Uint8Array(der, 0, der.byteLength);
}
function pkixToJwk(bytes) {
    const { result } = _asn1Js.fromBER(bytes);
    // @ts-expect-error this looks fragile but DER is a canonical format so we are
    // safe to have deeply property chains like this
    const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;
    return {
        kty: "RSA",
        n: (0, _toString.toString)(bnToBuf(values[0].toBigInt()), "base64url"),
        e: (0, _toString.toString)(bnToBuf(values[1].toBigInt()), "base64url")
    };
}
function jwkToPkix(jwk) {
    if (jwk.n == null || jwk.e == null) throw new (0, _interface.CodeError)("JWK was missing components", "ERR_INVALID_PARAMETERS");
    const root = new _asn1Js.Sequence({
        value: [
            new _asn1Js.Sequence({
                value: [
                    // rsaEncryption
                    new _asn1Js.ObjectIdentifier({
                        value: "1.2.840.113549.1.1.1"
                    }),
                    new _asn1Js.Null()
                ]
            }),
            // this appears to be a bug in asn1js.js - this should really be a Sequence
            // and not a BitString but it generates the same bytes as node-forge so 🤷‍♂️
            new _asn1Js.BitString({
                valueHex: new _asn1Js.Sequence({
                    value: [
                        _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.n, "base64url"))),
                        _asn1Js.Integer.fromBigInt(bufToBn((0, _fromString.fromString)(jwk.e, "base64url")))
                    ]
                }).toBER()
            })
        ]
    });
    const der = root.toBER();
    return new Uint8Array(der, 0, der.byteLength);
}
function bnToBuf(bn) {
    let hex = bn.toString(16);
    if (hex.length % 2 > 0) hex = `0${hex}`;
    const len = hex.length / 2;
    const u8 = new Uint8Array(len);
    let i = 0;
    let j = 0;
    while(i < len){
        u8[i] = parseInt(hex.slice(j, j + 2), 16);
        i += 1;
        j += 2;
    }
    return u8;
}
function bufToBn(u8) {
    const hex = [];
    u8.forEach(function(i) {
        let h = i.toString(16);
        if (h.length % 2 > 0) h = `0${h}`;
        hex.push(h);
    });
    return BigInt("0x" + hex.join(""));
}
const SALT_LENGTH = 16;
const KEY_SIZE = 32;
const ITERATIONS = 10000;
async function exportToPem(privateKey, password) {
    const crypto = (0, _webcryptoJsDefault.default).get();
    // PrivateKeyInfo
    const keyWrapper = new _asn1Js.Sequence({
        value: [
            // version (0)
            new _asn1Js.Integer({
                value: 0
            }),
            // privateKeyAlgorithm
            new _asn1Js.Sequence({
                value: [
                    // rsaEncryption OID
                    new _asn1Js.ObjectIdentifier({
                        value: "1.2.840.113549.1.1.1"
                    }),
                    new _asn1Js.Null()
                ]
            }),
            // PrivateKey
            new _asn1Js.OctetString({
                valueHex: privateKey.marshal()
            })
        ]
    });
    const keyBuf = keyWrapper.toBER();
    const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
    const salt = (0, _randomBytesJsDefault.default)(SALT_LENGTH);
    const encryptionKey = await (0, _pbkdf2.pbkdf2Async)((0, _sha512.sha512), password, salt, {
        c: ITERATIONS,
        dkLen: KEY_SIZE
    });
    const iv = (0, _randomBytesJsDefault.default)(16);
    const cryptoKey = await crypto.subtle.importKey("raw", encryptionKey, "AES-CBC", false, [
        "encrypt"
    ]);
    const encrypted = await crypto.subtle.encrypt({
        name: "AES-CBC",
        iv
    }, cryptoKey, keyArr);
    const pbkdf2Params = new _asn1Js.Sequence({
        value: [
            // salt
            new _asn1Js.OctetString({
                valueHex: salt
            }),
            // iteration count
            new _asn1Js.Integer({
                value: ITERATIONS
            }),
            // key length
            new _asn1Js.Integer({
                value: KEY_SIZE
            }),
            // AlgorithmIdentifier
            new _asn1Js.Sequence({
                value: [
                    // hmacWithSHA512
                    new _asn1Js.ObjectIdentifier({
                        value: "1.2.840.113549.2.11"
                    }),
                    new _asn1Js.Null()
                ]
            })
        ]
    });
    const encryptionAlgorithm = new _asn1Js.Sequence({
        value: [
            // pkcs5PBES2
            new _asn1Js.ObjectIdentifier({
                value: "1.2.840.113549.1.5.13"
            }),
            new _asn1Js.Sequence({
                value: [
                    // keyDerivationFunc
                    new _asn1Js.Sequence({
                        value: [
                            // pkcs5PBKDF2
                            new _asn1Js.ObjectIdentifier({
                                value: "1.2.840.113549.1.5.12"
                            }),
                            // PBKDF2-params
                            pbkdf2Params
                        ]
                    }),
                    // encryptionScheme
                    new _asn1Js.Sequence({
                        value: [
                            // aes256-CBC
                            new _asn1Js.ObjectIdentifier({
                                value: "2.16.840.1.101.3.4.1.42"
                            }),
                            // iv
                            new _asn1Js.OctetString({
                                valueHex: iv
                            })
                        ]
                    })
                ]
            })
        ]
    });
    const finalWrapper = new _asn1Js.Sequence({
        value: [
            encryptionAlgorithm,
            new _asn1Js.OctetString({
                valueHex: encrypted
            })
        ]
    });
    const finalWrapperBuf = finalWrapper.toBER();
    const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
    return [
        "-----BEGIN ENCRYPTED PRIVATE KEY-----",
        ...(0, _toString.toString)(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
        "-----END ENCRYPTED PRIVATE KEY-----"
    ].join("\n");
}
async function importFromPem(pem, password) {
    const crypto = (0, _webcryptoJsDefault.default).get();
    let plaintext;
    if (pem.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
        const key = (0, _fromString.fromString)(pem.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
        const { result } = _asn1Js.fromBER(key);
        const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);
        const encryptionKey = await (0, _pbkdf2.pbkdf2Async)((0, _sha512.sha512), password, salt, {
            c: iterations,
            dkLen: keySize
        });
        const cryptoKey = await crypto.subtle.importKey("raw", encryptionKey, "AES-CBC", false, [
            "decrypt"
        ]);
        const decrypted = toUint8Array(await crypto.subtle.decrypt({
            name: "AES-CBC",
            iv
        }, cryptoKey, cipherText));
        const { result: decryptedResult } = _asn1Js.fromBER(decrypted);
        plaintext = findPEMData(decryptedResult);
    } else if (pem.includes("-----BEGIN PRIVATE KEY-----")) {
        const key = (0, _fromString.fromString)(pem.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
        const { result } = _asn1Js.fromBER(key);
        plaintext = findPEMData(result);
    } else throw new (0, _interface.CodeError)("Could not parse private key from PEM data", "ERR_INVALID_PARAMETERS");
    return (0, _rsaClassJs.unmarshalRsaPrivateKey)(plaintext);
}
function findEncryptedPEMData(root) {
    const encryptionAlgorithm = root.valueBlock.value[0];
    const scheme = encryptionAlgorithm.valueBlock.value[0].toString();
    if (scheme !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") throw new (0, _interface.CodeError)("Only pkcs5PBES2 encrypted private keys are supported", "ERR_INVALID_PARAMS");
    const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];
    const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();
    if (keyDerivationFuncName !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") throw new (0, _interface.CodeError)("Only pkcs5PBKDF2 key derivation functions are supported", "ERR_INVALID_PARAMS");
    const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];
    const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());
    let iterations = ITERATIONS;
    let keySize = KEY_SIZE;
    if (pbkdf2Params.valueBlock.value.length === 3) {
        iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());
        keySize = Number(pbkdf2Params.valueBlock.value[2].toBigInt());
    } else if (pbkdf2Params.valueBlock.value.length === 2) throw new (0, _interface.CodeError)("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key", "ERR_INVALID_PARAMS");
    const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];
    const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();
    if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.2.840.113549.3.7") ;
    else if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.3.14.3.2.7") ;
    else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") ;
    else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") ;
    else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") ;
    else throw new (0, _interface.CodeError)("Only AES-CBC encryption schemes are supported", "ERR_INVALID_PARAMS");
    const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());
    return {
        cipherText: toUint8Array(root.valueBlock.value[1].getValue()),
        salt,
        iterations,
        keySize,
        iv
    };
}
function findPEMData(seq) {
    return toUint8Array(seq.valueBlock.value[2].getValue());
}
function toUint8Array(buf) {
    return new Uint8Array(buf, 0, buf.byteLength);
}

},{"@libp2p/interface":"b14bx","@noble/hashes/pbkdf2":"8xpcg","@noble/hashes/sha512":"V7q1R","asn1js":"aRCxh","uint8arrays/from-string":"3YvUV","uint8arrays/to-string":"63irA","../random-bytes.js":"kzV30","../webcrypto.js":"lOvMh","./rsa-class.js":"5oJln","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8xpcg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */ parcelHelpers.export(exports, "pbkdf2", ()=>pbkdf2);
parcelHelpers.export(exports, "pbkdf2Async", ()=>pbkdf2Async);
var _assertJs = require("./_assert.js");
var _hmacJs = require("./hmac.js");
var _utilsJs = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assertJs.hash)(hash);
    const opts = (0, _utilsJs.checkOpts)({
        dkLen: 32,
        asyncTick: 10
    }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, _assertJs.number)(c);
    (0, _assertJs.number)(dkLen);
    (0, _assertJs.number)(asyncTick);
    if (c < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = (0, _utilsJs.toBytes)(_password);
    const salt = (0, _utilsJs.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = (0, _hmacJs.hmac).create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt
    };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    u.fill(0);
    return DK;
}
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, _utilsJs.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for(let ui = 1; ui < c; ui++){
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, _utilsJs.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, _utilsJs.asyncLoop)(c - 1, asyncTick, ()=>{
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

},{"./_assert.js":"5Bz9G","./hmac.js":"1S2SD","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1S2SD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// HMAC (RFC 2104)
parcelHelpers.export(exports, "HMAC", ()=>HMAC);
parcelHelpers.export(exports, "hmac", ()=>hmac);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
class HMAC extends (0, _utilsJs.Hash) {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assertJs.hash)(hash);
        const key = (0, _utilsJs.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assertJs.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assertJs.exists)(this);
        (0, _assertJs.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key)=>new HMAC(hash, key);

},{"./_assert.js":"5Bz9G","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aRCxh":[function(require,module,exports) {
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Any", ()=>Any);
parcelHelpers.export(exports, "BaseBlock", ()=>BaseBlock);
parcelHelpers.export(exports, "BaseStringBlock", ()=>BaseStringBlock);
parcelHelpers.export(exports, "BitString", ()=>BitString);
parcelHelpers.export(exports, "BmpString", ()=>BmpString);
parcelHelpers.export(exports, "Boolean", ()=>Boolean);
parcelHelpers.export(exports, "CharacterString", ()=>CharacterString);
parcelHelpers.export(exports, "Choice", ()=>Choice);
parcelHelpers.export(exports, "Constructed", ()=>Constructed);
parcelHelpers.export(exports, "DATE", ()=>DATE);
parcelHelpers.export(exports, "DateTime", ()=>DateTime);
parcelHelpers.export(exports, "Duration", ()=>Duration);
parcelHelpers.export(exports, "EndOfContent", ()=>EndOfContent);
parcelHelpers.export(exports, "Enumerated", ()=>Enumerated);
parcelHelpers.export(exports, "GeneralString", ()=>GeneralString);
parcelHelpers.export(exports, "GeneralizedTime", ()=>GeneralizedTime);
parcelHelpers.export(exports, "GraphicString", ()=>GraphicString);
parcelHelpers.export(exports, "HexBlock", ()=>HexBlock);
parcelHelpers.export(exports, "IA5String", ()=>IA5String);
parcelHelpers.export(exports, "Integer", ()=>Integer);
parcelHelpers.export(exports, "Null", ()=>Null);
parcelHelpers.export(exports, "NumericString", ()=>NumericString);
parcelHelpers.export(exports, "ObjectIdentifier", ()=>ObjectIdentifier);
parcelHelpers.export(exports, "OctetString", ()=>OctetString);
parcelHelpers.export(exports, "Primitive", ()=>Primitive);
parcelHelpers.export(exports, "PrintableString", ()=>PrintableString);
parcelHelpers.export(exports, "RawData", ()=>RawData);
parcelHelpers.export(exports, "RelativeObjectIdentifier", ()=>RelativeObjectIdentifier);
parcelHelpers.export(exports, "Repeated", ()=>Repeated);
parcelHelpers.export(exports, "Sequence", ()=>Sequence);
parcelHelpers.export(exports, "Set", ()=>Set);
parcelHelpers.export(exports, "TIME", ()=>TIME);
parcelHelpers.export(exports, "TeletexString", ()=>TeletexString);
parcelHelpers.export(exports, "TimeOfDay", ()=>TimeOfDay);
parcelHelpers.export(exports, "UTCTime", ()=>UTCTime);
parcelHelpers.export(exports, "UniversalString", ()=>UniversalString);
parcelHelpers.export(exports, "Utf8String", ()=>Utf8String);
parcelHelpers.export(exports, "ValueBlock", ()=>ValueBlock);
parcelHelpers.export(exports, "VideotexString", ()=>VideotexString);
parcelHelpers.export(exports, "ViewWriter", ()=>ViewWriter);
parcelHelpers.export(exports, "VisibleString", ()=>VisibleString);
parcelHelpers.export(exports, "compareSchema", ()=>compareSchema);
parcelHelpers.export(exports, "fromBER", ()=>fromBER);
parcelHelpers.export(exports, "verifySchema", ()=>verifySchema);
var _pvtsutils = require("pvtsutils");
var _pvutils = require("pvutils");
function assertBigInt() {
    if (typeof BigInt === "undefined") throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
}
function concat(buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for(let i = 0; i < buffers.length; i++){
        const buffer = buffers[i];
        outputLength += buffer.byteLength;
    }
    const retView = new Uint8Array(outputLength);
    for(let i = 0; i < buffers.length; i++){
        const buffer = buffers[i];
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof Uint8Array)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
class ViewWriter {
    constructor(){
        this.items = [];
    }
    write(buf) {
        this.items.push(buf);
    }
    final() {
        return concat(this.items);
    }
}
const powers2 = [
    new Uint8Array([
        1
    ])
];
const digitsString = "0123456789";
const NAME = "name";
const VALUE_HEX_VIEW = "valueHexView";
const IS_HEX_ONLY = "isHexOnly";
const ID_BLOCK = "idBlock";
const TAG_CLASS = "tagClass";
const TAG_NUMBER = "tagNumber";
const IS_CONSTRUCTED = "isConstructed";
const FROM_BER = "fromBER";
const TO_BER = "toBER";
const LOCAL = "local";
const EMPTY_STRING = "";
const EMPTY_BUFFER = new ArrayBuffer(0);
const EMPTY_VIEW = new Uint8Array(0);
const END_OF_CONTENT_NAME = "EndOfContent";
const OCTET_STRING_NAME = "OCTET STRING";
const BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
    var _a;
    return _a = class Some extends BaseClass {
        constructor(...args){
            var _a;
            super(...args);
            const params = args[0] || {};
            this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;
            this.valueHexView = params.valueHex ? _pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
        }
        get valueHex() {
            return this.valueHexView.slice().buffer;
        }
        set valueHex(value) {
            this.valueHexView = new Uint8Array(value);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
            if (!checkBufferParams(this, view, inputOffset, inputLength)) return -1;
            const endLength = inputOffset + inputLength;
            this.valueHexView = view.subarray(inputOffset, endLength);
            if (!this.valueHexView.length) {
                this.warnings.push("Zero buffer length");
                return inputOffset;
            }
            this.blockLength = inputLength;
            return endLength;
        }
        toBER(sizeOnly = false) {
            if (!this.isHexOnly) {
                this.error = "Flag 'isHexOnly' is not set, abort";
                return EMPTY_BUFFER;
            }
            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
            return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isHexOnly: this.isHexOnly,
                valueHex: _pvtsutils.Convert.ToHex(this.valueHexView)
            };
        }
    }, _a.NAME = "hexBlock", _a;
}
class LocalBaseBlock {
    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}){
        this.blockLength = blockLength;
        this.error = error;
        this.warnings = warnings;
        this.valueBeforeDecodeView = _pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);
    }
    static blockName() {
        return this.NAME;
    }
    get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
    }
    set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
    }
    toJSON() {
        return {
            blockName: this.constructor.NAME,
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: _pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)
        };
    }
}
LocalBaseBlock.NAME = "baseBlock";
class ValueBlock extends LocalBaseBlock {
    fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
    toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
}
ValueBlock.NAME = "valueBlock";
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
    constructor({ idBlock = {} } = {}){
        var _a, _b, _c, _d;
        super();
        if (idBlock) {
            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
            this.valueHexView = idBlock.valueHex ? _pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
            this.tagClass = -1;
            this.tagNumber = -1;
            this.isConstructed = false;
        }
    }
    toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch(this.tagClass){
            case 1:
                firstOctet |= 0x00;
                break;
            case 2:
                firstOctet |= 0x40;
                break;
            case 3:
                firstOctet |= 0x80;
                break;
            case 4:
                firstOctet |= 0xC0;
                break;
            default:
                this.error = "Unknown tag class";
                return EMPTY_BUFFER;
        }
        if (this.isConstructed) firstOctet |= 0x20;
        if (this.tagNumber < 31 && !this.isHexOnly) {
            const retView = new Uint8Array(1);
            if (!sizeOnly) {
                let number = this.tagNumber;
                number &= 0x1F;
                firstOctet |= number;
                retView[0] = firstOctet;
            }
            return retView.buffer;
        }
        if (!this.isHexOnly) {
            const encodedBuf = _pvutils.utilToBase(this.tagNumber, 7);
            const encodedView = new Uint8Array(encodedBuf);
            const size = encodedBuf.byteLength;
            const retView = new Uint8Array(size + 1);
            retView[0] = firstOctet | 0x1F;
            if (!sizeOnly) {
                for(let i = 0; i < size - 1; i++)retView[i + 1] = encodedView[i] | 0x80;
                retView[size] = encodedView[size - 1];
            }
            return retView.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 0x1F;
        if (!sizeOnly) {
            const curView = this.valueHexView;
            for(let i = 0; i < curView.length - 1; i++)retView[i + 1] = curView[i] | 0x80;
            retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        const tagClassMask = intBuffer[0] & 0xC0;
        switch(tagClassMask){
            case 0x00:
                this.tagClass = 1;
                break;
            case 0x40:
                this.tagClass = 2;
                break;
            case 0x80:
                this.tagClass = 3;
                break;
            case 0xC0:
                this.tagClass = 4;
                break;
            default:
                this.error = "Unknown tag class";
                return -1;
        }
        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 0x1F;
        if (tagNumberMask !== 0x1F) {
            this.tagNumber = tagNumberMask;
            this.blockLength = 1;
        } else {
            let count = 1;
            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
            let tagNumberBufferMaxLength = 255;
            while(intBuffer[count] & 0x80){
                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                count++;
                if (count >= intBuffer.length) {
                    this.error = "End of input reached before message was fully decoded";
                    return -1;
                }
                if (count === tagNumberBufferMaxLength) {
                    tagNumberBufferMaxLength += 255;
                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
                    for(let i = 0; i < intTagNumberBuffer.length; i++)tempBufferView[i] = intTagNumberBuffer[i];
                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
                }
            }
            this.blockLength = count + 1;
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            const tempBufferView = new Uint8Array(count);
            for(let i = 0; i < count; i++)tempBufferView[i] = intTagNumberBuffer[i];
            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
            intTagNumberBuffer.set(tempBufferView);
            if (this.blockLength <= 9) this.tagNumber = _pvutils.utilFromBase(intTagNumberBuffer, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Tag too long, represented as hex-coded");
            }
        }
        if (this.tagClass === 1 && this.isConstructed) switch(this.tagNumber){
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
                this.error = "Constructed encoding used for primitive type";
                return -1;
        }
        return inputOffset + this.blockLength;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            tagClass: this.tagClass,
            tagNumber: this.tagNumber,
            isConstructed: this.isConstructed
        };
    }
}
LocalIdentificationBlock.NAME = "identificationBlock";
class LocalLengthBlock extends LocalBaseBlock {
    constructor({ lenBlock = {} } = {}){
        var _a, _b, _c;
        super();
        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) return -1;
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        if (intBuffer[0] === 0xFF) {
            this.error = "Length block 0xFF is reserved by standard";
            return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 0x80;
        if (this.isIndefiniteForm) {
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 0x80);
        if (this.longFormUsed === false) {
            this.length = intBuffer[0];
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 0x7F;
        if (count > 8) {
            this.error = "Too big integer";
            return -1;
        }
        if (count + 1 > intBuffer.length) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");
        this.length = _pvutils.utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127) this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127) this.longFormUsed = true;
        if (this.isIndefiniteForm) {
            retBuf = new ArrayBuffer(1);
            if (sizeOnly === false) {
                retView = new Uint8Array(retBuf);
                retView[0] = 0x80;
            }
            return retBuf;
        }
        if (this.longFormUsed) {
            const encodedBuf = _pvutils.utilToBase(this.length, 8);
            if (encodedBuf.byteLength > 127) {
                this.error = "Too big length";
                return EMPTY_BUFFER;
            }
            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
            if (sizeOnly) return retBuf;
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            retView[0] = encodedBuf.byteLength | 0x80;
            for(let i = 0; i < encodedBuf.byteLength; i++)retView[i + 1] = encodedView[i];
            return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = this.length;
        }
        return retBuf;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            longFormUsed: this.longFormUsed,
            length: this.length
        };
    }
}
LocalLengthBlock.NAME = "lengthBlock";
const typeStore = {};
class BaseBlock extends LocalBaseBlock {
    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType){
        super(parameters);
        this.name = name;
        this.optional = optional;
        if (primitiveSchema) this.primitiveSchema = primitiveSchema;
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) prepareIndefiniteForm(this);
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
            _writer.write(new Uint8Array([
                0x80
            ]).buffer);
            this.valueBlock.toBER(sizeOnly, _writer);
            _writer.write(new ArrayBuffer(2));
        } else {
            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
            this.lenBlock.length = valueBlockBuf.byteLength;
            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
            _writer.write(lenBlockBuf);
            _writer.write(valueBlockBuf);
        }
        if (!writer) return _writer.final();
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            idBlock: this.idBlock.toJSON(),
            lenBlock: this.lenBlock.toJSON(),
            valueBlock: this.valueBlock.toJSON(),
            name: this.name,
            optional: this.optional
        };
        if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
    }
    toString(encoding = "ascii") {
        if (encoding === "ascii") return this.onAsciiEncoding();
        return _pvtsutils.Convert.ToHex(this.toBER());
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${_pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
    }
    isEqual(other) {
        if (this === other) return true;
        if (!(other instanceof this.constructor)) return false;
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return _pvutils.isEqualBuffer(thisRaw, otherRaw);
    }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
    if (baseBlock instanceof typeStore.Constructed) {
        for (const value of baseBlock.valueBlock.value)if (prepareIndefiniteForm(value)) baseBlock.lenBlock.isIndefiniteForm = true;
    }
    return !!baseBlock.lenBlock.isIndefiniteForm;
}
class BaseStringBlock extends BaseBlock {
    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType){
        super(parameters, stringValueBlockType);
        if (value) this.fromString(value);
    }
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
    }
}
BaseStringBlock.NAME = "BaseStringBlock";
class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
    constructor({ isHexOnly = true, ...parameters } = {}){
        super(parameters);
        this.isHexOnly = isHexOnly;
    }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
class Primitive extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
    }
}
_a$w = Primitive;
(()=>{
    typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
    if (inputObject instanceof newType) return inputObject;
    const newObject = new newType();
    newObject.idBlock = inputObject.idBlock;
    newObject.lenBlock = inputObject.lenBlock;
    newObject.warnings = inputObject.warnings;
    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
    return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
    const incomingOffset = inputOffset;
    let returnObject = new BaseBlock({}, ValueBlock);
    const baseBlock = new LocalBaseBlock();
    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
        returnObject.error = baseBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
    if (!intBuffer.length) {
        returnObject.error = "Zero buffer length";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.idBlock.warnings.length) returnObject.warnings.concat(returnObject.idBlock.warnings);
    if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.lenBlock.warnings.length) returnObject.warnings.concat(returnObject.lenBlock.warnings);
    if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let newASN1Type = BaseBlock;
    switch(returnObject.idBlock.tagClass){
        case 1:
            if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
                returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                return {
                    offset: -1,
                    result: returnObject
                };
            }
            switch(returnObject.idBlock.tagNumber){
                case 0:
                    if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
                        returnObject.error = "Type [UNIVERSAL 0] is reserved";
                        return {
                            offset: -1,
                            result: returnObject
                        };
                    }
                    newASN1Type = typeStore.EndOfContent;
                    break;
                case 1:
                    newASN1Type = typeStore.Boolean;
                    break;
                case 2:
                    newASN1Type = typeStore.Integer;
                    break;
                case 3:
                    newASN1Type = typeStore.BitString;
                    break;
                case 4:
                    newASN1Type = typeStore.OctetString;
                    break;
                case 5:
                    newASN1Type = typeStore.Null;
                    break;
                case 6:
                    newASN1Type = typeStore.ObjectIdentifier;
                    break;
                case 10:
                    newASN1Type = typeStore.Enumerated;
                    break;
                case 12:
                    newASN1Type = typeStore.Utf8String;
                    break;
                case 13:
                    newASN1Type = typeStore.RelativeObjectIdentifier;
                    break;
                case 14:
                    newASN1Type = typeStore.TIME;
                    break;
                case 15:
                    returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                    return {
                        offset: -1,
                        result: returnObject
                    };
                case 16:
                    newASN1Type = typeStore.Sequence;
                    break;
                case 17:
                    newASN1Type = typeStore.Set;
                    break;
                case 18:
                    newASN1Type = typeStore.NumericString;
                    break;
                case 19:
                    newASN1Type = typeStore.PrintableString;
                    break;
                case 20:
                    newASN1Type = typeStore.TeletexString;
                    break;
                case 21:
                    newASN1Type = typeStore.VideotexString;
                    break;
                case 22:
                    newASN1Type = typeStore.IA5String;
                    break;
                case 23:
                    newASN1Type = typeStore.UTCTime;
                    break;
                case 24:
                    newASN1Type = typeStore.GeneralizedTime;
                    break;
                case 25:
                    newASN1Type = typeStore.GraphicString;
                    break;
                case 26:
                    newASN1Type = typeStore.VisibleString;
                    break;
                case 27:
                    newASN1Type = typeStore.GeneralString;
                    break;
                case 28:
                    newASN1Type = typeStore.UniversalString;
                    break;
                case 29:
                    newASN1Type = typeStore.CharacterString;
                    break;
                case 30:
                    newASN1Type = typeStore.BmpString;
                    break;
                case 31:
                    newASN1Type = typeStore.DATE;
                    break;
                case 32:
                    newASN1Type = typeStore.TimeOfDay;
                    break;
                case 33:
                    newASN1Type = typeStore.DateTime;
                    break;
                case 34:
                    newASN1Type = typeStore.Duration;
                    break;
                default:
                    {
                        const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
                        newObject.idBlock = returnObject.idBlock;
                        newObject.lenBlock = returnObject.lenBlock;
                        newObject.warnings = returnObject.warnings;
                        returnObject = newObject;
                    }
            }
            break;
        case 2:
        case 3:
        case 4:
        default:
            newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
        offset: resultOffset,
        result: returnObject
    };
}
function fromBER(inputBuffer) {
    if (!inputBuffer.byteLength) {
        const result = new BaseBlock({}, ValueBlock);
        result.error = "Input buffer has zero length";
        return {
            offset: -1,
            result
        };
    }
    return localFromBER(_pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
    if (indefiniteLength) return 1;
    return length;
}
class LocalConstructedValueBlock extends ValueBlock {
    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}){
        super(parameters);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) return -1;
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
        }
        let currentOffset = inputOffset;
        while(checkLen(this.isIndefiniteForm, inputLength) > 0){
            const returnObject = localFromBER(view, currentOffset, inputLength);
            if (returnObject.offset === -1) {
                this.error = returnObject.result.error;
                this.warnings.concat(returnObject.result.warnings);
                return -1;
            }
            currentOffset = returnObject.offset;
            this.blockLength += returnObject.result.blockLength;
            inputLength -= returnObject.result.blockLength;
            this.value.push(returnObject.result);
            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) break;
        }
        if (this.isIndefiniteForm) {
            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) this.value.pop();
            else this.warnings.push("No EndOfContent block encoded");
        }
        return currentOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for(let i = 0; i < this.value.length; i++)this.value[i].toBER(sizeOnly, _writer);
        if (!writer) return _writer.final();
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            value: []
        };
        for (const value of this.value)object.value.push(value.toJSON());
        return object;
    }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
class Constructed extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value)values.push(value.toString("ascii").split("\n").map((o)=>`  ${o}`).join("\n"));
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :\n${values.join("\n")}` : `${blockName} :`;
    }
}
_a$v = Constructed;
(()=>{
    typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
class LocalEndOfContentValueBlock extends ValueBlock {
    fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
    }
    toBER(sizeOnly) {
        return EMPTY_BUFFER;
    }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
class EndOfContent extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
    }
}
_a$u = EndOfContent;
(()=>{
    typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
class Null extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
            this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
            return -1;
        }
        return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
            const retView = new Uint8Array(retBuf);
            retView[0] = 0x05;
            retView[1] = 0x00;
        }
        if (writer) writer.write(retBuf);
        return retBuf;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME}`;
    }
}
_a$t = Null;
(()=>{
    typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
    constructor({ value, ...parameters } = {}){
        super(parameters);
        if (parameters.valueHex) this.valueHexView = _pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);
        else this.valueHexView = new Uint8Array(1);
        if (value) this.value = value;
    }
    get value() {
        for (const octet of this.valueHexView){
            if (octet > 0) return true;
        }
        return false;
    }
    set value(value) {
        this.valueHexView[0] = value ? 0xFF : 0x00;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        _pvutils.utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
    }
    toBER() {
        return this.valueHexView.slice();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value
        };
    }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
class Boolean extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
    }
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
    }
}
_a$s = Boolean;
(()=>{
    typeStore.Boolean = _a$s;
})();
Boolean.NAME = "BOOLEAN";
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ isConstructed = false, ...parameters } = {}){
        super(parameters);
        this.isConstructed = isConstructed;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
            this.isHexOnly = false;
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for(let i = 0; i < this.value.length; i++){
                const currentBlockName = this.value[i].constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm) break;
                    else {
                        this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== OCTET_STRING_NAME) {
                    this.error = "OCTET STRING may consists of OCTET STRINGs only";
                    return -1;
                }
            }
        } else {
            this.isHexOnly = true;
            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
            this.blockLength = inputLength;
        }
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isConstructed: this.isConstructed
        };
    }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
class OctetString extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm
            },
            ...parameters
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
            if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
            if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
            return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
            const buf = view.subarray(inputOffset, inputOffset + inputLength);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === inputLength) this.valueBlock.value = [
                        asn.result
                    ];
                }
            } catch (e) {}
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) return Constructed.prototype.onAsciiEncoding.call(this);
        return `${this.constructor.NAME} : ${_pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;
    }
    getValue() {
        if (!this.idBlock.isConstructed) return this.valueBlock.valueHexView.slice().buffer;
        const array = [];
        for (const content of this.valueBlock.value)if (content instanceof OctetString) array.push(content.valueBlock.valueHexView);
        return _pvtsutils.BufferSourceConverter.concat(array);
    }
}
_a$r = OctetString;
(()=>{
    typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}){
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) return inputOffset;
        let resultOffset = -1;
        if (this.isConstructed) {
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for (const value of this.value){
                const currentBlockName = value.constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm) break;
                    else {
                        this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== BIT_STRING_NAME) {
                    this.error = "BIT STRING may consists of BIT STRINGs only";
                    return -1;
                }
                const valueBlock = value.valueBlock;
                if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
                    this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
                    return -1;
                }
                this.unusedBits = valueBlock.unusedBits;
            }
            return resultOffset;
        }
        const inputView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
            this.error = "Unused bits for BitString must be in range 0-7";
            return -1;
        }
        if (!this.unusedBits) {
            const buf = intBuffer.subarray(1);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === inputLength - 1) this.value = [
                        asn.result
                    ];
                }
            } catch (e) {}
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength + 1);
        if (!this.valueHexView.byteLength) return EMPTY_BUFFER;
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            unusedBits: this.unusedBits,
            isConstructed: this.isConstructed
        };
    }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
class BitString extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm
            },
            ...parameters
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) return Constructed.prototype.onAsciiEncoding.call(this);
        else {
            const bits = [];
            const valueHex = this.valueBlock.valueHexView;
            for (const byte of valueHex)bits.push(byte.toString(2).padStart(8, "0"));
            const bitsStr = bits.join("");
            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
    }
}
_a$q = BitString;
(()=>{
    typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
    const c = new Uint8Array([
        0
    ]);
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    let firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value = 0;
    const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
    let counter = 0;
    for(let i = max; i >= 0; i--, counter++){
        switch(true){
            case counter < secondViewCopy.length:
                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                break;
            default:
                value = firstViewCopy[firstViewCopyLength - counter] + c[0];
        }
        c[0] = value / 10;
        switch(true){
            case counter >= firstViewCopy.length:
                firstViewCopy = _pvutils.utilConcatView(new Uint8Array([
                    value % 10
                ]), firstViewCopy);
                break;
            default:
                firstViewCopy[firstViewCopyLength - counter] = value % 10;
        }
    }
    if (c[0] > 0) firstViewCopy = _pvutils.utilConcatView(c, firstViewCopy);
    return firstViewCopy;
}
function power2(n) {
    if (n >= powers2.length) for(let p = powers2.length; p <= n; p++){
        const c = new Uint8Array([
            0
        ]);
        let digits = powers2[p - 1].slice(0);
        for(let i = digits.length - 1; i >= 0; i--){
            const newValue = new Uint8Array([
                (digits[i] << 1) + c[0]
            ]);
            c[0] = newValue[0] / 10;
            digits[i] = newValue[0] % 10;
        }
        if (c[0] > 0) digits = _pvutils.utilConcatView(c, digits);
        powers2.push(digits);
    }
    return powers2[n];
}
function viewSub(first, second) {
    let b = 0;
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    const firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value;
    let counter = 0;
    for(let i = secondViewCopyLength; i >= 0; i--, counter++){
        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
        switch(true){
            case value < 0:
                b = 1;
                firstViewCopy[firstViewCopyLength - counter] = value + 10;
                break;
            default:
                b = 0;
                firstViewCopy[firstViewCopyLength - counter] = value;
        }
    }
    if (b > 0) for(let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++){
        value = firstViewCopy[firstViewCopyLength - counter] - b;
        if (value < 0) {
            b = 1;
            firstViewCopy[firstViewCopyLength - counter] = value + 10;
        } else {
            b = 0;
            firstViewCopy[firstViewCopyLength - counter] = value;
            break;
        }
    }
    return firstViewCopy.slice();
}
class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
    constructor({ value, ...parameters } = {}){
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) this.setValueHex();
        if (value !== undefined) this.valueDec = value;
    }
    setValueHex() {
        if (this.valueHexView.length >= 4) {
            this.warnings.push("Too big Integer for decoding, hex only");
            this.isHexOnly = true;
            this._valueDec = 0;
        } else {
            this.isHexOnly = false;
            if (this.valueHexView.length > 0) this._valueDec = _pvutils.utilDecodeTC.call(this);
        }
    }
    set valueDec(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(_pvutils.utilEncodeTC(v));
    }
    get valueDec() {
        return this._valueDec;
    }
    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1) return offset;
        const view = this.valueHexView;
        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) this.valueHexView = view.subarray(1);
        else {
            if (expectedLength !== 0) {
                if (view.length < expectedLength) {
                    if (expectedLength - view.length > 1) expectedLength = view.length + 1;
                    this.valueHexView = view.subarray(expectedLength - view.length);
                }
            }
        }
        return offset;
    }
    toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch(true){
            case (view[0] & 0x80) !== 0:
                {
                    const updatedView = new Uint8Array(this.valueHexView.length + 1);
                    updatedView[0] = 0x00;
                    updatedView.set(view, 1);
                    this.valueHexView = updatedView;
                }
                break;
            case view[0] === 0x00 && (view[1] & 0x80) === 0:
                this.valueHexView = this.valueHexView.subarray(1);
                break;
        }
        return this.toBER(sizeOnly);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) return resultOffset;
        this.setValueHex();
        return resultOffset;
    }
    toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec
        };
    }
    toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for(let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--){
            currentByte = asn1View[byteNumber];
            for(let i = 0; i < 8; i++){
                if ((currentByte & 1) === 1) switch(bitNumber){
                    case firstBit:
                        digits = viewSub(power2(bitNumber), digits);
                        result = "-";
                        break;
                    default:
                        digits = viewAdd(digits, power2(bitNumber));
                }
                bitNumber++;
                currentByte >>= 1;
            }
        }
        for(let i = 0; i < digits.length; i++){
            if (digits[i]) flag = true;
            if (flag) result += digitsString.charAt(digits[i]);
        }
        if (flag === false) result += digitsString.charAt(0);
        return result;
    }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(()=>{
    Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v) {
            this.valueHexView = new Uint8Array(v);
            this.setValueHex();
        },
        get: function() {
            return this.valueHexView.slice().buffer;
        }
    });
})();
var _a$o;
class Integer extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
    }
    toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
    }
    static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(_pvtsutils.Convert.FromHex(hex));
        if (bigIntValue < 0) {
            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
            first[0] |= 0x80;
            const firstInt = BigInt(`0x${_pvtsutils.Convert.ToHex(first)}`);
            const secondInt = firstInt + bigIntValue;
            const second = _pvtsutils.BufferSourceConverter.toUint8Array(_pvtsutils.Convert.FromHex(secondInt.toString(16)));
            second[0] |= 0x80;
            writer.write(second);
        } else {
            if (view[0] & 0x80) writer.write(new Uint8Array([
                0
            ]));
            writer.write(view);
        }
        const res = new Integer({
            valueHex: writer.final()
        });
        return res;
    }
    convertToDER() {
        const integer = new Integer({
            valueHex: this.valueBlock.valueHexView
        });
        integer.valueBlock.toDER();
        return integer;
    }
    convertFromDER() {
        return new Integer({
            valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
    }
}
_a$o = Integer;
(()=>{
    typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
class Enumerated extends Integer {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
    }
}
_a$n = Enumerated;
(()=>{
    typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
class LocalSidValueBlock extends HexBlock(ValueBlock) {
    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}){
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) return inputOffset;
        const inputView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for(let i = 0; i < inputLength; i++){
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for(let i = 0; i < this.blockLength; i++)tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = _pvutils.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while(bits.length % 7)bits = "0" + bits;
        const bytes = new Uint8Array(bits.length / 7);
        for(let i = 0; i < bytes.length; i++)bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
        this.fromBER(bytes.buffer, 0, bytes.length);
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = _pvutils.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView;
    }
    toString() {
        let result = "";
        if (this.isHexOnly) result = _pvtsutils.Convert.ToHex(this.valueHexView);
        else if (this.isFirstSid) {
            let sidValue = this.valueDec;
            if (this.valueDec <= 39) result = "0.";
            else if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
            } else {
                result = "2.";
                sidValue -= 80;
            }
            result += sidValue.toString();
        } else result = this.valueDec.toString();
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec,
            isFirstSid: this.isFirstSid
        };
    }
}
LocalSidValueBlock.NAME = "sidBlock";
class LocalObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value = EMPTY_STRING, ...parameters } = {}){
        super(parameters);
        this.value = [];
        if (value) this.fromString(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            if (this.value.length === 0) sidBlock.isFirstSid = true;
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly) {
        const retBuffers = [];
        for(let i = 0; i < this.value.length; i++){
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substring(pos1);
            else sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            if (flag) {
                const sidBlock = this.value[0];
                let plus = 0;
                switch(sidBlock.valueDec){
                    case 0:
                        break;
                    case 1:
                        plus = 40;
                        break;
                    case 2:
                        plus = 80;
                        break;
                    default:
                        this.value = [];
                        return;
                }
                const parsedSID = parseInt(sid, 10);
                if (isNaN(parsedSID)) return;
                sidBlock.valueDec = parsedSID + plus;
                flag = false;
            } else {
                const sidBlock = new LocalSidValueBlock();
                if (sid > Number.MAX_SAFE_INTEGER) {
                    assertBigInt();
                    const sidValue = BigInt(sid);
                    sidBlock.valueBigInt = sidValue;
                } else {
                    sidBlock.valueDec = parseInt(sid, 10);
                    if (isNaN(sidBlock.valueDec)) return;
                }
                if (!this.value.length) {
                    sidBlock.isFirstSid = true;
                    flag = true;
                }
                this.value.push(sidBlock);
            }
        }while (pos2 !== -1);
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i = 0; i < this.value.length; i++){
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;
                else result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: []
        };
        for(let i = 0; i < this.value.length; i++)object.sidArray.push(this.value[i].toJSON());
        return object;
    }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
class ObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
    }
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue()
        };
    }
}
_a$m = ObjectIdentifier;
(()=>{
    typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
    constructor({ valueDec = 0, ...parameters } = {}){
        super(parameters);
        this.valueDec = valueDec;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        const inputView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for(let i = 0; i < inputLength; i++){
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for(let i = 0; i < this.blockLength; i++)tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = _pvutils.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = _pvutils.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView.buffer;
    }
    toString() {
        let result = "";
        if (this.isHexOnly) result = _pvtsutils.Convert.ToHex(this.valueHexView);
        else result = this.valueDec.toString();
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec
        };
    }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value = EMPTY_STRING, ...parameters } = {}){
        super(parameters);
        this.value = [];
        if (value) this.fromString(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalRelativeSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        const retBuffers = [];
        for(let i = 0; i < this.value.length; i++){
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substring(pos1);
            else sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            const sidBlock = new LocalRelativeSidValueBlock();
            sidBlock.valueDec = parseInt(sid, 10);
            if (isNaN(sidBlock.valueDec)) return true;
            this.value.push(sidBlock);
        }while (pos2 !== -1);
        return true;
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i = 0; i < this.value.length; i++){
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: []
        };
        for(let i = 0; i < this.value.length; i++)object.sidArray.push(this.value[i].toJSON());
        return object;
    }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
class RelativeObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
    }
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue()
        };
    }
}
_a$l = RelativeObjectIdentifier;
(()=>{
    typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
class Sequence extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
    }
}
_a$k = Sequence;
(()=>{
    typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
class Set extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
    }
}
_a$j = Set;
(()=>{
    typeStore.Set = _a$j;
})();
Set.NAME = "SET";
class LocalStringValueBlock extends HexBlock(ValueBlock) {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value
        };
    }
}
LocalStringValueBlock.NAME = "StringValueBlock";
class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
class LocalSimpleStringBlock extends BaseStringBlock {
    constructor({ ...parameters } = {}){
        super(parameters, LocalSimpleStringValueBlock);
    }
    fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
    }
    fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for(let i = 0; i < strLen; i++)view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
    }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
            this.valueBlock.value = _pvtsutils.Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
            this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
            this.valueBlock.value = _pvtsutils.Convert.ToBinary(inputBuffer);
        }
    }
    fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(_pvtsutils.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
    }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
class Utf8String extends LocalUtf8StringValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
    }
}
_a$i = Utf8String;
(()=>{
    typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.value = _pvtsutils.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    }
    fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(_pvtsutils.Convert.FromUtf16String(inputString));
    }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
class BmpString extends LocalBmpStringValueBlock {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
    }
}
_a$h = BmpString;
(()=>{
    typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for(let i = 0; i < valueView.length; i += 4){
            valueView[i] = valueView[i + 3];
            valueView[i + 1] = valueView[i + 2];
            valueView[i + 2] = 0x00;
            valueView[i + 3] = 0x00;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    }
    fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for(let i = 0; i < strLength; i++){
            const codeBuf = _pvutils.utilToBase(inputString.charCodeAt(i), 8);
            const codeView = new Uint8Array(codeBuf);
            if (codeView.length > 4) continue;
            const dif = 4 - codeView.length;
            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
    }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
class UniversalString extends LocalUniversalStringValueBlock {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
    }
}
_a$g = UniversalString;
(()=>{
    typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
class NumericString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
    }
}
_a$f = NumericString;
(()=>{
    typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
class PrintableString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
    }
}
_a$e = PrintableString;
(()=>{
    typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
class TeletexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
    }
}
_a$d = TeletexString;
(()=>{
    typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
class VideotexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
    }
}
_a$c = VideotexString;
(()=>{
    typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
class IA5String extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
    }
}
_a$b = IA5String;
(()=>{
    typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
class GraphicString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
    }
}
_a$a = GraphicString;
(()=>{
    typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
class VisibleString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
    }
}
_a$9 = VisibleString;
(()=>{
    typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
class GeneralString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
    }
}
_a$8 = GeneralString;
(()=>{
    typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
class CharacterString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
    }
}
_a$7 = CharacterString;
(()=>{
    typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
class UTCTime extends VisibleString {
    constructor({ value, valueDate, ...parameters } = {}){
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
            this.fromString(value);
            this.valueBlock.valueHexView = new Uint8Array(value.length);
            for(let i = 0; i < value.length; i++)this.valueBlock.valueHexView[i] = value.charCodeAt(i);
        }
        if (valueDate) {
            this.fromDate(valueDate);
            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
    }
    fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));
    }
    toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for(let i = 0; i < str.length; i++)view[i] = str.charCodeAt(i);
        return buffer;
    }
    fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
    }
    fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
            this.error = "Wrong input string for conversion";
            return;
        }
        const year = parseInt(parserArray[1], 10);
        if (year >= 50) this.year = 1900 + year;
        else this.year = 2000 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = new Array(7);
            outputArray[0] = _pvutils.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
            outputArray[1] = _pvutils.padNumber(this.month, 2);
            outputArray[2] = _pvutils.padNumber(this.day, 2);
            outputArray[3] = _pvutils.padNumber(this.hour, 2);
            outputArray[4] = _pvutils.padNumber(this.minute, 2);
            outputArray[5] = _pvutils.padNumber(this.second, 2);
            outputArray[6] = "Z";
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second
        };
    }
}
_a$6 = UTCTime;
(()=>{
    typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
class GeneralizedTime extends UTCTime {
    constructor(parameters = {}){
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
    }
    fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
    }
    fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
            timeString = inputString.substring(0, inputString.length - 1);
            isUTC = true;
        } else {
            const number = new Number(inputString[inputString.length - 1]);
            if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
            timeString = inputString;
        }
        if (isUTC) {
            if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for conversion");
            if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for conversion");
        } else {
            let multiplier = 1;
            let differencePosition = timeString.indexOf("+");
            let differenceString = "";
            if (differencePosition === -1) {
                differencePosition = timeString.indexOf("-");
                multiplier = -1;
            }
            if (differencePosition !== -1) {
                differenceString = timeString.substring(differencePosition + 1);
                timeString = timeString.substring(0, differencePosition);
                if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for conversion");
                let number = parseInt(differenceString.substring(0, 2), 10);
                if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
                hourDifference = multiplier * number;
                if (differenceString.length === 4) {
                    number = parseInt(differenceString.substring(2, 4), 10);
                    if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
                    minuteDifference = multiplier * number;
                }
            }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
            if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for conversion");
            fractionPart = fractionPartCheck.valueOf();
            dateTimeString = timeString.substring(0, fractionPointPosition);
        } else dateTimeString = timeString;
        switch(true){
            case dateTimeString.length === 8:
                parser = /(\d{4})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) throw new Error("Wrong input string for conversion");
                break;
            case dateTimeString.length === 10:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.minute = Math.floor(fractionResult);
                    fractionResult = 60 * (fractionResult - this.minute);
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 12:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 14:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    const fractionResult = 1000 * fractionPart;
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            default:
                throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null) throw new Error("Wrong input string for conversion");
        for(let j = 1; j < parserArray.length; j++)switch(j){
            case 1:
                this.year = parseInt(parserArray[j], 10);
                break;
            case 2:
                this.month = parseInt(parserArray[j], 10);
                break;
            case 3:
                this.day = parseInt(parserArray[j], 10);
                break;
            case 4:
                this.hour = parseInt(parserArray[j], 10) + hourDifference;
                break;
            case 5:
                this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                break;
            case 6:
                this.second = parseInt(parserArray[j], 10);
                break;
            default:
                throw new Error("Wrong input string for conversion");
        }
        if (isUTC === false) {
            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
            this.year = tempDate.getUTCFullYear();
            this.month = tempDate.getUTCMonth();
            this.day = tempDate.getUTCDay();
            this.hour = tempDate.getUTCHours();
            this.minute = tempDate.getUTCMinutes();
            this.second = tempDate.getUTCSeconds();
            this.millisecond = tempDate.getUTCMilliseconds();
        }
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = [];
            outputArray.push(_pvutils.padNumber(this.year, 4));
            outputArray.push(_pvutils.padNumber(this.month, 2));
            outputArray.push(_pvutils.padNumber(this.day, 2));
            outputArray.push(_pvutils.padNumber(this.hour, 2));
            outputArray.push(_pvutils.padNumber(this.minute, 2));
            outputArray.push(_pvutils.padNumber(this.second, 2));
            if (this.millisecond !== 0) {
                outputArray.push(".");
                outputArray.push(_pvutils.padNumber(this.millisecond, 3));
            }
            outputArray.push("Z");
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            millisecond: this.millisecond
        };
    }
}
_a$5 = GeneralizedTime;
(()=>{
    typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
class DATE extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
    }
}
_a$4 = DATE;
(()=>{
    typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
class TimeOfDay extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
    }
}
_a$3 = TimeOfDay;
(()=>{
    typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
class DateTime extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
    }
}
_a$2 = DateTime;
(()=>{
    typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
class Duration extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
    }
}
_a$1 = Duration;
(()=>{
    typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
class TIME extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
    }
}
_a = TIME;
(()=>{
    typeStore.TIME = _a;
})();
TIME.NAME = "TIME";
class Any {
    constructor({ name = EMPTY_STRING, optional = false } = {}){
        this.name = name;
        this.optional = optional;
    }
}
class Choice extends Any {
    constructor({ value = [], ...parameters } = {}){
        super(parameters);
        this.value = value;
    }
}
class Repeated extends Any {
    constructor({ value = new Any(), local = false, ...parameters } = {}){
        super(parameters);
        this.value = value;
        this.local = local;
    }
}
class RawData {
    constructor({ data = EMPTY_VIEW } = {}){
        this.dataView = _pvtsutils.BufferSourceConverter.toUint8Array(data);
    }
    get data() {
        return this.dataView.slice().buffer;
    }
    set data(value) {
        this.dataView = _pvtsutils.BufferSourceConverter.toUint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = _pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
    }
    toBER(sizeOnly) {
        return this.dataView.slice().buffer;
    }
}
function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
        for(let j = 0; j < inputSchema.value.length; j++){
            const result = compareSchema(root, inputData, inputSchema.value[j]);
            if (result.verified) return {
                verified: true,
                result: root
            };
        }
        {
            const _result = {
                verified: false,
                result: {
                    error: "Wrong values for Choice type"
                }
            };
            if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;
            return _result;
        }
    }
    if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;
        return {
            verified: true,
            result: root
        };
    }
    if (root instanceof Object === false) return {
        verified: false,
        result: {
            error: "Wrong root object"
        }
    };
    if (inputData instanceof Object === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 data"
        }
    };
    if (inputSchema instanceof Object === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (ID_BLOCK in inputSchema === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (FROM_BER in inputSchema.idBlock === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (TO_BER in inputSchema.idBlock === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    const encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) return {
        verified: false,
        result: {
            error: "Error encoding idBlock for ASN.1 schema"
        }
    };
    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) return {
        verified: false,
        result: {
            error: "Error decoding idBlock for ASN.1 schema"
        }
    };
    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) return {
        verified: false,
        result: root
    };
    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) return {
        verified: false,
        result: root
    };
    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) return {
        verified: false,
        result: root
    };
    if (!(IS_HEX_ONLY in inputSchema.idBlock)) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema"
        }
    };
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) return {
        verified: false,
        result: root
    };
    if (inputSchema.idBlock.isHexOnly) {
        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
        const schemaView = inputSchema.idBlock.valueHexView;
        const asn1View = inputData.idBlock.valueHexView;
        if (schemaView.length !== asn1View.length) return {
            verified: false,
            result: root
        };
        for(let i = 0; i < schemaView.length; i++){
            if (schemaView[i] !== asn1View[1]) return {
                verified: false,
                result: root
            };
        }
    }
    if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) root[inputSchema.name] = inputData;
    }
    if (inputSchema instanceof typeStore.Constructed) {
        let admission = 0;
        let result = {
            verified: false,
            result: {
                error: "Unknown error"
            }
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;
        }
        if (maxLength === 0) return {
            verified: true,
            result: root
        };
        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
            let _optional = true;
            for(let i = 0; i < inputSchema.valueBlock.value.length; i++)_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
            if (_optional) return {
                verified: true,
                result: root
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) delete root[inputSchema.name];
            }
            root.error = "Inconsistent object length";
            return {
                verified: false,
                result: root
            };
        }
        for(let i = 0; i < maxLength; i++){
            if (i - admission >= inputData.valueBlock.value.length) {
                if (inputSchema.valueBlock.value[i].optional === false) {
                    const _result = {
                        verified: false,
                        result: root
                    };
                    root.error = "Inconsistent length between ASN.1 data and schema";
                    if (inputSchema.name) {
                        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                        if (inputSchema.name) {
                            delete root[inputSchema.name];
                            _result.name = inputSchema.name;
                        }
                    }
                    return _result;
                }
            } else if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
                if (result.verified === false) {
                    if (inputSchema.valueBlock.value[0].optional) admission++;
                    else {
                        if (inputSchema.name) {
                            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                            if (inputSchema.name) delete root[inputSchema.name];
                        }
                        return result;
                    }
                }
                if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                    let arrayRoot = {};
                    if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;
                    else arrayRoot = root;
                    if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                    arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
                }
            } else {
                result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
                if (result.verified === false) {
                    if (inputSchema.valueBlock.value[i].optional) admission++;
                    else {
                        if (inputSchema.name) {
                            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                            if (inputSchema.name) delete root[inputSchema.name];
                        }
                        return result;
                    }
                }
            }
        }
        if (result.verified === false) {
            const _result = {
                verified: false,
                result: root
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return {
            verified: true,
            result: root
        };
    }
    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
        const asn1 = localFromBER(inputData.valueBlock.valueHexView);
        if (asn1.offset === -1) {
            const _result = {
                verified: false,
                result: asn1.result
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
        verified: true,
        result: root
    };
}
function verifySchema(inputBuffer, inputSchema) {
    if (inputSchema instanceof Object === false) return {
        verified: false,
        result: {
            error: "Wrong ASN.1 schema type"
        }
    };
    const asn1 = localFromBER(_pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
    if (asn1.offset === -1) return {
        verified: false,
        result: asn1.result
    };
    return compareSchema(asn1.result, asn1.result, inputSchema);
}

},{"pvtsutils":"kOw4x","pvutils":"d8HEN","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kOw4x":[function(require,module,exports) {
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */ var Buffer = require("4043947670c9bf50").Buffer;
"use strict";
const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
class BufferSourceConverter {
    static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
    }
    static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) return data;
        if (data.byteLength === data.buffer.byteLength) return data.buffer;
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return data.buffer;
        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
    }
    static toUint8Array(data) {
        return this.toView(data, Uint8Array);
    }
    static toView(data, type) {
        if (data.constructor === type) return data;
        if (this.isArrayBuffer(data)) return new type(data);
        if (this.isArrayBufferView(data)) return new type(data.buffer, data.byteOffset, data.byteLength);
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
    }
    static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
    }
    static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
    }
    static isEqual(a, b) {
        const aView = BufferSourceConverter.toUint8Array(a);
        const bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) return false;
        for(let i = 0; i < aView.length; i++){
            if (aView[i] !== bView[i]) return false;
        }
        return true;
    }
    static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) buffers = args[0];
        else if (Array.isArray(args[0]) && args[1] instanceof Function) buffers = args[0];
        else if (args[args.length - 1] instanceof Function) buffers = args.slice(0, args.length - 1);
        else buffers = args;
        let size = 0;
        for (const buffer of buffers)size += buffer.byteLength;
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer of buffers){
            const view = this.toUint8Array(buffer);
            res.set(view, offset);
            offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) return this.toView(res, args[args.length - 1]);
        return res.buffer;
    }
}
const STRING_TYPE = "string";
const HEX_REGEX = /^[0-9a-f]+$/i;
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
class Utf8Converter {
    static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for(let i = 0; i < s.length; i++)uintArray[i] = s.charCodeAt(i);
        return uintArray.buffer;
    }
    static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for(let i = 0; i < buf.length; i++)encodedString += String.fromCharCode(buf[i]);
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
}
class Utf16Converter {
    static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for(let i = 0; i < arrayBuffer.byteLength; i += 2){
            const code = dataView.getUint16(i, littleEndian);
            res += String.fromCharCode(code);
        }
        return res;
    }
    static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView = new DataView(res);
        for(let i = 0; i < text.length; i++)dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        return res;
    }
}
class Convert {
    static isHex(data) {
        return typeof data === STRING_TYPE && HEX_REGEX.test(data);
    }
    static isBase64(data) {
        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
    }
    static isBase64Url(data) {
        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
    }
    static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch(enc.toLowerCase()){
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            case "utf16le":
                return Utf16Converter.toString(buf, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buf);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static FromString(str, enc = "utf8") {
        if (!str) return new ArrayBuffer(0);
        switch(enc.toLowerCase()){
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            case "utf16le":
                return Utf16Converter.fromString(str, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(str);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf, "binary");
            return btoa(binary);
        } else return Buffer.from(buf).toString("base64");
    }
    static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) return new ArrayBuffer(0);
        if (!Convert.isBase64(formatted)) throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        if (typeof atob !== "undefined") return this.FromBinary(atob(formatted));
        else return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
    static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) return new ArrayBuffer(0);
        if (!Convert.isBase64Url(formatted)) throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    }
    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch(encoding){
            case "ascii":
                return this.FromBinary(text);
            case "utf8":
                return Utf8Converter.fromString(text);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(text);
            case "utf16le":
            case "usc2":
                return Utf16Converter.fromString(text, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch(encoding){
            case "ascii":
                return this.ToBinary(buffer);
            case "utf8":
                return Utf8Converter.toString(buffer);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buffer);
            case "utf16le":
            case "usc2":
                return Utf16Converter.toString(buffer, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for(let i = 0; i < stringLength; i++)resultView[i] = text.charCodeAt(i);
        return resultView.buffer;
    }
    static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for(let i = 0; i < buf.length; i++)res += String.fromCharCode(buf[i]);
        return res;
    }
    static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let result = "";
        const len = buf.length;
        for(let i = 0; i < len; i++){
            const byte = buf[i];
            if (byte < 16) result += "0";
            result += byte.toString(16);
        }
        return result;
    }
    static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) return new ArrayBuffer(0);
        if (!Convert.isHex(formatted)) throw new TypeError("Argument 'hexString' is not HEX encoded");
        if (formatted.length % 2) formatted = `0${formatted}`;
        const res = new Uint8Array(formatted.length / 2);
        for(let i = 0; i < formatted.length; i = i + 2){
            const c = formatted.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
    }
    static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
    }
    static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
    }
    static Base64Padding(base64) {
        const padCount = 4 - base64.length % 4;
        if (padCount < 4) for(let i = 0; i < padCount; i++)base64 += "=";
        return base64;
    }
    static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
    }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";
function assign(target, ...sources) {
    const res = arguments[0];
    for(let i = 1; i < arguments.length; i++){
        const obj = arguments[i];
        for(const prop in obj)res[prop] = obj[prop];
    }
    return res;
}
function combine(...buf) {
    const totalByteLength = buf.map((item)=>item.byteLength).reduce((prev, cur)=>prev + cur);
    const res = new Uint8Array(totalByteLength);
    let currentPos = 0;
    buf.map((item)=>new Uint8Array(item)).forEach((arr)=>{
        for (const item2 of arr)res[currentPos++] = item2;
    });
    return res.buffer;
}
function isEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) return false;
    if (bytes1.byteLength !== bytes2.byteLength) return false;
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for(let i = 0; i < bytes1.byteLength; i++){
        if (b1[i] !== b2[i]) return false;
    }
    return true;
}
exports.BufferSourceConverter = BufferSourceConverter;
exports.Convert = Convert;
exports.assign = assign;
exports.combine = combine;
exports.isEqual = isEqual;

},{"4043947670c9bf50":"fCgem"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"d8HEN":[function(require,module,exports) {
/*!
 Copyright (c) Peculiar Ventures, LLC
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayBufferToString", ()=>arrayBufferToString);
parcelHelpers.export(exports, "bufferToHexCodes", ()=>bufferToHexCodes);
parcelHelpers.export(exports, "checkBufferParams", ()=>checkBufferParams);
parcelHelpers.export(exports, "clearProps", ()=>clearProps);
parcelHelpers.export(exports, "fromBase64", ()=>fromBase64);
parcelHelpers.export(exports, "getParametersValue", ()=>getParametersValue);
parcelHelpers.export(exports, "getUTCDate", ()=>getUTCDate);
parcelHelpers.export(exports, "isEqualBuffer", ()=>isEqualBuffer);
parcelHelpers.export(exports, "nearestPowerOf2", ()=>nearestPowerOf2);
parcelHelpers.export(exports, "padNumber", ()=>padNumber);
parcelHelpers.export(exports, "stringToArrayBuffer", ()=>stringToArrayBuffer);
parcelHelpers.export(exports, "toBase64", ()=>toBase64);
parcelHelpers.export(exports, "utilConcatBuf", ()=>utilConcatBuf);
parcelHelpers.export(exports, "utilConcatView", ()=>utilConcatView);
parcelHelpers.export(exports, "utilDecodeTC", ()=>utilDecodeTC);
parcelHelpers.export(exports, "utilEncodeTC", ()=>utilEncodeTC);
parcelHelpers.export(exports, "utilFromBase", ()=>utilFromBase);
parcelHelpers.export(exports, "utilToBase", ()=>utilToBase);
function getUTCDate(date) {
    return new Date(date.getTime() + date.getTimezoneOffset() * 60000);
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if (parameters instanceof Object === false) return defaultValue;
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
    let result = "";
    for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)){
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) result += "0";
        result += str;
        if (insertSpace) result += " ";
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = 'Wrong parameter: inputBuffer must be "ArrayBuffer"';
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) return inputBuffer[0];
    for(let i = inputBuffer.length - 1; i >= 0; i--)result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
    return result;
}
function utilToBase(value, base, reserved = -1) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for(let i = 1; i < 8; i++){
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            } else {
                if (internalReserved < i) return new ArrayBuffer(0);
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for(let j = i - 1; j >= 0; j--){
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= retView[result - j - 1] * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers)outputLength += buffer.byteLength;
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers){
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views)outputLength += view.length;
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views){
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = buf[0] === 0xFF && buf[1] & 0x80;
        const condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;
        if (condition1 || condition2) this.warnings.push("Needlessly long format");
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for(let i = 0; i < this.valueHex.byteLength; i++)bigIntView[i] = 0;
    bigIntView[0] = buf[0] & 0x80;
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for(let j = 0; j < this.valueHex.byteLength; j++)smallIntView[j] = buf[j];
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return smallInt - bigInt;
}
function utilEncodeTC(value) {
    const modValue = value < 0 ? value * -1 : value;
    let bigInt = 128;
    for(let i = 1; i < 8; i++){
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for(let k = 0; k < tempBuf.byteLength; k++)retView[k + 1] = tempView[k];
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) return false;
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for(let i = 0; i < view1.length; i++){
        if (view1[i] !== view2[i]) return false;
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) return "";
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for(let i = 0; i < dif; i++)padding[i] = "0";
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for(let i = 0; i < input.length; i++)if (input.charCodeAt(i) !== 0) {
            nonZeroPosition = i;
            break;
        }
        input = input.slice(nonZeroPosition);
    }
    while(i < input.length){
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) flag1 = 1;
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) flag2 = 1;
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;
        let enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) enc3 = enc4 = 64;
        else if (flag2 === 1) enc4 = 64;
        if (skipPadding) {
            if (enc3 === 64) output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            else if (enc4 === 64) output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
            else output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        } else output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for(let i = 0; i < 64; i++){
            if (template.charAt(i) === toSearch) return i;
        }
        return 64;
    }
    function test(incoming) {
        return incoming === 64 ? 0x00 : incoming;
    }
    let i = 0;
    let output = "";
    while(i < input.length){
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = test(enc1) << 2 | test(enc2) >> 4;
        const chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;
        const chr3 = (test(enc3) & 0x03) << 6 | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) output += String.fromCharCode(chr2);
        if (enc4 !== 64) output += String.fromCharCode(chr3);
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = -1;
        for(let i = outputLength - 1; i >= 0; i--)if (output.charCodeAt(i) !== 0) {
            nonZeroStart = i;
            break;
        }
        if (nonZeroStart !== -1) output = output.slice(0, nonZeroStart + 1);
        else output = "";
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view)resultString += String.fromCharCode(element);
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for(let i = 0; i < stringLength; i++)resultView[i] = str.charCodeAt(i);
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = Math.log(length) / log2;
    const floor = Math.floor(base);
    const round = Math.round(base);
    return floor === round ? floor : round;
}
function clearProps(object, propsArray) {
    for (const prop of propsArray)delete object[prop];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"e3TYG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Secp256k1PublicKey", ()=>Secp256k1PublicKey);
parcelHelpers.export(exports, "Secp256k1PrivateKey", ()=>Secp256k1PrivateKey);
parcelHelpers.export(exports, "unmarshalSecp256k1PrivateKey", ()=>unmarshalSecp256k1PrivateKey);
parcelHelpers.export(exports, "unmarshalSecp256k1PublicKey", ()=>unmarshalSecp256k1PublicKey);
parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
var _interface = require("@libp2p/interface");
var _sha2 = require("multiformats/hashes/sha2");
var _equals = require("uint8arrays/equals");
var _toString = require("uint8arrays/to-string");
var _utilJs = require("../util.js");
var _exporterJs = require("./exporter.js");
var _keysJs = require("./keys.js");
var _secp256K1Js = require("./secp256k1.js");
class Secp256k1PublicKey {
    _key;
    constructor(key){
        _secp256K1Js.validatePublicKey(key);
        this._key = key;
    }
    verify(data, sig) {
        return _secp256K1Js.hashAndVerify(this._key, sig, data);
    }
    marshal() {
        return _secp256K1Js.compressPublicKey(this._key);
    }
    get bytes() {
        return _keysJs.PublicKey.encode({
            Type: _keysJs.KeyType.Secp256k1,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    async hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        let bytes;
        if ((0, _utilJs.isPromise)(p)) ({ bytes } = await p);
        else bytes = p.bytes;
        return bytes;
    }
}
class Secp256k1PrivateKey {
    _key;
    _publicKey;
    constructor(key, publicKey){
        this._key = key;
        this._publicKey = publicKey ?? _secp256K1Js.computePublicKey(key);
        _secp256K1Js.validatePrivateKey(this._key);
        _secp256K1Js.validatePublicKey(this._publicKey);
    }
    sign(message) {
        return _secp256K1Js.hashAndSign(this._key, message);
    }
    get public() {
        return new Secp256k1PublicKey(this._publicKey);
    }
    marshal() {
        return this._key;
    }
    get bytes() {
        return _keysJs.PrivateKey.encode({
            Type: _keysJs.KeyType.Secp256k1,
            Data: this.marshal()
        }).subarray();
    }
    equals(key) {
        return (0, _equals.equals)(this.bytes, key.bytes);
    }
    hash() {
        const p = (0, _sha2.sha256).digest(this.bytes);
        if ((0, _utilJs.isPromise)(p)) return p.then(({ bytes })=>bytes);
        return p.bytes;
    }
    /**
     * Gets the ID of the key.
     *
     * The key id is the base58 encoding of the SHA-256 multihash of its public key.
     * The public key is a protobuf encoding containing a type and the DER encoding
     * of the PKCS SubjectPublicKeyInfo.
     */ async id() {
        const hash = await this.public.hash();
        return (0, _toString.toString)(hash, "base58btc");
    }
    /**
     * Exports the key into a password protected `format`
     */ async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") return (0, _exporterJs.exporter)(this.bytes, password);
        else throw new (0, _interface.CodeError)(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
}
function unmarshalSecp256k1PrivateKey(bytes) {
    return new Secp256k1PrivateKey(bytes);
}
function unmarshalSecp256k1PublicKey(bytes) {
    return new Secp256k1PublicKey(bytes);
}
async function generateKeyPair() {
    const privateKeyBytes = _secp256K1Js.generateKey();
    return new Secp256k1PrivateKey(privateKeyBytes);
}

},{"@libp2p/interface":"b14bx","multiformats/hashes/sha2":"9qYCS","uint8arrays/equals":"CKVqX","uint8arrays/to-string":"63irA","../util.js":"kswAQ","./exporter.js":"87Mdx","./keys.js":"fwqFh","./secp256k1.js":"gx8HF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gx8HF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "privateKeyLength", ()=>PRIVATE_KEY_BYTE_LENGTH);
parcelHelpers.export(exports, "generateKey", ()=>generateKey);
/**
 * Hash and sign message with private key
 */ parcelHelpers.export(exports, "hashAndSign", ()=>hashAndSign);
/**
 * Hash message and verify signature with public key
 */ parcelHelpers.export(exports, "hashAndVerify", ()=>hashAndVerify);
parcelHelpers.export(exports, "compressPublicKey", ()=>compressPublicKey);
parcelHelpers.export(exports, "decompressPublicKey", ()=>decompressPublicKey);
parcelHelpers.export(exports, "validatePrivateKey", ()=>validatePrivateKey);
parcelHelpers.export(exports, "validatePublicKey", ()=>validatePublicKey);
parcelHelpers.export(exports, "computePublicKey", ()=>computePublicKey);
var _interface = require("@libp2p/interface");
var _secp256K1 = require("@noble/curves/secp256k1");
var _sha2 = require("multiformats/hashes/sha2");
var _utilJs = require("../util.js");
const PRIVATE_KEY_BYTE_LENGTH = 32;
function generateKey() {
    return (0, _secp256K1.secp256k1).utils.randomPrivateKey();
}
function hashAndSign(key, msg) {
    const p = (0, _sha2.sha256).digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if ((0, _utilJs.isPromise)(p)) return p.then(({ digest })=>(0, _secp256K1.secp256k1).sign(digest, key).toDERRawBytes()).catch((err)=>{
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_INPUT");
    });
    try {
        return (0, _secp256K1.secp256k1).sign(p.digest, key).toDERRawBytes();
    } catch (err) {
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_INPUT");
    }
}
function hashAndVerify(key, sig, msg) {
    const p = (0, _sha2.sha256).digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if ((0, _utilJs.isPromise)(p)) return p.then(({ digest })=>(0, _secp256K1.secp256k1).verify(sig, digest, key)).catch((err)=>{
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_INPUT");
    });
    try {
        return (0, _secp256K1.secp256k1).verify(sig, p.digest, key);
    } catch (err) {
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_INPUT");
    }
}
function compressPublicKey(key) {
    const point = (0, _secp256K1.secp256k1).ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
}
function decompressPublicKey(key) {
    const point = (0, _secp256K1.secp256k1).ProjectivePoint.fromHex(key).toRawBytes(false);
    return point;
}
function validatePrivateKey(key) {
    try {
        (0, _secp256K1.secp256k1).getPublicKey(key, true);
    } catch (err) {
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
}
function validatePublicKey(key) {
    try {
        (0, _secp256K1.secp256k1).ProjectivePoint.fromHex(key);
    } catch (err) {
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_PUBLIC_KEY");
    }
}
function computePublicKey(privateKey) {
    try {
        return (0, _secp256K1.secp256k1).getPublicKey(privateKey, true);
    } catch (err) {
        throw new (0, _interface.CodeError)(String(err), "ERR_INVALID_PRIVATE_KEY");
    }
}

},{"@libp2p/interface":"b14bx","@noble/curves/secp256k1":"k8xYt","multiformats/hashes/sha2":"9qYCS","../util.js":"kswAQ","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"k8xYt":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1", ()=>secp256k1);
parcelHelpers.export(exports, "schnorr", ()=>schnorr);
parcelHelpers.export(exports, "hashToCurve", ()=>hashToCurve);
parcelHelpers.export(exports, "encodeToCurve", ()=>encodeToCurve);
var _sha256 = require("@noble/hashes/sha256");
var _utils = require("@noble/hashes/utils");
var _modularJs = require("./abstract/modular.js");
var _weierstrassJs = require("./abstract/weierstrass.js");
var _utilsJs = require("./abstract/utils.js");
var _hashToCurveJs = require("./abstract/hash-to-curve.js");
var _shortwUtilsJs = require("./_shortw_utils.js");
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b)=>(a + b / _2n) / b;
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P; // x^3, 11
    const b3 = b2 * b2 * y % P; // x^7
    const b6 = (0, _modularJs.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, _modularJs.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, _modularJs.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, _modularJs.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, _modularJs.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, _modularJs.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, _modularJs.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, _modularJs.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, _modularJs.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, _modularJs.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, _modularJs.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, _modularJs.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error("Cannot find square root");
    return root;
}
const Fp = (0, _modularJs.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
const secp256k1 = (0, _shortwUtilsJs.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k)=>{
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000"); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, _modularJs.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, _modularJs.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
            return {
                k1neg,
                k1,
                k2neg,
                k2
            };
        }
    }
}, (0, _sha256.sha256));
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x)=>typeof x === "bigint" && _0n < x && x < secp256k1P;
const ge = (x)=>typeof x === "bigint" && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, _sha256.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
        tagP = (0, _utilsJs.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, _sha256.sha256)((0, _utilsJs.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point)=>point.toRawBytes(true).slice(1);
const numTo32b = (n)=>(0, _utilsJs.numberToBytesBE)(n, 32);
const modP = (x)=>(0, _modularJs.mod)(x, secp256k1P);
const modN = (x)=>(0, _modularJs.mod)(x, secp256k1N);
const Point = secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    if (!fe(x)) throw new Error("bad x: need 0 < x < p"); // Fail if x ≥ p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge(...args) {
    return modN((0, _utilsJs.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand = (0, _utils.randomBytes)(32)) {
    const m = (0, _utilsJs.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, _utilsJs.ensureBytes)("auxRand", auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, _utilsJs.bytesToNumberBE)(taggedHash("BIP0340/aux", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash("BIP0340/nonce", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, _utilsJs.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error("sign failed: k is zero"); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error("sign: Invalid signature produced");
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    const sig = (0, _utilsJs.ensureBytes)("signature", signature, 64);
    const m = (0, _utilsJs.ensureBytes)("message", message);
    const pub = (0, _utilsJs.ensureBytes)("publicKey", publicKey, 32);
    try {
        const P = lift_x((0, _utilsJs.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, _utilsJs.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!fe(r)) return false;
        const s = (0, _utilsJs.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!ge(s)) return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
    } catch (error) {
        return false;
    }
}
const schnorr = /* @__PURE__ */ (()=>({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: secp256k1.utils.randomPrivateKey,
            lift_x,
            pointToBytes,
            numberToBytesBE: (0, _utilsJs.numberToBytesBE),
            bytesToNumberBE: (0, _utilsJs.bytesToNumberBE),
            taggedHash,
            mod: (0, _modularJs.mod)
        }
    }))();
const isoMap = /* @__PURE__ */ (()=>(0, _hashToCurveJs.isogenyMap)(Fp, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((i)=>i.map((j)=>BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (()=>(0, _weierstrassJs.mapToCurveSimpleSWU)(Fp, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fp.create(BigInt("-11"))
    }))();
const htf = /* @__PURE__ */ (()=>(0, _hashToCurveJs.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{
        const { x, y } = mapSWU(Fp.create(scalars[0]));
        return isoMap(x, y);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: (0, _sha256.sha256)
    }))();
const hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();
const encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)();

},{"@noble/hashes/sha256":"hPfLW","@noble/hashes/utils":"eYkBB","./abstract/modular.js":"aWzDR","./abstract/weierstrass.js":"dvVS3","./abstract/utils.js":"6xA5w","./abstract/hash-to-curve.js":"xT4Ur","./_shortw_utils.js":"e5PHG","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hPfLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha224", ()=>sha224);
var _sha2Js = require("./_sha2.js");
var _utilsJs = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c)=>a & b ^ ~a & c;
// Majority function, true if any two inpust is true
const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends (0, _sha2Js.SHA2) {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, _utilsJs.rotr)(W15, 7) ^ (0, _utilsJs.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, _utilsJs.rotr)(W2, 17) ^ (0, _utilsJs.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, _utilsJs.rotr)(E, 6) ^ (0, _utilsJs.rotr)(E, 11) ^ (0, _utilsJs.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, _utilsJs.rotr)(A, 2) ^ (0, _utilsJs.rotr)(A, 13) ^ (0, _utilsJs.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor(){
        super();
        this.A = -1056596264;
        this.B = 914150663;
        this.C = 812702999;
        this.D = -150054599;
        this.E = -4191439;
        this.F = 1750603025;
        this.G = 1694076839;
        this.H = -1090891868;
        this.outputLen = 28;
    }
}
const sha256 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA224());

},{"./_sha2.js":"klWn8","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dvVS3":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DER", ()=>DER);
parcelHelpers.export(exports, "weierstrassPoints", ()=>weierstrassPoints);
parcelHelpers.export(exports, "weierstrass", ()=>weierstrass);
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ parcelHelpers.export(exports, "SWUFpSqrtRatio", ()=>SWUFpSqrtRatio);
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ parcelHelpers.export(exports, "mapToCurveSimpleSWU", ()=>mapToCurveSimpleSWU);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
var _curveJs = require("./curve.js");
function validatePointOpts(curve) {
    const opts = (0, _curveJs.validateBasic)(curve);
    _utilsJs.validateObject(opts, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...opts
    });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = _utilsJs;
const DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = ""){
            super(m);
        }
    },
    _parseInt (data) {
        const { Err: E } = DER;
        if (data.length < 2 || data[0] !== 0x02) throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len) throw new E("Invalid signature integer: wrong length");
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128) throw new E("Invalid signature integer: negative");
        if (res[0] === 0x00 && !(res[1] & 128)) throw new E("Invalid signature integer: unnecessary leading zero");
        return {
            d: b2n(res),
            l: data.subarray(len + 2)
        }; // d is data, l is left
    },
    toSig (hex) {
        // parse DER signature
        const { Err: E } = DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!_utilsJs.isBytes(data)) throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 0x30) throw new E("Invalid signature tag");
        if (data[1] !== l - 2) throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length) throw new E("Invalid signature: left bytes after parsing");
        return {
            r,
            s
        };
    },
    hexFromSig (sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? "00" + s : s;
        const h = (num)=>{
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{
        const a = point.toAffine();
        return _utilsJs.concatBytes(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes)=>{
        // const head = bytes[0];
        const tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x,
            y
        };
    });
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula
     * @returns y²
     */ function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error("bad generator point: equation left != right");
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
            if (_utilsJs.isBytes(key)) key = _utilsJs.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== "string" || !lengths.includes(key.length)) throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
            num = typeof key === "bigint" ? key : _utilsJs.bytesToNumberBE((0, _utilsJs.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey) num = _modularJs.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ class Point {
        constructor(px, py, pz){
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px)) throw new Error("x required");
            if (py == null || !Fp.isValid(py)) throw new Error("y required");
            if (pz == null || !Fp.isValid(pz)) throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error("invalid affine point");
            if (p instanceof Point) throw new Error("projective point not allowed");
            const is0 = (i)=>Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p)=>p.pz));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, _utilsJs.ensureBytes)("pointHex", hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
                throw new Error("bad point: ZERO");
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error("bad point: x or y not FE");
            const left = Fp.sqr(y); // y²
            const right = weierstrassEquation(x); // x³ + ax + b
            if (!Fp.eql(left, right)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */ equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{
                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));
                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n) return I;
            assertGE(n); // Will throw on 0
            if (n === _1n) return this;
            const { endo } = CURVE;
            if (!endo) return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0) return {
                x: Fp.ZERO,
                y: Fp.ZERO
            };
            if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
            return {
                x: ax,
                y: ay
            };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return _utilsJs.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, _curveJs.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
    };
}
function validateOpts(curve) {
    const opts = (0, _curveJs.validateBasic)(curve);
    _utilsJs.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    });
    return Object.freeze({
        lowS: true,
        ...opts
    });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return _modularJs.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return _modularJs.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes (_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = _utilsJs.concatBytes;
            if (isCompressed) return cat(Uint8Array.from([
                point.hasEvenY() ? 0x02 : 0x03
            ]), x);
            else return cat(Uint8Array.from([
                0x04
            ]), x, Fp.toBytes(a.y));
        },
        fromBytes (bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = _utilsJs.bytesToNumberBE(tail);
                if (!isValidFieldElement(x)) throw new Error("Point is not on curve");
                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x,
                    y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x,
                    y
                };
            } else throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
    });
    const numToNByteStr = (num)=>_utilsJs.bytesToHex(_utilsJs.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to)=>_utilsJs.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ class Signature {
        constructor(r, s, recovery){
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, _utilsJs.ensureBytes)("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = DER.toSig((0, _utilsJs.ensureBytes)("DER", hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s)) throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, _utilsJs.ensureBytes)("msgHash", msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error("point at infinify"); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return _utilsJs.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return _utilsJs.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey (privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: ()=>{
            const length = _modularJs.getMinHashLength(CURVE.n);
            return _modularJs.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        const arr = _utilsJs.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA)) throw new Error("first arg must be private key");
        if (!isProbPub(publicB)) throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int || function(bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        const num = _utilsJs.bytesToNumberBE(bytes); // check for == u8 done here
        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = _utilsJs.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        if (typeof num !== "bigint") throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return _utilsJs.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if ([
            "recovered",
            "canonical"
        ].some((k)=>k in opts)) throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, _utilsJs.ensureBytes)("msgHash", msgHash);
        if (prehash) msgHash = (0, _utilsJs.ensureBytes)("prehashed msgHash", hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, _utilsJs.ensureBytes)("extraEntropy", e)); // check for being bytes
        }
        const seed = _utilsJs.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed,
            k2sig
        };
    }
    const defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    const defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = _utilsJs.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1⋅G - U2⋅P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, _utilsJs.ensureBytes)("msgHash", msgHash);
        publicKey = (0, _utilsJs.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === "string" || _utilsJs.isBytes(sg)) // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
            // Since DER can also be 2*nByteLength bytes, we check for it first.
            try {
                _sig = Signature.fromDER(sg);
            } catch (derError) {
                if (!(derError instanceof DER.Err)) throw derError;
                _sig = Signature.fromCompact(sg);
            }
            else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            } else throw new Error("PARSE");
            P = Point.fromHex(publicKey);
        } catch (error) {
            if (error.message === "PARSE") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
        if (!R) return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
    };
}
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v)=>{
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(let i = c1; i > _1n; i--){
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v)=>{
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
    _modularJs.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error("Fp.isOdd is not implemented!");
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u)=>{
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
            x,
            y
        };
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","./curve.js":"37yfg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"e5PHG":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// connects noble-curves to noble-hashes
parcelHelpers.export(exports, "getHash", ()=>getHash);
parcelHelpers.export(exports, "createCurve", ()=>createCurve);
var _hmac = require("@noble/hashes/hmac");
var _utils = require("@noble/hashes/utils");
var _weierstrassJs = require("./abstract/weierstrass.js");
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs)=>(0, _hmac.hmac)(hash, key, (0, _utils.concatBytes)(...msgs)),
        randomBytes: (0, _utils.randomBytes)
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash)=>(0, _weierstrassJs.weierstrass)({
            ...curveDef,
            ...getHash(hash)
        });
    return Object.freeze({
        ...create(defHash),
        create
    });
}

},{"@noble/hashes/hmac":"1S2SD","@noble/hashes/utils":"eYkBB","./abstract/weierstrass.js":"dvVS3","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aeh5U":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * A logger for libp2p based on the venerable [debug](https://www.npmjs.com/package/debug) module.
 *
 * @example
 *
 * ```TypeScript
 * import { logger } from '@libp2p/logger'
 *
 * const log = logger('libp2p:my:component:name')
 *
 * log('something happened: %s', 'it was ok')
 * log.error('something bad happened: %o', err)
 *
 * log('with this peer: %p', aPeerId)
 * log('and this base58btc: %b', aUint8Array)
 * log('and this base32: %t', aUint8Array)
 *  ```
 * ```console
 * $ DEBUG=libp2p:* node index.js
 * something happened: it was ok
 * something bad happened: <stack trace>
 * with this peer: 12D3Foo
 * with this base58btc: Qmfoo
 * with this base32: bafyfoo
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a component logger that will prefix any log messages with a truncated
 * peer id.
 *
 * @example
 *
 * ```TypeScript
 * import { peerLogger } from '@libp2p/logger'
 * import { peerIdFromString } from '@libp2p/peer-id'
 *
 * const peerId = peerIdFromString('12D3FooBar')
 * const logger = peerLogger(peerId)
 *
 * const log = logger.forComponent('my-component')
 * log.info('hello world')
 * // logs "12…oBar:my-component hello world"
 * ```
 */ parcelHelpers.export(exports, "peerLogger", ()=>peerLogger);
/**
 * Create a component logger that will prefix any log messages with the passed
 * string.
 *
 * @example
 *
 * ```TypeScript
 * import { prefixLogger } from '@libp2p/logger'
 *
 * const logger = prefixLogger('my-node')
 *
 * const log = logger.forComponent('my-component')
 * log.info('hello world')
 * // logs "my-node:my-component hello world"
 * ```
 */ parcelHelpers.export(exports, "prefixLogger", ()=>prefixLogger);
/**
 * Create a component logger
 *
 * @example
 *
 * ```TypeScript
 * import { defaultLogger } from '@libp2p/logger'
 * import { peerIdFromString } from '@libp2p/peer-id'
 *
 * const logger = defaultLogger()
 *
 * const log = logger.forComponent('my-component')
 * log.info('hello world')
 * // logs "my-component hello world"
 * ```
 */ parcelHelpers.export(exports, "defaultLogger", ()=>defaultLogger);
/**
 * Creates a logger for the passed component name.
 *
 * @example
 *
 * ```TypeScript
 * import { logger } from '@libp2p/logger'
 *
 * const log = logger('my-component')
 * log.info('hello world')
 * // logs "my-component hello world"
 * ```
 */ parcelHelpers.export(exports, "logger", ()=>logger);
parcelHelpers.export(exports, "disable", ()=>disable);
parcelHelpers.export(exports, "enable", ()=>enable);
parcelHelpers.export(exports, "enabled", ()=>enabled);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _base32 = require("multiformats/bases/base32");
var _base58 = require("multiformats/bases/base58");
var _base64 = require("multiformats/bases/base64");
var _utilsJs = require("./utils.js");
// Add a formatter for converting to a base58 string
(0, _debugDefault.default).formatters.b = (v)=>{
    return v == null ? "undefined" : (0, _base58.base58btc).baseEncode(v);
};
// Add a formatter for converting to a base32 string
(0, _debugDefault.default).formatters.t = (v)=>{
    return v == null ? "undefined" : (0, _base32.base32).baseEncode(v);
};
// Add a formatter for converting to a base64 string
(0, _debugDefault.default).formatters.m = (v)=>{
    return v == null ? "undefined" : (0, _base64.base64).baseEncode(v);
};
// Add a formatter for stringifying peer ids
(0, _debugDefault.default).formatters.p = (v)=>{
    return v == null ? "undefined" : v.toString();
};
// Add a formatter for stringifying CIDs
(0, _debugDefault.default).formatters.c = (v)=>{
    return v == null ? "undefined" : v.toString();
};
// Add a formatter for stringifying Datastore keys
(0, _debugDefault.default).formatters.k = (v)=>{
    return v == null ? "undefined" : v.toString();
};
// Add a formatter for stringifying Multiaddrs
(0, _debugDefault.default).formatters.a = (v)=>{
    return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace) {
    const logger = ()=>{};
    logger.enabled = false;
    logger.color = "";
    logger.diff = 0;
    logger.log = ()=>{};
    logger.namespace = namespace;
    logger.destroy = ()=>true;
    logger.extend = ()=>logger;
    return logger;
}
function peerLogger(peerId, options = {}) {
    return prefixLogger((0, _utilsJs.truncatePeerId)(peerId, options));
}
function prefixLogger(prefix) {
    return {
        forComponent (name) {
            return logger(`${prefix}:${name}`);
        }
    };
}
function defaultLogger() {
    return {
        forComponent (name) {
            return logger(name);
        }
    };
}
function logger(name) {
    // trace logging is a no-op by default
    let trace = createDisabledLogger(`${name}:trace`);
    // look at all the debug names and see if trace logging has explicitly been enabled
    if ((0, _debugDefault.default).enabled(`${name}:trace`) && (0, _debugDefault.default).names.map((r)=>r.toString()).find((n)=>n.includes(":trace")) != null) trace = (0, _debugDefault.default)(`${name}:trace`);
    return Object.assign((0, _debugDefault.default)(name), {
        error: (0, _debugDefault.default)(`${name}:error`),
        trace
    });
}
function disable() {
    (0, _debugDefault.default).disable();
}
function enable(namespaces) {
    (0, _debugDefault.default).enable(namespaces);
}
function enabled(namespaces) {
    return (0, _debugDefault.default).enabled(namespaces);
}

},{"debug":"l0oUb","multiformats/bases/base32":"dpCMu","multiformats/bases/base58":"9K4Ju","multiformats/bases/base64":"2m5sV","./utils.js":"5zcEq","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"l0oUb":[function(require,module,exports) {
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var process = require("12edbb1af7d8bd3b");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === "%%") return;
        index++;
        if (match === "%c") // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== "undefined" && "env" in process) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = require("d9172905aa5ed6c")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
    }
};

},{"12edbb1af7d8bd3b":"d5jf4","d9172905aa5ed6c":"6Yq2n"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"6Yq2n":[function(require,module,exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require("5c5c8c8b1996f88f");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) return;
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") // Anything else let's inspect with %O
            args.unshift("%O");
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") return "%";
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) return enableOverride;
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") createDebug.init(debug);
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            else createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>"-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === "*") return true;
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;

},{"5c5c8c8b1996f88f":"jauEe"}],"jauEe":[function(require,module,exports) {
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse(val);
    else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * y;
        case "weeks":
        case "week":
        case "w":
            return n * w;
        case "days":
        case "day":
        case "d":
            return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return Math.round(ms / d) + "d";
    if (msAbs >= h) return Math.round(ms / h) + "h";
    if (msAbs >= m) return Math.round(ms / m) + "m";
    if (msAbs >= s) return Math.round(ms / s) + "s";
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return plural(ms, msAbs, d, "day");
    if (msAbs >= h) return plural(ms, msAbs, h, "hour");
    if (msAbs >= m) return plural(ms, msAbs, m, "minute");
    if (msAbs >= s) return plural(ms, msAbs, s, "second");
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}

},{}],"5zcEq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "truncatePeerId", ()=>truncatePeerId);
function truncatePeerId(peerId, options = {}) {
    const prefixLength = options.prefixLength ?? 2;
    const suffixLength = options.suffixLength ?? 4;
    const peerIdString = peerId.toString();
    return `${peerIdString.substring(0, prefixLength)}\u{2026}${peerIdString.substring(peerIdString.length, peerIdString.length - suffixLength)}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jqBHH":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * We can't use PeerIds as collection keys because collection keys are compared using same-value-zero equality, so this is just a group of collections that stringifies PeerIds before storing them.
 *
 * PeerIds cache stringified versions of themselves so this should be a cheap operation.
 *
 * Tracked versions are also available which report their current size to the libp2p Metrics collector.
 *
 * @example Peer lists
 *
 * ```TypeScript
 * import { peerList } from '@libp2p/peer-collections'
 *
 * const list = peerList()
 * list.push(peerId)
 * ```
 *
 * @example Tracked peer lists
 *
 * ```TypeScript
 * import { trackedPeerList } from '@libp2p/peer-collections'
 * import { createLibp2p } from 'libp2p'
 *
 * const libp2p = await createLibp2p()
 *
 * const list = trackedPeerList({ name: 'my_metric_name', metrics: libp2p.metrics })
 * list.push(peerId)
 * ```
 *
 * @example Peer maps
 *
 * ```TypeScript
 * import { peerMap } from '@libp2p/peer-collections'
 *
 * const map = peerMap<string>()
 * map.set(peerId, 'value')
 * ```
 *
 * @example Tracked peer maps
 *
 * ```TypeScript
 * import { trackedPeerMap } from '@libp2p/peer-collections'
 * import { createLibp2p } from 'libp2p'
 *
 * const libp2p = await createLibp2p()
 *
 * const list = trackedPeerMap({ name: 'my_metric_name', metrics: libp2p.metrics })
 * map.set(peerId, 'value')
 * ```
 *
 * @example Peer sets
 *
 * ```TypeScript
 * import { peerSet } from '@libp2p/peer-collections'
 *
 * const set = peerSet()
 * set.add(peerId)
 * ```
 *
 * @example Tracked peer sets
 *
 * ```TypeScript
 * import { trackedPeerSet } from '@libp2p/peer-collections'
 * import { createLibp2p } from 'libp2p'
 *
 * const libp2p = await createLibp2p()
 *
 * const list = trackedPeerSet({ name: 'my_metric_name', metrics: libp2p.metrics })
 * map.add(peerId)
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PeerMap", ()=>(0, _mapJs.PeerMap));
parcelHelpers.export(exports, "peerMap", ()=>(0, _mapJs.peerMap));
parcelHelpers.export(exports, "PeerSet", ()=>(0, _setJs.PeerSet));
parcelHelpers.export(exports, "peerSet", ()=>(0, _setJs.peerSet));
parcelHelpers.export(exports, "PeerList", ()=>(0, _listJs.PeerList));
parcelHelpers.export(exports, "peerList", ()=>(0, _listJs.peerList));
parcelHelpers.export(exports, "trackedPeerMap", ()=>(0, _trackedMapJs.trackedPeerMap));
parcelHelpers.export(exports, "trackedPeerSet", ()=>(0, _trackedSetJs.trackedPeerSet));
parcelHelpers.export(exports, "trackedPeerList", ()=>(0, _trackedListJs.trackedPeerList));
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _listJs = require("./list.js");
var _trackedMapJs = require("./tracked-map.js");
var _trackedSetJs = require("./tracked-set.js");
var _trackedListJs = require("./tracked-list.js");

},{"./map.js":"iYN4z","./set.js":"695Rh","./list.js":false,"./tracked-map.js":false,"./tracked-set.js":false,"./tracked-list.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iYN4z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * We can't use PeerIds as map keys because map keys are
 * compared using same-value-zero equality, so this is just
 * a map that stringifies the PeerIds before storing them.
 *
 * PeerIds cache stringified versions of themselves so this
 * should be a cheap operation.
 *
 * @example
 *
 * ```TypeScript
 * import { peerMap } from '@libp2p/peer-collections'
 *
 * const map = peerMap<string>()
 * map.set(peerId, 'value')
 * ```
 */ parcelHelpers.export(exports, "PeerMap", ()=>PeerMap);
parcelHelpers.export(exports, "peerMap", ()=>peerMap);
var _peerId = require("@libp2p/peer-id");
var _utilJs = require("./util.js");
class PeerMap {
    map;
    constructor(map){
        this.map = new Map();
        if (map != null) for (const [key, value] of map.entries())this.map.set(key.toString(), value);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    clear() {
        this.map.clear();
    }
    delete(peer) {
        return this.map.delete(peer.toString());
    }
    entries() {
        return (0, _utilJs.mapIterable)(this.map.entries(), (val)=>{
            return [
                (0, _peerId.peerIdFromString)(val[0]),
                val[1]
            ];
        });
    }
    forEach(fn) {
        this.map.forEach((value, key)=>{
            fn(value, (0, _peerId.peerIdFromString)(key), this);
        });
    }
    get(peer) {
        return this.map.get(peer.toString());
    }
    has(peer) {
        return this.map.has(peer.toString());
    }
    set(peer, value) {
        this.map.set(peer.toString(), value);
    }
    keys() {
        return (0, _utilJs.mapIterable)(this.map.keys(), (val)=>{
            return (0, _peerId.peerIdFromString)(val);
        });
    }
    values() {
        return this.map.values();
    }
    get size() {
        return this.map.size;
    }
}
function peerMap() {
    return new PeerMap();
}

},{"@libp2p/peer-id":"8wBUr","./util.js":"8u1Lg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8wBUr":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * An implementation of a peer id
 *
 * @example
 *
 * ```TypeScript
 * import { peerIdFromString } from '@libp2p/peer-id'
 * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')
 *
 * console.log(peer.toCid()) // CID(bafzaa...)
 * console.log(peer.toString()) // "12D3K..."
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPeerId", ()=>createPeerId);
parcelHelpers.export(exports, "peerIdFromPeerId", ()=>peerIdFromPeerId);
parcelHelpers.export(exports, "peerIdFromString", ()=>peerIdFromString);
parcelHelpers.export(exports, "peerIdFromBytes", ()=>peerIdFromBytes);
parcelHelpers.export(exports, "peerIdFromCID", ()=>peerIdFromCID);
/**
 * @param publicKey - A marshalled public key
 * @param privateKey - A marshalled private key
 */ parcelHelpers.export(exports, "peerIdFromKeys", ()=>peerIdFromKeys);
var _interface = require("@libp2p/interface");
var _base58 = require("multiformats/bases/base58");
var _basics = require("multiformats/basics");
var _cid = require("multiformats/cid");
var _digest = require("multiformats/hashes/digest");
var _identity = require("multiformats/hashes/identity");
var _sha2 = require("multiformats/hashes/sha2");
var _equals = require("uint8arrays/equals");
const inspect = Symbol.for("nodejs.util.inspect.custom");
const baseDecoder = Object.values((0, _basics.bases)).map((codec)=>codec.decoder)// @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141
.reduce((acc, curr)=>acc.or(curr), (0, _basics.bases).identity.decoder);
// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv
const LIBP2P_KEY_CODE = 0x72;
const MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
const MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
class PeerIdImpl {
    type;
    multihash;
    privateKey;
    publicKey;
    string;
    constructor(init){
        this.type = init.type;
        this.multihash = init.multihash;
        this.privateKey = init.privateKey;
        // mark string cache as non-enumerable
        Object.defineProperty(this, "string", {
            enumerable: false,
            writable: true
        });
    }
    get [Symbol.toStringTag]() {
        return `PeerId(${this.toString()})`;
    }
    [(0, _interface.peerIdSymbol)] = true;
    toString() {
        if (this.string == null) this.string = (0, _base58.base58btc).encode(this.multihash.bytes).slice(1);
        return this.string;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
        return (0, _cid.CID).createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toBytes() {
        return this.multihash.bytes;
    }
    /**
     * Returns Multiaddr as a JSON string
     */ toJSON() {
        return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */ equals(id) {
        if (id == null) return false;
        if (id instanceof Uint8Array) return (0, _equals.equals)(this.multihash.bytes, id);
        else if (typeof id === "string") return peerIdFromString(id).equals(this);
        else if (id?.multihash?.bytes != null) return (0, _equals.equals)(this.multihash.bytes, id.multihash.bytes);
        else throw new Error("not valid Id");
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */ [inspect]() {
        return `PeerId(${this.toString()})`;
    }
}
class RSAPeerIdImpl extends PeerIdImpl {
    type = "RSA";
    publicKey;
    constructor(init){
        super({
            ...init,
            type: "RSA"
        });
        this.publicKey = init.publicKey;
    }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
    type = "Ed25519";
    publicKey;
    constructor(init){
        super({
            ...init,
            type: "Ed25519"
        });
        this.publicKey = init.multihash.digest;
    }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
    type = "secp256k1";
    publicKey;
    constructor(init){
        super({
            ...init,
            type: "secp256k1"
        });
        this.publicKey = init.multihash.digest;
    }
}
function createPeerId(init) {
    if (init.type === "RSA") return new RSAPeerIdImpl(init);
    if (init.type === "Ed25519") return new Ed25519PeerIdImpl(init);
    if (init.type === "secp256k1") return new Secp256k1PeerIdImpl(init);
    throw new (0, _interface.CodeError)('Type must be "RSA", "Ed25519" or "secp256k1"', "ERR_INVALID_PARAMETERS");
}
function peerIdFromPeerId(other) {
    if (other.type === "RSA") return new RSAPeerIdImpl(other);
    if (other.type === "Ed25519") return new Ed25519PeerIdImpl(other);
    if (other.type === "secp256k1") return new Secp256k1PeerIdImpl(other);
    throw new (0, _interface.CodeError)("Not a PeerId", "ERR_INVALID_PARAMETERS");
}
function peerIdFromString(str, decoder) {
    decoder = decoder ?? baseDecoder;
    if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
        // identity hash ed25519/secp256k1 key or sha2-256 hash of
        // rsa public key - base58btc encoded either way
        const multihash = _digest.decode((0, _base58.base58btc).decode(`z${str}`));
        if (str.startsWith("12D")) return new Ed25519PeerIdImpl({
            multihash
        });
        else if (str.startsWith("16U")) return new Secp256k1PeerIdImpl({
            multihash
        });
        else return new RSAPeerIdImpl({
            multihash
        });
    }
    return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf) {
    try {
        const multihash = _digest.decode(buf);
        if (multihash.code === (0, _identity.identity).code) {
            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) return new Ed25519PeerIdImpl({
                multihash
            });
            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) return new Secp256k1PeerIdImpl({
                multihash
            });
        }
        if (multihash.code === (0, _sha2.sha256).code) return new RSAPeerIdImpl({
            multihash
        });
    } catch  {
        return peerIdFromCID((0, _cid.CID).decode(buf));
    }
    throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
    if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) throw new Error("Supplied PeerID CID is invalid");
    const multihash = cid.multihash;
    if (multihash.code === (0, _sha2.sha256).code) return new RSAPeerIdImpl({
        multihash: cid.multihash
    });
    else if (multihash.code === (0, _identity.identity).code) {
        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) return new Ed25519PeerIdImpl({
            multihash: cid.multihash
        });
        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) return new Secp256k1PeerIdImpl({
            multihash: cid.multihash
        });
    }
    throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) return new Ed25519PeerIdImpl({
        multihash: _digest.create((0, _identity.identity).code, publicKey),
        privateKey
    });
    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) return new Secp256k1PeerIdImpl({
        multihash: _digest.create((0, _identity.identity).code, publicKey),
        privateKey
    });
    return new RSAPeerIdImpl({
        multihash: await (0, _sha2.sha256).digest(publicKey),
        publicKey,
        privateKey
    });
}

},{"@libp2p/interface":"b14bx","multiformats/bases/base58":"9K4Ju","multiformats/basics":"W6yRG","multiformats/cid":"1oUcK","multiformats/hashes/digest":"cZirI","multiformats/hashes/identity":"fYS82","multiformats/hashes/sha2":"9qYCS","uint8arrays/equals":"CKVqX","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8u1Lg":[function(require,module,exports) {
/**
 * Calls the passed map function on every entry of the passed iterable iterator
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIterable", ()=>mapIterable);
function mapIterable(iter, map) {
    const iterator = {
        [Symbol.iterator]: ()=>{
            return iterator;
        },
        next: ()=>{
            const next = iter.next();
            const val = next.value;
            if (next.done === true || val == null) {
                const result = {
                    done: true,
                    value: undefined
                };
                return result;
            }
            return {
                done: false,
                value: map(val)
            };
        }
    };
    return iterator;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"695Rh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * We can't use PeerIds as set entries because set entries are
 * compared using same-value-zero equality, so this is just
 * a map that stringifies the PeerIds before storing them.
 *
 * PeerIds cache stringified versions of themselves so this
 * should be a cheap operation.
 *
 * @example
 *
 * ```TypeScript
 * import { peerSet } from '@libp2p/peer-collections'
 *
 * const set = peerSet()
 * set.add(peerId)
 * ```
 */ parcelHelpers.export(exports, "PeerSet", ()=>PeerSet);
parcelHelpers.export(exports, "peerSet", ()=>peerSet);
var _peerId = require("@libp2p/peer-id");
var _utilJs = require("./util.js");
class PeerSet {
    set;
    constructor(set){
        this.set = new Set();
        if (set != null) for (const key of set)this.set.add(key.toString());
    }
    get size() {
        return this.set.size;
    }
    [Symbol.iterator]() {
        return this.values();
    }
    add(peer) {
        this.set.add(peer.toString());
    }
    clear() {
        this.set.clear();
    }
    delete(peer) {
        this.set.delete(peer.toString());
    }
    entries() {
        return (0, _utilJs.mapIterable)(this.set.entries(), (val)=>{
            const peerId = (0, _peerId.peerIdFromString)(val[0]);
            return [
                peerId,
                peerId
            ];
        });
    }
    forEach(predicate) {
        this.set.forEach((str)=>{
            const id = (0, _peerId.peerIdFromString)(str);
            predicate(id, id, this);
        });
    }
    has(peer) {
        return this.set.has(peer.toString());
    }
    values() {
        return (0, _utilJs.mapIterable)(this.set.values(), (val)=>{
            return (0, _peerId.peerIdFromString)(val);
        });
    }
    intersection(other) {
        const output = new PeerSet();
        for (const peerId of other)if (this.has(peerId)) output.add(peerId);
        return output;
    }
    difference(other) {
        const output = new PeerSet();
        for (const peerId of this)if (!other.has(peerId)) output.add(peerId);
        return output;
    }
    union(other) {
        const output = new PeerSet();
        for (const peerId of other)output.add(peerId);
        for (const peerId of this)output.add(peerId);
        return output;
    }
}
function peerSet() {
    return new PeerSet();
}

},{"@libp2p/peer-id":"8wBUr","./util.js":"8u1Lg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7WdjB":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Generate, import, and export PeerIDs.
 *
 * A Peer ID is the SHA-256 [multihash](https://github.com/multiformats/multihash) of a public key.
 *
 * The public key is a base64 encoded string of a protobuf containing an RSA DER buffer. This uses a node buffer to pass the base64 encoded public key protobuf to the multihash for ID generation.
 *
 * @example
 *
 * ```TypeScript
 * import { createEd25519PeerId } from '@libp2p/peer-id-factory'
 *
 * const peerId = await createEd25519PeerId()
 * console.log(id.toString())
 * ```
 *
 * ```bash
 * 12D3KooWRm8J3iL796zPFi2EtGGtUJn58AG67gcqzMFHZnnsTzqD
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createEd25519PeerId", ()=>createEd25519PeerId);
parcelHelpers.export(exports, "createSecp256k1PeerId", ()=>createSecp256k1PeerId);
parcelHelpers.export(exports, "createRSAPeerId", ()=>createRSAPeerId);
parcelHelpers.export(exports, "createFromPubKey", ()=>createFromPubKey);
parcelHelpers.export(exports, "createFromPrivKey", ()=>createFromPrivKey);
parcelHelpers.export(exports, "exportToProtobuf", ()=>exportToProtobuf);
parcelHelpers.export(exports, "createFromProtobuf", ()=>createFromProtobuf);
parcelHelpers.export(exports, "createFromJSON", ()=>createFromJSON);
var _keys = require("@libp2p/crypto/keys");
var _peerId = require("@libp2p/peer-id");
var _fromString = require("uint8arrays/from-string");
var _protoJs = require("./proto.js");
const createEd25519PeerId = async ()=>{
    const key = await (0, _keys.generateKeyPair)("Ed25519");
    const id = await createFromPrivKey(key);
    if (id.type === "Ed25519") return id;
    throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
const createSecp256k1PeerId = async ()=>{
    const key = await (0, _keys.generateKeyPair)("secp256k1");
    const id = await createFromPrivKey(key);
    if (id.type === "secp256k1") return id;
    throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
const createRSAPeerId = async (opts)=>{
    const key = await (0, _keys.generateKeyPair)("RSA", opts?.bits ?? 2048);
    const id = await createFromPrivKey(key);
    if (id.type === "RSA") return id;
    throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPubKey(publicKey) {
    return (0, _peerId.peerIdFromKeys)((0, _keys.marshalPublicKey)(publicKey));
}
async function createFromPrivKey(privateKey) {
    return (0, _peerId.peerIdFromKeys)((0, _keys.marshalPublicKey)(privateKey.public), (0, _keys.marshalPrivateKey)(privateKey));
}
function exportToProtobuf(peerId, excludePrivateKey) {
    return (0, _protoJs.PeerIdProto).encode({
        id: peerId.multihash.bytes,
        pubKey: peerId.publicKey,
        privKey: excludePrivateKey === true || peerId.privateKey == null ? undefined : peerId.privateKey
    });
}
async function createFromProtobuf(buf) {
    const { id, privKey, pubKey } = (0, _protoJs.PeerIdProto).decode(buf);
    return createFromParts(id ?? new Uint8Array(0), privKey, pubKey);
}
async function createFromJSON(obj) {
    return createFromParts((0, _fromString.fromString)(obj.id, "base58btc"), obj.privKey != null ? (0, _fromString.fromString)(obj.privKey, "base64pad") : undefined, obj.pubKey != null ? (0, _fromString.fromString)(obj.pubKey, "base64pad") : undefined);
}
async function createFromParts(multihash, privKey, pubKey) {
    if (privKey != null) {
        const key = await (0, _keys.unmarshalPrivateKey)(privKey);
        return createFromPrivKey(key);
    } else if (pubKey != null) {
        const key = (0, _keys.unmarshalPublicKey)(pubKey);
        return createFromPubKey(key);
    }
    return (0, _peerId.peerIdFromBytes)(multihash);
}

},{"@libp2p/crypto/keys":"LlEWq","@libp2p/peer-id":"8wBUr","uint8arrays/from-string":"3YvUV","./proto.js":"4jHxT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4jHxT":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PeerIdProto", ()=>PeerIdProto);
var _protonsRuntime = require("protons-runtime");
var PeerIdProto;
(function(PeerIdProto) {
    let _codec;
    PeerIdProto.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.id != null) {
                w.uint32(10);
                w.bytes(obj.id);
            }
            if (obj.pubKey != null) {
                w.uint32(18);
                w.bytes(obj.pubKey);
            }
            if (obj.privKey != null) {
                w.uint32(26);
                w.bytes(obj.privKey);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.id = reader.bytes();
                        break;
                    case 2:
                        obj.pubKey = reader.bytes();
                        break;
                    case 3:
                        obj.privKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    PeerIdProto.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, PeerIdProto.codec());
    };
    PeerIdProto.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, PeerIdProto.codec());
    };
})(PeerIdProto || (PeerIdProto = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3z6QI":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * The peer store is where libp2p stores data about the peers it has encountered on the network.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An implementation of PeerStore that stores data in a Datastore
 */ parcelHelpers.export(exports, "PersistentPeerStore", ()=>PersistentPeerStore);
var _peerRecord = require("@libp2p/peer-record");
var _itAll = require("it-all");
var _itAllDefault = parcelHelpers.interopDefault(_itAll);
var _storeJs = require("./store.js");
class PersistentPeerStore {
    store;
    events;
    peerId;
    log;
    constructor(components, init = {}){
        this.log = components.logger.forComponent("libp2p:peer-store");
        this.events = components.events;
        this.peerId = components.peerId;
        this.store = new (0, _storeJs.PersistentStore)(components, init);
    }
    async forEach(fn, query) {
        this.log.trace("forEach await read lock");
        const release = await this.store.lock.readLock();
        this.log.trace("forEach got read lock");
        try {
            for await (const peer of this.store.all(query))fn(peer);
        } finally{
            this.log.trace("forEach release read lock");
            release();
        }
    }
    async all(query) {
        this.log.trace("all await read lock");
        const release = await this.store.lock.readLock();
        this.log.trace("all got read lock");
        try {
            return await (0, _itAllDefault.default)(this.store.all(query));
        } finally{
            this.log.trace("all release read lock");
            release();
        }
    }
    async delete(peerId) {
        this.log.trace("delete await write lock");
        const release = await this.store.lock.writeLock();
        this.log.trace("delete got write lock");
        try {
            await this.store.delete(peerId);
        } finally{
            this.log.trace("delete release write lock");
            release();
        }
    }
    async has(peerId) {
        this.log.trace("has await read lock");
        const release = await this.store.lock.readLock();
        this.log.trace("has got read lock");
        try {
            return await this.store.has(peerId);
        } finally{
            this.log.trace("has release read lock");
            release();
        }
    }
    async get(peerId) {
        this.log.trace("get await read lock");
        const release = await this.store.lock.readLock();
        this.log.trace("get got read lock");
        try {
            return await this.store.load(peerId);
        } finally{
            this.log.trace("get release read lock");
            release();
        }
    }
    async save(id, data) {
        this.log.trace("save await write lock");
        const release = await this.store.lock.writeLock();
        this.log.trace("save got write lock");
        try {
            const result = await this.store.save(id, data);
            this.#emitIfUpdated(id, result);
            return result.peer;
        } finally{
            this.log.trace("save release write lock");
            release();
        }
    }
    async patch(id, data) {
        this.log.trace("patch await write lock");
        const release = await this.store.lock.writeLock();
        this.log.trace("patch got write lock");
        try {
            const result = await this.store.patch(id, data);
            this.#emitIfUpdated(id, result);
            return result.peer;
        } finally{
            this.log.trace("patch release write lock");
            release();
        }
    }
    async merge(id, data) {
        this.log.trace("merge await write lock");
        const release = await this.store.lock.writeLock();
        this.log.trace("merge got write lock");
        try {
            const result = await this.store.merge(id, data);
            this.#emitIfUpdated(id, result);
            return result.peer;
        } finally{
            this.log.trace("merge release write lock");
            release();
        }
    }
    async consumePeerRecord(buf, expectedPeer) {
        const envelope = await (0, _peerRecord.RecordEnvelope).openAndCertify(buf, (0, _peerRecord.PeerRecord).DOMAIN);
        if (expectedPeer?.equals(envelope.peerId) === false) {
            this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, envelope.peerId);
            return false;
        }
        const peerRecord = (0, _peerRecord.PeerRecord).createFromProtobuf(envelope.payload);
        let peer;
        try {
            peer = await this.get(envelope.peerId);
        } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") throw err;
        }
        // ensure seq is greater than, or equal to, the last received
        if (peer?.peerRecordEnvelope != null) {
            const storedEnvelope = await (0, _peerRecord.RecordEnvelope).createFromProtobuf(peer.peerRecordEnvelope);
            const storedRecord = (0, _peerRecord.PeerRecord).createFromProtobuf(storedEnvelope.payload);
            if (storedRecord.seqNumber >= peerRecord.seqNumber) {
                this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
                return false;
            }
        }
        await this.patch(peerRecord.peerId, {
            peerRecordEnvelope: buf,
            addresses: peerRecord.multiaddrs.map((multiaddr)=>({
                    isCertified: true,
                    multiaddr
                }))
        });
        return true;
    }
    #emitIfUpdated(id, result) {
        if (!result.updated) return;
        if (this.peerId.equals(id)) this.events.safeDispatchEvent("self:peer:update", {
            detail: result
        });
        else this.events.safeDispatchEvent("peer:update", {
            detail: result
        });
    }
}

},{"@libp2p/peer-record":"2OBzm","it-all":"a2ZbU","./store.js":"1DEqK","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2OBzm":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Libp2p nodes need to store data in a public location (e.g. a DHT), or rely on potentially untrustworthy intermediaries to relay information over its lifetime. Accordingly, libp2p nodes need to be able to verify that the data came from a specific peer and that it hasn't been tampered with.
 *
 * ## Envelope
 *
 * Libp2p provides an all-purpose data container called **envelope**. It was created to enable the distribution of verifiable records, which we can prove originated from the addressed peer itself. The envelope includes a signature of the data, so that its authenticity is verified.
 *
 * This envelope stores a marshaled record implementing the [interface-record](https://github.com/libp2p/js-libp2p/blob/main/packages/interface/src/record/index.ts). These Records are designed to be serialized to bytes and placed inside of the envelopes before being shared with other peers.
 *
 * You can read further about the envelope in [libp2p/specs#217](https://github.com/libp2p/specs/pull/217).
 *
 * @example Creating a peer record
 *
 * Create an envelope with an instance of an [interface-record](https://github.com/libp2p/js-libp2p/blob/main/packages/interface/src/record/index.ts) implementation and prepare it for being exchanged:
 *
 * ```js
 * // interface-record implementation example with the "libp2p-example" namespace
 * import { PeerRecord } from '@libp2p/peer-record'
 * import { fromString } from 'uint8arrays/from-string'
 *
 * class ExampleRecord extends PeerRecord {
 *   constructor () {
 *     super ('libp2p-example', fromString('0302', 'hex'))
 *   }
 *
 *   marshal () {}
 *
 *   equals (other) {}
 * }
 *
 * ExampleRecord.createFromProtobuf = () => {}
 * ```
 *
 * ```js
 * import { PeerEnvelope } from '@libp2p/peer-record'
 * import { ExampleRecord } from './example-record.js'
 *
 * const rec = new ExampleRecord()
 * const e = await PeerEnvelope.seal(rec, peerId)
 * const wireData = e.marshal()
 * ```
 *
 * @example Consuming a peer record
 *
 * Consume a received envelope (`wireData`) and transform it back to a record:
 *
 * ```js
 * import { PeerEnvelope } from '@libp2p/peer-record'
 * import { ExampleRecord } from './example-record.js'
 *
 * const domain = 'libp2p-example'
 * let e
 *
 * try {
 *   e = await PeerEnvelope.openAndCertify(wireData, domain)
 * } catch (err) {}
 *
 * const rec = ExampleRecord.createFromProtobuf(e.payload)
 * ```
 *
 * ## Peer Record
 *
 * All libp2p nodes keep a `PeerStore`, that among other information stores a set of known addresses for each peer, which can come from a variety of sources.
 *
 * Libp2p peer records were created to enable the distribution of verifiable address records, which we can prove originated from the addressed peer itself. With such guarantees, libp2p is able to prioritize addresses based on their authenticity, with the most strict strategy being to only dial certified addresses (no strategies have been implemented at the time of writing).
 *
 * A peer record contains the peers' publicly reachable listen addresses, and may be extended in the future to contain additional metadata relevant to routing. It also contains a `seqNumber` field, a timestamp per the spec, so that we can verify the most recent record.
 *
 * You can read further about the Peer Record in [libp2p/specs#217](https://github.com/libp2p/specs/pull/217).
 *
 * @example
 *
 * Create a new Peer Record
 *
 * ```js
 * import { PeerRecord } from '@libp2p/peer-record'
 *
 * const pr = new PeerRecord({
 *   peerId: node.peerId,
 *   multiaddrs: node.multiaddrs
 * })
 * ```
 *
 * @example
 *
 * Create a Peer Record from a protobuf
 *
 * ```js
 * import { PeerRecord } from '@libp2p/peer-record'
 *
 * const pr = PeerRecord.createFromProtobuf(data)
 * ```
 *
 * ## Libp2p Flows
 *
 * ### Self Record
 *
 * Once a libp2p node has started and is listening on a set of multiaddrs, its own peer record can be created.
 *
 * The identify service is responsible for creating the self record when the identify protocol kicks in for the first time. This record will be stored for future needs of the identify protocol when connecting with other peers.
 *
 * ### Self record Updates
 *
 * While creating peer records is fairly trivial, addresses are not static and might be modified at arbitrary times. This can happen via an Address Manager API, or even through AutoRelay/AutoNAT.
 *
 * When a libp2p node changes its listen addresses, the identify service will be informed. Once that happens, the identify service creates a new self record and stores it. With the new record, the identify push/delta protocol will be used to communicate this change to the connected peers.
 *
 * ### Subsystem receiving a record
 *
 * Considering that a node can discover other peers' addresses from a variety of sources, Libp2p Peerstore can differentiate the addresses that were obtained through a signed peer record.
 *
 * Once a record is received and its signature properly validated, its envelope is stored in the AddressBook in its byte representation. The `seqNumber` remains unmarshalled so that we can quickly compare it against incoming records to determine the most recent record.
 *
 * The AddressBook Addresses will be updated with the content of the envelope with a certified property. This allows other subsystems to identify the known certified addresses of a peer.
 *
 * ### Subsystem providing a record
 *
 * Libp2p subsystems that exchange other peers information will provide the envelope that they received by those peers. As a result, other peers can verify if the envelope was really created by the addressed peer.
 *
 * When a subsystem wants to provide a record, it will get it from the AddressBook, if it exists. Other subsystems are also able to provide the self record, since it is also stored in the AddressBook.
 *
 * ## Future Work
 *
 * - Persistence only considering certified addresses?
 * - Peers may not know their own addresses. It's often impossible to automatically infer one's own public address, and peers may need to rely on third party peers to inform them of their observed public addresses.
 * - A peer may inadvertently or maliciously sign an address that they do not control. In other words, a signature isn't a guarantee that a given address is valid.
 * - Some addresses may be ambiguous. For example, addresses on a private subnet are valid within that subnet but are useless on the public internet.
 * - Once all these pieces are in place, we will also need a way to prioritize addresses based on their authenticity, that is, the dialer can prioritize self-certified addresses over addresses from an unknown origin.
 * - Modular dialer? (taken from go PR notes)
 *     - With the modular dialer, users should easily be able to configure precedence. With dialer v1, anything we do to prioritise dials is gonna be spaghetti and adhoc. With the modular dialer, you’d be able to specify the order of dials when instantiating the pipeline.
 *     - Multiple parallel dials. We already have the issue where new addresses aren't added to existing dials.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecordEnvelope", ()=>(0, _indexJs.RecordEnvelope));
parcelHelpers.export(exports, "PeerRecord", ()=>(0, _indexJs1.PeerRecord));
var _indexJs = require("./envelope/index.js");
var _indexJs1 = require("./peer-record/index.js");

},{"./envelope/index.js":"demGq","./peer-record/index.js":"8YUg9","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"demGq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecordEnvelope", ()=>RecordEnvelope);
var _keys = require("@libp2p/crypto/keys");
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _uint8Varint = require("uint8-varint");
var _uint8Arraylist = require("uint8arraylist");
var _equals = require("uint8arrays/equals");
var _fromString = require("uint8arrays/from-string");
var _errorsJs = require("../errors.js");
var _envelopeJs = require("./envelope.js");
class RecordEnvelope {
    /**
     * Unmarshal a serialized Envelope protobuf message
     */ static createFromProtobuf = async (data)=>{
        const envelopeData = (0, _envelopeJs.Envelope).decode(data);
        const peerId = await (0, _peerId.peerIdFromKeys)(envelopeData.publicKey);
        return new RecordEnvelope({
            peerId,
            payloadType: envelopeData.payloadType,
            payload: envelopeData.payload,
            signature: envelopeData.signature
        });
    };
    /**
     * Seal marshals the given Record, places the marshaled bytes inside an Envelope
     * and signs it with the given peerId's private key
     */ static seal = async (record, peerId)=>{
        if (peerId.privateKey == null) throw new Error("Missing private key");
        const domain = record.domain;
        const payloadType = record.codec;
        const payload = record.marshal();
        const signData = formatSignaturePayload(domain, payloadType, payload);
        const key = await (0, _keys.unmarshalPrivateKey)(peerId.privateKey);
        const signature = await key.sign(signData.subarray());
        return new RecordEnvelope({
            peerId,
            payloadType,
            payload,
            signature
        });
    };
    /**
     * Open and certify a given marshalled envelope.
     * Data is unmarshalled and the signature validated for the given domain.
     */ static openAndCertify = async (data, domain)=>{
        const envelope = await RecordEnvelope.createFromProtobuf(data);
        const valid = await envelope.validate(domain);
        if (!valid) throw new (0, _interface.CodeError)("envelope signature is not valid for the given domain", (0, _errorsJs.codes).ERR_SIGNATURE_NOT_VALID);
        return envelope;
    };
    peerId;
    payloadType;
    payload;
    signature;
    marshaled;
    /**
     * The Envelope is responsible for keeping an arbitrary signed record
     * by a libp2p peer.
     */ constructor(init){
        const { peerId, payloadType, payload, signature } = init;
        this.peerId = peerId;
        this.payloadType = payloadType;
        this.payload = payload;
        this.signature = signature;
    }
    /**
     * Marshal the envelope content
     */ marshal() {
        if (this.peerId.publicKey == null) throw new Error("Missing public key");
        if (this.marshaled == null) this.marshaled = (0, _envelopeJs.Envelope).encode({
            publicKey: this.peerId.publicKey,
            payloadType: this.payloadType,
            payload: this.payload.subarray(),
            signature: this.signature
        });
        return this.marshaled;
    }
    /**
     * Verifies if the other Envelope is identical to this one
     */ equals(other) {
        return (0, _equals.equals)(this.marshal(), other.marshal());
    }
    /**
     * Validate envelope data signature for the given domain
     */ async validate(domain) {
        const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
        if (this.peerId.publicKey == null) throw new Error("Missing public key");
        const key = (0, _keys.unmarshalPublicKey)(this.peerId.publicKey);
        return key.verify(signData.subarray(), this.signature);
    }
}
/**
 * Helper function that prepares a Uint8Array to sign or verify a signature
 */ const formatSignaturePayload = (domain, payloadType, payload)=>{
    // When signing, a peer will prepare a Uint8Array by concatenating the following:
    // - The length of the domain separation string string in bytes
    // - The domain separation string, encoded as UTF-8
    // - The length of the payload_type field in bytes
    // - The value of the payload_type field
    // - The length of the payload field in bytes
    // - The value of the payload field
    const domainUint8Array = (0, _fromString.fromString)(domain);
    const domainLength = _uint8Varint.encode(domainUint8Array.byteLength);
    const payloadTypeLength = _uint8Varint.encode(payloadType.length);
    const payloadLength = _uint8Varint.encode(payload.length);
    return new (0, _uint8Arraylist.Uint8ArrayList)(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

},{"@libp2p/crypto/keys":"LlEWq","@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","uint8-varint":"3o84q","uint8arraylist":"1W1Ks","uint8arrays/equals":"CKVqX","uint8arrays/from-string":"3YvUV","../errors.js":"ljyOh","./envelope.js":"4TZHs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1W1Ks":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * A class that lets you do operations over a list of Uint8Arrays without
 * copying them.
 *
 * ```js
 * import { Uint8ArrayList } from 'uint8arraylist'
 *
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray()
 * // -> Uint8Array([0, 1, 2, 3, 4, 5])
 *
 * list.consume(3)
 * list.subarray()
 * // -> Uint8Array([3, 4, 5])
 *
 * // you can also iterate over the list
 * for (const buf of list) {
 *   // ..do something with `buf`
 * }
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ## Converting Uint8ArrayLists to Uint8Arrays
 *
 * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.
 *
 * ### slice
 *
 * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.slice(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ### subarray
 *
 * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0]) - no-copy
 *
 * list.subarray(2, 5)
 * // -> Uint8Array([2, 3, 4]) - copy
 * ```
 *
 * ### sublist
 *
 * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.sublist(0, 1)
 * // -> Uint8ArrayList([0]) - no-copy
 *
 * list.sublist(2, 5)
 * // -> Uint8ArrayList([2], [3, 4]) - no-copy
 * ```
 *
 * ## Inspiration
 *
 * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if object is a CID instance
 *
 * @example
 *
 * ```js
 * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'
 *
 * isUint8ArrayList(true) // false
 * isUint8ArrayList([]) // false
 * isUint8ArrayList(new Uint8ArrayList()) // true
 * ```
 */ parcelHelpers.export(exports, "isUint8ArrayList", ()=>isUint8ArrayList);
parcelHelpers.export(exports, "Uint8ArrayList", ()=>Uint8ArrayList) /*
function indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {
  for (let i = offset; i < haystack.byteLength; i++) {
    for (let j = 0; j < needle.length; j++) {
      if (haystack[i + j] !== needle[j]) {
        break
      }

      if (j === needle.byteLength -1) {
        return i
      }
    }

    if (haystack.byteLength - i < needle.byteLength) {
      break
    }
  }

  return -1
}
*/ ;
var _alloc = require("uint8arrays/alloc");
var _concat = require("uint8arrays/concat");
var _equals = require("uint8arrays/equals");
const symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) throw new RangeError("index is out of bounds");
    let offset = 0;
    for (const buf of bufs){
        const bufEnd = offset + buf.byteLength;
        if (index < bufEnd) return {
            buf,
            index: index - offset
        };
        offset = bufEnd;
    }
    throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
    return Boolean(value?.[symbol]);
}
class Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data){
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) this.appendAll(data);
    }
    *[Symbol.iterator]() {
        yield* this.bufs;
    }
    get byteLength() {
        return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */ append(...bufs) {
        this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */ appendAll(bufs) {
        let length = 0;
        for (const buf of bufs){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.push(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.push(...buf.bufs);
            } else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
        }
        this.length += length;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */ prepend(...bufs) {
        this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */ prependAll(bufs) {
        let length = 0;
        for (const buf of bufs.reverse()){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.unshift(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.unshift(...buf.bufs);
            } else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
        }
        this.length += length;
    }
    /**
     * Read the value at `index`
     */ get(index) {
        const res = findBufAndOffset(this.bufs, index);
        return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */ set(index, value) {
        const res = findBufAndOffset(this.bufs, index);
        res.buf[res.index] = value;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */ write(buf, offset = 0) {
        if (buf instanceof Uint8Array) for(let i = 0; i < buf.length; i++)this.set(offset + i, buf[i]);
        else if (isUint8ArrayList(buf)) for(let i = 0; i < buf.length; i++)this.set(offset + i, buf.get(i));
        else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
    /**
     * Remove bytes from the front of the pool
     */ consume(bytes) {
        // first, normalize the argument, in accordance with how Buffer does it
        bytes = Math.trunc(bytes);
        // do nothing if not a positive number
        if (Number.isNaN(bytes) || bytes <= 0) return;
        // if consuming all bytes, skip iterating
        if (bytes === this.byteLength) {
            this.bufs = [];
            this.length = 0;
            return;
        }
        while(this.bufs.length > 0)if (bytes >= this.bufs[0].byteLength) {
            bytes -= this.bufs[0].byteLength;
            this.length -= this.bufs[0].byteLength;
            this.bufs.shift();
        } else {
            this.bufs[0] = this.bufs[0].subarray(bytes);
            this.length -= bytes;
            break;
        }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */ slice(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        return (0, _concat.concat)(bufs, length);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */ subarray(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) return bufs[0];
        return (0, _concat.concat)(bufs, length);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */ sublist(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        const list = new Uint8ArrayList();
        list.length = length;
        // don't loop, just set the bufs
        list.bufs = [
            ...bufs
        ];
        return list;
    }
    _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) beginInclusive = this.length + beginInclusive;
        if (endExclusive < 0) endExclusive = this.length + endExclusive;
        if (beginInclusive < 0 || endExclusive > this.length) throw new RangeError("index is out of bounds");
        if (beginInclusive === endExclusive) return {
            bufs: [],
            length: 0
        };
        if (beginInclusive === 0 && endExclusive === this.length) return {
            bufs: this.bufs,
            length: this.length
        };
        const bufs = [];
        let offset = 0;
        for(let i = 0; i < this.bufs.length; i++){
            const buf = this.bufs[i];
            const bufStart = offset;
            const bufEnd = bufStart + buf.byteLength;
            // for next loop
            offset = bufEnd;
            if (beginInclusive >= bufEnd) continue;
            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
            if (sliceStartInBuf && sliceEndsInBuf) {
                // slice is wholly contained within this buffer
                if (beginInclusive === bufStart && endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                const start = beginInclusive - bufStart;
                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
                break;
            }
            if (sliceStartInBuf) {
                // slice starts in this buffer
                if (beginInclusive === 0) {
                    // requested whole buffer
                    bufs.push(buf);
                    continue;
                }
                // requested part of buffer
                bufs.push(buf.subarray(beginInclusive - bufStart));
                continue;
            }
            if (sliceEndsInBuf) {
                if (endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                bufs.push(buf.subarray(0, endExclusive - bufStart));
                break;
            }
            // slice started before this buffer and ends after it
            bufs.push(buf);
        }
        return {
            bufs,
            length: endExclusive - beginInclusive
        };
    }
    indexOf(search, offset = 0) {
        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
        const needle = search instanceof Uint8Array ? search : search.subarray();
        offset = Number(offset ?? 0);
        if (isNaN(offset)) offset = 0;
        if (offset < 0) offset = this.length + offset;
        if (offset < 0) offset = 0;
        if (search.length === 0) return offset > this.length ? this.length : offset;
        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm
        const M = needle.byteLength;
        if (M === 0) throw new TypeError("search must be at least 1 byte long");
        // radix
        const radix = 256;
        const rightmostPositions = new Int32Array(radix);
        // position of the rightmost occurrence of the byte c in the pattern
        for(let c = 0; c < radix; c++)// -1 for bytes not in pattern
        rightmostPositions[c] = -1;
        for(let j = 0; j < M; j++)// rightmost position for bytes in pattern
        rightmostPositions[needle[j]] = j;
        // Return offset of first match, -1 if no match
        const right = rightmostPositions;
        const lastIndex = this.byteLength - needle.byteLength;
        const lastPatIndex = needle.byteLength - 1;
        let skip;
        for(let i = offset; i <= lastIndex; i += skip){
            skip = 0;
            for(let j = lastPatIndex; j >= 0; j--){
                const char = this.get(i + j);
                if (needle[j] !== char) {
                    skip = Math.max(1, j - right[char]);
                    break;
                }
            }
            if (skip === 0) return i;
        }
        return -1;
    }
    getInt8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
        const buf = (0, _alloc.allocUnsafe)(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt8(0, value);
        this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigInt64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
        const buf = (0, _alloc.allocUnsafe)(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint8(0, value);
        this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigUint64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        const buf = (0, _alloc.alloc)(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    equals(other) {
        if (other == null) return false;
        if (!(other instanceof Uint8ArrayList)) return false;
        if (other.bufs.length !== this.bufs.length) return false;
        for(let i = 0; i < this.bufs.length; i++){
            if (!(0, _equals.equals)(this.bufs[i], other.bufs[i])) return false;
        }
        return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */ static fromUint8Arrays(bufs, length) {
        const list = new Uint8ArrayList();
        list.bufs = bufs;
        if (length == null) length = bufs.reduce((acc, curr)=>acc + curr.byteLength, 0);
        list.length = length;
        return list;
    }
}

},{"uint8arrays/alloc":"9stB1","uint8arrays/concat":"byG2b","uint8arrays/equals":"CKVqX","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ljyOh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "codes", ()=>codes);
const codes = {
    ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4TZHs":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Envelope", ()=>Envelope);
var _protonsRuntime = require("protons-runtime");
var Envelope;
(function(Envelope) {
    let _codec;
    Envelope.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.publicKey);
            }
            if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
                w.uint32(18);
                w.bytes(obj.payloadType);
            }
            if (obj.payload != null && obj.payload.byteLength > 0) {
                w.uint32(26);
                w.bytes(obj.payload);
            }
            if (obj.signature != null && obj.signature.byteLength > 0) {
                w.uint32(42);
                w.bytes(obj.signature);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                publicKey: new Uint8Array(0),
                payloadType: new Uint8Array(0),
                payload: new Uint8Array(0),
                signature: new Uint8Array(0)
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.publicKey = reader.bytes();
                        break;
                    case 2:
                        obj.payloadType = reader.bytes();
                        break;
                    case 3:
                        obj.payload = reader.bytes();
                        break;
                    case 5:
                        obj.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Envelope.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Envelope.codec());
    };
    Envelope.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Envelope.codec());
    };
})(Envelope || (Envelope = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8YUg9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The PeerRecord is used for distributing peer routing records across the network.
 * It contains the peer's reachable listen addresses.
 */ parcelHelpers.export(exports, "PeerRecord", ()=>PeerRecord);
var _peerId = require("@libp2p/peer-id");
var _arrayEquals = require("@libp2p/utils/array-equals");
var _multiaddr = require("@multiformats/multiaddr");
var _constsJs = require("./consts.js");
var _peerRecordJs = require("./peer-record.js");
class PeerRecord {
    /**
     * Unmarshal Peer Record Protobuf
     */ static createFromProtobuf = (buf)=>{
        const peerRecord = (0, _peerRecordJs.PeerRecord).decode(buf);
        const peerId = (0, _peerId.peerIdFromBytes)(peerRecord.peerId);
        const multiaddrs = (peerRecord.addresses ?? []).map((a)=>(0, _multiaddr.multiaddr)(a.multiaddr));
        const seqNumber = peerRecord.seq;
        return new PeerRecord({
            peerId,
            multiaddrs,
            seqNumber
        });
    };
    static DOMAIN = (0, _constsJs.ENVELOPE_DOMAIN_PEER_RECORD);
    static CODEC = (0, _constsJs.ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
    peerId;
    multiaddrs;
    seqNumber;
    domain = PeerRecord.DOMAIN;
    codec = PeerRecord.CODEC;
    marshaled;
    constructor(init){
        const { peerId, multiaddrs, seqNumber } = init;
        this.peerId = peerId;
        this.multiaddrs = multiaddrs ?? [];
        this.seqNumber = seqNumber ?? BigInt(Date.now());
    }
    /**
     * Marshal a record to be used in an envelope
     */ marshal() {
        if (this.marshaled == null) this.marshaled = (0, _peerRecordJs.PeerRecord).encode({
            peerId: this.peerId.toBytes(),
            seq: BigInt(this.seqNumber),
            addresses: this.multiaddrs.map((m)=>({
                    multiaddr: m.bytes
                }))
        });
        return this.marshaled;
    }
    /**
     * Returns true if `this` record equals the `other`
     */ equals(other) {
        if (!(other instanceof PeerRecord)) return false;
        // Validate PeerId
        if (!this.peerId.equals(other.peerId)) return false;
        // Validate seqNumber
        if (this.seqNumber !== other.seqNumber) return false;
        // Validate multiaddrs
        if (!(0, _arrayEquals.arrayEquals)(this.multiaddrs, other.multiaddrs)) return false;
        return true;
    }
}

},{"@libp2p/peer-id":"8wBUr","@libp2p/utils/array-equals":"fY5Rc","@multiformats/multiaddr":"7Qpz2","./consts.js":"cVewE","./peer-record.js":"hd093","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fY5Rc":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Provides strategies ensure arrays are equivalent.
 *
 * @example
 *
 * ```typescript
 * import { arrayEquals } from '@libp2p/utils/array-equals'
 * import { multiaddr } from '@multformats/multiaddr'
 *
 * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),
 * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')
 *
 * console.info(arrayEquals([ma1], [ma1])) // true
 * console.info(arrayEquals([ma1], [ma2])) // false
 * ```
 */ /**
 * Verify if two arrays of non primitive types with the "equals" function are equal.
 * Compatible with multiaddr, peer-id and others.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayEquals", ()=>arrayEquals);
function arrayEquals(a, b) {
    const sort = (a, b)=>a.toString().localeCompare(b.toString());
    if (a.length !== b.length) return false;
    b.sort(sort);
    return a.sort(sort).every((item, index)=>b[index].equals(item));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7Qpz2":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * A standard way to represent addresses that
 *
 * - support any standard network protocol
 * - are self-describing
 * - have a binary packed format
 * - have a nice string representation
 * - encapsulate well
 *
 * @example
 *
 * ```js
 * import { multiaddr } from '@multiformats/multiaddr'
 * const addr =  multiaddr("/ip4/127.0.0.1/udp/1234")
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * const addr = multiaddr("/ip4/127.0.0.1/udp/1234")
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * addr.bytes
 * // <Uint8Array 04 7f 00 00 01 11 04 d2>
 *
 * addr.toString()
 * // '/ip4/127.0.0.1/udp/1234'
 *
 * addr.protos()
 * // [
 * //   {code: 4, name: 'ip4', size: 32},
 * //   {code: 273, name: 'udp', size: 16}
 * // ]
 *
 * // gives you an object that is friendly with what Node.js core modules expect for addresses
 * addr.nodeAddress()
 * // {
 * //   family: 4,
 * //   port: 1234,
 * //   address: "127.0.0.1"
 * // }
 *
 * addr.encapsulate('/sctp/5678')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)
 * ```
 *
 * ## Resolvers
 *
 * `multiaddr` allows multiaddrs to be resolved when appropriate resolvers are provided. This module already has resolvers available, but you can also create your own.  Resolvers should always be set in the same module that is calling `multiaddr.resolve()` to avoid conflicts if multiple versions of `multiaddr` are in your dependency tree.
 *
 * To provide multiaddr resolvers you can do:
 *
 * ```js
 * import { resolvers  } from '@multiformats/multiaddr'
 *
 * resolvers.set('dnsaddr', resolvers.dnsaddrResolver)
 * ```
 *
 * The available resolvers are:
 *
 * | Name              | type      | Description                         |
 * | ----------------- | --------- | ----------------------------------- |
 * | `dnsaddrResolver` | `dnsaddr` | dnsaddr resolution with TXT Records |
 *
 * A resolver receives a `Multiaddr` as a parameter and returns a `Promise<Array<string>>`.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MultiaddrFilter", ()=>(0, _multiaddrFilterJs.MultiaddrFilter));
parcelHelpers.export(exports, "resolvers", ()=>resolvers);
/**
 * Creates a Multiaddr from a node-friendly address object
 *
 * @example
 * ```js
 * import { fromNodeAddress } from '@multiformats/multiaddr'
 *
 * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
 * // Multiaddr(/ip4/127.0.0.1/tcp/4001)
 * ```
 */ parcelHelpers.export(exports, "fromNodeAddress", ()=>fromNodeAddress);
/**
 * Returns if something is a {@link Multiaddr} that is a resolvable name
 *
 * @example
 *
 * ```js
 * import { isName, multiaddr } from '@multiformats/multiaddr'
 *
 * isName(multiaddr('/ip4/127.0.0.1'))
 * // false
 * isName(multiaddr('/dns/ipfs.io'))
 * // true
 * ```
 */ parcelHelpers.export(exports, "isName", ()=>isName);
/**
 * Check if object is a {@link Multiaddr} instance
 *
 * @example
 *
 * ```js
 * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'
 *
 * isMultiaddr(5)
 * // false
 * isMultiaddr(multiaddr('/ip4/127.0.0.1'))
 * // true
 * ```
 */ parcelHelpers.export(exports, "isMultiaddr", ()=>isMultiaddr);
/**
 * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}
 *
 * @example
 * ```js
 * import { multiaddr } from '@libp2p/multiaddr'
 *
 * multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // Multiaddr(/ip4/127.0.0.1/tcp/4001)
 * ```
 *
 * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
 */ parcelHelpers.export(exports, "multiaddr", ()=>multiaddr);
parcelHelpers.export(exports, "protocols", ()=>(0, _protocolsTableJs.getProtocol));
var _multiaddrJs = require("./multiaddr.js");
var _protocolsTableJs = require("./protocols-table.js");
var _multiaddrFilterJs = require("./filter/multiaddr-filter.js");
const resolvers = new Map();
function fromNodeAddress(addr, transport) {
    if (addr == null) throw new Error("requires node address object");
    if (transport == null) throw new Error("requires transport protocol");
    let ip;
    let host = addr.address;
    switch(addr.family){
        case 4:
            ip = "ip4";
            break;
        case 6:
            ip = "ip6";
            if (host.includes("%")) {
                const parts = host.split("%");
                if (parts.length !== 2) throw Error("Multiple ip6 zones in multiaddr");
                host = parts[0];
                const zone = parts[1];
                ip = `/ip6zone/${zone}/ip6`;
            }
            break;
        default:
            throw Error("Invalid addr family, should be 4 or 6.");
    }
    return new (0, _multiaddrJs.Multiaddr)("/" + [
        ip,
        host,
        transport,
        addr.port
    ].join("/"));
}
function isName(addr) {
    if (!isMultiaddr(addr)) return false;
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto)=>proto.resolvable);
}
function isMultiaddr(value) {
    return Boolean(value?.[0, _multiaddrJs.symbol]);
}
function multiaddr(addr) {
    return new (0, _multiaddrJs.Multiaddr)(addr);
}

},{"./multiaddr.js":"8Sehq","./protocols-table.js":"fBqZI","./filter/multiaddr-filter.js":"aAJvm","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8Sehq":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * An implementation of a Multiaddr in JavaScript
 *
 * @example
 *
 * ```js
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "symbol", ()=>symbol);
/**
 * Creates a {@link Multiaddr} from a {@link MultiaddrInput}
 */ parcelHelpers.export(exports, "Multiaddr", ()=>Multiaddr);
var _interface = require("@libp2p/interface");
var _base58 = require("multiformats/bases/base58");
var _cid = require("multiformats/cid");
var _equals = require("uint8arrays/equals");
var _toString = require("uint8arrays/to-string");
var _codecJs = require("./codec.js");
var _protocolsTableJs = require("./protocols-table.js");
var _indexJs = require("./index.js");
const inspect = Symbol.for("nodejs.util.inspect.custom");
const symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
const DNS_CODES = [
    (0, _protocolsTableJs.getProtocol)("dns").code,
    (0, _protocolsTableJs.getProtocol)("dns4").code,
    (0, _protocolsTableJs.getProtocol)("dns6").code,
    (0, _protocolsTableJs.getProtocol)("dnsaddr").code
];
class Multiaddr {
    bytes;
    #string;
    #tuples;
    #stringTuples;
    #path;
    [symbol] = true;
    constructor(addr){
        // default
        if (addr == null) addr = "";
        let parts;
        if (addr instanceof Uint8Array) parts = (0, _codecJs.bytesToMultiaddrParts)(addr);
        else if (typeof addr === "string") {
            if (addr.length > 0 && addr.charAt(0) !== "/") throw new Error(`multiaddr "${addr}" must start with a "/"`);
            parts = (0, _codecJs.stringToMultiaddrParts)(addr);
        } else if ((0, _indexJs.isMultiaddr)(addr)) parts = (0, _codecJs.bytesToMultiaddrParts)(addr.bytes);
        else throw new Error("addr must be a string, Buffer, or another Multiaddr");
        this.bytes = parts.bytes;
        this.#string = parts.string;
        this.#tuples = parts.tuples;
        this.#stringTuples = parts.stringTuples;
        this.#path = parts.path;
    }
    toString() {
        return this.#string;
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        let family;
        let transport;
        let host;
        let port;
        let zone = "";
        const tcp = (0, _protocolsTableJs.getProtocol)("tcp");
        const udp = (0, _protocolsTableJs.getProtocol)("udp");
        const ip4 = (0, _protocolsTableJs.getProtocol)("ip4");
        const ip6 = (0, _protocolsTableJs.getProtocol)("ip6");
        const dns6 = (0, _protocolsTableJs.getProtocol)("dns6");
        const ip6zone = (0, _protocolsTableJs.getProtocol)("ip6zone");
        for (const [code, value] of this.stringTuples()){
            if (code === ip6zone.code) zone = `%${value ?? ""}`;
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(code)) {
                transport = tcp.name;
                port = 443;
                host = `${value ?? ""}${zone}`;
                family = code === dns6.code ? 6 : 4;
            }
            if (code === tcp.code || code === udp.code) {
                transport = (0, _protocolsTableJs.getProtocol)(code).name;
                port = parseInt(value ?? "");
            }
            if (code === ip4.code || code === ip6.code) {
                transport = (0, _protocolsTableJs.getProtocol)(code).name;
                host = `${value ?? ""}${zone}`;
                family = code === ip6.code ? 6 : 4;
            }
        }
        if (family == null || transport == null || host == null || port == null) throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        const opts = {
            family,
            host,
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.#tuples.map(([code])=>Object.assign({}, (0, _protocolsTableJs.getProtocol)(code)));
    }
    protoCodes() {
        return this.#tuples.map(([code])=>code);
    }
    protoNames() {
        return this.#tuples.map(([code])=>(0, _protocolsTableJs.getProtocol)(code).name);
    }
    tuples() {
        return this.#tuples;
    }
    stringTuples() {
        return this.#stringTuples;
    }
    encapsulate(addr) {
        addr = new Multiaddr(addr);
        return new Multiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        return new Multiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for(let i = tuples.length - 1; i >= 0; i--){
            if (tuples[i][0] === code) return new Multiaddr((0, _codecJs.tuplesToBytes)(tuples.slice(0, i)));
        }
        return this;
    }
    getPeerId() {
        try {
            let tuples = [];
            this.stringTuples().forEach(([code, name])=>{
                if (code === (0, _protocolsTableJs.names).p2p.code) tuples.push([
                    code,
                    name
                ]);
                // if this is a p2p-circuit address, return the target peer id if present
                // not the peer id of the relay
                if (code === (0, _protocolsTableJs.names)["p2p-circuit"].code) tuples = [];
            });
            // Get the last ipfs tuple ['p2p', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") return (0, _toString.toString)((0, _base58.base58btc).decode(`z${peerIdStr}`), "base58btc");
                // try to parse peer id as CID
                return (0, _toString.toString)((0, _cid.CID).parse(peerIdStr).multihash.bytes, "base58btc");
            }
            return null;
        } catch (e) {
            return null;
        }
    }
    getPath() {
        return this.#path;
    }
    equals(addr) {
        return (0, _equals.equals)(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p)=>p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) return [
            this
        ];
        const resolver = (0, _indexJs.resolvers).get(resolvableProto.name);
        if (resolver == null) throw new (0, _interface.CodeError)(`no available resolver for ${resolvableProto.name}`, "ERR_NO_AVAILABLE_RESOLVER");
        const addresses = await resolver(this, options);
        return addresses.map((a)=>new Multiaddr(a));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== "tcp" && options.transport !== "udp") throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) return false;
        if (protos[0].code !== 4 && protos[0].code !== 41) return false;
        if (protos[1].code !== 6 && protos[1].code !== 273) return false;
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */ [inspect]() {
        return `Multiaddr(${this.#string})`;
    }
}

},{"@libp2p/interface":"b14bx","multiformats/bases/base58":"9K4Ju","multiformats/cid":"1oUcK","uint8arrays/equals":"CKVqX","uint8arrays/to-string":"63irA","./codec.js":"8r9NY","./protocols-table.js":"fBqZI","./index.js":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8r9NY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringToMultiaddrParts", ()=>stringToMultiaddrParts);
parcelHelpers.export(exports, "bytesToMultiaddrParts", ()=>bytesToMultiaddrParts);
/**
 * [[int code, Uint8Array ]... ] -> Uint8Array
 */ parcelHelpers.export(exports, "tuplesToBytes", ()=>tuplesToBytes);
parcelHelpers.export(exports, "bytesToTuples", ()=>bytesToTuples);
parcelHelpers.export(exports, "cleanPath", ()=>cleanPath);
parcelHelpers.export(exports, "ParseError", ()=>ParseError);
var _uint8Varint = require("uint8-varint");
var _concat = require("uint8arrays/concat");
var _toString = require("uint8arrays/to-string");
var _convertJs = require("./convert.js");
var _protocolsTableJs = require("./protocols-table.js");
function stringToMultiaddrParts(str) {
    str = cleanPath(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split("/").slice(1);
    if (parts.length === 1 && parts[0] === "") return {
        bytes: new Uint8Array(),
        string: "/",
        tuples: [],
        stringTuples: [],
        path: null
    };
    for(let p = 0; p < parts.length; p++){
        const part = parts[p];
        const proto = (0, _protocolsTableJs.getProtocol)(part);
        if (proto.size === 0) {
            tuples.push([
                proto.code
            ]);
            stringTuples.push([
                proto.code
            ]);
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) throw ParseError("invalid address: " + str);
        // if it's a path proto, take the rest
        if (proto.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = cleanPath(parts.slice(p).join("/"));
            tuples.push([
                proto.code,
                (0, _convertJs.convertToBytes)(proto.code, path)
            ]);
            stringTuples.push([
                proto.code,
                path
            ]);
            break;
        }
        const bytes = (0, _convertJs.convertToBytes)(proto.code, parts[p]);
        tuples.push([
            proto.code,
            bytes
        ]);
        stringTuples.push([
            proto.code,
            (0, _convertJs.convertToString)(proto.code, bytes)
        ]);
    }
    return {
        string: stringTuplesToString(stringTuples),
        bytes: tuplesToBytes(tuples),
        tuples,
        stringTuples,
        path
    };
}
function bytesToMultiaddrParts(bytes) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while(i < bytes.length){
        const code = _uint8Varint.decode(bytes, i);
        const n = _uint8Varint.encodingLength(code);
        const p = (0, _protocolsTableJs.getProtocol)(code);
        const size = sizeForAddr(p, bytes.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            stringTuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = bytes.slice(i + n, i + n + size);
        i += size + n;
        if (i > bytes.length) throw ParseError("Invalid address Uint8Array: " + (0, _toString.toString)(bytes, "base16"));
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
        const stringAddr = (0, _convertJs.convertToString)(code, addr);
        stringTuples.push([
            code,
            stringAddr
        ]);
        if (p.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = stringAddr;
            break;
        }
    }
    return {
        bytes: Uint8Array.from(bytes),
        string: stringTuplesToString(stringTuples),
        tuples,
        stringTuples,
        path
    };
}
/**
 * [[str name, str addr]... ] -> string
 */ function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup)=>{
        const proto = (0, _protocolsTableJs.getProtocol)(tup[0]);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) parts.push(tup[1]);
        return null;
    });
    return cleanPath(parts.join("/"));
}
function tuplesToBytes(tuples) {
    return (0, _concat.concat)(tuples.map((tup)=>{
        const proto = (0, _protocolsTableJs.getProtocol)(tup[0]);
        let buf = Uint8Array.from(_uint8Varint.encode(proto.code));
        if (tup.length > 1 && tup[1] != null) buf = (0, _concat.concat)([
            buf,
            tup[1]
        ]); // add address buffer
        return buf;
    }));
}
/**
 * For the passed address, return the serialized size
 */ function sizeForAddr(p, addr) {
    if (p.size > 0) return p.size / 8;
    else if (p.size === 0) return 0;
    else {
        const size = _uint8Varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
        return size + _uint8Varint.encodingLength(size);
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while(i < buf.length){
        const code = _uint8Varint.decode(buf, i);
        const n = _uint8Varint.encodingLength(code);
        const p = (0, _protocolsTableJs.getProtocol)(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf.length) throw ParseError("Invalid address Uint8Array: " + (0, _toString.toString)(buf, "base16"));
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
    }
    return tuples;
}
function cleanPath(str) {
    return "/" + str.trim().split("/").filter((a)=>a).join("/");
}
function ParseError(str) {
    return new Error("Error parsing address: " + str);
}

},{"uint8-varint":"3o84q","uint8arrays/concat":"byG2b","uint8arrays/to-string":"63irA","./convert.js":"e5ODO","./protocols-table.js":"fBqZI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"e5ODO":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Provides methods for converting
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convert", ()=>convert);
/**
 * Convert [code,Uint8Array] to string
 */ parcelHelpers.export(exports, "convertToString", ()=>convertToString);
parcelHelpers.export(exports, "convertToBytes", ()=>convertToBytes);
parcelHelpers.export(exports, "convertToIpNet", ()=>convertToIpNet);
var _netmask = require("@chainsafe/netmask");
var _base32 = require("multiformats/bases/base32");
var _base58 = require("multiformats/bases/base58");
var _basics = require("multiformats/basics");
var _cid = require("multiformats/cid");
var _digest = require("multiformats/hashes/digest");
var _uint8Varint = require("uint8-varint");
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
var _toString = require("uint8arrays/to-string");
var _ipJs = require("./ip.js");
var _protocolsTableJs = require("./protocols-table.js");
const ip4Protocol = (0, _protocolsTableJs.getProtocol)("ip4");
const ip6Protocol = (0, _protocolsTableJs.getProtocol)("ip6");
const ipcidrProtocol = (0, _protocolsTableJs.getProtocol)("ipcidr");
function convert(proto, a) {
    if (a instanceof Uint8Array) return convertToString(proto, a);
    else return convertToBytes(proto, a);
}
function convertToString(proto, buf) {
    const protocol = (0, _protocolsTableJs.getProtocol)(proto);
    switch(protocol.code){
        case 4:
        case 41:
            return bytes2ip(buf);
        case 42:
            return bytes2str(buf);
        case 6:
        case 273:
        case 33:
        case 132:
            return bytes2port(buf).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return bytes2str(buf);
        case 421:
            return bytes2mh(buf);
        case 444:
            return bytes2onion(buf);
        case 445:
            return bytes2onion(buf);
        case 466:
            return bytes2mb(buf);
        default:
            return (0, _toString.toString)(buf, "base16"); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0, _protocolsTableJs.getProtocol)(proto);
    switch(protocol.code){
        case 4:
            return ip2bytes(str);
        case 41:
            return ip2bytes(str);
        case 42:
            return str2bytes(str);
        case 6:
        case 273:
        case 33:
        case 132:
            return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return str2bytes(str);
        case 421:
            return mh2bytes(str);
        case 444:
            return onion2bytes(str);
        case 445:
            return onion32bytes(str);
        case 466:
            return mb2bytes(str);
        default:
            return (0, _fromString.fromString)(str, "base16"); // no clue. convert from hex
    }
}
function convertToIpNet(multiaddr) {
    let mask;
    let addr;
    multiaddr.stringTuples().forEach(([code, value])=>{
        if (code === ip4Protocol.code || code === ip6Protocol.code) addr = value;
        if (code === ipcidrProtocol.code) mask = value;
    });
    if (mask == null || addr == null) throw new Error("Invalid multiaddr");
    return new (0, _netmask.IpNet)(addr, mask);
}
const decoders = Object.values((0, _basics.bases)).map((c)=>c.decoder);
const anybaseDecoder = function() {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d)=>acc = acc.or(d));
    return acc;
}();
function ip2bytes(ipString) {
    if (!_ipJs.isIP(ipString)) throw new Error("invalid ip address");
    return _ipJs.toBytes(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = _ipJs.toString(ipBuff, 0, ipBuff.length);
    if (ipString == null) throw new Error("ipBuff is required");
    if (!_ipJs.isIP(ipString)) throw new Error("invalid ip address");
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0, _fromString.fromString)(str);
    const size = Uint8Array.from(_uint8Varint.encode(buf.length));
    return (0, _concat.concat)([
        size,
        buf
    ], size.length + buf.length);
}
function bytes2str(buf) {
    const size = _uint8Varint.decode(buf);
    buf = buf.slice(_uint8Varint.encodingLength(size));
    if (buf.length !== size) throw new Error("inconsistent lengths");
    return (0, _toString.toString)(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === "Q" || hash[0] === "1") mh = _digest.decode((0, _base58.base58btc).decode(`z${hash}`)).bytes;
    else mh = (0, _cid.CID).parse(hash).multihash.bytes;
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from(_uint8Varint.encode(mh.length));
    return (0, _concat.concat)([
        size,
        mh
    ], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(_uint8Varint.encode(mb.length));
    return (0, _concat.concat)([
        size,
        mb
    ], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = _uint8Varint.decode(buf);
    const hash = buf.slice(_uint8Varint.encodingLength(size));
    if (hash.length !== size) throw new Error("inconsistent lengths");
    return "u" + (0, _toString.toString)(hash, "base64url");
}
/**
 * Converts bytes to bas58btc string
 */ function bytes2mh(buf) {
    const size = _uint8Varint.decode(buf);
    const address = buf.slice(_uint8Varint.encodingLength(size));
    if (address.length !== size) throw new Error("inconsistent lengths");
    return (0, _toString.toString)(address, "base58btc");
}
function onion2bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    if (addr[0].length !== 16) throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = (0, _base32.base32).decode("b" + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) throw new Error("Port number is not in range(1, 65536)");
    const portBuf = port2bytes(port);
    return (0, _concat.concat)([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    if (addr[0].length !== 56) throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = (0, _base32.base32).decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) throw new Error("Port number is not in range(1, 65536)");
    const portBuf = port2bytes(port);
    return (0, _concat.concat)([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0, _toString.toString)(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
}

},{"@chainsafe/netmask":"9OPb8","multiformats/bases/base32":"dpCMu","multiformats/bases/base58":"9K4Ju","multiformats/basics":"W6yRG","multiformats/cid":"1oUcK","multiformats/hashes/digest":"cZirI","uint8-varint":"3o84q","uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","uint8arrays/to-string":"63irA","./ip.js":"5WlUL","./protocols-table.js":"fBqZI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9OPb8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ipToString", ()=>(0, _utilJs.ipToString));
parcelHelpers.export(exports, "maskIp", ()=>(0, _ipJs.maskIp));
parcelHelpers.export(exports, "iPv4FromIPv6", ()=>(0, _ipJs.iPv4FromIPv6));
parcelHelpers.export(exports, "isIPv4mappedIPv6", ()=>(0, _ipJs.isIPv4mappedIPv6));
parcelHelpers.export(exports, "IpNet", ()=>(0, _ipnetJs.IpNet));
parcelHelpers.export(exports, "parseCidr", ()=>(0, _cidrJs.parseCidr));
/**
 * Checks if cidr block contains ip address
 * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48
 * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::
 *
 */ parcelHelpers.export(exports, "cidrContains", ()=>cidrContains);
var _ipnetJs = require("./ipnet.js");
var _utilJs = require("./util.js");
var _ipJs = require("./ip.js");
var _cidrJs = require("./cidr.js");
function cidrContains(cidr, ip) {
    const ipnet = new (0, _ipnetJs.IpNet)(cidr);
    return ipnet.contains(ip);
}

},{"./ipnet.js":"7pMyE","./util.js":"2AMzc","./ip.js":"6OkEv","./cidr.js":"5EHHA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7pMyE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IpNet", ()=>IpNet);
var _parse = require("@chainsafe/is-ip/parse");
var _cidrJs = require("./cidr.js");
var _ipJs = require("./ip.js");
var _utilJs = require("./util.js");
class IpNet {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */ constructor(ipOrCidr, mask){
        if (mask == null) ({ network: this.network, mask: this.mask } = (0, _cidrJs.parseCidr)(ipOrCidr));
        else {
            const ipResult = (0, _parse.parseIP)(ipOrCidr);
            if (ipResult == null) throw new Error("Failed to parse network");
            mask = String(mask);
            const m = parseInt(mask, 10);
            if (Number.isNaN(m) || String(m).length !== mask.length || m < 0 || m > ipResult.length * 8) {
                const maskResult = (0, _parse.parseIP)(mask);
                if (maskResult == null) throw new Error("Failed to parse mask");
                this.mask = maskResult;
            } else this.mask = (0, _cidrJs.cidrMask)(m, 8 * ipResult.length);
            this.network = (0, _ipJs.maskIp)(ipResult, this.mask);
        }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */ contains(ip) {
        return (0, _ipJs.containsIp)({
            network: this.network,
            mask: this.mask
        }, ip);
    }
    /**Serializes back to string format */ toString() {
        const l = (0, _utilJs.simpleMaskLength)(this.mask);
        const mask = l !== -1 ? String(l) : (0, _utilJs.maskToHex)(this.mask);
        return (0, _utilJs.ipToString)(this.network) + "/" + mask;
    }
}

},{"@chainsafe/is-ip/parse":"2L93T","./cidr.js":"5EHHA","./ip.js":"6OkEv","./util.js":"2AMzc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2L93T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Parse `input` into IPv4 bytes. */ parcelHelpers.export(exports, "parseIPv4", ()=>parseIPv4);
/** Parse `input` into IPv6 bytes. */ parcelHelpers.export(exports, "parseIPv6", ()=>parseIPv6);
/** Parse `input` into IPv4 or IPv6 bytes. */ parcelHelpers.export(exports, "parseIP", ()=>parseIP);
var _parserJs = require("./parser.js");
// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new (0, _parserJs.Parser)();
function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) return undefined;
    return parser.new(input).parseWith(()=>parser.readIPv4Addr());
}
function parseIPv6(input) {
    // strip zone index if it is present
    if (input.includes("%")) input = input.split("%")[0];
    if (input.length > MAX_IPV6_LENGTH) return undefined;
    return parser.new(input).parseWith(()=>parser.readIPv6Addr());
}
function parseIP(input) {
    // strip zone index if it is present
    if (input.includes("%")) input = input.split("%")[0];
    if (input.length > MAX_IPV6_LENGTH) return undefined;
    return parser.new(input).parseWith(()=>parser.readIPAddr());
}

},{"./parser.js":"bCmSF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bCmSF":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-unsafe-return */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Parser", ()=>Parser);
class Parser {
    index = 0;
    input = "";
    new(input) {
        this.index = 0;
        this.input = input;
        return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */ readAtomically(fn) {
        const index = this.index;
        const result = fn();
        if (result === undefined) this.index = index;
        return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */ parseWith(fn) {
        const result = fn();
        if (this.index !== this.input.length) return undefined;
        return result;
    }
    /** Peek the next character from the input */ peekChar() {
        if (this.index >= this.input.length) return undefined;
        return this.input[this.index];
    }
    /** Read the next character from the input */ readChar() {
        if (this.index >= this.input.length) return undefined;
        return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */ readGivenChar(target) {
        return this.readAtomically(()=>{
            const char = this.readChar();
            if (char !== target) return undefined;
            return char;
        });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */ readSeparator(sep, index, inner) {
        return this.readAtomically(()=>{
            if (index > 0) {
                if (this.readGivenChar(sep) === undefined) return undefined;
            }
            return inner();
        });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */ readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
        return this.readAtomically(()=>{
            let result = 0;
            let digitCount = 0;
            const leadingChar = this.peekChar();
            if (leadingChar === undefined) return undefined;
            const hasLeadingZero = leadingChar === "0";
            const maxValue = 2 ** (8 * maxBytes) - 1;
            // eslint-disable-next-line no-constant-condition
            while(true){
                const digit = this.readAtomically(()=>{
                    const char = this.readChar();
                    if (char === undefined) return undefined;
                    const num = Number.parseInt(char, radix);
                    if (Number.isNaN(num)) return undefined;
                    return num;
                });
                if (digit === undefined) break;
                result *= radix;
                result += digit;
                if (result > maxValue) return undefined;
                digitCount += 1;
                if (maxDigits !== undefined) {
                    if (digitCount > maxDigits) return undefined;
                }
            }
            if (digitCount === 0) return undefined;
            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) return undefined;
            else return result;
        });
    }
    /** Read an IPv4 address. */ readIPv4Addr() {
        return this.readAtomically(()=>{
            const out = new Uint8Array(4);
            for(let i = 0; i < out.length; i++){
                const ix = this.readSeparator(".", i, ()=>this.readNumber(10, 3, false, 1));
                if (ix === undefined) return undefined;
                out[i] = ix;
            }
            return out;
        });
    }
    /** Read an IPv6 Address. */ readIPv6Addr() {
        /**
         * Read a chunk of an IPv6 address into `groups`. Returns the number
         * of groups read, along with a bool indicating if an embedded
         * trailing IPv4 address was read. Specifically, read a series of
         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional
         * trailing embedded IPv4 address.
         */ const readGroups = (groups)=>{
            for(let i = 0; i < groups.length / 2; i++){
                const ix = i * 2;
                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.
                if (i < groups.length - 3) {
                    const ipv4 = this.readSeparator(":", i, ()=>this.readIPv4Addr());
                    if (ipv4 !== undefined) {
                        groups[ix] = ipv4[0];
                        groups[ix + 1] = ipv4[1];
                        groups[ix + 2] = ipv4[2];
                        groups[ix + 3] = ipv4[3];
                        return [
                            ix + 4,
                            true
                        ];
                    }
                }
                const group = this.readSeparator(":", i, ()=>this.readNumber(16, 4, true, 2));
                if (group === undefined) return [
                    ix,
                    false
                ];
                groups[ix] = group >> 8;
                groups[ix + 1] = group & 255;
            }
            return [
                groups.length,
                false
            ];
        };
        return this.readAtomically(()=>{
            // Read the front part of the address; either the whole thing, or up to the first ::
            const head = new Uint8Array(16);
            const [headSize, headIp4] = readGroups(head);
            if (headSize === 16) return head;
            // IPv4 part is not allowed before `::`
            if (headIp4) return undefined;
            // Read `::` if previous code parsed less than 8 groups.
            // `::` indicates one or more groups of 16 bits of zeros.
            if (this.readGivenChar(":") === undefined) return undefined;
            if (this.readGivenChar(":") === undefined) return undefined;
            // Read the back part of the address. The :: must contain at least one
            // set of zeroes, so our max length is 7.
            const tail = new Uint8Array(14);
            const limit = 16 - (headSize + 2);
            const [tailSize] = readGroups(tail.subarray(0, limit));
            // Concat the head and tail of the IP address
            head.set(tail.subarray(0, tailSize), 16 - tailSize);
            return head;
        });
    }
    /** Read an IP Address, either IPv4 or IPv6. */ readIPAddr() {
        return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5EHHA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseCidr", ()=>parseCidr);
parcelHelpers.export(exports, "cidrMask", ()=>cidrMask);
var _parse = require("@chainsafe/is-ip/parse");
var _ipJs = require("./ip.js");
function parseCidr(s) {
    const [address, maskString] = s.split("/");
    if (!address || !maskString) throw new Error("Failed to parse given CIDR: " + s);
    let ipLength = (0, _ipJs.IPv4Len);
    let ip = (0, _parse.parseIPv4)(address);
    if (ip == null) {
        ipLength = (0, _ipJs.IPv6Len);
        ip = (0, _parse.parseIPv6)(address);
        if (ip == null) throw new Error("Failed to parse given CIDR: " + s);
    }
    const m = parseInt(maskString, 10);
    if (Number.isNaN(m) || String(m).length !== maskString.length || m < 0 || m > ipLength * 8) throw new Error("Failed to parse given CIDR: " + s);
    const mask = cidrMask(m, 8 * ipLength);
    return {
        network: (0, _ipJs.maskIp)(ip, mask),
        mask
    };
}
function cidrMask(ones, bits) {
    if (bits !== 8 * (0, _ipJs.IPv4Len) && bits !== 8 * (0, _ipJs.IPv6Len)) throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits) throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m = new Uint8Array(l);
    for(let i = 0; i < l; i++){
        if (ones >= 8) {
            m[i] = 0xff;
            ones -= 8;
            continue;
        }
        m[i] = 255 - (0xff >> ones);
        ones = 0;
    }
    return m;
}

},{"@chainsafe/is-ip/parse":"2L93T","./ip.js":"6OkEv","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6OkEv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IPv4Len", ()=>IPv4Len);
parcelHelpers.export(exports, "IPv6Len", ()=>IPv6Len);
parcelHelpers.export(exports, "maxIPv6Octet", ()=>maxIPv6Octet);
parcelHelpers.export(exports, "ipv4Prefix", ()=>ipv4Prefix);
parcelHelpers.export(exports, "maskIp", ()=>maskIp);
parcelHelpers.export(exports, "containsIp", ()=>containsIp);
parcelHelpers.export(exports, "iPv4FromIPv6", ()=>iPv4FromIPv6);
parcelHelpers.export(exports, "isIPv4mappedIPv6", ()=>isIPv4mappedIPv6);
var _parse = require("@chainsafe/is-ip/parse");
var _utilJs = require("./util.js");
const IPv4Len = 4;
const IPv6Len = 16;
const maxIPv6Octet = parseInt("0xFFFF", 16);
const ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
]);
function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && (0, _utilJs.allFF)(mask, 0, 11)) mask = mask.slice(12);
    if (mask.length === IPv4Len && ip.length === IPv6Len && (0, _utilJs.deepEqual)(ip, ipv4Prefix, 0, 11)) ip = ip.slice(12);
    const n = ip.length;
    if (n != mask.length) throw new Error("Failed to mask ip");
    const out = new Uint8Array(n);
    for(let i = 0; i < n; i++)out[i] = ip[i] & mask[i];
    return out;
}
function containsIp(net, ip) {
    if (typeof ip === "string") ip = (0, _parse.parseIP)(ip);
    if (ip == null) throw new Error("Invalid ip");
    if (ip.length !== net.network.length) return false;
    for(let i = 0; i < ip.length; i++){
        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) return false;
    }
    return true;
}
function iPv4FromIPv6(ip) {
    if (!isIPv4mappedIPv6(ip)) throw new Error("Must have 0xffff prefix");
    return ip.slice(12);
}
function isIPv4mappedIPv6(ip) {
    return (0, _utilJs.deepEqual)(ip, ipv4Prefix, 0, 11);
}

},{"@chainsafe/is-ip/parse":"2L93T","./util.js":"2AMzc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2AMzc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allFF", ()=>allFF);
parcelHelpers.export(exports, "deepEqual", ()=>deepEqual);
/***
 * Returns long ip format
 */ parcelHelpers.export(exports, "ipToString", ()=>ipToString);
/**
 * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1
 */ parcelHelpers.export(exports, "simpleMaskLength", ()=>simpleMaskLength);
parcelHelpers.export(exports, "maskToHex", ()=>maskToHex);
var _ipJs = require("./ip.js");
function allFF(a, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== 0xff) return false;
        i++;
    }
    return true;
}
function deepEqual(a, b, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== b[i]) return false;
        i++;
    }
    return true;
}
function ipToString(ip) {
    switch(ip.length){
        case 0, _ipJs.IPv4Len:
            return ip.join(".");
        case 0, _ipJs.IPv6Len:
            {
                const result = [];
                for(let i = 0; i < ip.length; i++)if (i % 2 === 0) result.push(ip[i].toString(16).padStart(2, "0") + ip[i + 1].toString(16).padStart(2, "0"));
                return result.join(":");
            }
        default:
            throw new Error("Invalid ip length");
    }
}
function simpleMaskLength(mask) {
    let ones = 0;
    // eslint-disable-next-line prefer-const
    for (let [index, byte] of mask.entries()){
        if (byte === 0xff) {
            ones += 8;
            continue;
        }
        while((byte & 0x80) != 0){
            ones++;
            byte = byte << 1;
        }
        if ((byte & 0x80) != 0) return -1;
        for(let i = index + 1; i < mask.length; i++){
            if (mask[i] != 0) return -1;
        }
        break;
    }
    return ones;
}
function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask)hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);
    return hex;
}

},{"./ip.js":"6OkEv","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5WlUL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIP", ()=>(0, _isIp.isIP));
parcelHelpers.export(exports, "isV4", ()=>isV4);
parcelHelpers.export(exports, "isV6", ()=>isV6);
parcelHelpers.export(exports, "toBytes", ()=>toBytes);
parcelHelpers.export(exports, "toString", ()=>toString);
var _isIp = require("@chainsafe/is-ip");
var _toString = require("uint8arrays/to-string");
const isV4 = (0, _isIp.isIPv4);
const isV6 = (0, _isIp.isIPv6);
const toBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte)=>{
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(":", 8);
        let i;
        for(i = 0; i < sections.length; i++){
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0, _toString.toString)(v4Buffer.slice(0, 2), "base16");
            }
            if (v4Buffer != null && ++i < 8) sections.splice(i, 0, (0, _toString.toString)(v4Buffer.slice(2, 4), "base16"));
        }
        if (sections[0] === "") while(sections.length < 8)sections.unshift("0");
        else if (sections[sections.length - 1] === "") while(sections.length < 8)sections.push("0");
        else if (sections.length < 8) {
            for(i = 0; i < sections.length && sections[i] !== ""; i++);
            const argv = [
                i,
                1
            ];
            for(i = 9 - sections.length; i > 0; i--)argv.push("0");
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for(i = 0; i < sections.length; i++){
            const word = parseInt(sections[i], 16);
            bytes[offset++] = word >> 8 & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error("invalid ip address");
};
const toString = function(buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for(let i = 0; i < length; i++)result.push(buf[offset + i]);
        return result.join(".");
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for(let i = 0; i < length; i += 2)result.push(view.getUint16(offset + i).toString(16));
        return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
    }
    return "";
};

},{"@chainsafe/is-ip":"aTlfV","uint8arrays/to-string":"63irA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aTlfV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Check if `input` is IPv4. */ parcelHelpers.export(exports, "isIPv4", ()=>isIPv4);
/** Check if `input` is IPv6. */ parcelHelpers.export(exports, "isIPv6", ()=>isIPv6);
/** Check if `input` is IPv4 or IPv6. */ parcelHelpers.export(exports, "isIP", ()=>isIP);
/**
 * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.
 */ parcelHelpers.export(exports, "ipVersion", ()=>ipVersion);
var _parseJs = require("./parse.js");
function isIPv4(input) {
    return Boolean((0, _parseJs.parseIPv4)(input));
}
function isIPv6(input) {
    return Boolean((0, _parseJs.parseIPv6)(input));
}
function isIP(input) {
    return Boolean((0, _parseJs.parseIP)(input));
}
function ipVersion(input) {
    if (isIPv4(input)) return 4;
    else if (isIPv6(input)) return 6;
    else return undefined;
}

},{"./parse.js":"2L93T","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fBqZI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "names", ()=>names);
parcelHelpers.export(exports, "codes", ()=>codes);
parcelHelpers.export(exports, "table", ()=>table);
parcelHelpers.export(exports, "createProtocol", ()=>createProtocol);
/**
 * For the passed proto string or number, return a {@link Protocol}
 *
 * @example
 *
 * ```js
 * import { protocol } from '@multiformats/multiaddr'
 *
 * console.info(protocol(4))
 * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }
 * ```
 */ parcelHelpers.export(exports, "getProtocol", ()=>getProtocol);
const V = -1;
const names = {};
const codes = {};
const table = [
    [
        4,
        32,
        "ip4"
    ],
    [
        6,
        16,
        "tcp"
    ],
    [
        33,
        16,
        "dccp"
    ],
    [
        41,
        128,
        "ip6"
    ],
    [
        42,
        V,
        "ip6zone"
    ],
    [
        43,
        8,
        "ipcidr"
    ],
    [
        53,
        V,
        "dns",
        true
    ],
    [
        54,
        V,
        "dns4",
        true
    ],
    [
        55,
        V,
        "dns6",
        true
    ],
    [
        56,
        V,
        "dnsaddr",
        true
    ],
    [
        132,
        16,
        "sctp"
    ],
    [
        273,
        16,
        "udp"
    ],
    [
        275,
        0,
        "p2p-webrtc-star"
    ],
    [
        276,
        0,
        "p2p-webrtc-direct"
    ],
    [
        277,
        0,
        "p2p-stardust"
    ],
    [
        280,
        0,
        "webrtc-direct"
    ],
    [
        281,
        0,
        "webrtc"
    ],
    [
        290,
        0,
        "p2p-circuit"
    ],
    [
        301,
        0,
        "udt"
    ],
    [
        302,
        0,
        "utp"
    ],
    [
        400,
        V,
        "unix",
        false,
        true
    ],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [
        421,
        V,
        "ipfs"
    ],
    // `p2p` is the preferred name for 421, and is now the default
    [
        421,
        V,
        "p2p"
    ],
    [
        443,
        0,
        "https"
    ],
    [
        444,
        96,
        "onion"
    ],
    [
        445,
        296,
        "onion3"
    ],
    [
        446,
        V,
        "garlic64"
    ],
    [
        448,
        0,
        "tls"
    ],
    [
        449,
        V,
        "sni"
    ],
    [
        460,
        0,
        "quic"
    ],
    [
        461,
        0,
        "quic-v1"
    ],
    [
        465,
        0,
        "webtransport"
    ],
    [
        466,
        V,
        "certhash"
    ],
    [
        477,
        0,
        "ws"
    ],
    [
        478,
        0,
        "wss"
    ],
    [
        479,
        0,
        "p2p-websocket-star"
    ],
    [
        480,
        0,
        "http"
    ],
    [
        777,
        V,
        "memory"
    ]
];
// populate tables
table.forEach((row)=>{
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
function getProtocol(proto) {
    if (typeof proto === "number") {
        if (codes[proto] != null) return codes[proto];
        throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === "string") {
        if (names[proto] != null) return names[proto];
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aAJvm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A utility class to determine if a Multiaddr contains another
 * multiaddr.
 *
 * This can be used with ipcidr ranges to determine if a given
 * multiaddr is in a ipcidr range.
 *
 * @example
 *
 * ```js
 * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'
 *
 * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')
 * const filter = new MultiaddrFilter(range)
 *
 * const input = multiaddr('/ip4/192.168.10.2/udp/60')
 * console.info(filter.contains(input)) // true
 * ```
 */ parcelHelpers.export(exports, "MultiaddrFilter", ()=>MultiaddrFilter);
var _convertJs = require("../convert.js");
var _indexJs = require("../index.js");
class MultiaddrFilter {
    multiaddr;
    netmask;
    constructor(input){
        this.multiaddr = (0, _indexJs.multiaddr)(input);
        this.netmask = (0, _convertJs.convertToIpNet)(this.multiaddr);
    }
    contains(input) {
        if (input == null) return false;
        const m = (0, _indexJs.multiaddr)(input);
        let ip;
        for (const [code, value] of m.stringTuples())if (code === 4 || code === 41) {
            ip = value;
            break;
        }
        if (ip === undefined) return false;
        return this.netmask.contains(ip);
    }
}

},{"../convert.js":"e5ODO","../index.js":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cVewE":[function(require,module,exports) {
// The domain string used for peer records contained in a Envelope.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ENVELOPE_DOMAIN_PEER_RECORD", ()=>ENVELOPE_DOMAIN_PEER_RECORD);
parcelHelpers.export(exports, "ENVELOPE_PAYLOAD_TYPE_PEER_RECORD", ()=>ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
const ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([
    3,
    1
]);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hd093":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PeerRecord", ()=>PeerRecord);
var _protonsRuntime = require("protons-runtime");
var PeerRecord;
(function(PeerRecord) {
    let AddressInfo;
    (function(AddressInfo) {
        let _codec;
        AddressInfo.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
                    w.uint32(10);
                    w.bytes(obj.multiaddr);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {
                    multiaddr: new Uint8Array(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.multiaddr = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        AddressInfo.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, AddressInfo.codec());
        };
        AddressInfo.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, AddressInfo.codec());
        };
    })(AddressInfo = PeerRecord.AddressInfo || (PeerRecord.AddressInfo = {}));
    let _codec;
    PeerRecord.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.peerId != null && obj.peerId.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.peerId);
            }
            if (obj.seq != null && obj.seq !== 0n) {
                w.uint32(16);
                w.uint64(obj.seq);
            }
            if (obj.addresses != null) for (const value of obj.addresses){
                w.uint32(26);
                PeerRecord.AddressInfo.codec().encode(value, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                peerId: new Uint8Array(0),
                seq: 0n,
                addresses: []
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.peerId = reader.bytes();
                        break;
                    case 2:
                        obj.seq = reader.uint64();
                        break;
                    case 3:
                        obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    PeerRecord.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, PeerRecord.codec());
    };
    PeerRecord.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, PeerRecord.codec());
    };
})(PeerRecord || (PeerRecord = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"a2ZbU":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * For when you need a one-liner to collect iterable values.
 *
 * @example
 *
 * ```javascript
 * import all from 'it-all'
 *
 * // This can also be an iterator, etc
 * const values = function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const arr = all(values)
 *
 * console.info(arr) // 0, 1, 2, 3, 4
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const arr = await all(values())
 *
 * console.info(arr) // 0, 1, 2, 3, 4
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function all(source) {
    if (isAsyncIterable(source)) return (async ()=>{
        const arr = [];
        for await (const entry of source)arr.push(entry);
        return arr;
    })();
    const arr = [];
    for (const entry of source)arr.push(entry);
    return arr;
}
exports.default = all;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1DEqK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PersistentStore", ()=>PersistentStore);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _peerId = require("@libp2p/peer-id");
var _mortice = require("mortice");
var _morticeDefault = parcelHelpers.interopDefault(_mortice);
var _base32 = require("multiformats/bases/base32");
var _equals = require("uint8arrays/equals");
var _errorsJs = require("./errors.js");
var _peerJs = require("./pb/peer.js");
var _bytesToPeerJs = require("./utils/bytes-to-peer.js");
var _peerIdToDatastoreKeyJs = require("./utils/peer-id-to-datastore-key.js");
var _toPeerPbJs = require("./utils/to-peer-pb.js");
function decodePeer(key, value, cache) {
    // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}
    const base32Str = key.toString().split("/")[2];
    const buf = (0, _base32.base32).decode(base32Str);
    const peerId = (0, _peerId.peerIdFromBytes)(buf);
    const cached = cache.get(peerId);
    if (cached != null) return cached;
    const peer = (0, _bytesToPeerJs.bytesToPeer)(peerId, value);
    cache.set(peerId, peer);
    return peer;
}
function mapQuery(query, cache) {
    if (query == null) return {};
    return {
        prefix: (0, _peerIdToDatastoreKeyJs.NAMESPACE_COMMON),
        filters: (query.filters ?? []).map((fn)=>({ key, value })=>{
                return fn(decodePeer(key, value, cache));
            }),
        orders: (query.orders ?? []).map((fn)=>(a, b)=>{
                return fn(decodePeer(a.key, a.value, cache), decodePeer(b.key, b.value, cache));
            })
    };
}
class PersistentStore {
    peerId;
    datastore;
    lock;
    addressFilter;
    constructor(components, init = {}){
        this.peerId = components.peerId;
        this.datastore = components.datastore;
        this.addressFilter = init.addressFilter;
        this.lock = (0, _morticeDefault.default)({
            name: "peer-store",
            singleProcess: true
        });
    }
    async has(peerId) {
        return this.datastore.has((0, _peerIdToDatastoreKeyJs.peerIdToDatastoreKey)(peerId));
    }
    async delete(peerId) {
        if (this.peerId.equals(peerId)) throw new (0, _interface.CodeError)("Cannot delete self peer", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        await this.datastore.delete((0, _peerIdToDatastoreKeyJs.peerIdToDatastoreKey)(peerId));
    }
    async load(peerId) {
        const buf = await this.datastore.get((0, _peerIdToDatastoreKeyJs.peerIdToDatastoreKey)(peerId));
        return (0, _bytesToPeerJs.bytesToPeer)(peerId, buf);
    }
    async save(peerId, data) {
        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
        const peerPb = await (0, _toPeerPbJs.toPeerPB)(peerId, data, "patch", {
            addressFilter: this.addressFilter
        });
        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
    }
    async patch(peerId, data) {
        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
        const peerPb = await (0, _toPeerPbJs.toPeerPB)(peerId, data, "patch", {
            addressFilter: this.addressFilter,
            existingPeer
        });
        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
    }
    async merge(peerId, data) {
        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);
        const peerPb = await (0, _toPeerPbJs.toPeerPB)(peerId, data, "merge", {
            addressFilter: this.addressFilter,
            existingPeer
        });
        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);
    }
    async *all(query) {
        const peerCache = new (0, _peerCollections.PeerMap)();
        for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))){
            const peer = decodePeer(key, value, peerCache);
            if (peer.id.equals(this.peerId)) continue;
            yield peer;
        }
    }
    async #findExistingPeer(peerId) {
        try {
            const existingBuf = await this.datastore.get((0, _peerIdToDatastoreKeyJs.peerIdToDatastoreKey)(peerId));
            const existingPeer = (0, _bytesToPeerJs.bytesToPeer)(peerId, existingBuf);
            return {
                existingBuf,
                existingPeer
            };
        } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") throw err;
        }
        return {};
    }
    async #saveIfDifferent(peerId, peer, existingBuf, existingPeer) {
        const buf = (0, _peerJs.Peer).encode(peer);
        if (existingBuf != null && (0, _equals.equals)(buf, existingBuf)) return {
            peer: (0, _bytesToPeerJs.bytesToPeer)(peerId, buf),
            previous: existingPeer,
            updated: false
        };
        await this.datastore.put((0, _peerIdToDatastoreKeyJs.peerIdToDatastoreKey)(peerId), buf);
        return {
            peer: (0, _bytesToPeerJs.bytesToPeer)(peerId, buf),
            previous: existingPeer,
            updated: true
        };
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","@libp2p/peer-id":"8wBUr","mortice":"j50Hr","multiformats/bases/base32":"dpCMu","uint8arrays/equals":"CKVqX","./errors.js":"gUvdd","./pb/peer.js":"ft2rP","./utils/bytes-to-peer.js":"kRay7","./utils/peer-id-to-datastore-key.js":"cwAzZ","./utils/to-peer-pb.js":"cTqT7","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"j50Hr":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * - Reads occur concurrently
 * - Writes occur one at a time
 * - No reads occur while a write operation is in progress
 * - Locks can be created with different names
 * - Reads/writes can time out
 *
 * ## Usage
 *
 * ```javascript
 * import mortice from 'mortice'
 * import delay from 'delay'
 *
 * // the lock name & options objects are both optional
 * const mutex = mortice('my-lock', {
 *
 *   // how long before write locks time out (default: 24 hours)
 *   timeout: 30000,
 *
 *    // control how many read operations are executed concurrently (default: Infinity)
 *   concurrency: 5,
 *
 *   // by default the the lock will be held on the main thread, set this to true if the
 *   // a lock should reside on each worker (default: false)
 *   singleProcess: false
 * })
 *
 * Promise.all([
 *   (async () => {
 *     const release = await mutex.readLock()
 *
 *     try {
 *       console.info('read 1')
 *     } finally {
 *       release()
 *     }
 *   })(),
 *   (async () => {
 *     const release = await mutex.readLock()
 *
 *     try {
 *       console.info('read 2')
 *     } finally {
 *       release()
 *     }
 *   })(),
 *   (async () => {
 *     const release = await mutex.writeLock()
 *
 *     try {
 *       await delay(1000)
 *
 *       console.info('write 1')
 *     } finally {
 *       release()
 *     }
 *   })(),
 *   (async () => {
 *     const release = await mutex.readLock()
 *
 *     try {
 *       console.info('read 3')
 *     } finally {
 *       release()
 *     }
 *   })()
 * ])
 * ```
 *
 *     read 1
 *     read 2
 *     <small pause>
 *     write 1
 *     read 3
 *
 * ## Browser
 *
 * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:
 *
 * ```javascript
 * // main.js
 * import mortice from 'mortice'
 * import observe from 'observable-webworkers'
 *
 * // create our lock on the main thread, it will be held here
 * const mutex = mortice()
 *
 * const worker = new Worker('worker.js')
 *
 * observe(worker)
 * ```
 *
 * ```javascript
 * // worker.js
 * import mortice from 'mortice'
 * import delay from 'delay'
 *
 * const mutex = mortice()
 *
 * let release = await mutex.readLock()
 * // read something
 * release()
 *
 * release = await mutex.writeLock()
 * // write something
 * release()
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createMortice);
var _pQueue = require("p-queue");
var _pQueueDefault = parcelHelpers.interopDefault(_pQueue);
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
var _nodeJs = require("./node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
const mutexes = {};
let implementation;
async function createReleaseable(queue, options) {
    let res;
    const p = new Promise((resolve)=>{
        res = resolve;
    });
    queue.add(async ()=>(0, _pTimeoutDefault.default)((async ()=>{
            await new Promise((resolve)=>{
                res(()=>{
                    resolve();
                });
            });
        })(), {
            milliseconds: options.timeout
        }));
    return p;
}
const createMutex = (name, options)=>{
    if (implementation.isWorker === true) return {
        readLock: implementation.readLock(name, options),
        writeLock: implementation.writeLock(name, options)
    };
    const masterQueue = new (0, _pQueueDefault.default)({
        concurrency: 1
    });
    let readQueue;
    return {
        async readLock () {
            // If there's already a read queue, just add the task to it
            if (readQueue != null) return createReleaseable(readQueue, options);
            // Create a new read queue
            readQueue = new (0, _pQueueDefault.default)({
                concurrency: options.concurrency,
                autoStart: false
            });
            const localReadQueue = readQueue;
            // Add the task to the read queue
            const readPromise = createReleaseable(readQueue, options);
            masterQueue.add(async ()=>{
                // Start the task only once the master queue has completed processing
                // any previous tasks
                localReadQueue.start();
                // Once all the tasks in the read queue have completed, remove it so
                // that the next read lock will occur after any write locks that were
                // started in the interim
                await localReadQueue.onIdle().then(()=>{
                    if (readQueue === localReadQueue) readQueue = null;
                });
            });
            return readPromise;
        },
        async writeLock () {
            // Remove the read queue reference, so that any later read locks will be
            // added to a new queue that starts after this write lock has been
            // released
            readQueue = null;
            return createReleaseable(masterQueue, options);
        }
    };
};
const defaultOptions = {
    name: "lock",
    concurrency: Infinity,
    timeout: 84600000,
    singleProcess: false
};
function createMortice(options) {
    const opts = Object.assign({}, defaultOptions, options);
    if (implementation == null) {
        implementation = (0, _nodeJsDefault.default)(opts);
        if (implementation.isWorker !== true) {
            // we are master, set up worker requests
            implementation.addEventListener("requestReadLock", (event)=>{
                if (mutexes[event.data.name] == null) return;
                mutexes[event.data.name].readLock().then(async (release)=>event.data.handler().finally(()=>{
                        release();
                    }));
            });
            implementation.addEventListener("requestWriteLock", async (event)=>{
                if (mutexes[event.data.name] == null) return;
                mutexes[event.data.name].writeLock().then(async (release)=>event.data.handler().finally(()=>{
                        release();
                    }));
            });
        }
    }
    if (mutexes[opts.name] == null) mutexes[opts.name] = createMutex(opts.name, opts);
    return mutexes[opts.name];
}

},{"p-queue":"3KoWO","p-timeout":"2j2Zi","./node.js":"4Zhsm","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3KoWO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventemitter3 = require("eventemitter3");
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
var _priorityQueueJs = require("./priority-queue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
class PQueue extends (0, _eventemitter3.EventEmitter) {
    #carryoverConcurrencyCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #interval;
    #intervalEnd = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    #throwOnTimeout;
    /**
    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.

    Applies to each future operation.
    */ timeout;
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options){
        super();
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        options = {
            carryoverConcurrencyCount: false,
            intervalCap: Number.POSITIVE_INFINITY,
            interval: 0,
            concurrency: Number.POSITIVE_INFINITY,
            autoStart: true,
            queueClass: (0, _priorityQueueJsDefault.default),
            ...options
        };
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
        this.#intervalCap = options.intervalCap;
        this.#interval = options.interval;
        this.#queue = new options.queueClass();
        this.#queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this.timeout = options.timeout;
        this.#throwOnTimeout = options.throwOnTimeout === true;
        this.#isPaused = options.autoStart === false;
    }
    get #doesIntervalAllowAnother() {
        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
        return this.#pending < this.#concurrency;
    }
    #next() {
        this.#pending--;
        this.#tryToStartAnother();
        this.emit("next");
    }
    #onResumeInterval() {
        this.#onInterval();
        this.#initializeIntervalIfNeeded();
        this.#timeoutId = undefined;
    }
    get #isIntervalPaused() {
        const now = Date.now();
        if (this.#intervalId === undefined) {
            const delay = this.#intervalEnd - now;
            if (delay < 0) // Act as the interval was done
            // We don't need to resume it here because it will be resumed on line 160
            this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
            else {
                // Act as the interval is pending
                if (this.#timeoutId === undefined) this.#timeoutId = setTimeout(()=>{
                    this.#onResumeInterval();
                }, delay);
                return true;
            }
        }
        return false;
    }
    #tryToStartAnother() {
        if (this.#queue.size === 0) {
            // We can clear the interval ("pause")
            // Because we can redo it later ("resume")
            if (this.#intervalId) clearInterval(this.#intervalId);
            this.#intervalId = undefined;
            this.emit("empty");
            if (this.#pending === 0) this.emit("idle");
            return false;
        }
        if (!this.#isPaused) {
            const canInitializeInterval = !this.#isIntervalPaused;
            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
                const job = this.#queue.dequeue();
                if (!job) return false;
                this.emit("active");
                job();
                if (canInitializeInterval) this.#initializeIntervalIfNeeded();
                return true;
            }
        }
        return false;
    }
    #initializeIntervalIfNeeded() {
        if (this.#isIntervalIgnored || this.#intervalId !== undefined) return;
        this.#intervalId = setInterval(()=>{
            this.#onInterval();
        }, this.#interval);
        this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
            clearInterval(this.#intervalId);
            this.#intervalId = undefined;
        }
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
        this.#processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */ #processQueue() {
        // eslint-disable-next-line no-empty
        while(this.#tryToStartAnother());
    }
    get concurrency() {
        return this.#concurrency;
    }
    set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        this.#concurrency = newConcurrency;
        this.#processQueue();
    }
    async #throwOnAbort(signal) {
        return new Promise((_resolve, reject)=>{
            signal.addEventListener("abort", ()=>{
                reject(signal.reason);
            }, {
                once: true
            });
        });
    }
    async add(function_, options = {}) {
        options = {
            timeout: this.timeout,
            throwOnTimeout: this.#throwOnTimeout,
            ...options
        };
        return new Promise((resolve, reject)=>{
            this.#queue.enqueue(async ()=>{
                this.#pending++;
                this.#intervalCount++;
                try {
                    options.signal?.throwIfAborted();
                    let operation = function_({
                        signal: options.signal
                    });
                    if (options.timeout) operation = (0, _pTimeoutDefault.default)(Promise.resolve(operation), {
                        milliseconds: options.timeout
                    });
                    if (options.signal) operation = Promise.race([
                        operation,
                        this.#throwOnAbort(options.signal)
                    ]);
                    const result = await operation;
                    resolve(result);
                    this.emit("completed", result);
                } catch (error) {
                    if (error instanceof (0, _pTimeout.TimeoutError) && !options.throwOnTimeout) {
                        resolve();
                        return;
                    }
                    reject(error);
                    this.emit("error", error);
                } finally{
                    this.#next();
                }
            }, options);
            this.emit("add");
            this.#tryToStartAnother();
        });
    }
    async addAll(functions, options) {
        return Promise.all(functions.map(async (function_)=>this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */ start() {
        if (!this.#isPaused) return this;
        this.#isPaused = false;
        this.#processQueue();
        return this;
    }
    /**
    Put queue execution on hold.
    */ pause() {
        this.#isPaused = true;
    }
    /**
    Clear the queue.
    */ clear() {
        this.#queue = new this.#queueClass();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */ async onEmpty() {
        // Instantly resolve if the queue is empty
        if (this.#queue.size === 0) return;
        await this.#onEvent("empty");
    }
    /**
    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.

    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.

    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
    */ async onSizeLessThan(limit) {
        // Instantly resolve if the queue is empty.
        if (this.#queue.size < limit) return;
        await this.#onEvent("next", ()=>this.#queue.size < limit);
    }
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */ async onIdle() {
        // Instantly resolve if none pending and if nothing else is queued
        if (this.#pending === 0 && this.#queue.size === 0) return;
        await this.#onEvent("idle");
    }
    async #onEvent(event, filter) {
        return new Promise((resolve)=>{
            const listener = ()=>{
                if (filter && !filter()) return;
                this.off(event, listener);
                resolve();
            };
            this.on(event, listener);
        });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */ get size() {
        return this.#queue.size;
    }
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */ sizeBy(options) {
        // eslint-disable-next-line unicorn/no-array-callback-reference
        return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */ get pending() {
        return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */ get isPaused() {
        return this.#isPaused;
    }
}
exports.default = PQueue;

},{"eventemitter3":"5t0Jx","p-timeout":"2j2Zi","./priority-queue.js":"grf7X","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5t0Jx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventEmitter", ()=>(0, _indexJsDefault.default));
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default);

},{"./index.js":"3fnfh","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3fnfh":[function(require,module,exports) {
"use strict";
var has = Object.prototype.hasOwnProperty, prefix = "~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"2j2Zi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
/**
An error to be thrown when the request is aborted by AbortController.
DOMException is thrown instead of this Error when DOMException is available.
*/ parcelHelpers.export(exports, "AbortError", ()=>AbortError);
parcelHelpers.export(exports, "default", ()=>pTimeout);
class TimeoutError extends Error {
    constructor(message){
        super(message);
        this.name = "TimeoutError";
    }
}
class AbortError extends Error {
    constructor(message){
        super();
        this.name = "AbortError";
        this.message = message;
    }
}
/**
TODO: Remove AbortError and just throw DOMException when targeting Node 18.
*/ const getDOMException = (errorMessage)=>globalThis.DOMException === undefined ? new AbortError(errorMessage) : new DOMException(errorMessage);
/**
TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.
*/ const getAbortedReason = (signal)=>{
    const reason = signal.reason === undefined ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
    const { milliseconds, fallback, message, customTimers = {
        setTimeout,
        clearTimeout
    } } = options;
    let timer;
    const wrappedPromise = new Promise((resolve, reject)=>{
        if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
        if (options.signal) {
            const { signal } = options;
            if (signal.aborted) reject(getAbortedReason(signal));
            signal.addEventListener("abort", ()=>{
                reject(getAbortedReason(signal));
            });
        }
        if (milliseconds === Number.POSITIVE_INFINITY) {
            promise.then(resolve, reject);
            return;
        }
        // We create the error outside of `setTimeout` to preserve the stack trace.
        const timeoutError = new TimeoutError();
        timer = customTimers.setTimeout.call(undefined, ()=>{
            if (fallback) {
                try {
                    resolve(fallback());
                } catch (error) {
                    reject(error);
                }
                return;
            }
            if (typeof promise.cancel === "function") promise.cancel();
            if (message === false) resolve();
            else if (message instanceof Error) reject(message);
            else {
                timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
                reject(timeoutError);
            }
        }, milliseconds);
        (async ()=>{
            try {
                resolve(await promise);
            } catch (error) {
                reject(error);
            }
        })();
    });
    const cancelablePromise = wrappedPromise.finally(()=>{
        cancelablePromise.clear();
    });
    cancelablePromise.clear = ()=>{
        customTimers.clearTimeout.call(undefined, timer);
        timer = undefined;
    };
    return cancelablePromise;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"grf7X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lowerBoundJs = require("./lower-bound.js");
var _lowerBoundJsDefault = parcelHelpers.interopDefault(_lowerBoundJs);
class PriorityQueue {
    #queue = [];
    enqueue(run, options) {
        options = {
            priority: 0,
            ...options
        };
        const element = {
            priority: options.priority,
            run
        };
        if (this.size && this.#queue[this.size - 1].priority >= options.priority) {
            this.#queue.push(element);
            return;
        }
        const index = (0, _lowerBoundJsDefault.default)(this.#queue, element, (a, b)=>b.priority - a.priority);
        this.#queue.splice(index, 0, element);
    }
    dequeue() {
        const item = this.#queue.shift();
        return item?.run;
    }
    filter(options) {
        return this.#queue.filter((element)=>element.priority === options.priority).map((element)=>element.run);
    }
    get size() {
        return this.#queue.length;
    }
}
exports.default = PriorityQueue;

},{"./lower-bound.js":"etZjf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"etZjf":[function(require,module,exports) {
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>lowerBound);
function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while(count > 0){
        const step = Math.trunc(count / 2);
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        } else count = step;
    }
    return first;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4Zhsm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observableWebworkers = require("observable-webworkers");
var _observableWebworkersDefault = parcelHelpers.interopDefault(_observableWebworkers);
var _constantsJs = require("./constants.js");
var _utilsJs = require("./utils.js");
const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType)=>{
    return (worker, event)=>{
        if (event.data.type !== requestType) return;
        const requestEvent = {
            type: event.data.type,
            name: event.data.name,
            identifier: event.data.identifier
        };
        emitter.dispatchEvent(new MessageEvent(masterEvent, {
            data: {
                name: requestEvent.name,
                handler: async ()=>{
                    // grant lock to worker
                    worker.postMessage({
                        type: grantType,
                        name: requestEvent.name,
                        identifier: requestEvent.identifier
                    });
                    // wait for worker to finish
                    await new Promise((resolve)=>{
                        const releaseEventListener = (event)=>{
                            if (event == null || event.data == null) return;
                            const releaseEvent = {
                                type: event.data.type,
                                name: event.data.name,
                                identifier: event.data.identifier
                            };
                            if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                                worker.removeEventListener("message", releaseEventListener);
                                resolve();
                            }
                        };
                        worker.addEventListener("message", releaseEventListener);
                    });
                }
            }
        }));
    };
};
const makeWorkerLockRequest = (name, requestType, grantType, releaseType)=>{
    return async ()=>{
        const id = (0, _utilsJs.nanoid)();
        globalThis.postMessage({
            type: requestType,
            identifier: id,
            name
        });
        return new Promise((resolve)=>{
            const listener = (event)=>{
                if (event == null || event.data == null) return;
                const responseEvent = {
                    type: event.data.type,
                    identifier: event.data.identifier
                };
                if (responseEvent.type === grantType && responseEvent.identifier === id) {
                    globalThis.removeEventListener("message", listener);
                    // grant lock
                    resolve(()=>{
                        // release lock
                        globalThis.postMessage({
                            type: releaseType,
                            identifier: id,
                            name
                        });
                    });
                }
            };
            globalThis.addEventListener("message", listener);
        });
    };
};
const defaultOptions = {
    singleProcess: false
};
exports.default = (options)=>{
    options = Object.assign({}, defaultOptions, options);
    const isPrimary = Boolean(globalThis.document) || options.singleProcess;
    if (isPrimary) {
        const emitter = new EventTarget();
        (0, _observableWebworkersDefault.default).addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", (0, _constantsJs.WORKER_REQUEST_READ_LOCK), (0, _constantsJs.WORKER_RELEASE_READ_LOCK), (0, _constantsJs.MASTER_GRANT_READ_LOCK)));
        (0, _observableWebworkersDefault.default).addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", (0, _constantsJs.WORKER_REQUEST_WRITE_LOCK), (0, _constantsJs.WORKER_RELEASE_WRITE_LOCK), (0, _constantsJs.MASTER_GRANT_WRITE_LOCK)));
        return emitter;
    }
    return {
        isWorker: true,
        readLock: (name)=>makeWorkerLockRequest(name, (0, _constantsJs.WORKER_REQUEST_READ_LOCK), (0, _constantsJs.MASTER_GRANT_READ_LOCK), (0, _constantsJs.WORKER_RELEASE_READ_LOCK)),
        writeLock: (name)=>makeWorkerLockRequest(name, (0, _constantsJs.WORKER_REQUEST_WRITE_LOCK), (0, _constantsJs.MASTER_GRANT_WRITE_LOCK), (0, _constantsJs.WORKER_RELEASE_WRITE_LOCK))
    };
};

},{"observable-webworkers":"1ts9K","./constants.js":"3GNVd","./utils.js":"5OG17","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1ts9K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const events = {};
const observable = (worker)=>{
    worker.addEventListener("message", (event)=>{
        observable.dispatchEvent("message", worker, event);
    });
    if (worker.port != null) worker.port.addEventListener("message", (event)=>{
        observable.dispatchEvent("message", worker, event);
    });
};
observable.addEventListener = (type, fn)=>{
    if (events[type] == null) events[type] = [];
    events[type].push(fn);
};
observable.removeEventListener = (type, fn)=>{
    if (events[type] == null) return;
    events[type] = events[type].filter((listener)=>listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
    if (events[type] == null) return;
    events[type].forEach((fn)=>fn(worker, event));
};
exports.default = observable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3GNVd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WORKER_REQUEST_READ_LOCK", ()=>WORKER_REQUEST_READ_LOCK);
parcelHelpers.export(exports, "WORKER_RELEASE_READ_LOCK", ()=>WORKER_RELEASE_READ_LOCK);
parcelHelpers.export(exports, "MASTER_GRANT_READ_LOCK", ()=>MASTER_GRANT_READ_LOCK);
parcelHelpers.export(exports, "WORKER_REQUEST_WRITE_LOCK", ()=>WORKER_REQUEST_WRITE_LOCK);
parcelHelpers.export(exports, "WORKER_RELEASE_WRITE_LOCK", ()=>WORKER_RELEASE_WRITE_LOCK);
parcelHelpers.export(exports, "MASTER_GRANT_WRITE_LOCK", ()=>MASTER_GRANT_WRITE_LOCK);
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
const WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
const MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
const WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
const WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
const MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5OG17":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nanoid", ()=>nanoid);
const nanoid = (size = 21)=>{
    return Math.random().toString().substring(2);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gUvdd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "codes", ()=>codes);
const codes = {
    ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ft2rP":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Peer", ()=>Peer);
parcelHelpers.export(exports, "Address", ()=>Address);
parcelHelpers.export(exports, "Tag", ()=>Tag);
var _protonsRuntime = require("protons-runtime");
var Peer;
(function(Peer) {
    let Peer$metadataEntry;
    (function(Peer$metadataEntry) {
        let _codec;
        Peer$metadataEntry.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.key != null && obj.key !== "") {
                    w.uint32(10);
                    w.string(obj.key);
                }
                if (obj.value != null && obj.value.byteLength > 0) {
                    w.uint32(18);
                    w.bytes(obj.value);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {
                    key: "",
                    value: new Uint8Array(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.key = reader.string();
                            break;
                        case 2:
                            obj.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        Peer$metadataEntry.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, Peer$metadataEntry.codec());
        };
        Peer$metadataEntry.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, Peer$metadataEntry.codec());
        };
    })(Peer$metadataEntry = Peer.Peer$metadataEntry || (Peer.Peer$metadataEntry = {}));
    let Peer$tagsEntry;
    (function(Peer$tagsEntry) {
        let _codec;
        Peer$tagsEntry.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.key != null && obj.key !== "") {
                    w.uint32(10);
                    w.string(obj.key);
                }
                if (obj.value != null) {
                    w.uint32(18);
                    Tag.codec().encode(obj.value, w);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {
                    key: ""
                };
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.key = reader.string();
                            break;
                        case 2:
                            obj.value = Tag.codec().decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        Peer$tagsEntry.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, Peer$tagsEntry.codec());
        };
        Peer$tagsEntry.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, Peer$tagsEntry.codec());
        };
    })(Peer$tagsEntry = Peer.Peer$tagsEntry || (Peer.Peer$tagsEntry = {}));
    let _codec;
    Peer.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.addresses != null) for (const value of obj.addresses){
                w.uint32(10);
                Address.codec().encode(value, w);
            }
            if (obj.protocols != null) for (const value of obj.protocols){
                w.uint32(18);
                w.string(value);
            }
            if (obj.publicKey != null) {
                w.uint32(34);
                w.bytes(obj.publicKey);
            }
            if (obj.peerRecordEnvelope != null) {
                w.uint32(42);
                w.bytes(obj.peerRecordEnvelope);
            }
            if (obj.metadata != null && obj.metadata.size !== 0) for (const [key, value] of obj.metadata.entries()){
                w.uint32(50);
                Peer.Peer$metadataEntry.codec().encode({
                    key,
                    value
                }, w);
            }
            if (obj.tags != null && obj.tags.size !== 0) for (const [key, value] of obj.tags.entries()){
                w.uint32(58);
                Peer.Peer$tagsEntry.codec().encode({
                    key,
                    value
                }, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                addresses: [],
                protocols: [],
                metadata: new Map(),
                tags: new Map()
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.addresses.push(Address.codec().decode(reader, reader.uint32()));
                        break;
                    case 2:
                        obj.protocols.push(reader.string());
                        break;
                    case 4:
                        obj.publicKey = reader.bytes();
                        break;
                    case 5:
                        obj.peerRecordEnvelope = reader.bytes();
                        break;
                    case 6:
                        {
                            const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32());
                            obj.metadata.set(entry.key, entry.value);
                            break;
                        }
                    case 7:
                        {
                            const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32());
                            obj.tags.set(entry.key, entry.value);
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Peer.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Peer.codec());
    };
    Peer.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Peer.codec());
    };
})(Peer || (Peer = {}));
var Address;
(function(Address) {
    let _codec;
    Address.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.multiaddr);
            }
            if (obj.isCertified != null) {
                w.uint32(16);
                w.bool(obj.isCertified);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                multiaddr: new Uint8Array(0)
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.multiaddr = reader.bytes();
                        break;
                    case 2:
                        obj.isCertified = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Address.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Address.codec());
    };
    Address.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Address.codec());
    };
})(Address || (Address = {}));
var Tag;
(function(Tag) {
    let _codec;
    Tag.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.value != null && obj.value !== 0) {
                w.uint32(8);
                w.uint32(obj.value);
            }
            if (obj.expiry != null) {
                w.uint32(16);
                w.uint64(obj.expiry);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                value: 0
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.value = reader.uint32();
                        break;
                    case 2:
                        obj.expiry = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Tag.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Tag.codec());
    };
    Tag.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Tag.codec());
    };
})(Tag || (Tag = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kRay7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bytesToPeer", ()=>bytesToPeer);
var _peerId = require("@libp2p/peer-id");
var _multiaddr = require("@multiformats/multiaddr");
var _peerJs = require("../pb/peer.js");
function bytesToPeer(peerId, buf) {
    const peer = (0, _peerJs.Peer).decode(buf);
    if (peer.publicKey != null && peerId.publicKey == null) peerId = (0, _peerId.peerIdFromPeerId)({
        ...peerId,
        publicKey: peerId.publicKey
    });
    const tags = new Map();
    // remove any expired tags
    const now = BigInt(Date.now());
    for (const [key, tag] of peer.tags.entries()){
        if (tag.expiry != null && tag.expiry < now) continue;
        tags.set(key, tag);
    }
    return {
        ...peer,
        id: peerId,
        addresses: peer.addresses.map(({ multiaddr: ma, isCertified })=>{
            return {
                multiaddr: (0, _multiaddr.multiaddr)(ma),
                isCertified: isCertified ?? false
            };
        }),
        metadata: peer.metadata,
        peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,
        tags
    };
}

},{"@libp2p/peer-id":"8wBUr","@multiformats/multiaddr":"7Qpz2","../pb/peer.js":"ft2rP","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cwAzZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NAMESPACE_COMMON", ()=>NAMESPACE_COMMON);
parcelHelpers.export(exports, "peerIdToDatastoreKey", ()=>peerIdToDatastoreKey);
var _interface = require("@libp2p/interface");
var _key = require("interface-datastore/key");
var _errorsJs = require("../errors.js");
const NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
    if (!(0, _interface.isPeerId)(peerId) || peerId.type == null) throw new (0, _interface.CodeError)("Invalid PeerId", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    const b32key = peerId.toCID().toString();
    return new (0, _key.Key)(`${NAMESPACE_COMMON}${b32key}`);
}

},{"@libp2p/interface":"b14bx","interface-datastore/key":"kWD9d","../errors.js":"gUvdd","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kWD9d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Key represents the unique identifier of an object.
 * Our Key scheme is inspired by file systems and Google App Engine key model.
 * Keys are meant to be unique across a system. Keys are hierarchical,
 * incorporating more and more specific namespaces. Thus keys can be deemed
 * 'children' or 'ancestors' of other keys:
 * - `new Key('/Comedy')`
 * - `new Key('/Comedy/MontyPython')`
 * Also, every namespace can be parametrized to embed relevant object
 * information. For example, the Key `name` (most specific namespace) could
 * include the object type:
 * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`
 * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`
 *
 */ parcelHelpers.export(exports, "Key", ()=>Key);
var _fromString = require("uint8arrays/from-string");
var _toString = require("uint8arrays/to-string");
const pathSepS = "/";
const pathSepB = new TextEncoder().encode(pathSepS);
const pathSep = pathSepB[0];
class Key {
    _buf;
    /**
     * @param {string | Uint8Array} s
     * @param {boolean} [clean]
     */ constructor(s, clean){
        if (typeof s === "string") this._buf = (0, _fromString.fromString)(s);
        else if (s instanceof Uint8Array) this._buf = s;
        else throw new Error("Invalid key, should be String of Uint8Array");
        if (clean == null) clean = true;
        if (clean) this.clean();
        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) throw new Error("Invalid key");
    }
    /**
     * Convert to the string representation
     *
     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
     * @returns {string}
     */ toString(encoding = "utf8") {
        return (0, _toString.toString)(this._buf, encoding);
    }
    /**
     * Return the Uint8Array representation of the key
     *
     * @returns {Uint8Array}
     */ uint8Array() {
        return this._buf;
    }
    /**
     * Return string representation of the key
     *
     * @returns {string}
     */ get [Symbol.toStringTag]() {
        return `Key(${this.toString()})`;
    }
    /**
     * Constructs a key out of a namespace array.
     *
     * @param {Array<string>} list - The array of namespaces
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.withNamespaces(['one', 'two'])
     * // => Key('/one/two')
     * ```
     */ static withNamespaces(list) {
        return new Key(list.join(pathSepS));
    }
    /**
     * Returns a randomly (uuid) generated key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.random()
     * // => Key('/344502982398')
     * ```
     */ static random() {
        return new Key(Math.random().toString().substring(2));
    }
    /**
     * @param {*} other
     */ static asKey(other) {
        if (other instanceof Uint8Array || typeof other === "string") // we can create a key from this
        return new Key(other);
        if (typeof other.uint8Array === "function") // this is an older version or may have crossed the esm/cjs boundary
        return new Key(other.uint8Array());
        return null;
    }
    /**
     * Cleanup the current key
     *
     * @returns {void}
     */ clean() {
        if (this._buf == null || this._buf.byteLength === 0) this._buf = pathSepB;
        if (this._buf[0] !== pathSep) {
            const bytes = new Uint8Array(this._buf.byteLength + 1);
            bytes.fill(pathSep, 0, 1);
            bytes.set(this._buf, 1);
            this._buf = bytes;
        }
        // normalize does not remove trailing slashes
        while(this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep)this._buf = this._buf.subarray(0, -1);
    }
    /**
     * Check if the given key is sorted lower than ourself.
     *
     * @param {Key} key - The other Key to check against
     * @returns {boolean}
     */ less(key) {
        const list1 = this.list();
        const list2 = key.list();
        for(let i = 0; i < list1.length; i++){
            if (list2.length < i + 1) return false;
            const c1 = list1[i];
            const c2 = list2[i];
            if (c1 < c2) return true;
            else if (c1 > c2) return false;
        }
        return list1.length < list2.length;
    }
    /**
     * Returns the key with all parts in reversed order.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
     * ```
     */ reverse() {
        return Key.withNamespaces(this.list().slice().reverse());
    }
    /**
     * Returns the `namespaces` making up this Key.
     *
     * @returns {Array<string>}
     */ namespaces() {
        return this.list();
    }
    /** Returns the "base" namespace of this key.
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
     * // => 'Actor:JohnCleese'
     * ```
     */ baseNamespace() {
        const ns = this.namespaces();
        return ns[ns.length - 1];
    }
    /**
     * Returns the `list` representation of this key.
     *
     * @returns {Array<string>}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
     * ```
     */ list() {
        return this.toString().split(pathSepS).slice(1);
    }
    /**
     * Returns the "type" of this key (value of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
     * // => 'Actor'
     * ```
     */ type() {
        return namespaceType(this.baseNamespace());
    }
    /**
     * Returns the "name" of this key (field of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
     * // => 'JohnCleese'
     * ```
     */ name() {
        return namespaceValue(this.baseNamespace());
    }
    /**
     * Returns an "instance" of this type key (appends value to namespace).
     *
     * @param {string} s - The string to append.
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */ instance(s) {
        return new Key(this.toString() + ":" + s);
    }
    /**
     * Returns the "path" of this key (parent + type).
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
     * // => Key('/Comedy/MontyPython/Actor')
     * ```
     */ path() {
        let p = this.parent().toString();
        if (!p.endsWith(pathSepS)) p += pathSepS;
        p += this.type();
        return new Key(p);
    }
    /**
     * Returns the `parent` Key of this Key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
     * // => Key("/Comedy/MontyPython")
     * ```
     */ parent() {
        const list = this.list();
        if (list.length === 1) return new Key(pathSepS);
        return new Key(list.slice(0, -1).join(pathSepS));
    }
    /**
     * Returns the `child` Key of this Key.
     *
     * @param {Key} key - The child Key to add
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */ child(key) {
        if (this.toString() === pathSepS) return key;
        else if (key.toString() === pathSepS) return this;
        return new Key(this.toString() + key.toString(), false);
    }
    /**
     * Returns whether this key is a prefix of `other`
     *
     * @param {Key} other - The other key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
     * // => true
     * ```
     */ isAncestorOf(other) {
        if (other.toString() === this.toString()) return false;
        return other.toString().startsWith(this.toString());
    }
    /**
     * Returns whether this key is a contains another as prefix.
     *
     * @param {Key} other - The other Key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
     * // => true
     * ```
     */ isDecendantOf(other) {
        if (other.toString() === this.toString()) return false;
        return this.toString().startsWith(other.toString());
    }
    /**
     * Checks if this key has only one namespace.
     *
     * @returns {boolean}
     */ isTopLevel() {
        return this.list().length === 1;
    }
    /**
     * Concats one or more Keys into one new Key.
     *
     * @param {Array<Key>} keys - The array of keys to concatenate
     * @returns {Key}
     */ concat(...keys) {
        return Key.withNamespaces([
            ...this.namespaces(),
            ...flatten(keys.map((key)=>key.namespaces()))
        ]);
    }
}
/**
 * The first component of a namespace. `foo` in `foo:bar`
 *
 * @param {string} ns
 * @returns {string}
 */ function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) return "";
    return parts.slice(0, -1).join(":");
}
/**
 * The last component of a namespace, `baz` in `foo:bar:baz`.
 *
 * @param {string} ns
 * @returns {string}
 */ function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
}
/**
 * Flatten array of arrays (only one level)
 *
 * @template T
 * @param {Array<any>} arr
 * @returns {T[]}
 */ function flatten(arr) {
    return [].concat(...arr);
}

},{"uint8arrays/from-string":"3YvUV","uint8arrays/to-string":"63irA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cTqT7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toPeerPB", ()=>toPeerPB);
var _interface = require("@libp2p/interface");
var _equals = require("uint8arrays/equals");
var _errorsJs = require("../errors.js");
var _dedupeAddressesJs = require("./dedupe-addresses.js");
async function toPeerPB(peerId, data, strategy, options) {
    if (data == null) throw new (0, _interface.CodeError)("Invalid PeerData", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    if (data.publicKey != null && peerId.publicKey != null && !(0, _equals.equals)(data.publicKey, peerId.publicKey)) throw new (0, _interface.CodeError)("publicKey bytes do not match peer id publicKey bytes", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    const existingPeer = options.existingPeer;
    if (existingPeer != null && !peerId.equals(existingPeer.id)) throw new (0, _interface.CodeError)("peer id did not match existing peer id", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    let addresses = existingPeer?.addresses ?? [];
    let protocols = new Set(existingPeer?.protocols ?? []);
    let metadata = existingPeer?.metadata ?? new Map();
    let tags = existingPeer?.tags ?? new Map();
    let peerRecordEnvelope = existingPeer?.peerRecordEnvelope;
    // when patching, we replace the original fields with passed values
    if (strategy === "patch") {
        if (data.multiaddrs != null || data.addresses != null) {
            addresses = [];
            if (data.multiaddrs != null) addresses.push(...data.multiaddrs.map((multiaddr)=>({
                    isCertified: false,
                    multiaddr
                })));
            if (data.addresses != null) addresses.push(...data.addresses);
        }
        if (data.protocols != null) protocols = new Set(data.protocols);
        if (data.metadata != null) {
            const metadataEntries = data.metadata instanceof Map ? [
                ...data.metadata.entries()
            ] : Object.entries(data.metadata);
            metadata = createSortedMap(metadataEntries, {
                validate: validateMetadata
            });
        }
        if (data.tags != null) {
            const tagsEntries = data.tags instanceof Map ? [
                ...data.tags.entries()
            ] : Object.entries(data.tags);
            tags = createSortedMap(tagsEntries, {
                validate: validateTag,
                map: mapTag
            });
        }
        if (data.peerRecordEnvelope != null) peerRecordEnvelope = data.peerRecordEnvelope;
    }
    // when merging, we join the original fields with passed values
    if (strategy === "merge") {
        if (data.multiaddrs != null) addresses.push(...data.multiaddrs.map((multiaddr)=>({
                isCertified: false,
                multiaddr
            })));
        if (data.addresses != null) addresses.push(...data.addresses);
        if (data.protocols != null) protocols = new Set([
            ...protocols,
            ...data.protocols
        ]);
        if (data.metadata != null) {
            const metadataEntries = data.metadata instanceof Map ? [
                ...data.metadata.entries()
            ] : Object.entries(data.metadata);
            for (const [key, value] of metadataEntries)if (value == null) metadata.delete(key);
            else metadata.set(key, value);
            metadata = createSortedMap([
                ...metadata.entries()
            ], {
                validate: validateMetadata
            });
        }
        if (data.tags != null) {
            const tagsEntries = data.tags instanceof Map ? [
                ...data.tags.entries()
            ] : Object.entries(data.tags);
            const mergedTags = new Map(tags);
            for (const [key, value] of tagsEntries)if (value == null) mergedTags.delete(key);
            else mergedTags.set(key, value);
            tags = createSortedMap([
                ...mergedTags.entries()
            ], {
                validate: validateTag,
                map: mapTag
            });
        }
        if (data.peerRecordEnvelope != null) peerRecordEnvelope = data.peerRecordEnvelope;
    }
    const output = {
        addresses: await (0, _dedupeAddressesJs.dedupeFilterAndSortAddresses)(peerId, options.addressFilter ?? (async ()=>true), addresses),
        protocols: [
            ...protocols.values()
        ].sort((a, b)=>{
            return a.localeCompare(b);
        }),
        metadata,
        tags,
        publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,
        peerRecordEnvelope
    };
    // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it
    if (peerId.type !== "RSA") delete output.publicKey;
    return output;
}
/**
 * In JS maps are ordered by insertion order so create a new map with the
 * keys inserted in alphabetical order.
 */ function createSortedMap(entries, options) {
    const output = new Map();
    for (const [key, value] of entries){
        if (value == null) continue;
        options.validate(key, value);
    }
    for (const [key, value] of entries.sort(([a], [b])=>{
        return a.localeCompare(b);
    }))if (value != null) output.set(key, options.map?.(key, value) ?? value);
    return output;
}
function validateMetadata(key, value) {
    if (typeof key !== "string") throw new (0, _interface.CodeError)("Metadata key must be a string", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    if (!(value instanceof Uint8Array)) throw new (0, _interface.CodeError)("Metadata value must be a Uint8Array", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
}
function validateTag(key, tag) {
    if (typeof key !== "string") throw new (0, _interface.CodeError)("Tag name must be a string", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    if (tag.value != null) {
        if (parseInt(`${tag.value}`, 10) !== tag.value) throw new (0, _interface.CodeError)("Tag value must be an integer", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        if (tag.value < 0 || tag.value > 100) throw new (0, _interface.CodeError)("Tag value must be between 0-100", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    }
    if (tag.ttl != null) {
        if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) throw new (0, _interface.CodeError)("Tag ttl must be an integer", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        if (tag.ttl < 0) throw new (0, _interface.CodeError)("Tag ttl must be between greater than 0", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
    }
}
function mapTag(key, tag) {
    let expiry;
    if (tag.expiry != null) expiry = tag.expiry;
    if (tag.ttl != null) expiry = BigInt(Date.now() + Number(tag.ttl));
    return {
        value: tag.value ?? 0,
        expiry
    };
}

},{"@libp2p/interface":"b14bx","uint8arrays/equals":"CKVqX","../errors.js":"gUvdd","./dedupe-addresses.js":"fzjgU","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fzjgU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dedupeFilterAndSortAddresses", ()=>dedupeFilterAndSortAddresses);
var _interface = require("@libp2p/interface");
var _multiaddr = require("@multiformats/multiaddr");
var _errorsJs = require("../errors.js");
async function dedupeFilterAndSortAddresses(peerId, filter, addresses) {
    const addressMap = new Map();
    for (const addr of addresses){
        if (addr == null) continue;
        if (addr.multiaddr instanceof Uint8Array) addr.multiaddr = (0, _multiaddr.multiaddr)(addr.multiaddr);
        if (!(0, _multiaddr.isMultiaddr)(addr.multiaddr)) throw new (0, _interface.CodeError)("Multiaddr was invalid", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        if (!await filter(peerId, addr.multiaddr)) continue;
        const isCertified = addr.isCertified ?? false;
        const maStr = addr.multiaddr.toString();
        const existingAddr = addressMap.get(maStr);
        if (existingAddr != null) addr.isCertified = existingAddr.isCertified || isCertified;
        else addressMap.set(maStr, {
            multiaddr: addr.multiaddr,
            isCertified
        });
    }
    return [
        ...addressMap.values()
    ].sort((a, b)=>{
        return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ isCertified, multiaddr })=>({
            isCertified,
            multiaddr: multiaddr.bytes
        }));
}

},{"@libp2p/interface":"b14bx","@multiformats/multiaddr":"7Qpz2","../errors.js":"gUvdd","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ipHme":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MemoryDatastore", ()=>MemoryDatastore);
var _key = require("interface-datastore/key");
var _baseJs = require("./base.js");
var _errorsJs = require("./errors.js");
class MemoryDatastore extends (0, _baseJs.BaseDatastore) {
    data;
    constructor(){
        super();
        this.data = new Map();
    }
    put(key, val) {
        this.data.set(key.toString(), val);
        return key;
    }
    get(key) {
        const result = this.data.get(key.toString());
        if (result == null) throw _errorsJs.notFoundError();
        return result;
    }
    has(key) {
        return this.data.has(key.toString());
    }
    delete(key) {
        this.data.delete(key.toString());
    }
    *_all() {
        for (const [key, value] of this.data.entries())yield {
            key: new (0, _key.Key)(key),
            value
        };
    }
    *_allKeys() {
        for (const key of this.data.keys())yield new (0, _key.Key)(key);
    }
}

},{"interface-datastore/key":"kWD9d","./base.js":"jLoLn","./errors.js":"fQQno","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jLoLn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseDatastore", ()=>BaseDatastore);
var _itDrain = require("it-drain");
var _itDrainDefault = parcelHelpers.interopDefault(_itDrain);
var _itFilter = require("it-filter");
var _itFilterDefault = parcelHelpers.interopDefault(_itFilter);
var _itSort = require("it-sort");
var _itSortDefault = parcelHelpers.interopDefault(_itSort);
var _itTake = require("it-take");
var _itTakeDefault = parcelHelpers.interopDefault(_itTake);
class BaseDatastore {
    put(key, val, options) {
        return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options) {
        return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options) {
        return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options) {
        return Promise.reject(new Error(".delete is not implemented"));
    }
    async *putMany(source, options = {}) {
        for await (const { key, value } of source){
            await this.put(key, value, options);
            yield key;
        }
    }
    async *getMany(source, options = {}) {
        for await (const key of source)yield {
            key,
            value: await this.get(key, options)
        };
    }
    async *deleteMany(source, options = {}) {
        for await (const key of source){
            await this.delete(key, options);
            yield key;
        }
    }
    batch() {
        let puts = [];
        let dels = [];
        return {
            put (key, value) {
                puts.push({
                    key,
                    value
                });
            },
            delete (key) {
                dels.push(key);
            },
            commit: async (options)=>{
                await (0, _itDrainDefault.default)(this.putMany(puts, options));
                puts = [];
                await (0, _itDrainDefault.default)(this.deleteMany(dels, options));
                dels = [];
            }
        };
    }
    /**
     * Extending classes should override `query` or implement this method
     */ // eslint-disable-next-line require-yield
    async *_all(q, options) {
        throw new Error("._all is not implemented");
    }
    /**
     * Extending classes should override `queryKeys` or implement this method
     */ // eslint-disable-next-line require-yield
    async *_allKeys(q, options) {
        throw new Error("._allKeys is not implemented");
    }
    query(q, options) {
        let it = this._all(q, options);
        if (q.prefix != null) {
            const prefix = q.prefix;
            it = (0, _itFilterDefault.default)(it, (e)=>e.key.toString().startsWith(prefix));
        }
        if (Array.isArray(q.filters)) it = q.filters.reduce((it, f)=>(0, _itFilterDefault.default)(it, f), it);
        if (Array.isArray(q.orders)) it = q.orders.reduce((it, f)=>(0, _itSortDefault.default)(it, f), it);
        if (q.offset != null) {
            let i = 0;
            const offset = q.offset;
            it = (0, _itFilterDefault.default)(it, ()=>i++ >= offset);
        }
        if (q.limit != null) it = (0, _itTakeDefault.default)(it, q.limit);
        return it;
    }
    queryKeys(q, options) {
        let it = this._allKeys(q, options);
        if (q.prefix != null) {
            const prefix = q.prefix;
            it = (0, _itFilterDefault.default)(it, (key)=>key.toString().startsWith(prefix));
        }
        if (Array.isArray(q.filters)) it = q.filters.reduce((it, f)=>(0, _itFilterDefault.default)(it, f), it);
        if (Array.isArray(q.orders)) it = q.orders.reduce((it, f)=>(0, _itSortDefault.default)(it, f), it);
        if (q.offset != null) {
            const offset = q.offset;
            let i = 0;
            it = (0, _itFilterDefault.default)(it, ()=>i++ >= offset);
        }
        if (q.limit != null) it = (0, _itTakeDefault.default)(it, q.limit);
        return it;
    }
}

},{"it-drain":"hQUgs","it-filter":"iYWPo","it-sort":"aw83D","it-take":"gVzdE","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hQUgs":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.
 *
 * @example
 *
 * ```javascript
 * import drain from 'it-drain'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * drain(values)
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import drain from 'it-drain'
 *
 * const values = async function * {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * await drain(values())
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
    if (isAsyncIterable(source)) return (async ()=>{
        for await (const _ of source); // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars
    })();
    else {
        for (const _ of source); // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars
    }
}
exports.default = drain;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iYWPo":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Filter values out of an (async)iterable
 *
 * @example
 *
 * ```javascript
 * import all from 'it-all'
 * import filter from 'it-filter'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * const fn = val => val > 2 // Return boolean to keep item
 *
 * const arr = all(filter(values, fn))
 *
 * console.info(arr) // 3, 4
 * ```
 *
 * Async sources and filter functions must be awaited:
 *
 * ```javascript
 * import all from 'it-all'
 * import filter from 'it-filter'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const fn = async val => val > 2 // Return boolean or promise of boolean to keep item
 *
 * const arr = await all(filter(values, fn))
 *
 * console.info(arr) // 3, 4
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itPeekable = require("it-peekable");
var _itPeekableDefault = parcelHelpers.interopDefault(_itPeekable);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
    if (isAsyncIterable(source)) return async function*() {
        for await (const entry of source)if (await fn(entry)) yield entry;
    }();
    // if mapping function returns a promise we have to return an async generator
    const peekable = (0, _itPeekableDefault.default)(source);
    const { value, done } = peekable.next();
    if (done === true) return function*() {}();
    const res = fn(value);
    // @ts-expect-error .then is not present on O
    if (typeof res.then === "function") return async function*() {
        if (await res) yield value;
        for await (const entry of peekable)if (await fn(entry)) yield entry;
    }();
    const func = fn;
    return function*() {
        if (res === true) yield value;
        for (const entry of peekable)if (func(entry)) yield entry;
    }();
}
exports.default = filter;

},{"it-peekable":"2V0IL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2V0IL":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Lets you look at the contents of an async iterator and decide what to do
 *
 * @example
 *
 * ```javascript
 * import peekable from 'it-peekable'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * const it = peekable(value)
 *
 * const first = it.peek()
 *
 * console.info(first) // 0
 *
 * it.push(first)
 *
 * console.info([...it])
 * // [ 0, 1, 2, 3, 4 ]
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import peekable from 'it-peekable'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const it = peekable(values())
 *
 * const first = await it.peek()
 *
 * console.info(first) // 0
 *
 * it.push(first)
 *
 * console.info(await all(it))
 * // [ 0, 1, 2, 3, 4 ]
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function peekable(iterable) {
    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable
    const [iterator, symbol] = iterable[Symbol.asyncIterator] != null ? [
        iterable[Symbol.asyncIterator](),
        Symbol.asyncIterator
    ] : [
        iterable[Symbol.iterator](),
        Symbol.iterator
    ];
    const queue = [];
    // @ts-expect-error can't use symbol to index peekable
    return {
        peek: ()=>{
            return iterator.next();
        },
        push: (value)=>{
            queue.push(value);
        },
        next: ()=>{
            if (queue.length > 0) return {
                done: false,
                value: queue.shift()
            };
            return iterator.next();
        },
        [symbol] () {
            return this;
        }
    };
}
exports.default = peekable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aw83D":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.
 *
 * @example
 *
 * ```javascript
 * import sort from 'it-sort'
 * import all from 'it-all'
 *
 * const sorter = (a, b) => {
 *   return a.localeCompare(b)
 * }
 *
 * // This can also be an iterator, generator, etc
 * const values = ['foo', 'bar']
 *
 * const arr = all(sort(values, sorter))
 *
 * console.info(arr) // 'bar', 'foo'
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import sort from 'it-sort'
 * import all from 'it-all'
 *
 * const sorter = (a, b) => {
 *   return a.localeCompare(b)
 * }
 *
 * const values = async function * () {
 *   yield * ['foo', 'bar']
 * }
 *
 * const arr = await all(sort(values, sorter))
 *
 * console.info(arr) // 'bar', 'foo'
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itAll = require("it-all");
var _itAllDefault = parcelHelpers.interopDefault(_itAll);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
    if (isAsyncIterable(source)) return async function*() {
        const arr = await (0, _itAllDefault.default)(source);
        yield* arr.sort(sorter);
    }();
    return function*() {
        const arr = (0, _itAllDefault.default)(source);
        yield* arr.sort(sorter);
    }();
}
exports.default = sort;

},{"it-all":"a2ZbU","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gVzdE":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * For when you only want a few values out of an (async)iterable.
 *
 * @example
 *
 * ```javascript
 * import take from 'it-take'
 * import all from 'it-all'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * const arr = all(take(values, 2))
 *
 * console.info(arr) // 0, 1
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import take from 'it-take'
 * import all from 'it-all'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const arr = await all(take(values(), 2))
 *
 * console.info(arr) // 0, 1
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
    if (isAsyncIterable(source)) return async function*() {
        let items = 0;
        if (limit < 1) return;
        for await (const entry of source){
            yield entry;
            items++;
            if (items === limit) return;
        }
    }();
    return function*() {
        let items = 0;
        if (limit < 1) return;
        for (const entry of source){
            yield entry;
            items++;
            if (items === limit) return;
        }
    }();
}
exports.default = take;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fQQno":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dbOpenFailedError", ()=>dbOpenFailedError);
parcelHelpers.export(exports, "dbDeleteFailedError", ()=>dbDeleteFailedError);
parcelHelpers.export(exports, "dbWriteFailedError", ()=>dbWriteFailedError);
parcelHelpers.export(exports, "dbReadFailedError", ()=>dbReadFailedError);
parcelHelpers.export(exports, "notFoundError", ()=>notFoundError);
parcelHelpers.export(exports, "abortedError", ()=>abortedError);
var _errCode = require("err-code");
var _errCodeDefault = parcelHelpers.interopDefault(_errCode);
function dbOpenFailedError(err) {
    err = err ?? new Error("Cannot open database");
    return (0, _errCodeDefault.default)(err, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err) {
    err = err ?? new Error("Delete failed");
    return (0, _errCodeDefault.default)(err, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err) {
    err = err ?? new Error("Write failed");
    return (0, _errCodeDefault.default)(err, "ERR_DB_WRITE_FAILED");
}
function dbReadFailedError(err) {
    err = err ?? new Error("Read failed");
    return (0, _errCodeDefault.default)(err, "ERR_DB_READ_FAILED");
}
function notFoundError(err) {
    err = err ?? new Error("Not Found");
    return (0, _errCodeDefault.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
    err = err ?? new Error("Aborted");
    return (0, _errCodeDefault.default)(err, "ERR_ABORTED");
}

},{"err-code":"dUrrM","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dUrrM":[function(require,module,exports) {
"use strict";
/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */ /**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */ function assign(obj, props) {
    for(const key in props)Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true
    });
    return obj;
}
/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */ function createError(err, code, props) {
    if (!err || typeof err === "string") throw new TypeError("Please pass an Error to err-code");
    if (!props) props = {};
    if (typeof code === "object") {
        props = code;
        code = "";
    }
    if (code) props.code = code;
    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {};
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        // @ts-ignore
        const output = assign(new ErrClass(), props);
        return output;
    }
}
module.exports = createError;

},{}],"e0oKn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultAddressManager", ()=>DefaultAddressManager);
var _peerId = require("@libp2p/peer-id");
var _multiaddr = require("@multiformats/multiaddr");
var _utilsJs = require("./utils.js");
const defaultAddressFilter = (addrs)=>addrs;
/**
 * If the passed multiaddr contains the passed peer id, remove it
 */ function stripPeerId(ma, peerId) {
    const observedPeerIdStr = ma.getPeerId();
    // strip our peer id if it has been passed
    if (observedPeerIdStr != null) {
        const observedPeerId = (0, _peerId.peerIdFromString)(observedPeerIdStr);
        // use same encoding for comparison
        if (observedPeerId.equals(peerId)) ma = ma.decapsulate((0, _multiaddr.multiaddr)(`/p2p/${peerId.toString()}`));
    }
    return ma;
}
class DefaultAddressManager {
    log;
    components;
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    listen;
    announce;
    observed;
    announceFilter;
    /**
     * Responsible for managing the peer addresses.
     * Peers can specify their listen and announce addresses.
     * The listen addresses will be used by the libp2p transports to listen for new connections,
     * while the announce addresses will be used for the peer addresses' to other peers in the network.
     */ constructor(components, init = {}){
        const { listen = [], announce = [] } = init;
        this.components = components;
        this.log = components.logger.forComponent("libp2p:address-manager");
        this.listen = listen.map((ma)=>ma.toString());
        this.announce = new Set(announce.map((ma)=>ma.toString()));
        this.observed = new Map();
        this.announceFilter = init.announceFilter ?? defaultAddressFilter;
        // this method gets called repeatedly on startup when transports start listening so
        // debounce it so we don't cause multiple self:peer:update events to be emitted
        this._updatePeerStoreAddresses = (0, _utilsJs.debounce)(this._updatePeerStoreAddresses.bind(this), 1000);
        // update our stored addresses when new transports listen
        components.events.addEventListener("transport:listening", ()=>{
            this._updatePeerStoreAddresses();
        });
        // update our stored addresses when existing transports stop listening
        components.events.addEventListener("transport:close", ()=>{
            this._updatePeerStoreAddresses();
        });
    }
    _updatePeerStoreAddresses() {
        // if announce addresses have been configured, ensure they make it into our peer
        // record for things like identify
        const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([
            ...this.observed.entries()
        ].filter(([_, metadata])=>metadata.confident).map(([str])=>(0, _multiaddr.multiaddr)(str))).map((ma)=>{
            // strip our peer id if it is present
            if (ma.getPeerId() === this.components.peerId.toString()) return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
            return ma;
        });
        this.components.peerStore.patch(this.components.peerId, {
            multiaddrs: addrs
        }).catch((err)=>{
            this.log.error("error updating addresses", err);
        });
    }
    /**
     * Get peer listen multiaddrs
     */ getListenAddrs() {
        return Array.from(this.listen).map((a)=>(0, _multiaddr.multiaddr)(a));
    }
    /**
     * Get peer announcing multiaddrs
     */ getAnnounceAddrs() {
        return Array.from(this.announce).map((a)=>(0, _multiaddr.multiaddr)(a));
    }
    /**
     * Get observed multiaddrs
     */ getObservedAddrs() {
        return Array.from(this.observed).map(([a])=>(0, _multiaddr.multiaddr)(a));
    }
    /**
     * Add peer observed addresses
     */ addObservedAddr(addr) {
        addr = stripPeerId(addr, this.components.peerId);
        const addrString = addr.toString();
        // do not trigger the change:addresses event if we already know about this address
        if (this.observed.has(addrString)) return;
        this.observed.set(addrString, {
            confident: false
        });
    }
    confirmObservedAddr(addr) {
        addr = stripPeerId(addr, this.components.peerId);
        const addrString = addr.toString();
        const metadata = this.observed.get(addrString) ?? {
            confident: false
        };
        const startingConfidence = metadata.confident;
        this.observed.set(addrString, {
            confident: true
        });
        // only trigger the 'self:peer:update' event if our confidence in an address has changed
        if (!startingConfidence) this._updatePeerStoreAddresses();
    }
    removeObservedAddr(addr) {
        addr = stripPeerId(addr, this.components.peerId);
        const addrString = addr.toString();
        this.observed.delete(addrString);
    }
    getAddresses() {
        let addrs = this.getAnnounceAddrs().map((ma)=>ma.toString());
        if (addrs.length === 0) // no configured announce addrs, add configured listen addresses
        addrs = this.components.transportManager.getAddrs().map((ma)=>ma.toString());
        // add observed addresses we are confident in
        addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata])=>metadata.confident).map(([ma])=>ma));
        // dedupe multiaddrs
        const addrSet = new Set(addrs);
        // Create advertising list
        return this.announceFilter(Array.from(addrSet).map((str)=>(0, _multiaddr.multiaddr)(str))).map((ma)=>{
            // do not append our peer id to a path multiaddr as it will become invalid
            if (ma.protos().pop()?.path === true) return ma;
            if (ma.getPeerId() === this.components.peerId.toString()) return ma;
            return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
        });
    }
}

},{"@libp2p/peer-id":"8wBUr","@multiformats/multiaddr":"7Qpz2","./utils.js":"kH2W1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kH2W1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "debounce", ()=>debounce);
function debounce(func, wait) {
    let timeout;
    return function() {
        const later = function() {
            timeout = undefined;
            func();
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2f57U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultComponents", ()=>defaultComponents);
var _interface = require("@libp2p/interface");
var _logger = require("@libp2p/logger");
class DefaultComponents {
    components = {};
    _started = false;
    constructor(init = {}){
        this.components = {};
        for (const [key, value] of Object.entries(init))this.components[key] = value;
        if (this.components.logger == null) this.components.logger = (0, _logger.defaultLogger)();
    }
    isStarted() {
        return this._started;
    }
    async _invokeStartableMethod(methodName) {
        await Promise.all(Object.values(this.components).filter((obj)=>(0, _interface.isStartable)(obj)).map(async (startable)=>{
            await startable[methodName]?.();
        }));
    }
    async beforeStart() {
        await this._invokeStartableMethod("beforeStart");
    }
    async start() {
        await this._invokeStartableMethod("start");
        this._started = true;
    }
    async afterStart() {
        await this._invokeStartableMethod("afterStart");
    }
    async beforeStop() {
        await this._invokeStartableMethod("beforeStop");
    }
    async stop() {
        await this._invokeStartableMethod("stop");
        this._started = false;
    }
    async afterStop() {
        await this._invokeStartableMethod("afterStop");
    }
}
const OPTIONAL_SERVICES = [
    "metrics",
    "connectionProtector"
];
const NON_SERVICE_PROPERTIES = [
    "components",
    "isStarted",
    "beforeStart",
    "start",
    "afterStart",
    "beforeStop",
    "stop",
    "afterStop",
    "then",
    "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
    const components = new DefaultComponents(init);
    const proxy = new Proxy(components, {
        get (target, prop, receiver) {
            if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
                const service = components.components[prop];
                if (service == null && !OPTIONAL_SERVICES.includes(prop)) throw new (0, _interface.CodeError)(`${prop} not set`, "ERR_SERVICE_MISSING");
                return service;
            }
            return Reflect.get(target, prop, receiver);
        },
        set (target, prop, value) {
            if (typeof prop === "string") components.components[prop] = value;
            else Reflect.set(target, prop, value);
            return true;
        }
    });
    // @ts-expect-error component keys are proxied
    return proxy;
}

},{"@libp2p/interface":"b14bx","@libp2p/logger":"aeh5U","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2AmjA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a connection gater that disallows dialling private addresses by
 * default. Browsers are severely limited in their resource usage so don't
 * waste time trying to dial undiallable addresses.
 */ parcelHelpers.export(exports, "connectionGater", ()=>connectionGater);
var _privateIp = require("@libp2p/utils/private-ip");
function connectionGater(gater = {}) {
    return {
        denyDialPeer: async ()=>false,
        denyDialMultiaddr: async (multiaddr)=>{
            const tuples = multiaddr.stringTuples();
            if (tuples[0][0] === 4 || tuples[0][0] === 41) return Boolean((0, _privateIp.isPrivateIp)(`${tuples[0][1]}`));
            return false;
        },
        denyInboundConnection: async ()=>false,
        denyOutboundConnection: async ()=>false,
        denyInboundEncryptedConnection: async ()=>false,
        denyOutboundEncryptedConnection: async ()=>false,
        denyInboundUpgradedConnection: async ()=>false,
        denyOutboundUpgradedConnection: async ()=>false,
        filterMultiaddrForPeer: async ()=>true,
        ...gater
    };
}

},{"@libp2p/utils/private-ip":"3LaSy","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3LaSy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPrivateIp", ()=>isPrivateIp);
var _isIp = require("@chainsafe/is-ip");
var _netmask = require("netmask");
const PRIVATE_IP_RANGES = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.0.0/24",
    "192.0.0.0/29",
    "192.0.0.8/32",
    "192.0.0.9/32",
    "192.0.0.10/32",
    "192.0.0.170/32",
    "192.0.0.171/32",
    "192.0.2.0/24",
    "192.31.196.0/24",
    "192.52.193.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "192.175.48.0/24",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "240.0.0.0/4",
    "255.255.255.255/32"
];
const NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange)=>new (0, _netmask.Netmask)(ipRange));
function ipv4Check(ipAddr) {
    for (const r of NETMASK_RANGES){
        if (r.contains(ipAddr)) return true;
    }
    return false;
}
function ipv6Check(ipAddr) {
    return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
    if ((0, _isIp.isIPv4)(ip)) return ipv4Check(ip);
    else if ((0, _isIp.isIPv6)(ip)) return ipv6Check(ip);
    else return undefined;
}

},{"@chainsafe/is-ip":"aTlfV","netmask":"am2bo","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"am2bo":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
    long2ip = function(long) {
        var a, b, c, d;
        a = (long & -16777216) >>> 24;
        b = (long & 16711680) >>> 16;
        c = (long & 65280) >>> 8;
        d = long & 0xff;
        return [
            a,
            b,
            c,
            d
        ].join(".");
    };
    ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for(i = j = 0; j <= 3; i = ++j){
            if (ip.length === 0) break;
            if (i > 0) {
                if (ip[0] !== ".") throw new Error("Invalid IP");
                ip = ip.substring(1);
            }
            ref = atob(ip), n = ref[0], c = ref[1];
            ip = ip.substring(c);
            b.push(n);
        }
        if (ip.length !== 0) throw new Error("Invalid IP");
        switch(b.length){
            case 1:
                if (b[0] > 0xFFFFFFFF) throw new Error("Invalid IP");
                return b[0] >>> 0;
            case 2:
                if (b[0] > 0xFF || b[1] > 0xFFFFFF) throw new Error("Invalid IP");
                return (b[0] << 24 | b[1]) >>> 0;
            case 3:
                if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) throw new Error("Invalid IP");
                return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
            case 4:
                if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) throw new Error("Invalid IP");
                return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
            default:
                throw new Error("Invalid IP");
        }
    };
    chr = function(b) {
        return b.charCodeAt(0);
    };
    chr0 = chr("0");
    chra = chr("a");
    chrA = chr("A");
    atob = function(s) {
        var base, dmax, i, n, start;
        n = 0;
        base = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
            if (s[i + 1] === "x" || s[i + 1] === "X") {
                i += 2;
                base = 16;
            } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
                i++;
                base = 8;
                dmax = "7";
            }
        }
        start = i;
        while(i < s.length){
            if ("0" <= s[i] && s[i] <= dmax) n = n * base + (chr(s[i]) - chr0) >>> 0;
            else if (base === 16) {
                if ("a" <= s[i] && s[i] <= "f") n = n * base + (10 + chr(s[i]) - chra) >>> 0;
                else if ("A" <= s[i] && s[i] <= "F") n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
                else break;
            } else break;
            if (n > 0xFFFFFFFF) throw new Error("too large");
            i++;
        }
        if (i === start) throw new Error("empty octet");
        return [
            n,
            i
        ];
    };
    Netmask = function() {
        function Netmask(net, mask) {
            var error, i, j, ref;
            if (typeof net !== "string") throw new Error("Missing `net' parameter");
            if (!mask) ref = net.split("/", 2), net = ref[0], mask = ref[1];
            if (!mask) mask = 32;
            if (typeof mask === "string" && mask.indexOf(".") > -1) {
                try {
                    this.maskLong = ip2long(mask);
                } catch (error1) {
                    error = error1;
                    throw new Error("Invalid mask: " + mask);
                }
                for(i = j = 32; j >= 0; i = --j)if (this.maskLong === 0xffffffff << 32 - i >>> 0) {
                    this.bitmask = i;
                    break;
                }
            } else if (mask || mask === 0) {
                this.bitmask = parseInt(mask, 10);
                this.maskLong = 0;
                if (this.bitmask > 0) this.maskLong = 0xffffffff << 32 - this.bitmask >>> 0;
            } else throw new Error("Invalid mask: empty");
            try {
                this.netLong = (ip2long(net) & this.maskLong) >>> 0;
            } catch (error1) {
                error = error1;
                throw new Error("Invalid net address: " + net);
            }
            if (!(this.bitmask <= 32)) throw new Error("Invalid mask for ip4: " + mask);
            this.size = Math.pow(2, 32 - this.bitmask);
            this.base = long2ip(this.netLong);
            this.mask = long2ip(this.maskLong);
            this.hostmask = long2ip(~this.maskLong);
            this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
            this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
            this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask.prototype.contains = function(ip) {
            if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) ip = new Netmask(ip);
            if (ip instanceof Netmask) return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
            else return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
        };
        Netmask.prototype.next = function(count) {
            if (count == null) count = 1;
            return new Netmask(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask.prototype.forEach = function(fn) {
            var index, lastLong, long;
            long = ip2long(this.first);
            lastLong = ip2long(this.last);
            index = 0;
            while(long <= lastLong){
                fn(long2ip(long), long, index);
                index++;
                long++;
            }
        };
        Netmask.prototype.toString = function() {
            return this.base + "/" + this.bitmask;
        };
        return Netmask;
    }();
    exports.ip2long = ip2long;
    exports.long2ip = long2ip;
    exports.Netmask = Netmask;
}).call(this);

},{}],"iJ0mm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateConfig", ()=>validateConfig);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _addressSort = require("@libp2p/utils/address-sort");
var _resolvers = require("@multiformats/multiaddr/resolvers");
var _mergeOptions = require("merge-options");
var _mergeOptionsDefault = parcelHelpers.interopDefault(_mergeOptions);
var _errorsJs = require("./errors.js");
const DefaultConfig = {
    addresses: {
        listen: [],
        announce: [],
        noAnnounce: [],
        announceFilter: (multiaddrs)=>multiaddrs
    },
    connectionManager: {
        resolvers: {
            dnsaddr: (0, _resolvers.dnsaddrResolver)
        },
        addressSorter: (0, _addressSort.defaultAddressSort)
    },
    transportManager: {
        faultTolerance: (0, _interface.FaultTolerance).FATAL_ALL
    }
};
async function validateConfig(opts) {
    const resultingOptions = (0, _mergeOptionsDefault.default)(DefaultConfig, opts);
    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) throw new (0, _interface.CodeError)((0, _errorsJs.messages).ERR_PROTECTOR_REQUIRED, (0, _errorsJs.codes).ERR_PROTECTOR_REQUIRED);
    if (!(await (0, _peerId.peerIdFromKeys)(resultingOptions.privateKey.public.bytes, resultingOptions.privateKey.bytes)).equals(resultingOptions.peerId)) throw new (0, _interface.CodeError)("Private key doesn't match peer id", (0, _errorsJs.codes).ERR_INVALID_KEY);
    return resultingOptions;
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@libp2p/utils/address-sort":"hXpHf","@multiformats/multiaddr/resolvers":"fZLfL","merge-options":"l45Gy","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hXpHf":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Provides strategies to sort a list of multiaddrs.
 *
 * @example
 *
 * ```typescript
 * import { publicAddressesFirst } from '@libp2p/utils/address-sort'
 * import { multiaddr } from '@multformats/multiaddr'
 *
 *
 * const addresses = [
 *   multiaddr('/ip4/127.0.0.1/tcp/9000'),
 *   multiaddr('/ip4/82.41.53.1/tcp/9000')
 * ].sort(publicAddressesFirst)
 *
 * console.info(addresses)
 * // ['/ip4/82.41.53.1/tcp/9000', '/ip4/127.0.0.1/tcp/9000']
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compare function for array.sort() that moves public addresses to the start
 * of the array.
 */ parcelHelpers.export(exports, "publicAddressesFirst", ()=>publicAddressesFirst);
/**
 * Compare function for array.sort() that moves certified addresses to the start
 * of the array.
 */ parcelHelpers.export(exports, "certifiedAddressesFirst", ()=>certifiedAddressesFirst);
/**
 * Compare function for array.sort() that moves circuit relay addresses to the
 * start of the array.
 */ parcelHelpers.export(exports, "circuitRelayAddressesLast", ()=>circuitRelayAddressesLast);
parcelHelpers.export(exports, "defaultAddressSort", ()=>defaultAddressSort);
var _multiaddrMatcher = require("@multiformats/multiaddr-matcher");
var _isPrivateJs = require("./multiaddr/is-private.js");
function publicAddressesFirst(a, b) {
    const isAPrivate = (0, _isPrivateJs.isPrivate)(a.multiaddr);
    const isBPrivate = (0, _isPrivateJs.isPrivate)(b.multiaddr);
    if (isAPrivate && !isBPrivate) return 1;
    else if (!isAPrivate && isBPrivate) return -1;
    return 0;
}
function certifiedAddressesFirst(a, b) {
    if (a.isCertified && !b.isCertified) return -1;
    else if (!a.isCertified && b.isCertified) return 1;
    return 0;
}
function circuitRelayAddressesLast(a, b) {
    const isACircuit = (0, _multiaddrMatcher.Circuit).exactMatch(a.multiaddr);
    const isBCircuit = (0, _multiaddrMatcher.Circuit).exactMatch(b.multiaddr);
    if (isACircuit && !isBCircuit) return 1;
    else if (!isACircuit && isBCircuit) return -1;
    return 0;
}
function defaultAddressSort(a, b) {
    const publicResult = publicAddressesFirst(a, b);
    if (publicResult !== 0) return publicResult;
    const relayResult = circuitRelayAddressesLast(a, b);
    if (relayResult !== 0) return relayResult;
    const certifiedResult = certifiedAddressesFirst(a, b);
    return certifiedResult;
}

},{"@multiformats/multiaddr-matcher":"8GlCq","./multiaddr/is-private.js":"55Ohm","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8GlCq":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module exports various matchers that can be used to infer the type of a
 * passed multiaddr.
 *
 * @example
 *
 * ```ts
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { DNS } from '@multiformats/multiaddr-matcher'
 *
 * const ma = multiaddr('/dnsaddr/example.org')
 *
 * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start
 * ```
 *
 * @example
 *
 * The default matching behaviour ignores any subsequent tuples in the multiaddr.
 * If you want stricter matching you can use `.exactMatch`:
 *
 * ```ts
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'
 *
 * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')
 *
 * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component
 * Circuit.matches(ma) // true
 * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS4", ()=>DNS4);
parcelHelpers.export(exports, "DNS6", ()=>DNS6);
parcelHelpers.export(exports, "DNSADDR", ()=>DNSADDR);
parcelHelpers.export(exports, "DNS", ()=>DNS);
parcelHelpers.export(exports, "IP_OR_DOMAIN", ()=>IP_OR_DOMAIN);
parcelHelpers.export(exports, "IP4", ()=>IP4);
parcelHelpers.export(exports, "IP6", ()=>IP6);
parcelHelpers.export(exports, "IP", ()=>IP);
parcelHelpers.export(exports, "TCP", ()=>TCP);
parcelHelpers.export(exports, "UDP", ()=>UDP);
parcelHelpers.export(exports, "QUIC", ()=>QUIC);
parcelHelpers.export(exports, "QUICV1", ()=>QUICV1);
parcelHelpers.export(exports, "WebSockets", ()=>WebSockets);
parcelHelpers.export(exports, "WebSocketsSecure", ()=>WebSocketsSecure);
parcelHelpers.export(exports, "WebRTCDirect", ()=>WebRTCDirect);
parcelHelpers.export(exports, "WebTransport", ()=>WebTransport);
parcelHelpers.export(exports, "P2P", ()=>P2P);
parcelHelpers.export(exports, "Circuit", ()=>Circuit);
parcelHelpers.export(exports, "WebRTC", ()=>WebRTC);
var _isIp = require("@chainsafe/is-ip");
var _multiaddr = require("@multiformats/multiaddr");
var _base58 = require("multiformats/bases/base58");
var _base64 = require("multiformats/bases/base64");
/**
 * Split a multiaddr into path components
 */ const toParts = (ma)=>{
    return ma.toString().split("/").slice(1);
};
const func = (fn)=>{
    return {
        match: (vals)=>{
            if (vals.length < 1) return false;
            if (fn(vals[0])) return vals.slice(1);
            return false;
        },
        pattern: "fn"
    };
};
const literal = (str)=>{
    return {
        match: (vals)=>func((val)=>val === str).match(vals),
        pattern: str
    };
};
const string = ()=>{
    return {
        match: (vals)=>func((val)=>typeof val === "string").match(vals),
        pattern: "{string}"
    };
};
const number = ()=>{
    return {
        match: (vals)=>func((val)=>!isNaN(parseInt(val))).match(vals),
        pattern: "{number}"
    };
};
const peerId = ()=>{
    return {
        match: (vals)=>{
            if (vals.length < 2) return false;
            if (vals[0] !== "p2p" && vals[0] !== "ipfs") return false;
            // Q is RSA, 1 is Ed25519 or Secp256k1
            if (vals[1].startsWith("Q") || vals[1].startsWith("1")) try {
                (0, _base58.base58btc).decode(`z${vals[1]}`);
            } catch (err) {
                return false;
            }
            else return false;
            return vals.slice(2);
        },
        pattern: "/p2p/{peerid}"
    };
};
const certhash = ()=>{
    return {
        match: (vals)=>{
            if (vals.length < 2) return false;
            if (vals[0] !== "certhash") return false;
            try {
                (0, _base64.base64url).decode(vals[1]);
            } catch  {
                return false;
            }
            return vals.slice(2);
        },
        pattern: "/certhash/{certhash}"
    };
};
const optional = (matcher)=>{
    return {
        match: (vals)=>{
            const result = matcher.match(vals);
            if (result === false) return vals;
            return result;
        },
        pattern: `optional(${matcher.pattern})`
    };
};
const or = (...matchers)=>{
    return {
        match: (vals)=>{
            let matches;
            for (const matcher of matchers){
                const result = matcher.match(vals);
                // no match
                if (result === false) continue;
                // choose greediest matcher
                if (matches == null || result.length < matches.length) matches = result;
            }
            if (matches == null) return false;
            return matches;
        },
        pattern: `or(${matchers.map((m)=>m.pattern).join(", ")})`
    };
};
const and = (...matchers)=>{
    return {
        match: (vals)=>{
            for (const matcher of matchers){
                // pass what's left of the array
                const result = matcher.match(vals);
                // no match
                if (result === false) return false;
                vals = result;
            }
            return vals;
        },
        pattern: `and(${matchers.map((m)=>m.pattern).join(", ")})`
    };
};
function fmt(...matchers) {
    function match(ma) {
        let parts = toParts(ma);
        for (const matcher of matchers){
            const result = matcher.match(parts);
            if (result === false) return false;
            parts = result;
        }
        return parts;
    }
    function matches(ma) {
        const result = match(ma);
        return result !== false;
    }
    function exactMatch(ma) {
        const result = match(ma);
        if (result === false) return false;
        return result.length === 0;
    }
    return {
        matches,
        exactMatch
    };
}
/**
 * DNS matchers
 */ const _DNS4 = and(literal("dns4"), string());
const _DNS6 = and(literal("dns6"), string());
const _DNSADDR = and(literal("dnsaddr"), string());
const _DNS = and(literal("dns"), string());
const DNS4 = fmt(_DNS4);
const DNS6 = fmt(_DNS6);
const DNSADDR = fmt(_DNSADDR);
const DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6));
const _IP4 = and(literal("ip4"), func((0, _isIp.isIPv4)));
const _IP6 = and(literal("ip6"), func((0, _isIp.isIPv6)));
const _IP = or(_IP4, _IP6);
const _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
const IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN);
const IP4 = fmt(_IP4);
const IP6 = fmt(_IP6);
const IP = fmt(_IP);
const _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number());
const _UDP = and(_IP_OR_DOMAIN, literal("udp"), number());
const TCP_OR_UDP = or(_TCP, _UDP);
const TCP = fmt(_TCP);
const UDP = fmt(_UDP);
const _QUIC = and(_UDP, literal("quic"));
const _QUICV1 = and(_UDP, literal("quic-v1"));
const QUIC_V0_OR_V1 = or(_QUIC, _QUICV1);
const QUIC = fmt(_QUIC);
const QUICV1 = fmt(_QUICV1);
const _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
const _WebSockets = or(and(_WEB, literal("ws"), optional(peerId())));
const WebSockets = fmt(_WebSockets);
const _WebSocketsSecure = or(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), literal("ws"), optional(peerId())));
const WebSocketsSecure = fmt(_WebSocketsSecure);
const _WebRTCDirect = and(TCP_OR_UDP, literal("webrtc-direct"), certhash(), optional(certhash()), optional(peerId()));
const WebRTCDirect = fmt(_WebRTCDirect);
const _WebTransport = and(_QUICV1, literal("webtransport"), certhash(), certhash(), optional(peerId()));
const WebTransport = fmt(_WebTransport);
const _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
const P2P = fmt(_P2P);
const _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
const Circuit = fmt(_Circuit);
const _WebRTC = or(and(_P2P, literal("p2p-circuit"), literal("webrtc"), peerId()), and(_P2P, literal("webrtc"), optional(peerId())), literal("webrtc"));
const WebRTC = fmt(_WebRTC);

},{"@chainsafe/is-ip":"aTlfV","@multiformats/multiaddr":"7Qpz2","multiformats/bases/base58":"9K4Ju","multiformats/bases/base64":"2m5sV","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"55Ohm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if a given multiaddr has a private address.
 */ parcelHelpers.export(exports, "isPrivate", ()=>isPrivate);
var _privateIpJs = require("../private-ip.js");
function isPrivate(ma) {
    try {
        const { address } = ma.nodeAddress();
        return Boolean((0, _privateIpJs.isPrivateIp)(address));
    } catch  {
        return true;
    }
}

},{"../private-ip.js":"3LaSy","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fZLfL":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Provides strategies for resolving multiaddrs.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Resolver for dnsaddr addresses.
 *
 * @example
 *
 * ```typescript
 * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 * const addresses = await dnsaddrResolver(ma)
 *
 * console.info(addresses)
 * //[
 * //  '/dnsaddr/am6.bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',
 * //  '/dnsaddr/ny5.bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',
 * //  '/dnsaddr/sg1.bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',
 * //  '/dnsaddr/sv15.bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'
 * //]
 * ```
 */ parcelHelpers.export(exports, "dnsaddrResolver", ()=>dnsaddrResolver);
var _protocolsTableJs = require("../protocols-table.js");
var _dnsJs = require("./dns.js");
var _dnsJsDefault = parcelHelpers.interopDefault(_dnsJs);
const { code: dnsaddrCode } = (0, _protocolsTableJs.getProtocol)("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
    const resolver = new (0, _dnsJsDefault.default)();
    if (options.signal != null) options.signal.addEventListener("abort", ()=>{
        resolver.cancel();
    });
    const peerId = addr.getPeerId();
    const [, hostname] = addr.stringTuples().find(([proto])=>proto === dnsaddrCode) ?? [];
    if (hostname == null) throw new Error("No hostname found in multiaddr");
    const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
    let addresses = records.flat().map((a)=>a.split("=")[1]).filter(Boolean);
    if (peerId != null) addresses = addresses.filter((entry)=>entry.includes(peerId));
    return addresses;
}

},{"../protocols-table.js":"fBqZI","./dns.js":"71Vy4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"71Vy4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dnsOverHttpResolver = require("dns-over-http-resolver");
var _dnsOverHttpResolverDefault = parcelHelpers.interopDefault(_dnsOverHttpResolver);
exports.default = (0, _dnsOverHttpResolverDefault.default);

},{"dns-over-http-resolver":"23ld5","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"23ld5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _receptacle = require("receptacle");
var _receptacleDefault = parcelHelpers.interopDefault(_receptacle);
var _utilsJs = require("./utils.js");
const log = Object.assign((0, _debugDefault.default)("dns-over-http-resolver"), {
    error: (0, _debugDefault.default)("dns-over-http-resolver:error")
});
/**
 * DNS over HTTP resolver.
 * Uses a list of servers to resolve DNS records with HTTP requests.
 */ class Resolver {
    _cache;
    _TXTcache;
    _servers;
    _request;
    _abortControllers;
    /**
     * @class
     * @param {object} [options]
     * @param {number} [options.maxCache = 100] - maximum number of cached dns records
     * @param {Request} [options.request] - function to return DNSJSON
     */ constructor(options = {}){
        this._cache = new (0, _receptacleDefault.default)({
            max: options?.maxCache ?? 100
        });
        this._TXTcache = new (0, _receptacleDefault.default)({
            max: options?.maxCache ?? 100
        });
        this._servers = [
            "https://cloudflare-dns.com/dns-query",
            "https://dns.google/resolve"
        ];
        this._request = options.request ?? _utilsJs.request;
        this._abortControllers = [];
    }
    /**
     * Cancel all outstanding DNS queries made by this resolver. Any outstanding
     * requests will be aborted and promises rejected.
     */ cancel() {
        this._abortControllers.forEach((controller)=>{
            controller.abort();
        });
    }
    /**
     * Get an array of the IP addresses currently configured for DNS resolution.
     * These addresses are formatted according to RFC 5952. It can include a custom port.
     */ getServers() {
        return this._servers;
    }
    /**
     * Get a shuffled array of the IP addresses currently configured for DNS resolution.
     * These addresses are formatted according to RFC 5952. It can include a custom port.
     */ _getShuffledServers() {
        const newServers = [
            ...this._servers
        ];
        for(let i = newServers.length - 1; i > 0; i--){
            const j = Math.floor(Math.random() * i);
            const temp = newServers[i];
            newServers[i] = newServers[j];
            newServers[j] = temp;
        }
        return newServers;
    }
    /**
     * Sets the IP address and port of servers to be used when performing DNS resolution.
     *
     * @param {string[]} servers - array of RFC 5952 formatted addresses.
     */ setServers(servers) {
        this._servers = servers;
    }
    async resolve(hostname, rrType = "A") {
        switch(rrType){
            case "A":
                return this.resolve4(hostname);
            case "AAAA":
                return this.resolve6(hostname);
            case "TXT":
                return this.resolveTxt(hostname);
            default:
                throw new Error(`${rrType} is not supported`);
        }
    }
    /**
     * Uses the DNS protocol to resolve the given host name into IPv4 addresses
     *
     * @param {string} hostname - host name to resolve
     */ async resolve4(hostname) {
        const recordType = "A";
        const cached = this._cache.get(_utilsJs.getCacheKey(hostname, recordType));
        if (cached != null) return cached;
        let aborted = false;
        for (const server of this._getShuffledServers()){
            const controller = new AbortController();
            this._abortControllers.push(controller);
            try {
                const response = await this._request(_utilsJs.buildResource(server, hostname, recordType), controller.signal);
                const data = response.Answer.map((a)=>a.data);
                const ttl = Math.min(...response.Answer.map((a)=>a.TTL));
                this._cache.set(_utilsJs.getCacheKey(hostname, recordType), data, {
                    ttl
                });
                return data;
            } catch (err) {
                if (controller.signal.aborted) aborted = true;
                log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            } finally{
                this._abortControllers = this._abortControllers.filter((c)=>c !== controller);
            }
        }
        if (aborted) throw Object.assign(new Error("queryA ECANCELLED"), {
            code: "ECANCELLED"
        });
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    /**
     * Uses the DNS protocol to resolve the given host name into IPv6 addresses
     *
     * @param {string} hostname - host name to resolve
     */ async resolve6(hostname) {
        const recordType = "AAAA";
        const cached = this._cache.get(_utilsJs.getCacheKey(hostname, recordType));
        if (cached != null) return cached;
        let aborted = false;
        for (const server of this._getShuffledServers()){
            const controller = new AbortController();
            this._abortControllers.push(controller);
            try {
                const response = await this._request(_utilsJs.buildResource(server, hostname, recordType), controller.signal);
                const data = response.Answer.map((a)=>a.data);
                const ttl = Math.min(...response.Answer.map((a)=>a.TTL));
                this._cache.set(_utilsJs.getCacheKey(hostname, recordType), data, {
                    ttl
                });
                return data;
            } catch (err) {
                if (controller.signal.aborted) aborted = true;
                log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            } finally{
                this._abortControllers = this._abortControllers.filter((c)=>c !== controller);
            }
        }
        if (aborted) throw Object.assign(new Error("queryAaaa ECANCELLED"), {
            code: "ECANCELLED"
        });
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    /**
     * Uses the DNS protocol to resolve the given host name into a Text record
     *
     * @param {string} hostname - host name to resolve
     */ async resolveTxt(hostname) {
        const recordType = "TXT";
        const cached = this._TXTcache.get(_utilsJs.getCacheKey(hostname, recordType));
        if (cached != null) return cached;
        let aborted = false;
        for (const server of this._getShuffledServers()){
            const controller = new AbortController();
            this._abortControllers.push(controller);
            try {
                const response = await this._request(_utilsJs.buildResource(server, hostname, recordType), controller.signal);
                const data = response.Answer.map((a)=>[
                        a.data.replace(/['"]+/g, "")
                    ]);
                const ttl = Math.min(...response.Answer.map((a)=>a.TTL));
                this._TXTcache.set(_utilsJs.getCacheKey(hostname, recordType), data, {
                    ttl
                });
                return data;
            } catch (err) {
                if (controller.signal.aborted) aborted = true;
                log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            } finally{
                this._abortControllers = this._abortControllers.filter((c)=>c !== controller);
            }
        }
        if (aborted) throw Object.assign(new Error("queryTxt ECANCELLED"), {
            code: "ECANCELLED"
        });
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    clearCache() {
        this._cache.clear();
        this._TXTcache.clear();
    }
}
exports.default = Resolver;

},{"debug":"l0oUb","receptacle":"9MUpS","./utils.js":"3NMhG","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9MUpS":[function(require,module,exports) {
"use strict";
module.exports = Receptacle;
var toMS = require("b0a644cfef265efb");
var cache = Receptacle.prototype;
var counter = new Date() % 1e9;
function getUID() {
    return (Math.random() * 1e9 >>> 0) + counter++;
}
/**
 * Creates a cache with a maximum key size.
 *
 * @constructor
 * @param {Object} options
 * @param {Number} [options.max=Infinity] the maximum number of keys allowed in the cache (lru).
 * @param {Array} [options.items=[]] the default items in the cache.
 */ function Receptacle(options) {
    options = options || {};
    this.id = options.id || getUID();
    this.max = options.max || Infinity;
    this.items = options.items || [];
    this._lookup = {};
    this.size = this.items.length;
    this.lastModified = new Date(options.lastModified || new Date());
    // Setup initial timers and indexes for the cache.
    for(var item, ttl, i = this.items.length; i--;){
        item = this.items[i];
        ttl = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl > 0) this.expire(item.key, ttl);
        else if (ttl <= 0) this.delete(item.key);
    }
}
/**
 * Tests if a key is currently in the cache.
 * Does not check if slot is empty.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {Boolean}
 */ cache.has = function(key) {
    return key in this._lookup;
};
/**
 * Retrieves a key from the cache and marks it as recently used.
 *
 * @param {String} key - the key to retrieve from the cache.
 * @return {*}
 */ cache.get = function(key) {
    if (!this.has(key)) return null;
    var record = this._lookup[key];
    // Update expiry for "refresh" keys
    if (record.refresh) this.expire(key, record.refresh);
    // Move to front of the line.
    this.items.splice(this.items.indexOf(record), 1);
    this.items.push(record);
    return record.value;
};
/**
 * Retrieves user meta data for a cached item.
 *
 * @param {String} key - the key to retrieve meta data from the cache.
 * @return {*}
 */ cache.meta = function(key) {
    if (!this.has(key)) return null;
    var record = this._lookup[key];
    if (!("meta" in record)) return null;
    return record.meta;
};
/**
 * Puts a key into the cache with an optional expiry time.
 *
 * @param {String} key - the key for the value in the cache.
 * @param {*} value - the value to place at the key.
 * @param {Number} [options.ttl] - a time after which the key will be removed.
 * @return {Receptacle}
 */ cache.set = function(key, value, options) {
    var oldRecord = this._lookup[key];
    var record = this._lookup[key] = {
        key: key,
        value: value
    };
    // Mark cache as modified.
    this.lastModified = new Date();
    if (oldRecord) {
        // Replace an old key.
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
    } else {
        // Remove least used item if needed.
        if (this.size >= this.max) this.delete(this.items[0].key);
        // Add a new key.
        this.items.push(record);
        this.size++;
    }
    if (options) {
        // Setup key expiry.
        if ("ttl" in options) this.expire(key, options.ttl);
        // Store user options in the record.
        if ("meta" in options) record.meta = options.meta;
        // Mark a auto refresh key.
        if (options.refresh) record.refresh = options.ttl;
    }
    return this;
};
/**
 * Deletes an item from the cache.
 *
 * @param {String} key - the key to remove.
 * @return {Receptacle}
 */ cache.delete = function(key) {
    var record = this._lookup[key];
    if (!record) return false;
    this.lastModified = new Date();
    this.items.splice(this.items.indexOf(record), 1);
    clearTimeout(record.timeout);
    delete this._lookup[key];
    this.size--;
    return this;
};
/**
 * Utility to register a key that will be removed after some time.
 *
 * @param {String} key - the key to remove.
 * @param {Number} [ms] - the timeout before removal.
 * @return {Receptacle}
 */ cache.expire = function(key, ttl) {
    var ms = ttl || 0;
    var record = this._lookup[key];
    if (!record) return this;
    if (typeof ms === "string") ms = toMS(ttl);
    if (typeof ms !== "number") throw new TypeError("Expiration time must be a string or number.");
    clearTimeout(record.timeout);
    record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
    record.expires = Number(new Date()) + ms;
    return this;
};
/**
 * Deletes all items from the cache.
 * @return {Receptacle}
 */ cache.clear = function() {
    for(var i = this.items.length; i--;)this.delete(this.items[i].key);
    return this;
};
/**
 * Fixes serialization issues in polyfilled environments.
 * Ensures non-cyclical serialized object.
 */ cache.toJSON = function() {
    var items = new Array(this.items.length);
    var item;
    for(var i = items.length; i--;){
        item = this.items[i];
        items[i] = {
            key: item.key,
            meta: item.meta,
            value: item.value,
            expires: item.expires,
            refresh: item.refresh
        };
    }
    return {
        id: this.id,
        max: isFinite(this.max) ? this.max : undefined,
        lastModified: this.lastModified,
        items: items
    };
};

},{"b0a644cfef265efb":"jauEe"}],"3NMhG":[function(require,module,exports) {
/**
 * Build fetch resource for request
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildResource", ()=>buildResource);
/**
 * Use fetch to find the record
 */ parcelHelpers.export(exports, "request", ()=>request);
/**
 * Creates cache key composed by recordType and hostname
 *
 * @param {string} hostname
 * @param {string} recordType
 */ parcelHelpers.export(exports, "getCacheKey", ()=>getCacheKey);
function buildResource(serverResolver, hostname, recordType) {
    return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
    const req = await fetch(resource, {
        headers: new Headers({
            accept: "application/dns-json"
        }),
        signal
    });
    const res = await req.json();
    return res;
}
function getCacheKey(hostname, recordType) {
    return `${recordType}_${hostname}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"l45Gy":[function(require,module,exports) {
/**
 * Thin ESM wrapper for CJS named exports.
 *
 * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default);

},{"./index.js":"4XlQf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4XlQf":[function(require,module,exports) {
"use strict";
const isOptionObject = require("86b4d73825a044dc");
const { hasOwnProperty } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name, value)=>Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
    });
const globalThis = this;
const defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value)=>{
    const keys = [];
    for(const key in value)if (hasOwnProperty.call(value, key)) keys.push(key);
    /* istanbul ignore else  */ if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols)if (propertyIsEnumerable.call(value, symbol)) keys.push(symbol);
    }
    return keys;
};
function clone(value) {
    if (Array.isArray(value)) return cloneArray(value);
    if (isOptionObject(value)) return cloneOptionObject(value);
    return value;
}
function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key)=>{
        defineProperty(result, key, clone(array[key]));
    });
    return result;
}
function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key)=>{
        defineProperty(result, key, clone(object[key]));
    });
    return result;
}
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ const mergeKeys = (merged, source, keys, config)=>{
    keys.forEach((key)=>{
        if (typeof source[key] === "undefined" && config.ignoreUndefined) return;
        // Do not recurse into prototype chain of merged
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) defineProperty(merged, key, merge(merged[key], source[key], config));
        else defineProperty(merged, key, clone(source[key]));
    });
    return merged;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */ const concatArrays = (merged, source, config)=>{
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [
        merged,
        source
    ].forEach((array)=>{
        const indices = [];
        // `result.concat(array)` with cloning
        for(let k = 0; k < array.length; k++){
            if (!hasOwnProperty.call(array, k)) continue;
            indices.push(String(k));
            if (array === merged) // Already cloned
            defineProperty(result, resultIndex++, array[k]);
            else defineProperty(result, resultIndex++, clone(array[k]));
        }
        // Merge non-index keys
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key)=>!indices.includes(key)), config);
    });
    return result;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) return concatArrays(merged, source, config);
    if (!isOptionObject(source) || !isOptionObject(merged)) return clone(source);
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}
module.exports = function(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);
    let merged = {
        _: {}
    };
    for (const option of options){
        if (option === undefined) continue;
        if (!isOptionObject(option)) throw new TypeError("`" + option + "` is not an Option Object");
        merged = merge(merged, {
            _: option
        }, config);
    }
    return merged._;
};

},{"86b4d73825a044dc":"9Wkhz"}],"9Wkhz":[function(require,module,exports) {
"use strict";
module.exports = (value)=>{
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};

},{}],"ayaP8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messages", ()=>messages);
parcelHelpers.export(exports, "codes", ()=>codes);
var messages;
(function(messages) {
    messages["NOT_STARTED_YET"] = "The libp2p node is not started yet";
    messages["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
    messages["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes;
(function(codes) {
    codes["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
    codes["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
    codes["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
    codes["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
    codes["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
    codes["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
    codes["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
    codes["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
    codes["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
    codes["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
    codes["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
    codes["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
    codes["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
    codes["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
    codes["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
    codes["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
    codes["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
    codes["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
    codes["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
    codes["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
    codes["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
    codes["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
    codes["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
    codes["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
    codes["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
    codes["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
    codes["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
    codes["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
    codes["ERR_FIND_SELF"] = "ERR_FIND_SELF";
    codes["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
    codes["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
    codes["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
    codes["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
    codes["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
    codes["ERR_NO_KEY"] = "ERR_NO_KEY";
    codes["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
    codes["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
    codes["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
    codes["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
    codes["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
    codes["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
    codes["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
    codes["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
    codes["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
    codes["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
    codes["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
    codes["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
    codes["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
    codes["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
    codes["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
    codes["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
    codes["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
    codes["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
    codes["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
    codes["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
    codes["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
    codes["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
    codes["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
    codes["ERR_TRANSFER_LIMIT_EXCEEDED"] = "ERR_TRANSFER_LIMIT_EXCEEDED";
})(codes || (codes = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5sare":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Responsible for managing known connections.
 */ parcelHelpers.export(exports, "DefaultConnectionManager", ()=>DefaultConnectionManager);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _addressSort = require("@libp2p/utils/address-sort");
var _rateLimiter = require("@libp2p/utils/rate-limiter");
var _multiaddr = require("@multiformats/multiaddr");
var _resolvers = require("@multiformats/multiaddr/resolvers");
var _errorsJs = require("../errors.js");
var _getPeerJs = require("../get-peer.js");
var _autoDialJs = require("./auto-dial.js");
var _connectionPrunerJs = require("./connection-pruner.js");
var _constantsJs = require("./constants.js");
var _dialQueueJs = require("./dial-queue.js");
const DEFAULT_DIAL_PRIORITY = 50;
const defaultOptions = {
    minConnections: (0, _constantsJs.MIN_CONNECTIONS),
    maxConnections: (0, _constantsJs.MAX_CONNECTIONS),
    inboundConnectionThreshold: (0, _constantsJs.INBOUND_CONNECTION_THRESHOLD),
    maxIncomingPendingConnections: (0, _constantsJs.MAX_INCOMING_PENDING_CONNECTIONS),
    autoDialConcurrency: (0, _constantsJs.AUTO_DIAL_CONCURRENCY),
    autoDialPriority: (0, _constantsJs.AUTO_DIAL_PRIORITY),
    autoDialMaxQueueLength: (0, _constantsJs.AUTO_DIAL_MAX_QUEUE_LENGTH)
};
class DefaultConnectionManager {
    started;
    connections;
    allow;
    deny;
    maxIncomingPendingConnections;
    incomingPendingConnections;
    maxConnections;
    dialQueue;
    autoDial;
    connectionPruner;
    inboundConnectionRateLimiter;
    peerStore;
    metrics;
    events;
    log;
    constructor(components, init = {}){
        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;
        const minConnections = init.minConnections ?? defaultOptions.minConnections;
        if (this.maxConnections < minConnections) throw new (0, _interface.CodeError)("Connection Manager maxConnections must be greater than minConnections", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        /**
         * Map of connections per peer
         */ this.connections = new (0, _peerCollections.PeerMap)();
        this.started = false;
        this.peerStore = components.peerStore;
        this.metrics = components.metrics;
        this.events = components.events;
        this.log = components.logger.forComponent("libp2p:connection-manager");
        this.onConnect = this.onConnect.bind(this);
        this.onDisconnect = this.onDisconnect.bind(this);
        this.events.addEventListener("connection:open", this.onConnect);
        this.events.addEventListener("connection:close", this.onDisconnect);
        // allow/deny lists
        this.allow = (init.allow ?? []).map((ma)=>(0, _multiaddr.multiaddr)(ma));
        this.deny = (init.deny ?? []).map((ma)=>(0, _multiaddr.multiaddr)(ma));
        this.incomingPendingConnections = 0;
        this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;
        // controls individual peers trying to dial us too quickly
        this.inboundConnectionRateLimiter = new (0, _rateLimiter.RateLimiter)({
            points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,
            duration: 1
        });
        // controls what happens when we don't have enough connections
        this.autoDial = new (0, _autoDialJs.AutoDial)({
            connectionManager: this,
            peerStore: components.peerStore,
            events: components.events,
            logger: components.logger
        }, {
            minConnections,
            autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,
            autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,
            maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength
        });
        // controls what happens when we have too many connections
        this.connectionPruner = new (0, _connectionPrunerJs.ConnectionPruner)({
            connectionManager: this,
            peerStore: components.peerStore,
            events: components.events,
            logger: components.logger
        }, {
            maxConnections: this.maxConnections,
            allow: this.allow
        });
        this.dialQueue = new (0, _dialQueueJs.DialQueue)(components, {
            addressSorter: init.addressSorter ?? (0, _addressSort.defaultAddressSort),
            maxParallelDials: init.maxParallelDials ?? (0, _constantsJs.MAX_PARALLEL_DIALS),
            maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? (0, _constantsJs.MAX_PEER_ADDRS_TO_DIAL),
            dialTimeout: init.dialTimeout ?? (0, _constantsJs.DIAL_TIMEOUT),
            resolvers: init.resolvers ?? {
                dnsaddr: (0, _resolvers.dnsaddrResolver)
            },
            connections: this.connections
        });
    }
    isStarted() {
        return this.started;
    }
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */ async start() {
        // track inbound/outbound connections
        this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
            calculate: ()=>{
                const metric = {
                    inbound: 0,
                    outbound: 0
                };
                for (const conns of this.connections.values()){
                    for (const conn of conns)if (conn.direction === "inbound") metric.inbound++;
                    else metric.outbound++;
                }
                return metric;
            }
        });
        // track total number of streams per protocol
        this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
            label: "protocol",
            calculate: ()=>{
                const metric = {};
                for (const conns of this.connections.values()){
                    for (const conn of conns)for (const stream of conn.streams){
                        const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                        metric[key] = (metric[key] ?? 0) + 1;
                    }
                }
                return metric;
            }
        });
        // track 90th percentile of streams per protocol
        this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
            label: "protocol",
            calculate: ()=>{
                const allStreams = {};
                for (const conns of this.connections.values())for (const conn of conns){
                    const streams = {};
                    for (const stream of conn.streams){
                        const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                        streams[key] = (streams[key] ?? 0) + 1;
                    }
                    for (const [protocol, count] of Object.entries(streams)){
                        allStreams[protocol] = allStreams[protocol] ?? [];
                        allStreams[protocol].push(count);
                    }
                }
                const metric = {};
                for (let [protocol, counts] of Object.entries(allStreams)){
                    counts = counts.sort((a, b)=>a - b);
                    const index = Math.floor(counts.length * 0.9);
                    metric[protocol] = counts[index];
                }
                return metric;
            }
        });
        this.dialQueue.start();
        this.autoDial.start();
        this.started = true;
        this.log("started");
    }
    async afterStart() {
        // re-connect to any peers with the KEEP_ALIVE tag
        Promise.resolve().then(async ()=>{
            const keepAlivePeers = await this.peerStore.all({
                filters: [
                    (peer)=>{
                        return peer.tags.has((0, _interface.KEEP_ALIVE));
                    }
                ]
            });
            await Promise.all(keepAlivePeers.map(async (peer)=>{
                await this.openConnection(peer.id).catch((err)=>{
                    this.log.error(err);
                });
            }));
        }).catch((err)=>{
            this.log.error(err);
        });
        this.autoDial.afterStart();
    }
    /**
     * Stops the Connection Manager
     */ async stop() {
        this.dialQueue.stop();
        this.autoDial.stop();
        // Close all connections we're tracking
        const tasks = [];
        for (const connectionList of this.connections.values())for (const connection of connectionList)tasks.push((async ()=>{
            try {
                await connection.close();
            } catch (err) {
                this.log.error(err);
            }
        })());
        this.log("closing %d connections", tasks.length);
        await Promise.all(tasks);
        this.connections.clear();
        this.log("stopped");
    }
    onConnect(evt) {
        this._onConnect(evt).catch((err)=>{
            this.log.error(err);
        });
    }
    /**
     * Tracks the incoming connection and check the connection limit
     */ async _onConnect(evt) {
        const { detail: connection } = evt;
        if (!this.started) {
            // This can happen when we are in the process of shutting down the node
            await connection.close();
            return;
        }
        const peerId = connection.remotePeer;
        const storedConns = this.connections.get(peerId);
        let isNewPeer = false;
        if (storedConns != null) storedConns.push(connection);
        else {
            isNewPeer = true;
            this.connections.set(peerId, [
                connection
            ]);
        }
        // only need to store RSA public keys, all other types are embedded in the peer id
        if (peerId.publicKey != null && peerId.type === "RSA") await this.peerStore.patch(peerId, {
            publicKey: peerId.publicKey
        });
        if (isNewPeer) this.events.safeDispatchEvent("peer:connect", {
            detail: connection.remotePeer
        });
    }
    /**
     * Removes the connection from tracking
     */ onDisconnect(evt) {
        const { detail: connection } = evt;
        if (!this.started) // This can happen when we are in the process of shutting down the node
        return;
        const peerId = connection.remotePeer;
        let storedConn = this.connections.get(peerId);
        if (storedConn != null && storedConn.length > 1) {
            storedConn = storedConn.filter((conn)=>conn.id !== connection.id);
            this.connections.set(peerId, storedConn);
        } else if (storedConn != null) {
            this.connections.delete(peerId);
            this.events.safeDispatchEvent("peer:disconnect", {
                detail: connection.remotePeer
            });
        }
    }
    getConnections(peerId) {
        if (peerId != null) return this.connections.get(peerId) ?? [];
        let conns = [];
        for (const c of this.connections.values())conns = conns.concat(c);
        return conns;
    }
    getConnectionsMap() {
        return this.connections;
    }
    async openConnection(peerIdOrMultiaddr, options = {}) {
        if (!this.isStarted()) throw new (0, _interface.CodeError)("Not started", (0, _errorsJs.codes).ERR_NODE_NOT_STARTED);
        options.signal?.throwIfAborted();
        const { peerId } = (0, _getPeerJs.getPeerAddress)(peerIdOrMultiaddr);
        if (peerId != null && options.force !== true) {
            this.log("dial %p", peerId);
            const existingConnection = this.getConnections(peerId).find((conn)=>!conn.transient);
            if (existingConnection != null) {
                this.log("had an existing non-transient connection to %p", peerId);
                return existingConnection;
            }
        }
        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
            ...options,
            priority: options.priority ?? DEFAULT_DIAL_PRIORITY
        });
        let peerConnections = this.connections.get(connection.remotePeer);
        if (peerConnections == null) {
            peerConnections = [];
            this.connections.set(connection.remotePeer, peerConnections);
        }
        // we get notified of connections via the Upgrader emitting "connection"
        // events, double check we aren't already tracking this connection before
        // storing it
        let trackedConnection = false;
        for (const conn of peerConnections)if (conn.id === connection.id) trackedConnection = true;
        if (!trackedConnection) peerConnections.push(connection);
        return connection;
    }
    async closeConnections(peerId, options = {}) {
        const connections = this.connections.get(peerId) ?? [];
        await Promise.all(connections.map(async (connection)=>{
            try {
                await connection.close(options);
            } catch (err) {
                connection.abort(err);
            }
        }));
    }
    async acceptIncomingConnection(maConn) {
        // check deny list
        const denyConnection = this.deny.some((ma)=>{
            return maConn.remoteAddr.toString().startsWith(ma.toString());
        });
        if (denyConnection) {
            this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
            return false;
        }
        // check allow list
        const allowConnection = this.allow.some((ma)=>{
            return maConn.remoteAddr.toString().startsWith(ma.toString());
        });
        if (allowConnection) {
            this.incomingPendingConnections++;
            return true;
        }
        // check pending connections
        if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
            this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
            return false;
        }
        if (maConn.remoteAddr.isThinWaistAddress()) {
            const host = maConn.remoteAddr.nodeAddress().address;
            try {
                await this.inboundConnectionRateLimiter.consume(host, 1);
            } catch  {
                this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
                return false;
            }
        }
        if (this.getConnections().length < this.maxConnections) {
            this.incomingPendingConnections++;
            return true;
        }
        this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
        return false;
    }
    afterUpgradeInbound() {
        this.incomingPendingConnections--;
    }
    getDialQueue() {
        const statusMap = {
            queued: "queued",
            running: "active",
            errored: "error",
            complete: "success"
        };
        return this.dialQueue.queue.queue.map((job)=>{
            return {
                id: job.id,
                status: statusMap[job.status],
                peerId: job.options.peerId,
                multiaddrs: [
                    ...job.options.multiaddrs
                ].map((ma)=>(0, _multiaddr.multiaddr)(ma))
            };
        });
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","@libp2p/utils/address-sort":"hXpHf","@libp2p/utils/rate-limiter":"f8Zwb","@multiformats/multiaddr":"7Qpz2","@multiformats/multiaddr/resolvers":"fZLfL","../errors.js":"ayaP8","../get-peer.js":"1kzFk","./auto-dial.js":"6nLVS","./connection-pruner.js":"iNcEH","./constants.js":"ef8fV","./dial-queue.js":"64bMR","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"f8Zwb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RateLimiter", ()=>RateLimiter);
var _interface = require("@libp2p/interface");
var _delay = require("delay");
var _delayDefault = parcelHelpers.interopDefault(_delay);
class RateLimiter {
    memoryStorage;
    points;
    duration;
    blockDuration;
    execEvenly;
    execEvenlyMinDelayMs;
    keyPrefix;
    constructor(opts = {}){
        this.points = opts.points ?? 4;
        this.duration = opts.duration ?? 1;
        this.blockDuration = opts.blockDuration ?? 0;
        this.execEvenly = opts.execEvenly ?? false;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1000 / this.points;
        this.keyPrefix = opts.keyPrefix ?? "rlflx";
        this.memoryStorage = new MemoryStorage();
    }
    async consume(key, pointsToConsume = 1, options = {}) {
        const rlKey = this.getKey(key);
        const secDuration = this._getKeySecDuration(options);
        let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        if (res.consumedPoints > this.points) {
            // Block only first time when consumed more than points
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) // Block key
            res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            throw new (0, _interface.CodeError)("Rate limit exceeded", "ERR_RATE_LIMIT_EXCEEDED", res);
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            // Execute evenly
            let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delayMs < this.execEvenlyMinDelayMs) delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
            await (0, _delayDefault.default)(delayMs);
        }
        return res;
    }
    penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        const secDuration = this._getKeySecDuration(options);
        const res = this.memoryStorage.incrby(rlKey, points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        return res;
    }
    reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        const secDuration = this._getKeySecDuration(options);
        const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        return res;
    }
    /**
     * Block any key for secDuration seconds
     *
     * @param key
     * @param secDuration
     */ block(key, secDuration) {
        const msDuration = secDuration * 1000;
        const initPoints = this.points + 1;
        this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return {
            remainingPoints: 0,
            msBeforeNext: msDuration === 0 ? -1 : msDuration,
            consumedPoints: initPoints,
            isFirstInDuration: false
        };
    }
    set(key, points, secDuration = 0) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;
        this.memoryStorage.set(this.getKey(key), points, secDuration);
        return {
            remainingPoints: 0,
            msBeforeNext: msDuration === 0 ? -1 : msDuration,
            consumedPoints: points,
            isFirstInDuration: false
        };
    }
    get(key) {
        const res = this.memoryStorage.get(this.getKey(key));
        if (res != null) res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        return res;
    }
    delete(key) {
        this.memoryStorage.delete(this.getKey(key));
    }
    _getKeySecDuration(options) {
        if (options?.customDuration != null && options.customDuration >= 0) return options.customDuration;
        return this.duration;
    }
    getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
    }
}
class MemoryStorage {
    storage;
    constructor(){
        this.storage = new Map();
    }
    incrby(key, value, durationSec) {
        const existing = this.storage.get(key);
        if (existing != null) {
            const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - new Date().getTime() : -1;
            if (existing.expiresAt == null || msBeforeExpires > 0) {
                // Change value
                existing.value += value;
                return {
                    remainingPoints: 0,
                    msBeforeNext: msBeforeExpires,
                    consumedPoints: existing.value,
                    isFirstInDuration: false
                };
            }
            return this.set(key, value, durationSec);
        }
        return this.set(key, value, durationSec);
    }
    set(key, value, durationSec) {
        const durationMs = durationSec * 1000;
        const existing = this.storage.get(key);
        if (existing != null) clearTimeout(existing.timeoutId);
        const record = {
            value,
            expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined
        };
        this.storage.set(key, record);
        if (durationMs > 0) {
            record.timeoutId = setTimeout(()=>{
                this.storage.delete(key);
            }, durationMs);
            if (record.timeoutId.unref != null) record.timeoutId.unref();
        }
        return {
            remainingPoints: 0,
            msBeforeNext: durationMs === 0 ? -1 : durationMs,
            consumedPoints: record.value,
            isFirstInDuration: true
        };
    }
    get(key) {
        const existing = this.storage.get(key);
        if (existing != null) {
            const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - new Date().getTime() : -1;
            return {
                remainingPoints: 0,
                msBeforeNext: msBeforeExpires,
                consumedPoints: existing.value,
                isFirstInDuration: false
            };
        }
    }
    delete(key) {
        const record = this.storage.get(key);
        if (record != null) {
            if (record.timeoutId != null) clearTimeout(record.timeoutId);
            this.storage.delete(key);
            return true;
        }
        return false;
    }
}

},{"@libp2p/interface":"b14bx","delay":"3zsPy","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3zsPy":[function(require,module,exports) {
// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createDelay", ()=>createDelay);
parcelHelpers.export(exports, "rangeDelay", ()=>rangeDelay);
parcelHelpers.export(exports, "clearDelay", ()=>clearDelay);
const randomInteger = (minimum, maximum)=>Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
const createAbortError = ()=>{
    const error = new Error("Delay aborted");
    error.name = "AbortError";
    return error;
};
const clearMethods = new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
    // We cannot use `async` here as we need the promise identity.
    return (milliseconds, { value, signal } = {})=>{
        // TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.
        if (signal?.aborted) return Promise.reject(createAbortError());
        let timeoutId;
        let settle;
        let rejectFunction;
        const clear = defaultClear ?? clearTimeout;
        const signalListener = ()=>{
            clear(timeoutId);
            rejectFunction(createAbortError());
        };
        const cleanup = ()=>{
            if (signal) signal.removeEventListener("abort", signalListener);
        };
        const delayPromise = new Promise((resolve, reject)=>{
            settle = ()=>{
                cleanup();
                resolve(value);
            };
            rejectFunction = reject;
            timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
        });
        if (signal) signal.addEventListener("abort", signalListener, {
            once: true
        });
        clearMethods.set(delayPromise, ()=>{
            clear(timeoutId);
            timeoutId = null;
            settle();
        });
        return delayPromise;
    };
}
const delay = createDelay();
exports.default = delay;
async function rangeDelay(minimum, maximum, options = {}) {
    return delay(randomInteger(minimum, maximum), options);
}
function clearDelay(promise) {
    clearMethods.get(promise)?.();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1kzFk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs
 */ parcelHelpers.export(exports, "getPeerAddress", ()=>getPeerAddress);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _multiaddr = require("@multiformats/multiaddr");
var _errorsJs = require("./errors.js");
function getPeerAddress(peer) {
    if ((0, _interface.isPeerId)(peer)) return {
        peerId: peer,
        multiaddrs: []
    };
    if (!Array.isArray(peer)) peer = [
        peer
    ];
    let peerId;
    if (peer.length > 0) {
        const peerIdStr = peer[0].getPeerId();
        peerId = peerIdStr == null ? undefined : (0, _peerId.peerIdFromString)(peerIdStr);
        // ensure PeerId is either not set or is consistent
        peer.forEach((ma)=>{
            if (!(0, _multiaddr.isMultiaddr)(ma)) throw new (0, _interface.CodeError)("Invalid Multiaddr", (0, _errorsJs.codes).ERR_INVALID_MULTIADDR);
            const maPeerIdStr = ma.getPeerId();
            if (maPeerIdStr == null) {
                if (peerId != null) throw new (0, _interface.CodeError)("Multiaddrs must all have the same peer id or have no peer id", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
            } else {
                const maPeerId = (0, _peerId.peerIdFromString)(maPeerIdStr);
                if (peerId == null || !peerId.equals(maPeerId)) throw new (0, _interface.CodeError)("Multiaddrs must all have the same peer id or have no peer id", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
            }
        });
    }
    return {
        peerId,
        multiaddrs: peer
    };
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@multiformats/multiaddr":"7Qpz2","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6nLVS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AutoDial", ()=>AutoDial);
var _peerCollections = require("@libp2p/peer-collections");
var _peerQueue = require("@libp2p/utils/peer-queue");
var _toString = require("uint8arrays/to-string");
var _constantsJs = require("./constants.js");
const defaultOptions = {
    minConnections: (0, _constantsJs.MIN_CONNECTIONS),
    maxQueueLength: (0, _constantsJs.AUTO_DIAL_MAX_QUEUE_LENGTH),
    autoDialConcurrency: (0, _constantsJs.AUTO_DIAL_CONCURRENCY),
    autoDialPriority: (0, _constantsJs.AUTO_DIAL_PRIORITY),
    autoDialInterval: (0, _constantsJs.AUTO_DIAL_INTERVAL),
    autoDialPeerRetryThreshold: (0, _constantsJs.AUTO_DIAL_PEER_RETRY_THRESHOLD),
    autoDialDiscoveredPeersDebounce: (0, _constantsJs.AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE)
};
class AutoDial {
    connectionManager;
    peerStore;
    queue;
    minConnections;
    autoDialPriority;
    autoDialIntervalMs;
    autoDialMaxQueueLength;
    autoDialPeerRetryThresholdMs;
    autoDialDiscoveredPeersDebounce;
    autoDialInterval;
    started;
    running;
    log;
    /**
     * Proactively tries to connect to known peers stored in the PeerStore.
     * It will keep the number of connections below the upper limit and sort
     * the peers to connect based on whether we know their keys and protocols.
     */ constructor(components, init){
        this.connectionManager = components.connectionManager;
        this.peerStore = components.peerStore;
        this.minConnections = init.minConnections ?? defaultOptions.minConnections;
        this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority;
        this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval;
        this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength;
        this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold;
        this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce;
        this.log = components.logger.forComponent("libp2p:connection-manager:auto-dial");
        this.started = false;
        this.running = false;
        this.queue = new (0, _peerQueue.PeerQueue)({
            concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,
            metricName: "libp2p_autodial_queue",
            metrics: components.metrics
        });
        this.queue.addEventListener("error", (evt)=>{
            this.log.error("error during auto-dial", evt.detail);
        });
        // check the min connection limit whenever a peer disconnects
        components.events.addEventListener("connection:close", ()=>{
            this.autoDial().catch((err)=>{
                this.log.error(err);
            });
        });
        // sometimes peers are discovered in quick succession so add a small
        // debounce to ensure all eligible peers are autodialed
        let debounce;
        // when new peers are discovered, dial them if we don't have
        // enough connections
        components.events.addEventListener("peer:discovery", ()=>{
            clearTimeout(debounce);
            debounce = setTimeout(()=>{
                this.autoDial().catch((err)=>{
                    this.log.error(err);
                });
            }, this.autoDialDiscoveredPeersDebounce);
        });
    }
    isStarted() {
        return this.started;
    }
    start() {
        this.started = true;
    }
    afterStart() {
        this.autoDial().catch((err)=>{
            this.log.error("error while autodialing", err);
        });
    }
    stop() {
        // clear the queue
        this.queue.clear();
        clearTimeout(this.autoDialInterval);
        this.started = false;
        this.running = false;
    }
    async autoDial() {
        if (!this.started || this.running) return;
        const connections = this.connectionManager.getConnectionsMap();
        const numConnections = connections.size;
        // already have enough connections
        if (numConnections >= this.minConnections) {
            if (this.minConnections > 0) this.log.trace("have enough connections %d/%d", numConnections, this.minConnections);
            // no need to schedule next autodial as it will be run when on
            // connection:close event
            return;
        }
        if (this.queue.size > this.autoDialMaxQueueLength) {
            this.log("not enough connections %d/%d but auto dial queue is full", numConnections, this.minConnections);
            this.sheduleNextAutodial();
            return;
        }
        this.running = true;
        this.log("not enough connections %d/%d - will dial peers to increase the number of connections", numConnections, this.minConnections);
        const dialQueue = new (0, _peerCollections.PeerSet)(// @ts-expect-error boolean filter removes falsy peer IDs
        this.connectionManager.getDialQueue().map((queue)=>queue.peerId).filter(Boolean));
        // sort peers on whether we know protocols or public keys for them
        const peers = await this.peerStore.all({
            filters: [
                // remove some peers
                (peer)=>{
                    // remove peers without addresses
                    if (peer.addresses.length === 0) {
                        this.log.trace("not autodialing %p because they have no addresses", peer.id);
                        return false;
                    }
                    // remove peers we are already connected to
                    if (connections.has(peer.id)) {
                        this.log.trace("not autodialing %p because they are already connected", peer.id);
                        return false;
                    }
                    // remove peers we are already dialling
                    if (dialQueue.has(peer.id)) {
                        this.log.trace("not autodialing %p because they are already being dialed", peer.id);
                        return false;
                    }
                    // remove peers already in the autodial queue
                    if (this.queue.has(peer.id)) {
                        this.log.trace("not autodialing %p because they are already being autodialed", peer.id);
                        return false;
                    }
                    return true;
                }
            ]
        });
        // shuffle the peers - this is so peers with the same tag values will be
        // dialled in a different order each time
        const shuffledPeers = peers.sort(()=>Math.random() > 0.5 ? 1 : -1);
        // sort shuffled peers by tag value
        const peerValues = new (0, _peerCollections.PeerMap)();
        for (const peer of shuffledPeers){
            if (peerValues.has(peer.id)) continue;
            // sum all tag values
            peerValues.set(peer.id, [
                ...peer.tags.values()
            ].reduce((acc, curr)=>{
                return acc + curr.value;
            }, 0));
        }
        // sort by value, highest to lowest
        const sortedPeers = shuffledPeers.sort((a, b)=>{
            const peerAValue = peerValues.get(a.id) ?? 0;
            const peerBValue = peerValues.get(b.id) ?? 0;
            if (peerAValue > peerBValue) return -1;
            if (peerAValue < peerBValue) return 1;
            return 0;
        });
        const peersThatHaveNotFailed = sortedPeers.filter((peer)=>{
            const lastDialFailure = peer.metadata.get((0, _constantsJs.LAST_DIAL_FAILURE_KEY));
            if (lastDialFailure == null) return true;
            const lastDialFailureTimestamp = parseInt((0, _toString.toString)(lastDialFailure));
            if (isNaN(lastDialFailureTimestamp)) return true;
            // only dial if the time since the last failure is above the retry threshold
            return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;
        });
        this.log("selected %d/%d peers to dial", peersThatHaveNotFailed.length, peers.length);
        for (const peer of peersThatHaveNotFailed)this.queue.add(async ()=>{
            const numConnections = this.connectionManager.getConnectionsMap().size;
            // Check to see if we still need to auto dial
            if (numConnections >= this.minConnections) {
                this.log("got enough connections now %d/%d", numConnections, this.minConnections);
                this.queue.clear();
                return;
            }
            this.log("connecting to a peerStore stored peer %p", peer.id);
            await this.connectionManager.openConnection(peer.id, {
                priority: this.autoDialPriority
            });
        }, {
            peerId: peer.id
        }).catch((err)=>{
            this.log.error("could not connect to peerStore stored peer", err);
        });
        this.running = false;
        this.sheduleNextAutodial();
    }
    sheduleNextAutodial() {
        if (!this.started) return;
        this.autoDialInterval = setTimeout(()=>{
            this.autoDial().catch((err)=>{
                this.log.error("error while autodialing", err);
            });
        }, this.autoDialIntervalMs);
    }
}

},{"@libp2p/peer-collections":"jqBHH","@libp2p/utils/peer-queue":"98WyE","uint8arrays/to-string":"63irA","./constants.js":"ef8fV","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"98WyE":[function(require,module,exports) {
/* eslint-disable @typescript-eslint/no-non-null-assertion */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extends Queue to add support for querying queued jobs by peer id
 */ parcelHelpers.export(exports, "PeerQueue", ()=>PeerQueue);
var _indexJs = require("./queue/index.js");
class PeerQueue extends (0, _indexJs.Queue) {
    has(peerId) {
        return this.find(peerId) != null;
    }
    find(peerId) {
        return this.queue.find((job)=>{
            return peerId.equals(job.options.peerId);
        });
    }
}

},{"./queue/index.js":"i1Kpf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"i1Kpf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Heavily influence by `p-queue` with the following differences:
 *
 * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running
 * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue
 */ parcelHelpers.export(exports, "Queue", ()=>Queue);
var _interface = require("@libp2p/interface");
var _itPushable = require("it-pushable");
var _raceEvent = require("race-event");
var _jobJs = require("./job.js");
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while(count > 0){
        const step = Math.trunc(count / 2);
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        } else count = step;
    }
    return first;
}
class Queue extends (0, _interface.TypedEventEmitter) {
    concurrency;
    queue;
    pending;
    constructor(init = {}){
        super();
        this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
        this.pending = 0;
        if (init.metricName != null) init.metrics?.registerMetricGroup(init.metricName, {
            calculate: ()=>{
                return {
                    size: this.queue.length,
                    running: this.pending,
                    queued: this.queue.length - this.pending
                };
            }
        });
        this.queue = [];
    }
    tryToStartAnother() {
        if (this.size === 0) {
            // do this in the microtask queue so all job recipients receive the
            // result before the "empty" event fires
            queueMicrotask(()=>{
                this.safeDispatchEvent("empty");
            });
            if (this.running === 0) // do this in the microtask queue so all job recipients receive the
            // result before the "idle" event fires
            queueMicrotask(()=>{
                this.safeDispatchEvent("idle");
            });
            return false;
        }
        if (this.pending < this.concurrency) {
            let job;
            for (const j of this.queue)if (j.status === "queued") {
                job = j;
                break;
            }
            if (job == null) return false;
            this.safeDispatchEvent("active");
            this.pending++;
            job.run().finally(()=>{
                // remove the job from the queue
                for(let i = 0; i < this.queue.length; i++)if (this.queue[i] === job) {
                    this.queue.splice(i, 1);
                    break;
                }
                this.pending--;
                this.tryToStartAnother();
                this.safeDispatchEvent("next");
            });
            return true;
        }
        return false;
    }
    enqueue(job) {
        if (this.queue[this.size - 1]?.priority >= job.priority) {
            this.queue.push(job);
            return;
        }
        const index = lowerBound(this.queue, job, (a, b)=>b.priority - a.priority);
        this.queue.splice(index, 0, job);
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */ async add(fn, options) {
        options?.signal?.throwIfAborted();
        const job = new (0, _jobJs.Job)(fn, options, options?.priority);
        const p = job.join(options).then((result)=>{
            this.safeDispatchEvent("completed", {
                detail: result
            });
            return result;
        }).catch((err)=>{
            this.safeDispatchEvent("error", {
                detail: err
            });
            throw err;
        });
        this.enqueue(job);
        this.safeDispatchEvent("add");
        this.tryToStartAnother();
        return p;
    }
    /**
     * Clear the queue
     */ clear() {
        this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */ abort() {
        this.queue.forEach((job)=>{
            job.abort(new (0, _interface.AbortError)());
        });
        this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */ async onEmpty(options) {
        // Instantly resolve if the queue is empty
        if (this.size === 0) return;
        await (0, _raceEvent.raceEvent)(this, "empty", options?.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */ async onSizeLessThan(limit, options) {
        // Instantly resolve if the queue is empty.
        if (this.size < limit) return;
        await (0, _raceEvent.raceEvent)(this, "next", options?.signal, {
            filter: ()=>this.size < limit
        });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */ async onIdle(options) {
        // Instantly resolve if none pending and if nothing else is queued
        if (this.pending === 0 && this.size === 0) return;
        await (0, _raceEvent.raceEvent)(this, "idle", options?.signal);
    }
    /**
     * Size of the queue including running items
     */ get size() {
        return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */ get queued() {
        return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */ get running() {
        return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */ async *toGenerator(options) {
        options?.signal?.throwIfAborted();
        const stream = (0, _itPushable.pushable)({
            objectMode: true
        });
        const cleanup = (err)=>{
            if (err != null) this.abort();
            else this.clear();
            stream.end(err);
        };
        const onQueueJobComplete = (evt)=>{
            if (evt.detail != null) stream.push(evt.detail);
        };
        const onQueueError = (evt)=>{
            cleanup(evt.detail);
        };
        const onQueueIdle = ()=>{
            cleanup();
        };
        // clear the queue and throw if the query is aborted
        const onSignalAbort = ()=>{
            cleanup(new (0, _interface.CodeError)("Queue aborted", "ERR_QUEUE_ABORTED"));
        };
        // add listeners
        this.addEventListener("completed", onQueueJobComplete);
        this.addEventListener("error", onQueueError);
        this.addEventListener("idle", onQueueIdle);
        options?.signal?.addEventListener("abort", onSignalAbort);
        try {
            yield* stream;
        } finally{
            // remove listeners
            this.removeEventListener("completed", onQueueJobComplete);
            this.removeEventListener("error", onQueueError);
            this.removeEventListener("idle", onQueueIdle);
            options?.signal?.removeEventListener("abort", onSignalAbort);
            // empty the queue for when the user has broken out of a loop early
            cleanup();
        }
    }
}

},{"@libp2p/interface":"b14bx","it-pushable":"hxxEW","race-event":"446Ja","./job.js":"5Ew3U","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hxxEW":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * An iterable that you can push values into.
 *
 * @example
 *
 * ```js
 * import { pushable } from 'it-pushable'
 *
 * const source = pushable()
 *
 * setTimeout(() => source.push('hello'), 100)
 * setTimeout(() => source.push('world'), 200)
 * setTimeout(() => source.end(), 300)
 *
 * const start = Date.now()
 *
 * for await (const value of source) {
 *   console.log(`got "${value}" after ${Date.now() - start}ms`)
 * }
 * console.log(`done after ${Date.now() - start}ms`)
 *
 * // Output:
 * // got "hello" after 105ms
 * // got "world" after 207ms
 * // done after 309ms
 * ```
 *
 * @example
 *
 * ```js
 * import { pushableV } from 'it-pushable'
 * import all from 'it-all'
 *
 * const source = pushableV()
 *
 * source.push(1)
 * source.push(2)
 * source.push(3)
 * source.end()
 *
 * console.info(await all(source))
 *
 * // Output:
 * // [ [1, 2, 3] ]
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
parcelHelpers.export(exports, "pushable", ()=>pushable);
parcelHelpers.export(exports, "pushableV", ()=>pushableV);
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _fifoJs = require("./fifo.js");
class AbortError extends Error {
    type;
    code;
    constructor(message, code){
        super(message ?? "The operation was aborted");
        this.type = "aborted";
        this.code = code ?? "ABORT_ERR";
    }
}
function pushable(options = {}) {
    const getNext = (buffer)=>{
        const next = buffer.shift();
        if (next == null) return {
            done: true
        };
        if (next.error != null) throw next.error;
        return {
            done: next.done === true,
            // @ts-expect-error if done is false, value will be present
            value: next.value
        };
    };
    return _pushable(getNext, options);
}
function pushableV(options = {}) {
    const getNext = (buffer)=>{
        let next;
        const values = [];
        while(!buffer.isEmpty()){
            next = buffer.shift();
            if (next == null) break;
            if (next.error != null) throw next.error;
            if (next.done === false) // @ts-expect-error if done is false value should be pushed
            values.push(next.value);
        }
        if (next == null) return {
            done: true
        };
        return {
            done: next.done === true,
            value: values
        };
    };
    return _pushable(getNext, options);
}
function _pushable(getNext, options) {
    options = options ?? {};
    let onEnd = options.onEnd;
    let buffer = new (0, _fifoJs.FIFO)();
    let pushable;
    let onNext;
    let ended;
    let drain = (0, _pDeferDefault.default)();
    const waitNext = async ()=>{
        try {
            if (!buffer.isEmpty()) return getNext(buffer);
            if (ended) return {
                done: true
            };
            return await new Promise((resolve, reject)=>{
                onNext = (next)=>{
                    onNext = null;
                    buffer.push(next);
                    try {
                        resolve(getNext(buffer));
                    } catch (err) {
                        reject(err);
                    }
                    return pushable;
                };
            });
        } finally{
            if (buffer.isEmpty()) // settle promise in the microtask queue to give consumers a chance to
            // await after calling .push
            queueMicrotask(()=>{
                drain.resolve();
                drain = (0, _pDeferDefault.default)();
            });
        }
    };
    const bufferNext = (next)=>{
        if (onNext != null) return onNext(next);
        buffer.push(next);
        return pushable;
    };
    const bufferError = (err)=>{
        buffer = new (0, _fifoJs.FIFO)();
        if (onNext != null) return onNext({
            error: err
        });
        buffer.push({
            error: err
        });
        return pushable;
    };
    const push = (value)=>{
        if (ended) return pushable;
        // @ts-expect-error `byteLength` is not declared on PushType
        if (options?.objectMode !== true && value?.byteLength == null) throw new Error("objectMode was not true but tried to push non-Uint8Array value");
        return bufferNext({
            done: false,
            value
        });
    };
    const end = (err)=>{
        if (ended) return pushable;
        ended = true;
        return err != null ? bufferError(err) : bufferNext({
            done: true
        });
    };
    const _return = ()=>{
        buffer = new (0, _fifoJs.FIFO)();
        end();
        return {
            done: true
        };
    };
    const _throw = (err)=>{
        end(err);
        return {
            done: true
        };
    };
    pushable = {
        [Symbol.asyncIterator] () {
            return this;
        },
        next: waitNext,
        return: _return,
        throw: _throw,
        push,
        end,
        get readableLength () {
            return buffer.size;
        },
        onEmpty: async (options)=>{
            const signal = options?.signal;
            signal?.throwIfAborted();
            if (buffer.isEmpty()) return;
            let cancel;
            let listener;
            if (signal != null) cancel = new Promise((resolve, reject)=>{
                listener = ()=>{
                    reject(new AbortError());
                };
                signal.addEventListener("abort", listener);
            });
            try {
                await Promise.race([
                    drain.promise,
                    cancel
                ]);
            } finally{
                if (listener != null && signal != null) signal?.removeEventListener("abort", listener);
            }
        }
    };
    if (onEnd == null) return pushable;
    const _pushable = pushable;
    pushable = {
        [Symbol.asyncIterator] () {
            return this;
        },
        next () {
            return _pushable.next();
        },
        throw (err) {
            _pushable.throw(err);
            if (onEnd != null) {
                onEnd(err);
                onEnd = undefined;
            }
            return {
                done: true
            };
        },
        return () {
            _pushable.return();
            if (onEnd != null) {
                onEnd();
                onEnd = undefined;
            }
            return {
                done: true
            };
        },
        push,
        end (err) {
            _pushable.end(err);
            if (onEnd != null) {
                onEnd(err);
                onEnd = undefined;
            }
            return pushable;
        },
        get readableLength () {
            return _pushable.readableLength;
        },
        onEmpty: (opts)=>{
            return _pushable.onEmpty(opts);
        }
    };
    return pushable;
}

},{"p-defer":"cWx93","./fifo.js":"fftul","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cWx93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pDefer);
function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject)=>{
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fftul":[function(require,module,exports) {
// ported from https://www.npmjs.com/package/fast-fifo
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIFO", ()=>FIFO);
class FixedFIFO {
    buffer;
    mask;
    top;
    btm;
    next;
    constructor(hwm){
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
    }
    push(data) {
        if (this.buffer[this.top] !== undefined) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
    }
    shift() {
        const last = this.buffer[this.btm];
        if (last === undefined) return undefined;
        this.buffer[this.btm] = undefined;
        this.btm = this.btm + 1 & this.mask;
        return last;
    }
    isEmpty() {
        return this.buffer[this.btm] === undefined;
    }
}
class FIFO {
    size;
    hwm;
    head;
    tail;
    constructor(options = {}){
        this.hwm = options.splitLimit ?? 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.size = 0;
    }
    calculateSize(obj) {
        if (obj?.byteLength != null) return obj.byteLength;
        return 1;
    }
    push(val) {
        if (val?.value != null) this.size += this.calculateSize(val.value);
        if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
        }
    }
    shift() {
        let val = this.tail.shift();
        if (val === undefined && this.tail.next != null) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            val = this.tail.shift();
        }
        if (val?.value != null) this.size -= this.calculateSize(val.value);
        return val;
    }
    isEmpty() {
        return this.head.isEmpty();
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"446Ja":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Race an event against an AbortSignal, taking care to remove any event
 * listeners that were added.
 *
 * @example Getting started
 *
 * ```TypeScript
 * import { raceEvent } from 'race-event'
 *
 * const controller = new AbortController()
 * const emitter = new EventTarget()
 *
 * setTimeout(() => {
 *   controller.abort()
 * }, 500)
 *
 * setTimeout(() => {
 *   // too late
 *   emitter.dispatchEvent(new CustomEvent('event'))
 * }, 1000)
 *
 * // throws an AbortError
 * const resolve = await raceEvent(emitter, 'event', controller.signal)
 * ```
 *
 * @example Customising the thrown AbortError
 *
 * The error message and `.code` property of the thrown `AbortError` can be
 * specified by passing options:
 *
 * ```TypeScript
 * import { raceEvent } from 'race-event'
 *
 * const controller = new AbortController()
 * const emitter = new EventTarget()
 *
 * setTimeout(() => {
 *   controller.abort()
 * }, 500)
 *
 * // throws a Error: Oh no!
 * const resolve = await raceEvent(emitter, 'event', controller.signal, {
 *   errorMessage: 'Oh no!',
 *   errorCode: 'ERR_OH_NO'
 * })
 * ```
 *
 * @example Only resolving on specific events
 *
 * Where multiple events with the same type are emitted, a `filter` function can
 * be passed to only resolve on one of them:
 *
 * ```TypeScript
 * import { raceEvent } from 'race-event'
 *
 * const controller = new AbortController()
 * const emitter = new EventTarget()
 *
 * // throws a Error: Oh no!
 * const resolve = await raceEvent(emitter, 'event', controller.signal, {
 *   filter: (evt: Event) => {
 *     return evt.detail.foo === 'bar'
 *   }
 * })
 * ```
 *
 * @example Terminating early by throwing from the filter
 *
 * You can cause listening for the event to cease and all event listeners to be
 * removed by throwing from the filter:
 *
 * ```TypeScript
 * import { raceEvent } from 'race-event'
 *
 * const controller = new AbortController()
 * const emitter = new EventTarget()
 *
 * // throws Error: Cannot continue
 * const resolve = await raceEvent(emitter, 'event', controller.signal, {
 *   filter: (evt) => {
 *     if (...reasons) {
 *       throw new Error('Cannot continue')
 *     }
 *
 *     return true
 *   }
 * })
 * ```
 */ /**
 * An abort error class that extends error
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
/**
 * Race a promise against an abort signal
 */ parcelHelpers.export(exports, "raceEvent", ()=>raceEvent);
class AbortError extends Error {
    type;
    code;
    constructor(message, code){
        super(message ?? "The operation was aborted");
        this.type = "aborted";
        this.name = "AbortError";
        this.code = code ?? "ABORT_ERR";
    }
}
async function raceEvent(emitter, eventName, signal, opts) {
    // create the error here so we have more context in the stack trace
    const error = new AbortError(opts?.errorMessage, opts?.errorCode);
    if (signal?.aborted === true) return Promise.reject(error);
    return new Promise((resolve, reject)=>{
        const eventListener = (evt)=>{
            try {
                if (opts?.filter?.(evt) === false) return;
            } catch (err) {
                emitter.removeEventListener(eventName, eventListener);
                signal?.removeEventListener("abort", abortListener);
                reject(err);
                return;
            }
            emitter.removeEventListener(eventName, eventListener);
            signal?.removeEventListener("abort", abortListener);
            resolve(evt);
        };
        const abortListener = ()=>{
            emitter.removeEventListener(eventName, eventListener);
            signal?.removeEventListener("abort", abortListener);
            reject(error);
        };
        emitter.addEventListener(eventName, eventListener);
        signal?.addEventListener("abort", abortListener);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5Ew3U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Job", ()=>Job);
var _interface = require("@libp2p/interface");
var _raceSignal = require("race-signal");
var _recipientJs = require("./recipient.js");
/**
 * Returns a random string
 */ function randomId() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
class Job {
    id;
    fn;
    options;
    priority;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options, priority = 0){
        this.id = randomId();
        this.status = "queued";
        this.fn = fn;
        this.priority = priority;
        this.options = options;
        this.recipients = [];
        this.timeline = {
            created: Date.now()
        };
        this.controller = new AbortController();
        (0, _interface.setMaxListeners)(Infinity, this.controller.signal);
        this.onAbort = this.onAbort.bind(this);
    }
    abort(err) {
        this.controller.abort(err);
    }
    onAbort() {
        const allAborted = this.recipients.reduce((acc, curr)=>{
            return acc && curr.signal?.aborted === true;
        }, true);
        // if all recipients have aborted the job, actually abort the job
        if (allAborted) this.controller.abort(new (0, _interface.AbortError)());
    }
    async join(options = {}) {
        const recipient = new (0, _recipientJs.JobRecipient)(new Error("where").stack, options.signal);
        this.recipients.push(recipient);
        options.signal?.addEventListener("abort", this.onAbort);
        return recipient.deferred.promise;
    }
    async run() {
        this.status = "running";
        this.timeline.started = Date.now();
        try {
            this.controller.signal.throwIfAborted();
            const result = await (0, _raceSignal.raceSignal)(this.fn({
                ...this.options ?? {},
                signal: this.controller.signal
            }), this.controller.signal);
            this.recipients.forEach((recipient)=>{
                recipient.deferred.resolve(result);
            });
            this.status = "complete";
        } catch (err) {
            this.recipients.forEach((recipient)=>{
                recipient.deferred.reject(err);
            });
            this.status = "errored";
        } finally{
            this.timeline.finished = Date.now();
            this.cleanup();
        }
    }
    cleanup() {
        this.recipients.forEach((recipient)=>{
            recipient.signal?.removeEventListener("abort", this.onAbort);
        });
    }
}

},{"@libp2p/interface":"b14bx","race-signal":"dHlMT","./recipient.js":"1h5c5","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dHlMT":[function(require,module,exports) {
/**
 * An abort error class that extends error
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
/**
 * Race a promise against an abort signal
 */ parcelHelpers.export(exports, "raceSignal", ()=>raceSignal);
class AbortError extends Error {
    type;
    code;
    constructor(message, code){
        super(message ?? "The operation was aborted");
        this.type = "aborted";
        this.name = "AbortError";
        this.code = code ?? "ABORT_ERR";
    }
}
async function raceSignal(promise, signal, opts) {
    if (signal == null) return promise;
    if (signal.aborted) return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode));
    let listener;
    // create the error here so we have more context in the stack trace
    const error = new AbortError(opts?.errorMessage, opts?.errorCode);
    try {
        return await Promise.race([
            promise,
            new Promise((resolve, reject)=>{
                listener = ()=>{
                    reject(error);
                };
                signal.addEventListener("abort", listener);
            })
        ]);
    } finally{
        if (listener != null) signal.removeEventListener("abort", listener);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1h5c5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JobRecipient", ()=>JobRecipient);
var _interface = require("@libp2p/interface");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
class JobRecipient {
    deferred;
    signal;
    where;
    constructor(where, signal){
        this.signal = signal;
        this.deferred = (0, _pDeferDefault.default)();
        this.where = where;
        this.onAbort = this.onAbort.bind(this);
        this.signal?.addEventListener("abort", this.onAbort);
    }
    onAbort() {
        this.deferred.reject(new (0, _interface.AbortError)());
    }
    cleanup() {
        this.signal?.removeEventListener("abort", this.onAbort);
    }
}

},{"@libp2p/interface":"b14bx","p-defer":"cWx93","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ef8fV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN_CONNECTIONS", ()=>MIN_CONNECTIONS);
parcelHelpers.export(exports, "MAX_CONNECTIONS", ()=>MAX_CONNECTIONS);
parcelHelpers.export(exports, "MAX_PARALLEL_DIALS", ()=>MAX_PARALLEL_DIALS);
parcelHelpers.export(exports, "AUTO_DIAL_PEER_RETRY_THRESHOLD", ()=>AUTO_DIAL_PEER_RETRY_THRESHOLD);
var _constantsDefaultsJs = require("./constants.defaults.js");
parcelHelpers.exportAll(_constantsDefaultsJs, exports);
const MIN_CONNECTIONS = 5;
const MAX_CONNECTIONS = 100;
const MAX_PARALLEL_DIALS = 50;
const AUTO_DIAL_PEER_RETRY_THRESHOLD = 420000;

},{"./constants.defaults.js":"hQUz5","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hQUz5":[function(require,module,exports) {
/**
 * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DIAL_TIMEOUT", ()=>DIAL_TIMEOUT);
parcelHelpers.export(exports, "INBOUND_UPGRADE_TIMEOUT", ()=>INBOUND_UPGRADE_TIMEOUT);
parcelHelpers.export(exports, "MAX_PEER_ADDRS_TO_DIAL", ()=>MAX_PEER_ADDRS_TO_DIAL);
parcelHelpers.export(exports, "AUTO_DIAL_INTERVAL", ()=>AUTO_DIAL_INTERVAL);
parcelHelpers.export(exports, "AUTO_DIAL_CONCURRENCY", ()=>AUTO_DIAL_CONCURRENCY);
parcelHelpers.export(exports, "AUTO_DIAL_PRIORITY", ()=>AUTO_DIAL_PRIORITY);
parcelHelpers.export(exports, "AUTO_DIAL_MAX_QUEUE_LENGTH", ()=>AUTO_DIAL_MAX_QUEUE_LENGTH);
parcelHelpers.export(exports, "AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE", ()=>AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE);
parcelHelpers.export(exports, "INBOUND_CONNECTION_THRESHOLD", ()=>INBOUND_CONNECTION_THRESHOLD);
parcelHelpers.export(exports, "MAX_INCOMING_PENDING_CONNECTIONS", ()=>MAX_INCOMING_PENDING_CONNECTIONS);
parcelHelpers.export(exports, "LAST_DIAL_FAILURE_KEY", ()=>LAST_DIAL_FAILURE_KEY);
const DIAL_TIMEOUT = 30e3;
const INBOUND_UPGRADE_TIMEOUT = 30e3;
const MAX_PEER_ADDRS_TO_DIAL = 25;
const AUTO_DIAL_INTERVAL = 5000;
const AUTO_DIAL_CONCURRENCY = 25;
const AUTO_DIAL_PRIORITY = 0;
const AUTO_DIAL_MAX_QUEUE_LENGTH = 100;
const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;
const INBOUND_CONNECTION_THRESHOLD = 5;
const MAX_INCOMING_PENDING_CONNECTIONS = 10;
const LAST_DIAL_FAILURE_KEY = "last-dial-failure";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iNcEH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * If we go over the max connections limit, choose some connections to close
 */ parcelHelpers.export(exports, "ConnectionPruner", ()=>ConnectionPruner);
var _peerCollections = require("@libp2p/peer-collections");
var _constantsJs = require("./constants.js");
const defaultOptions = {
    maxConnections: (0, _constantsJs.MAX_CONNECTIONS),
    allow: []
};
class ConnectionPruner {
    maxConnections;
    connectionManager;
    peerStore;
    allow;
    events;
    log;
    constructor(components, init = {}){
        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;
        this.allow = init.allow ?? defaultOptions.allow;
        this.connectionManager = components.connectionManager;
        this.peerStore = components.peerStore;
        this.events = components.events;
        this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
        // check the max connection limit whenever a peer connects
        components.events.addEventListener("connection:open", ()=>{
            this.maybePruneConnections().catch((err)=>{
                this.log.error(err);
            });
        });
    }
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */ async maybePruneConnections() {
        const connections = this.connectionManager.getConnections();
        const numConnections = connections.length;
        const toPrune = Math.max(numConnections - this.maxConnections, 0);
        this.log("checking max connections limit %d/%d", numConnections, this.maxConnections);
        if (numConnections <= this.maxConnections) return;
        this.log("max connections limit exceeded %d/%d, pruning %d connection(s)", numConnections, this.maxConnections, toPrune);
        const peerValues = new (0, _peerCollections.PeerMap)();
        // work out peer values
        for (const connection of connections){
            const remotePeer = connection.remotePeer;
            if (peerValues.has(remotePeer)) continue;
            peerValues.set(remotePeer, 0);
            try {
                const peer = await this.peerStore.get(remotePeer);
                // sum all tag values
                peerValues.set(remotePeer, [
                    ...peer.tags.values()
                ].reduce((acc, curr)=>{
                    return acc + curr.value;
                }, 0));
            } catch (err) {
                if (err.code !== "ERR_NOT_FOUND") this.log.error("error loading peer tags", err);
            }
        }
        // sort by value, lowest to highest
        const sortedConnections = connections.sort((a, b)=>{
            const peerAValue = peerValues.get(a.remotePeer) ?? 0;
            const peerBValue = peerValues.get(b.remotePeer) ?? 0;
            if (peerAValue > peerBValue) return 1;
            if (peerAValue < peerBValue) return -1;
            // if the peers have an equal tag value then we want to close short-lived connections first
            const connectionALifespan = a.timeline.open;
            const connectionBLifespan = b.timeline.open;
            if (connectionALifespan < connectionBLifespan) return 1;
            if (connectionALifespan > connectionBLifespan) return -1;
            return 0;
        });
        // close some connections
        const toClose = [];
        for (const connection of sortedConnections){
            this.log("too many connections open - closing a connection to %p", connection.remotePeer);
            // check allow list
            const connectionInAllowList = this.allow.some((ma)=>{
                return connection.remoteAddr.toString().startsWith(ma.toString());
            });
            // Connections in the allow list should be excluded from pruning
            if (!connectionInAllowList) toClose.push(connection);
            if (toClose.length === toPrune) break;
        }
        // close connections
        await Promise.all(toClose.map(async (connection)=>{
            try {
                await connection.close();
            } catch (err) {
                this.log.error(err);
            }
        }));
        // despatch prune event
        this.events.safeDispatchEvent("connection:prune", {
            detail: toClose
        });
    }
}

},{"@libp2p/peer-collections":"jqBHH","./constants.js":"ef8fV","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"64bMR":[function(require,module,exports) {
/* eslint-disable max-depth */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DialQueue", ()=>DialQueue);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _addressSort = require("@libp2p/utils/address-sort");
var _queue = require("@libp2p/utils/queue");
var _multiaddr = require("@multiformats/multiaddr");
var _resolvers = require("@multiformats/multiaddr/resolvers");
var _anySignal = require("any-signal");
var _fromString = require("uint8arrays/from-string");
var _errorsJs = require("../errors.js");
var _getPeerJs = require("../get-peer.js");
var _constantsJs = require("./constants.js");
var _utilsJs = require("./utils.js");
const defaultOptions = {
    addressSorter: (0, _addressSort.defaultAddressSort),
    maxParallelDials: (0, _constantsJs.MAX_PARALLEL_DIALS),
    maxPeerAddrsToDial: (0, _constantsJs.MAX_PEER_ADDRS_TO_DIAL),
    dialTimeout: (0, _constantsJs.DIAL_TIMEOUT),
    resolvers: {
        dnsaddr: (0, _resolvers.dnsaddrResolver)
    }
};
class DialQueue {
    queue;
    components;
    addressSorter;
    maxPeerAddrsToDial;
    dialTimeout;
    shutDownController;
    connections;
    log;
    constructor(components, init = {}){
        this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter;
        this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial;
        this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout;
        this.connections = init.connections ?? new (0, _peerCollections.PeerMap)();
        this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
        this.components = components;
        this.shutDownController = new AbortController();
        (0, _interface.setMaxListeners)(Infinity, this.shutDownController.signal);
        for (const [key, value] of Object.entries(init.resolvers ?? {}))(0, _multiaddr.resolvers).set(key, value);
        // controls dial concurrency
        this.queue = new (0, _queue.Queue)({
            concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,
            metricName: "libp2p_dial_queue",
            metrics: components.metrics
        });
        // a started job errored
        this.queue.addEventListener("error", (event)=>{
            this.log.error("error in dial queue", event.detail);
        });
    }
    start() {
        this.shutDownController = new AbortController();
    }
    /**
     * Clears any pending dials
     */ stop() {
        this.shutDownController.abort();
        this.queue.abort();
    }
    /**
     * Connects to a given peer, multiaddr or list of multiaddrs.
     *
     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
     * multiaddrs are passed only those will be dialled.
     *
     * Where a list of multiaddrs is passed, if any contain a peer id then all
     * multiaddrs in the list must contain the same peer id.
     *
     * The dial to the first address that is successfully able to upgrade a
     * connection will be used, all other dials will be aborted when that happens.
     */ async dial(peerIdOrMultiaddr, options = {}) {
        const { peerId, multiaddrs } = (0, _getPeerJs.getPeerAddress)(peerIdOrMultiaddr);
        // make sure we don't have an existing connection to any of the addresses we
        // are about to dial
        const existingConnection = Array.from(this.connections.values()).flat().find((conn)=>{
            if (options.force === true) return false;
            if (conn.remotePeer.equals(peerId)) return true;
            return multiaddrs.find((addr)=>{
                return addr.equals(conn.remoteAddr);
            });
        });
        if (existingConnection != null) {
            this.log("already connected to %a", existingConnection.remoteAddr);
            return existingConnection;
        }
        // ready to dial, all async work finished - make sure we don't have any
        // pending dials in progress for this peer or set of multiaddrs
        const existingDial = this.queue.queue.find((job)=>{
            if (peerId?.equals(job.options.peerId) === true) return true;
            // does the dial contain any of the target multiaddrs?
            const addresses = job.options.multiaddrs;
            if (addresses == null) return false;
            for (const multiaddr of multiaddrs){
                if (addresses.has(multiaddr.toString())) return true;
            }
            return false;
        });
        if (existingDial != null) {
            this.log("joining existing dial target for %p", peerId);
            // add all multiaddrs to the dial target
            for (const multiaddr of multiaddrs)existingDial.options.multiaddrs.add(multiaddr.toString());
            return existingDial.join(options);
        }
        this.log("creating dial target for %p", peerId, multiaddrs.map((ma)=>ma.toString()));
        return this.queue.add(async (options)=>{
            // create abort conditions - need to do this before `calculateMultiaddrs` as
            // we may be about to resolve a dns addr which can time out
            const signal = this.createDialAbortController(options?.signal);
            let addrsToDial;
            try {
                // load addresses from address book, resolve and dnsaddrs, filter
                // undiallables, add peer IDs, etc
                addrsToDial = await this.calculateMultiaddrs(peerId, options?.multiaddrs, {
                    ...options,
                    signal
                });
                addrsToDial.map(({ multiaddr })=>multiaddr.toString()).forEach((addr)=>{
                    options?.multiaddrs.add(addr);
                });
            } catch (err) {
                signal.clear();
                throw err;
            }
            try {
                let dialed = 0;
                const errors = [];
                for (const address of addrsToDial){
                    if (dialed === this.maxPeerAddrsToDial) {
                        this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, peerId);
                        throw new (0, _interface.CodeError)("Peer had more than maxPeerAddrsToDial", (0, _errorsJs.codes).ERR_TOO_MANY_ADDRESSES);
                    }
                    dialed++;
                    try {
                        const conn = await this.components.transportManager.dial(address.multiaddr, {
                            ...options,
                            signal
                        });
                        this.log("dial to %a succeeded", address.multiaddr);
                        return conn;
                    } catch (err) {
                        this.log.error("dial failed to %a", address.multiaddr, err);
                        if (peerId != null) // record the failed dial
                        try {
                            await this.components.peerStore.patch(peerId, {
                                metadata: {
                                    [(0, _constantsJs.LAST_DIAL_FAILURE_KEY)]: (0, _fromString.fromString)(Date.now().toString())
                                }
                            });
                        } catch (err) {
                            this.log.error("could not update last dial failure key for %p", peerId, err);
                        }
                        // the user/dial timeout/shutdown controller signal aborted
                        if (signal.aborted) throw new (0, _interface.CodeError)(err.message, (0, _interface.ERR_TIMEOUT));
                        errors.push(err);
                    }
                }
                if (errors.length === 1) throw errors[0];
                throw new (0, _interface.AggregateCodeError)(errors, "All multiaddr dials failed", (0, _errorsJs.codes).ERR_TRANSPORT_DIAL_FAILED);
            } finally{
                // clean up abort signals/controllers
                signal.clear();
            }
        }, {
            peerId,
            priority: options.priority,
            multiaddrs: new Set(multiaddrs.map((ma)=>ma.toString())),
            signal: options.signal
        });
    }
    createDialAbortController(userSignal) {
        // let any signal abort the dial
        const signal = (0, _anySignal.anySignal)([
            AbortSignal.timeout(this.dialTimeout),
            this.shutDownController.signal,
            userSignal
        ]);
        // This emitter gets listened to a lot
        (0, _interface.setMaxListeners)(Infinity, signal);
        return signal;
    }
    // eslint-disable-next-line complexity
    async calculateMultiaddrs(peerId, multiaddrs = new Set(), options = {}) {
        const addrs = [
            ...multiaddrs
        ].map((ma)=>({
                multiaddr: (0, _multiaddr.multiaddr)(ma),
                isCertified: false
            }));
        // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it
        if (peerId != null) {
            if (this.components.peerId.equals(peerId)) throw new (0, _interface.CodeError)("Tried to dial self", (0, _errorsJs.codes).ERR_DIALED_SELF);
            if (await this.components.connectionGater.denyDialPeer?.(peerId) === true) throw new (0, _interface.CodeError)("The dial request is blocked by gater.allowDialPeer", (0, _errorsJs.codes).ERR_PEER_DIAL_INTERCEPTED);
            // if just a peer id was passed, load available multiaddrs for this peer
            // from the peer store
            if (addrs.length === 0) {
                this.log("loading multiaddrs for %p", peerId);
                try {
                    const peer = await this.components.peerStore.get(peerId);
                    addrs.push(...peer.addresses);
                    this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr })=>multiaddr.toString()));
                } catch (err) {
                    if (err.code !== (0, _errorsJs.codes).ERR_NOT_FOUND) throw err;
                }
            }
            // if we still don't have any addresses for this peer, try a lookup
            // using the peer routing
            if (addrs.length === 0) {
                this.log("looking up multiaddrs for %p in the peer routing", peerId);
                try {
                    const peerInfo = await this.components.peerRouting.findPeer(peerId);
                    this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr })=>multiaddr.toString()));
                    addrs.push(...peerInfo.multiaddrs.map((multiaddr)=>({
                            multiaddr,
                            isCertified: false
                        })));
                } catch (err) {
                    if (err.code !== (0, _errorsJs.codes).ERR_NO_ROUTERS_AVAILABLE) this.log.error("looking up multiaddrs for %p in the peer routing failed", peerId, err);
                }
            }
        }
        // resolve addresses - this can result in a one-to-many translation when
        // dnsaddrs are resolved
        let resolvedAddresses = (await Promise.all(addrs.map(async (addr)=>{
            const result = await (0, _utilsJs.resolveMultiaddrs)(addr.multiaddr, {
                ...options,
                log: this.log
            });
            if (result.length === 1 && result[0].equals(addr.multiaddr)) return addr;
            return result.map((multiaddr)=>({
                    multiaddr,
                    isCertified: false
                }));
        }))).flat();
        // ensure the peer id is appended to the multiaddr
        if (peerId != null) {
            const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
            resolvedAddresses = resolvedAddresses.map((addr)=>{
                const lastProto = addr.multiaddr.protos().pop();
                // do not append peer id to path multiaddrs
                if (lastProto?.path === true) return addr;
                // append peer id to multiaddr if it is not already present
                if (addr.multiaddr.getPeerId() == null) return {
                    multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
                    isCertified: addr.isCertified
                };
                return addr;
            });
        }
        const filteredAddrs = resolvedAddresses.filter((addr)=>{
            // filter out any multiaddrs that we do not have transports for
            if (this.components.transportManager.transportForMultiaddr(addr.multiaddr) == null) return false;
            // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it
            // - this can happen with addresses like bootstrap.libp2p.io that resolve
            // to multiple different peers
            const addrPeerId = addr.multiaddr.getPeerId();
            if (peerId != null && addrPeerId != null) return peerId.equals(addrPeerId);
            return true;
        });
        // deduplicate addresses
        const dedupedAddrs = new Map();
        for (const addr of filteredAddrs){
            const maStr = addr.multiaddr.toString();
            const existing = dedupedAddrs.get(maStr);
            if (existing != null) {
                existing.isCertified = existing.isCertified || addr.isCertified || false;
                continue;
            }
            dedupedAddrs.set(maStr, addr);
        }
        const dedupedMultiaddrs = [
            ...dedupedAddrs.values()
        ];
        // make sure we actually have some addresses to dial
        if (dedupedMultiaddrs.length === 0) throw new (0, _interface.CodeError)("The dial request has no valid addresses", (0, _errorsJs.codes).ERR_NO_VALID_ADDRESSES);
        const gatedAdrs = [];
        for (const addr of dedupedMultiaddrs){
            if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) continue;
            gatedAdrs.push(addr);
        }
        const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);
        // make sure we actually have some addresses to dial
        if (sortedGatedAddrs.length === 0) throw new (0, _interface.CodeError)("The connection gater denied all addresses in the dial request", (0, _errorsJs.codes).ERR_NO_VALID_ADDRESSES);
        this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr })=>multiaddr.toString()));
        this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr })=>multiaddr.toString()));
        return sortedGatedAddrs;
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","@libp2p/utils/address-sort":"hXpHf","@libp2p/utils/queue":"i1Kpf","@multiformats/multiaddr":"7Qpz2","@multiformats/multiaddr/resolvers":"fZLfL","any-signal":"j05UB","uint8arrays/from-string":"3YvUV","../errors.js":"ayaP8","../get-peer.js":"1kzFk","./constants.js":"ef8fV","./utils.js":"2DdgP","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"j05UB":[function(require,module,exports) {
/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "anySignal", ()=>anySignal);
function anySignal(signals) {
    const controller = new globalThis.AbortController();
    function onAbort() {
        controller.abort();
        for (const signal of signals)if (signal?.removeEventListener != null) signal.removeEventListener("abort", onAbort);
    }
    for (const signal of signals){
        if (signal?.aborted === true) {
            onAbort();
            break;
        }
        if (signal?.addEventListener != null) signal.addEventListener("abort", onAbort);
    }
    function clear() {
        for (const signal of signals)if (signal?.removeEventListener != null) signal.removeEventListener("abort", onAbort);
    }
    const signal = controller.signal;
    signal.clear = clear;
    return signal;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2DdgP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Resolve multiaddr recursively
 */ parcelHelpers.export(exports, "resolveMultiaddrs", ()=>resolveMultiaddrs);
var _multiaddr = require("@multiformats/multiaddr");
async function resolveMultiaddrs(ma, options) {
    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place
    // Now only supporting resolve for dnsaddr
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    // Multiaddr is not resolvable? End recursion!
    if (!resolvableProto) return [
        ma
    ];
    const resolvedMultiaddrs = await resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm)=>{
        return resolveMultiaddrs(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    const output = addrs.reduce((array, newM)=>{
        if (array.find((m)=>m.equals(newM)) == null) array.push(newM);
        return array;
    }, []);
    options.log("resolved %s to", ma, output.map((ma)=>ma.toString()));
    return output;
}
/**
 * Resolve a given multiaddr. If this fails, an empty array will be returned
 */ async function resolveRecord(ma, options) {
    try {
        ma = (0, _multiaddr.multiaddr)(ma.toString()); // Use current multiaddr module
        const multiaddrs = await ma.resolve(options);
        return multiaddrs;
    } catch (err) {
        options.log.error(`multiaddr ${ma.toString()} could not be resolved`, err);
        return [];
    }
}

},{"@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fgLfY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CompoundContentRouting", ()=>CompoundContentRouting);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _itMerge = require("it-merge");
var _itMergeDefault = parcelHelpers.interopDefault(_itMerge);
var _errorsJs = require("./errors.js");
class CompoundContentRouting {
    routers;
    started;
    components;
    constructor(components, init){
        this.routers = init.routers ?? [];
        this.started = false;
        this.components = components;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        this.started = true;
    }
    async stop() {
        this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */ async *findProviders(key, options = {}) {
        if (this.routers.length === 0) throw new (0, _interface.CodeError)("No content routers available", (0, _errorsJs.codes).ERR_NO_ROUTERS_AVAILABLE);
        const self = this;
        const seen = new (0, _peerCollections.PeerSet)();
        for await (const peer of (0, _itMergeDefault.default)(...self.routers.map((router)=>router.findProviders(key, options)))){
            // the peer was yielded by a content router without multiaddrs and we
            // failed to load them
            if (peer == null) continue;
            // store the addresses for the peer if found
            if (peer.multiaddrs.length > 0) await this.components.peerStore.merge(peer.id, {
                multiaddrs: peer.multiaddrs
            });
            // deduplicate peers
            if (seen.has(peer.id)) continue;
            seen.add(peer.id);
            yield peer;
        }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */ async provide(key, options = {}) {
        if (this.routers.length === 0) throw new (0, _interface.CodeError)("No content routers available", (0, _errorsJs.codes).ERR_NO_ROUTERS_AVAILABLE);
        await Promise.all(this.routers.map(async (router)=>{
            await router.provide(key, options);
        }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */ async put(key, value, options) {
        if (!this.isStarted()) throw new (0, _interface.CodeError)((0, _errorsJs.messages).NOT_STARTED_YET, (0, _errorsJs.codes).ERR_NODE_NOT_STARTED);
        await Promise.all(this.routers.map(async (router)=>{
            await router.put(key, value, options);
        }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */ async get(key, options) {
        if (!this.isStarted()) throw new (0, _interface.CodeError)((0, _errorsJs.messages).NOT_STARTED_YET, (0, _errorsJs.codes).ERR_NODE_NOT_STARTED);
        return Promise.any(this.routers.map(async (router)=>{
            return router.get(key, options);
        }));
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","it-merge":"7FBsB","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7FBsB":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Merge several (async)iterables into one, yield values as they arrive.
 *
 * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.
 *
 * @example
 *
 * ```javascript
 * import merge from 'it-merge'
 * import all from 'it-all'
 *
 * // This can also be an iterator, generator, etc
 * const values1 = [0, 1, 2, 3, 4]
 * const values2 = [5, 6, 7, 8, 9]
 *
 * const arr = all(merge(values1, values2))
 *
 * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import merge from 'it-merge'
 * import all from 'it-all'
 *
 * // This can also be an iterator, async iterator, generator, etc
 * const values1 = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 * const values2 = async function * () {
 *   yield * [5, 6, 7, 8, 9]
 * }
 *
 * const arr = await all(merge(values1(), values2()))
 *
 * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itPushable = require("it-pushable");
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function merge(...sources) {
    const syncSources = [];
    for (const source of sources)if (!isAsyncIterable(source)) syncSources.push(source);
    if (syncSources.length === sources.length) // all sources are synchronous
    return function*() {
        for (const source of syncSources)yield* source;
    }();
    return async function*() {
        const output = (0, _itPushable.pushable)({
            objectMode: true
        });
        Promise.resolve().then(async ()=>{
            try {
                await Promise.all(sources.map(async (source)=>{
                    for await (const item of source)output.push(item);
                }));
                output.end();
            } catch (err) {
                output.end(err);
            }
        });
        yield* output;
    }();
}
exports.default = merge;

},{"it-pushable":"hxxEW","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6qx0B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultPeerRouting", ()=>DefaultPeerRouting);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _itMerge = require("it-merge");
var _itMergeDefault = parcelHelpers.interopDefault(_itMerge);
var _itParallel = require("it-parallel");
var _itParallelDefault = parcelHelpers.interopDefault(_itParallel);
var _errorsJs = require("./errors.js");
class DefaultPeerRouting {
    log;
    peerId;
    peerStore;
    routers;
    constructor(components, init = {}){
        this.log = components.logger.forComponent("libp2p:peer-routing");
        this.peerId = components.peerId;
        this.peerStore = components.peerStore;
        this.routers = init.routers ?? [];
    }
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */ async findPeer(id, options) {
        if (this.routers.length === 0) throw new (0, _interface.CodeError)("No peer routers available", (0, _errorsJs.codes).ERR_NO_ROUTERS_AVAILABLE);
        if (id.toString() === this.peerId.toString()) throw new (0, _interface.CodeError)("Should not try to find self", (0, _errorsJs.codes).ERR_FIND_SELF);
        const self = this;
        const source = (0, _itMergeDefault.default)(...this.routers.map((router)=>(async function*() {
                try {
                    yield await router.findPeer(id, options);
                } catch (err) {
                    self.log.error(err);
                }
            })()));
        for await (const peer of source){
            if (peer == null) continue;
            // store the addresses for the peer if found
            if (peer.multiaddrs.length > 0) await this.peerStore.merge(peer.id, {
                multiaddrs: peer.multiaddrs
            });
            return peer;
        }
        throw new (0, _interface.CodeError)((0, _errorsJs.messages).NOT_FOUND, (0, _errorsJs.codes).ERR_NOT_FOUND);
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */ async *getClosestPeers(key, options = {}) {
        if (this.routers.length === 0) throw new (0, _interface.CodeError)("No peer routers available", (0, _errorsJs.codes).ERR_NO_ROUTERS_AVAILABLE);
        const self = this;
        const seen = new (0, _peerCollections.PeerSet)();
        for await (const peer of (0, _itParallelDefault.default)(async function*() {
            const source = (0, _itMergeDefault.default)(...self.routers.map((router)=>router.getClosestPeers(key, options)));
            for await (let peer of source)yield async ()=>{
                // find multiaddrs if they are missing
                if (peer.multiaddrs.length === 0) try {
                    peer = await self.findPeer(peer.id, {
                        ...options,
                        useCache: false
                    });
                } catch (err) {
                    self.log.error("could not find peer multiaddrs", err);
                    return;
                }
                return peer;
            };
        }())){
            if (peer == null) continue;
            // store the addresses for the peer if found
            if (peer.multiaddrs.length > 0) await this.peerStore.merge(peer.id, {
                multiaddrs: peer.multiaddrs
            });
            // deduplicate peers
            if (seen.has(peer.id)) continue;
            seen.add(peer.id);
            yield peer;
        }
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","it-merge":"7FBsB","it-parallel":"dPkg2","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dPkg2":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input
 *
 * @example
 *
 * ```javascript
 * import parallel from 'it-parallel'
 * import all from 'it-all'
 * import delay from 'delay'
 *
 * // This can also be an iterator, async iterator, generator, etc
 * const input = [
 *   async () => {
 *     console.info('start 1')
 *     await delay(500)
 *
 *     console.info('end 1')
 *     return 1
 *   },
 *   async () => {
 *     console.info('start 2')
 *     await delay(200)
 *
 *     console.info('end 2')
 *     return 2
 *   },
 *   async () => {
 *     console.info('start 3')
 *     await delay(100)
 *
 *     console.info('end 3')
 *     return 3
 *   }
 * ]
 *
 * const result = await all(parallel(input, {
 *   concurrency: 2
 * }))
 *
 * // output:
 * // start 1
 * // start 2
 * // end 2
 * // start 3
 * // end 3
 * // end 1
 *
 * console.info(result) // [2, 3, 1]
 * ```
 *
 * If order is important, pass `ordered: true` as an option:
 *
 * ```javascript
 * const result = await all(parallel(input, {
 *   concurrency: 2,
 *   ordered: true
 * }))
 *
 * // output:
 * // start 1
 * // start 2
 * // end 2
 * // start 3
 * // end 3
 * // end 1
 *
 * console.info(result) // [1, 2, 3]
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parallel);
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
const CustomEvent = globalThis.CustomEvent ?? Event;
async function* parallel(source, options = {}) {
    let concurrency = options.concurrency ?? Infinity;
    if (concurrency < 1) concurrency = Infinity;
    const ordered = options.ordered == null ? false : options.ordered;
    const emitter = new EventTarget();
    const ops = [];
    let slotAvailable = (0, _pDeferDefault.default)();
    let resultAvailable = (0, _pDeferDefault.default)();
    let sourceFinished = false;
    let sourceErr;
    let opErred = false;
    emitter.addEventListener("task-complete", ()=>{
        resultAvailable.resolve();
    });
    Promise.resolve().then(async ()=>{
        try {
            for await (const task of source){
                if (ops.length === concurrency) {
                    slotAvailable = (0, _pDeferDefault.default)();
                    await slotAvailable.promise;
                }
                if (opErred) break;
                const op = {
                    done: false
                };
                ops.push(op);
                task().then((result)=>{
                    op.done = true;
                    op.ok = true;
                    op.value = result;
                    emitter.dispatchEvent(new CustomEvent("task-complete"));
                }, (err)=>{
                    op.done = true;
                    op.err = err;
                    emitter.dispatchEvent(new CustomEvent("task-complete"));
                });
            }
            sourceFinished = true;
            emitter.dispatchEvent(new CustomEvent("task-complete"));
        } catch (err) {
            sourceErr = err;
            emitter.dispatchEvent(new CustomEvent("task-complete"));
        }
    });
    function valuesAvailable() {
        if (ordered) return ops[0]?.done;
        return Boolean(ops.find((op)=>op.done));
    }
    function* yieldOrderedValues() {
        while(ops.length > 0 && ops[0].done){
            const op = ops[0];
            ops.shift();
            if (op.ok) yield op.value;
            else {
                // allow the source to exit
                opErred = true;
                slotAvailable.resolve();
                throw op.err;
            }
            slotAvailable.resolve();
        }
    }
    function* yieldUnOrderedValues() {
        // more values can become available while we wait for `yield`
        // to return control to this function
        while(valuesAvailable()){
            for(let i = 0; i < ops.length; i++)if (ops[i].done) {
                const op = ops[i];
                ops.splice(i, 1);
                i--;
                if (op.ok) yield op.value;
                else {
                    opErred = true;
                    slotAvailable.resolve();
                    throw op.err;
                }
                slotAvailable.resolve();
            }
        }
    }
    while(true){
        if (!valuesAvailable()) {
            resultAvailable = (0, _pDeferDefault.default)();
            await resultAvailable.promise;
        }
        if (sourceErr != null) // the source threw an error, propagate it
        throw sourceErr;
        if (ordered) yield* yieldOrderedValues();
        else yield* yieldUnOrderedValues();
        if (sourceFinished && ops.length === 0) break;
    }
}

},{"p-defer":"cWx93","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1YGrc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MAX_INBOUND_STREAMS", ()=>DEFAULT_MAX_INBOUND_STREAMS);
parcelHelpers.export(exports, "DEFAULT_MAX_OUTBOUND_STREAMS", ()=>DEFAULT_MAX_OUTBOUND_STREAMS);
/**
 * Responsible for notifying registered protocols of events in the network.
 */ parcelHelpers.export(exports, "DefaultRegistrar", ()=>DefaultRegistrar);
var _interface = require("@libp2p/interface");
var _mergeOptions = require("merge-options");
var _mergeOptionsDefault = parcelHelpers.interopDefault(_mergeOptions);
var _errorsJs = require("./errors.js");
const DEFAULT_MAX_INBOUND_STREAMS = 32;
const DEFAULT_MAX_OUTBOUND_STREAMS = 64;
class DefaultRegistrar {
    log;
    topologies;
    handlers;
    components;
    constructor(components){
        this.log = components.logger.forComponent("libp2p:registrar");
        this.topologies = new Map();
        this.handlers = new Map();
        this.components = components;
        this._onDisconnect = this._onDisconnect.bind(this);
        this._onPeerUpdate = this._onPeerUpdate.bind(this);
        this._onPeerIdentify = this._onPeerIdentify.bind(this);
        this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
        this.components.events.addEventListener("peer:update", this._onPeerUpdate);
        this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
    }
    getProtocols() {
        return Array.from(new Set([
            ...this.handlers.keys()
        ])).sort();
    }
    getHandler(protocol) {
        const handler = this.handlers.get(protocol);
        if (handler == null) throw new (0, _interface.CodeError)(`No handler registered for protocol ${protocol}`, (0, _errorsJs.codes).ERR_NO_HANDLER_FOR_PROTOCOL);
        return handler;
    }
    getTopologies(protocol) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) return [];
        return [
            ...topologies.values()
        ];
    }
    /**
     * Registers the `handler` for each protocol
     */ async handle(protocol, handler, opts) {
        if (this.handlers.has(protocol)) throw new (0, _interface.CodeError)(`Handler already registered for protocol ${protocol}`, (0, _errorsJs.codes).ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
        const options = (0, _mergeOptionsDefault.default).bind({
            ignoreUndefined: true
        })({
            maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
            maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
        }, opts);
        this.handlers.set(protocol, {
            handler,
            options
        });
        // Add new protocol to self protocols in the peer store
        await this.components.peerStore.merge(this.components.peerId, {
            protocols: [
                protocol
            ]
        });
    }
    /**
     * Removes the handler for each protocol. The protocol
     * will no longer be supported on streams.
     */ async unhandle(protocols) {
        const protocolList = Array.isArray(protocols) ? protocols : [
            protocols
        ];
        protocolList.forEach((protocol)=>{
            this.handlers.delete(protocol);
        });
        // Update self protocols in the peer store
        await this.components.peerStore.patch(this.components.peerId, {
            protocols: this.getProtocols()
        });
    }
    /**
     * Register handlers for a set of multicodecs given
     */ async register(protocol, topology) {
        if (topology == null) throw new (0, _interface.CodeError)("invalid topology", (0, _errorsJs.codes).ERR_INVALID_PARAMETERS);
        // Create topology
        const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
        let topologies = this.topologies.get(protocol);
        if (topologies == null) {
            topologies = new Map();
            this.topologies.set(protocol, topologies);
        }
        topologies.set(id, topology);
        return id;
    }
    /**
     * Unregister topology
     */ unregister(id) {
        for (const [protocol, topologies] of this.topologies.entries())if (topologies.has(id)) {
            topologies.delete(id);
            if (topologies.size === 0) this.topologies.delete(protocol);
        }
    }
    /**
     * Remove a disconnected peer from the record
     */ _onDisconnect(evt) {
        const remotePeer = evt.detail;
        this.components.peerStore.get(remotePeer).then((peer)=>{
            for (const protocol of peer.protocols){
                const topologies = this.topologies.get(protocol);
                if (topologies == null) continue;
                for (const topology of topologies.values())topology.onDisconnect?.(remotePeer);
            }
        }).catch((err)=>{
            if (err.code === (0, _errorsJs.codes).ERR_NOT_FOUND) // peer has not completed identify so they are not in the peer store
            return;
            this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
        });
    }
    /**
     * When a peer is updated, if they have removed supported protocols notify any
     * topologies interested in the removed protocols.
     */ _onPeerUpdate(evt) {
        const { peer, previous } = evt.detail;
        const removed = (previous?.protocols ?? []).filter((protocol)=>!peer.protocols.includes(protocol));
        for (const protocol of removed){
            const topologies = this.topologies.get(protocol);
            if (topologies == null) continue;
            for (const topology of topologies.values())topology.onDisconnect?.(peer.id);
        }
    }
    /**
     * After identify has completed and we have received the list of supported
     * protocols, notify any topologies interested in those protocols.
     */ _onPeerIdentify(evt) {
        const protocols = evt.detail.protocols;
        const connection = evt.detail.connection;
        const peerId = evt.detail.peerId;
        for (const protocol of protocols){
            const topologies = this.topologies.get(protocol);
            if (topologies == null) continue;
            for (const topology of topologies.values()){
                if (connection.transient && topology.notifyOnTransient !== true) continue;
                topology.onConnect?.(peerId, connection);
            }
        }
    }
}

},{"@libp2p/interface":"b14bx","merge-options":"l45Gy","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lE30Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultTransportManager", ()=>DefaultTransportManager);
var _interface = require("@libp2p/interface");
var _trackedMap = require("@libp2p/utils/tracked-map");
var _errorsJs = require("./errors.js");
class DefaultTransportManager {
    log;
    components;
    transports;
    listeners;
    faultTolerance;
    started;
    constructor(components, init = {}){
        this.log = components.logger.forComponent("libp2p:transports");
        this.components = components;
        this.started = false;
        this.transports = new Map();
        this.listeners = (0, _trackedMap.trackedMap)({
            name: "libp2p_transport_manager_listeners",
            metrics: this.components.metrics
        });
        this.faultTolerance = init.faultTolerance ?? (0, _interface.FaultTolerance).FATAL_ALL;
    }
    /**
     * Adds a `Transport` to the manager
     */ add(transport) {
        const tag = transport[Symbol.toStringTag];
        if (tag == null) throw new (0, _interface.CodeError)("Transport must have a valid tag", (0, _errorsJs.codes).ERR_INVALID_KEY);
        if (this.transports.has(tag)) throw new (0, _interface.CodeError)(`There is already a transport with the tag ${tag}`, (0, _errorsJs.codes).ERR_DUPLICATE_TRANSPORT);
        this.log("adding transport %s", tag);
        this.transports.set(tag, transport);
        if (!this.listeners.has(tag)) this.listeners.set(tag, []);
    }
    isStarted() {
        return this.started;
    }
    start() {
        this.started = true;
    }
    async afterStart() {
        // Listen on the provided transports for the provided addresses
        const addrs = this.components.addressManager.getListenAddrs();
        await this.listen(addrs);
    }
    /**
     * Stops all listeners
     */ async stop() {
        const tasks = [];
        for (const [key, listeners] of this.listeners){
            this.log("closing listeners for %s", key);
            while(listeners.length > 0){
                const listener = listeners.pop();
                if (listener == null) continue;
                tasks.push(listener.close());
            }
        }
        await Promise.all(tasks);
        this.log("all listeners closed");
        for (const key of this.listeners.keys())this.listeners.set(key, []);
        this.started = false;
    }
    /**
     * Dials the given Multiaddr over it's supported transport
     */ async dial(ma, options) {
        const transport = this.transportForMultiaddr(ma);
        if (transport == null) throw new (0, _interface.CodeError)(`No transport available for address ${String(ma)}`, (0, _errorsJs.codes).ERR_TRANSPORT_UNAVAILABLE);
        try {
            return await transport.dial(ma, {
                ...options,
                upgrader: this.components.upgrader
            });
        } catch (err) {
            if (err.code == null) err.code = (0, _errorsJs.codes).ERR_TRANSPORT_DIAL_FAILED;
            throw err;
        }
    }
    /**
     * Returns all Multiaddr's the listeners are using
     */ getAddrs() {
        let addrs = [];
        for (const listeners of this.listeners.values())for (const listener of listeners)addrs = [
            ...addrs,
            ...listener.getAddrs()
        ];
        return addrs;
    }
    /**
     * Returns all the transports instances
     */ getTransports() {
        return Array.of(...this.transports.values());
    }
    /**
     * Returns all the listener instances
     */ getListeners() {
        return Array.of(...this.listeners.values()).flat();
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */ transportForMultiaddr(ma) {
        for (const transport of this.transports.values()){
            const addrs = transport.filter([
                ma
            ]);
            if (addrs.length > 0) return transport;
        }
    }
    /**
     * Starts listeners for each listen Multiaddr
     */ async listen(addrs) {
        if (!this.isStarted()) throw new (0, _interface.CodeError)("Not started", (0, _errorsJs.codes).ERR_NODE_NOT_STARTED);
        if (addrs == null || addrs.length === 0) {
            this.log("no addresses were provided for listening, this node is dial only");
            return;
        }
        const couldNotListen = [];
        for (const [key, transport] of this.transports.entries()){
            const supportedAddrs = transport.filter(addrs);
            const tasks = [];
            // For each supported multiaddr, create a listener
            for (const addr of supportedAddrs){
                this.log("creating listener for %s on %a", key, addr);
                const listener = transport.createListener({
                    upgrader: this.components.upgrader
                });
                let listeners = this.listeners.get(key) ?? [];
                if (listeners == null) {
                    listeners = [];
                    this.listeners.set(key, listeners);
                }
                listeners.push(listener);
                // Track listen/close events
                listener.addEventListener("listening", ()=>{
                    this.components.events.safeDispatchEvent("transport:listening", {
                        detail: listener
                    });
                });
                listener.addEventListener("close", ()=>{
                    const index = listeners.findIndex((l)=>l === listener);
                    // remove the listener
                    listeners.splice(index, 1);
                    this.components.events.safeDispatchEvent("transport:close", {
                        detail: listener
                    });
                });
                // We need to attempt to listen on everything
                tasks.push(listener.listen(addr));
            }
            // Keep track of transports we had no addresses for
            if (tasks.length === 0) {
                couldNotListen.push(key);
                continue;
            }
            const results = await Promise.allSettled(tasks);
            // If we are listening on at least 1 address, succeed.
            // TODO: we should look at adding a retry (`p-retry`) here to better support
            // listening on remote addresses as they may be offline. We could then potentially
            // just wait for any (`p-any`) listener to succeed on each transport before returning
            const isListening = results.find((r)=>r.status === "fulfilled");
            if (isListening == null && this.faultTolerance !== (0, _interface.FaultTolerance).NO_FATAL) throw new (0, _interface.CodeError)(`Transport (${key}) could not listen on any available address`, (0, _errorsJs.codes).ERR_NO_VALID_ADDRESSES);
        }
        // If no transports were able to listen, throw an error. This likely
        // means we were given addresses we do not have transports for
        if (couldNotListen.length === this.transports.size) {
            const message = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
            if (this.faultTolerance === (0, _interface.FaultTolerance).FATAL_ALL) throw new (0, _interface.CodeError)(message, (0, _errorsJs.codes).ERR_NO_VALID_ADDRESSES);
            this.log(`libp2p in dial mode only: ${message}`);
        }
    }
    /**
     * Removes the given transport from the manager.
     * If a transport has any running listeners, they will be closed.
     */ async remove(key) {
        const listeners = this.listeners.get(key) ?? [];
        this.log.trace("removing transport %s", key);
        // Close any running listeners
        const tasks = [];
        this.log.trace("closing listeners for %s", key);
        while(listeners.length > 0){
            const listener = listeners.pop();
            if (listener == null) continue;
            tasks.push(listener.close());
        }
        await Promise.all(tasks);
        this.transports.delete(key);
        this.listeners.delete(key);
    }
    /**
     * Removes all transports from the manager.
     * If any listeners are running, they will be closed.
     *
     * @async
     */ async removeAll() {
        const tasks = [];
        for (const key of this.transports.keys())tasks.push(this.remove(key));
        await Promise.all(tasks);
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/utils/tracked-map":"jWiq5","./errors.js":"ayaP8","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jWiq5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trackedMap", ()=>trackedMap);
class TrackedMap extends Map {
    metric;
    constructor(init){
        super();
        const { name, metrics } = init;
        this.metric = metrics.registerMetric(name);
        this.updateComponentMetric();
    }
    set(key, value) {
        super.set(key, value);
        this.updateComponentMetric();
        return this;
    }
    delete(key) {
        const deleted = super.delete(key);
        this.updateComponentMetric();
        return deleted;
    }
    clear() {
        super.clear();
        this.updateComponentMetric();
    }
    updateComponentMetric() {
        this.metric.update(this.size);
    }
}
function trackedMap(config) {
    const { name, metrics } = config;
    let map;
    if (metrics != null) map = new TrackedMap({
        name,
        metrics
    });
    else map = new Map();
    return map;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2Ewxj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultUpgrader", ()=>DefaultUpgrader);
var _interface = require("@libp2p/interface");
var _multistreamSelect = require("@libp2p/multistream-select");
var _peerId = require("@libp2p/peer-id");
var _indexJs = require("./connection/index.js");
var _constantsJs = require("./connection-manager/constants.js");
var _errorsJs = require("./errors.js");
var _registrarJs = require("./registrar.js");
const DEFAULT_PROTOCOL_SELECT_TIMEOUT = 30000;
function findIncomingStreamLimit(protocol, registrar) {
    try {
        const { options } = registrar.getHandler(protocol);
        return options.maxInboundStreams;
    } catch (err) {
        if (err.code !== (0, _errorsJs.codes).ERR_NO_HANDLER_FOR_PROTOCOL) throw err;
    }
    return 0, _registrarJs.DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
    try {
        const { options } = registrar.getHandler(protocol);
        if (options.maxOutboundStreams != null) return options.maxOutboundStreams;
    } catch (err) {
        if (err.code !== (0, _errorsJs.codes).ERR_NO_HANDLER_FOR_PROTOCOL) throw err;
    }
    return options.maxOutboundStreams ?? (0, _registrarJs.DEFAULT_MAX_OUTBOUND_STREAMS);
}
function countStreams(protocol, direction, connection) {
    let streamCount = 0;
    connection.streams.forEach((stream)=>{
        if (stream.direction === direction && stream.protocol === protocol) streamCount++;
    });
    return streamCount;
}
class DefaultUpgrader {
    components;
    connectionEncryption;
    muxers;
    inboundUpgradeTimeout;
    events;
    constructor(components, init){
        this.components = components;
        this.connectionEncryption = new Map();
        init.connectionEncryption.forEach((encrypter)=>{
            this.connectionEncryption.set(encrypter.protocol, encrypter);
        });
        this.muxers = new Map();
        init.muxers.forEach((muxer)=>{
            this.muxers.set(muxer.protocol, muxer);
        });
        this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? (0, _constantsJs.INBOUND_UPGRADE_TIMEOUT);
        this.events = components.events;
    }
    async shouldBlockConnection(remotePeer, maConn, connectionType) {
        const connectionGater = this.components.connectionGater[connectionType];
        if (connectionGater !== undefined) {
            if (await connectionGater(remotePeer, maConn)) throw new (0, _interface.CodeError)(`The multiaddr connection is blocked by gater.${connectionType}`, (0, _errorsJs.codes).ERR_CONNECTION_INTERCEPTED);
        }
    }
    /**
     * Upgrades an inbound connection
     */ async upgradeInbound(maConn, opts) {
        const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
        if (!accept) throw new (0, _interface.CodeError)("connection denied", (0, _errorsJs.codes).ERR_CONNECTION_DENIED);
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let muxerFactory;
        let cryptoProtocol;
        const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);
        const onAbort = ()=>{
            maConn.abort(new (0, _interface.CodeError)("inbound upgrade timeout", (0, _interface.ERR_TIMEOUT)));
        };
        signal.addEventListener("abort", onAbort, {
            once: true
        });
        (0, _interface.setMaxListeners)(Infinity, signal);
        try {
            if (await this.components.connectionGater.denyInboundConnection?.(maConn) === true) throw new (0, _interface.CodeError)("The multiaddr connection is blocked by gater.acceptConnection", (0, _errorsJs.codes).ERR_CONNECTION_INTERCEPTED);
            this.components.metrics?.trackMultiaddrConnection(maConn);
            maConn.log("starting the inbound connection upgrade");
            // Protect
            let protectedConn = maConn;
            if (opts?.skipProtection !== true) {
                const protector = this.components.connectionProtector;
                if (protector != null) {
                    maConn.log("protecting the inbound connection");
                    protectedConn = await protector.protect(maConn);
                }
            }
            try {
                // Encrypt the connection
                encryptedConn = protectedConn;
                if (opts?.skipEncryption !== true) {
                    ({ conn: encryptedConn, remotePeer, protocol: cryptoProtocol } = await this._encryptInbound(protectedConn));
                    const maConn = {
                        ...protectedConn,
                        ...encryptedConn
                    };
                    await this.shouldBlockConnection(remotePeer, maConn, "denyInboundEncryptedConnection");
                } else {
                    const idStr = maConn.remoteAddr.getPeerId();
                    if (idStr == null) throw new (0, _interface.CodeError)("inbound connection that skipped encryption must have a peer id", (0, _errorsJs.codes).ERR_INVALID_MULTIADDR);
                    const remotePeerId = (0, _peerId.peerIdFromString)(idStr);
                    cryptoProtocol = "native";
                    remotePeer = remotePeerId;
                }
                upgradedConn = encryptedConn;
                if (opts?.muxerFactory != null) muxerFactory = opts.muxerFactory;
                else if (this.muxers.size > 0) {
                    // Multiplex the connection
                    const multiplexed = await this._multiplexInbound({
                        ...protectedConn,
                        ...encryptedConn
                    }, this.muxers);
                    muxerFactory = multiplexed.muxerFactory;
                    upgradedConn = multiplexed.stream;
                }
            } catch (err) {
                maConn.log.error("failed to upgrade inbound connection", err);
                throw err;
            }
            await this.shouldBlockConnection(remotePeer, maConn, "denyInboundUpgradedConnection");
            maConn.log("successfully upgraded inbound connection");
            return this._createConnection({
                cryptoProtocol,
                direction: "inbound",
                maConn,
                upgradedConn,
                muxerFactory,
                remotePeer,
                transient: opts?.transient
            });
        } finally{
            signal.removeEventListener("abort", onAbort);
            this.components.connectionManager.afterUpgradeInbound();
        }
    }
    /**
     * Upgrades an outbound connection
     */ async upgradeOutbound(maConn, opts) {
        const idStr = maConn.remoteAddr.getPeerId();
        let remotePeerId;
        if (idStr != null) {
            remotePeerId = (0, _peerId.peerIdFromString)(idStr);
            await this.shouldBlockConnection(remotePeerId, maConn, "denyOutboundConnection");
        }
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let cryptoProtocol;
        let muxerFactory;
        this.components.metrics?.trackMultiaddrConnection(maConn);
        maConn.log("starting the outbound connection upgrade");
        // If the transport natively supports encryption, skip connection
        // protector and encryption
        // Protect
        let protectedConn = maConn;
        if (opts?.skipProtection !== true) {
            const protector = this.components.connectionProtector;
            if (protector != null) protectedConn = await protector.protect(maConn);
        }
        try {
            // Encrypt the connection
            encryptedConn = protectedConn;
            if (opts?.skipEncryption !== true) {
                ({ conn: encryptedConn, remotePeer, protocol: cryptoProtocol } = await this._encryptOutbound(protectedConn, remotePeerId));
                const maConn = {
                    ...protectedConn,
                    ...encryptedConn
                };
                await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundEncryptedConnection");
            } else {
                if (remotePeerId == null) throw new (0, _interface.CodeError)("Encryption was skipped but no peer id was passed", (0, _errorsJs.codes).ERR_INVALID_PEER);
                cryptoProtocol = "native";
                remotePeer = remotePeerId;
            }
            upgradedConn = encryptedConn;
            if (opts?.muxerFactory != null) muxerFactory = opts.muxerFactory;
            else if (this.muxers.size > 0) {
                // Multiplex the connection
                const multiplexed = await this._multiplexOutbound({
                    ...protectedConn,
                    ...encryptedConn
                }, this.muxers);
                muxerFactory = multiplexed.muxerFactory;
                upgradedConn = multiplexed.stream;
            }
        } catch (err) {
            maConn.log.error("failed to upgrade outbound connection", err);
            await maConn.close(err);
            throw err;
        }
        await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundUpgradedConnection");
        maConn.log("successfully upgraded outbound connection");
        return this._createConnection({
            cryptoProtocol,
            direction: "outbound",
            maConn,
            upgradedConn,
            muxerFactory,
            remotePeer,
            transient: opts?.transient
        });
    }
    /**
     * A convenience method for generating a new `Connection`
     */ _createConnection(opts) {
        const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;
        let muxer;
        let newStream;
        let connection; // eslint-disable-line prefer-const
        if (muxerFactory != null) {
            // Create the muxer
            muxer = muxerFactory.createStreamMuxer({
                direction,
                // Run anytime a remote stream is created
                onIncomingStream: (muxedStream)=>{
                    if (connection == null) return;
                    Promise.resolve().then(async ()=>{
                        const protocols = this.components.registrar.getProtocols();
                        const { stream, protocol } = await _multistreamSelect.handle(muxedStream, protocols, {
                            log: muxedStream.log,
                            yieldBytes: false
                        });
                        if (connection == null) return;
                        connection.log("incoming stream opened on %s", protocol);
                        const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
                        const streamCount = countStreams(protocol, "inbound", connection);
                        if (streamCount === incomingLimit) {
                            const err = new (0, _interface.CodeError)(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`, (0, _errorsJs.codes).ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
                            muxedStream.abort(err);
                            throw err;
                        }
                        // after the handshake the returned stream can have early data so override
                        // the souce/sink
                        muxedStream.source = stream.source;
                        muxedStream.sink = stream.sink;
                        muxedStream.protocol = protocol;
                        // allow closing the write end of a not-yet-negotiated stream
                        if (stream.closeWrite != null) muxedStream.closeWrite = stream.closeWrite;
                        // allow closing the read end of a not-yet-negotiated stream
                        if (stream.closeRead != null) muxedStream.closeRead = stream.closeRead;
                        // make sure we don't try to negotiate a stream we are closing
                        if (stream.close != null) muxedStream.close = stream.close;
                        // If a protocol stream has been successfully negotiated and is to be passed to the application,
                        // the peerstore should ensure that the peer is registered with that protocol
                        await this.components.peerStore.merge(remotePeer, {
                            protocols: [
                                protocol
                            ]
                        });
                        this.components.metrics?.trackProtocolStream(muxedStream, connection);
                        this._onStream({
                            connection,
                            stream: muxedStream,
                            protocol
                        });
                    }).catch(async (err)=>{
                        connection.log.error("error handling incoming stream id %s", muxedStream.id, err.message, err.code, err.stack);
                        if (muxedStream.timeline.close == null) await muxedStream.close();
                    });
                }
            });
            newStream = async (protocols, options = {})=>{
                if (muxer == null) throw new (0, _interface.CodeError)("Stream is not multiplexed", (0, _errorsJs.codes).ERR_MUXER_UNAVAILABLE);
                connection.log("starting new stream for protocols %s", protocols);
                const muxedStream = await muxer.newStream();
                connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
                try {
                    if (options.signal == null) {
                        muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
                        const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT);
                        (0, _interface.setMaxListeners)(Infinity, signal);
                        options = {
                            ...options,
                            signal
                        };
                    }
                    muxedStream.log.trace("selecting protocol from protocols %s", protocols);
                    const { stream, protocol } = await _multistreamSelect.select(muxedStream, protocols, {
                        ...options,
                        log: muxedStream.log,
                        yieldBytes: true
                    });
                    muxedStream.log("selected protocol %s", protocol);
                    const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
                    const streamCount = countStreams(protocol, "outbound", connection);
                    if (streamCount >= outgoingLimit) {
                        const err = new (0, _interface.CodeError)(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`, (0, _errorsJs.codes).ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
                        muxedStream.abort(err);
                        throw err;
                    }
                    // If a protocol stream has been successfully negotiated and is to be passed to the application,
                    // the peerstore should ensure that the peer is registered with that protocol
                    await this.components.peerStore.merge(remotePeer, {
                        protocols: [
                            protocol
                        ]
                    });
                    // after the handshake the returned stream can have early data so override
                    // the souce/sink
                    muxedStream.source = stream.source;
                    muxedStream.sink = stream.sink;
                    muxedStream.protocol = protocol;
                    // allow closing the write end of a not-yet-negotiated stream
                    if (stream.closeWrite != null) muxedStream.closeWrite = stream.closeWrite;
                    // allow closing the read end of a not-yet-negotiated stream
                    if (stream.closeRead != null) muxedStream.closeRead = stream.closeRead;
                    // make sure we don't try to negotiate a stream we are closing
                    if (stream.close != null) muxedStream.close = stream.close;
                    this.components.metrics?.trackProtocolStream(muxedStream, connection);
                    return muxedStream;
                } catch (err) {
                    connection.log.error("could not create new stream for protocols %s", protocols, err);
                    if (muxedStream.timeline.close == null) muxedStream.abort(err);
                    if (err.code != null) throw err;
                    throw new (0, _interface.CodeError)(String(err), (0, _errorsJs.codes).ERR_UNSUPPORTED_PROTOCOL);
                }
            };
            // Pipe all data through the muxer
            Promise.all([
                muxer.sink(upgradedConn.source),
                upgradedConn.sink(muxer.source)
            ]).catch((err)=>{
                connection.log.error("error piping data through muxer", err);
            });
        }
        const _timeline = maConn.timeline;
        maConn.timeline = new Proxy(_timeline, {
            set: (...args)=>{
                if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) // Wait for close to finish before notifying of the closure
                (async ()=>{
                    try {
                        if (connection.status === "open") await connection.close();
                    } catch (err) {
                        connection.log.error("error closing connection after timeline close", err);
                    } finally{
                        this.events.safeDispatchEvent("connection:close", {
                            detail: connection
                        });
                    }
                })().catch((err)=>{
                    connection.log.error("error thrown while dispatching connection:close event", err);
                });
                return Reflect.set(...args);
            }
        });
        maConn.timeline.upgraded = Date.now();
        const errConnectionNotMultiplexed = ()=>{
            throw new (0, _interface.CodeError)("connection is not multiplexed", (0, _errorsJs.codes).ERR_CONNECTION_NOT_MULTIPLEXED);
        };
        // Create the connection
        connection = (0, _indexJs.createConnection)({
            remoteAddr: maConn.remoteAddr,
            remotePeer,
            status: "open",
            direction,
            timeline: maConn.timeline,
            multiplexer: muxer?.protocol,
            encryption: cryptoProtocol,
            transient,
            logger: this.components.logger,
            newStream: newStream ?? errConnectionNotMultiplexed,
            getStreams: ()=>{
                if (muxer != null) return muxer.streams;
                else return [];
            },
            close: async (options)=>{
                // Ensure remaining streams are closed gracefully
                if (muxer != null) {
                    connection.log.trace("close muxer");
                    await muxer.close(options);
                }
                connection.log.trace("close maconn");
                // close the underlying transport
                await maConn.close(options);
                connection.log.trace("closed maconn");
            },
            abort: (err)=>{
                maConn.abort(err);
                // Ensure remaining streams are aborted
                if (muxer != null) muxer.abort(err);
            }
        });
        this.events.safeDispatchEvent("connection:open", {
            detail: connection
        });
        return connection;
    }
    /**
     * Routes incoming streams to the correct handler
     */ _onStream(opts) {
        const { connection, stream, protocol } = opts;
        const { handler, options } = this.components.registrar.getHandler(protocol);
        if (connection.transient && options.runOnTransientConnection !== true) throw new (0, _interface.CodeError)("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
        handler({
            connection,
            stream
        });
    }
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`
     */ async _encryptInbound(connection) {
        const protocols = Array.from(this.connectionEncryption.keys());
        connection.log("handling inbound crypto protocol selection", protocols);
        try {
            const { stream, protocol } = await _multistreamSelect.handle(connection, protocols, {
                log: connection.log
            });
            const encrypter = this.connectionEncryption.get(protocol);
            if (encrypter == null) throw new Error(`no crypto module found for ${protocol}`);
            connection.log("encrypting inbound connection using", protocol);
            return {
                ...await encrypter.secureInbound(this.components.peerId, stream),
                protocol
            };
        } catch (err) {
            connection.log.error("encrypting inbound connection to %p failed", err);
            throw new (0, _interface.CodeError)(err.message, (0, _errorsJs.codes).ERR_ENCRYPTION_FAILED);
        }
    }
    /**
     * Attempts to encrypt the given `connection` with the provided connection encrypters.
     * The first `ConnectionEncrypter` module to succeed will be used
     */ async _encryptOutbound(connection, remotePeerId) {
        const protocols = Array.from(this.connectionEncryption.keys());
        connection.log("selecting outbound crypto protocol", protocols);
        try {
            connection.log.trace("selecting encrypter from %s", protocols);
            const { stream, protocol } = await _multistreamSelect.select(connection, protocols, {
                log: connection.log,
                yieldBytes: true
            });
            const encrypter = this.connectionEncryption.get(protocol);
            if (encrypter == null) throw new Error(`no crypto module found for ${protocol}`);
            connection.log("encrypting outbound connection to %p using %p", remotePeerId);
            return {
                ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
                protocol
            };
        } catch (err) {
            connection.log.error("encrypting outbound connection to %p failed", err);
            throw new (0, _interface.CodeError)(err.message, (0, _errorsJs.codes).ERR_ENCRYPTION_FAILED);
        }
    }
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     */ async _multiplexOutbound(connection, muxers) {
        const protocols = Array.from(muxers.keys());
        connection.log("outbound selecting muxer %s", protocols);
        try {
            connection.log.trace("selecting stream muxer from %s", protocols);
            const { stream, protocol } = await _multistreamSelect.select(connection, protocols, {
                log: connection.log,
                yieldBytes: true
            });
            connection.log("selected %s as muxer protocol", protocol);
            const muxerFactory = muxers.get(protocol);
            return {
                stream,
                muxerFactory
            };
        } catch (err) {
            connection.log.error("error multiplexing outbound connection", err);
            throw new (0, _interface.CodeError)(String(err), (0, _errorsJs.codes).ERR_MUXER_UNAVAILABLE);
        }
    }
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     */ async _multiplexInbound(connection, muxers) {
        const protocols = Array.from(muxers.keys());
        connection.log("inbound handling muxers %s", protocols);
        try {
            const { stream, protocol } = await _multistreamSelect.handle(connection, protocols, {
                log: connection.log
            });
            const muxerFactory = muxers.get(protocol);
            return {
                stream,
                muxerFactory
            };
        } catch (err) {
            connection.log.error("error multiplexing inbound connection", err);
            throw new (0, _interface.CodeError)(String(err), (0, _errorsJs.codes).ERR_MUXER_UNAVAILABLE);
        }
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/multistream-select":"dyKgC","@libp2p/peer-id":"8wBUr","./connection/index.js":"cEmLm","./connection-manager/constants.js":"ef8fV","./errors.js":"ayaP8","./registrar.js":"1YGrc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dyKgC":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * multistream-select is protocol multiplexing per connection/stream. [Full spec here](https://github.com/multiformats/multistream-select)
 *
 * ## Select a protocol flow
 *
 * The caller will send "interactive" messages, expecting for some acknowledgement from the callee, which will "select" the handler for the desired and supported protocol:
 *
 * ```
 * < /multistream-select/0.3.0  # i speak multistream-select/0.3.0
 * > /multistream-select/0.3.0  # ok, let's speak multistream-select/0.3.0
 * > /ipfs-dht/0.2.3            # i want to speak ipfs-dht/0.2.3
 * < na                         # ipfs-dht/0.2.3 is not available
 * > /ipfs-dht/0.1.9            # What about ipfs-dht/0.1.9 ?
 * < /ipfs-dht/0.1.9            # ok let's speak ipfs-dht/0.1.9 -- in a sense acts as an ACK
 * > <dht-message>
 * > <dht-message>
 * > <dht-message>
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "select", ()=>(0, _selectJs.select));
parcelHelpers.export(exports, "handle", ()=>(0, _handleJs.handle));
parcelHelpers.export(exports, "PROTOCOL_ID", ()=>(0, _constantsJs.PROTOCOL_ID));
var _constantsJs = require("./constants.js");
var _selectJs = require("./select.js");
var _handleJs = require("./handle.js");

},{"./constants.js":"7XVak","./select.js":"hY7qu","./handle.js":"bwaht","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7XVak":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PROTOCOL_ID", ()=>PROTOCOL_ID);
parcelHelpers.export(exports, "MAX_PROTOCOL_LENGTH", ()=>MAX_PROTOCOL_LENGTH);
const PROTOCOL_ID = "/multistream/1.0.0";
const MAX_PROTOCOL_LENGTH = 1024;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hY7qu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Negotiate a protocol to use from a list of protocols.
 *
 * @param stream - A duplex iterable stream to dial on
 * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.
 * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will
 * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.
 * @example
 *
 * ```js
 * import { pipe } from 'it-pipe'
 * import * as mss from '@libp2p/multistream-select'
 * import { Mplex } from '@libp2p/mplex'
 *
 * const muxer = new Mplex()
 * const muxedStream = muxer.newStream()
 *
 * // mss.select(protocol(s))
 * // Select from one of the passed protocols (in priority order)
 * // Returns selected stream and protocol
 * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [
 *   // This might just be different versions of DHT, but could be different impls
 *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.
 *   '/ipfs-dht/1.0.0'
 * ])
 *
 * // Typically this stream will be passed back to the caller of libp2p.dialProtocol
 * //
 * // ...it might then do something like this:
 * // try {
 * //   await pipe(
 * //     [uint8ArrayFromString('Some DHT data')]
 * //     dhtStream,
 * //     async source => {
 * //       for await (const chunk of source)
 * //         // DHT response data
 * //     }
 * //   )
 * // } catch (err) {
 * //   // Error in stream
 * // }
 * ```
 */ parcelHelpers.export(exports, "select", ()=>select);
var _interface = require("@libp2p/interface");
var _itLengthPrefixedStream = require("it-length-prefixed-stream");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _raceSignal = require("race-signal");
var _uint8Varint = require("uint8-varint");
var _uint8Arraylist = require("uint8arraylist");
var _fromString = require("uint8arrays/from-string");
var _constantsJs = require("./constants.js");
var _multistreamJs = require("./multistream.js");
var _indexJs = require("./index.js");
async function select(stream, protocols, options) {
    protocols = Array.isArray(protocols) ? [
        ...protocols
    ] : [
        protocols
    ];
    if (protocols.length === 1 && options.negotiateFully === false) return optimisticSelect(stream, protocols[0], options);
    const lp = (0, _itLengthPrefixedStream.lpStream)(stream, {
        ...options,
        maxDataLength: (0, _constantsJs.MAX_PROTOCOL_LENGTH)
    });
    const protocol = protocols.shift();
    if (protocol == null) throw new Error("At least one protocol must be specified");
    options.log.trace('select: write ["%s", "%s"]', (0, _indexJs.PROTOCOL_ID), protocol);
    const p1 = (0, _fromString.fromString)(`${(0, _indexJs.PROTOCOL_ID)}\n`);
    const p2 = (0, _fromString.fromString)(`${protocol}\n`);
    await _multistreamJs.writeAll(lp, [
        p1,
        p2
    ], options);
    options.log.trace("select: reading multistream-select header");
    let response = await _multistreamJs.readString(lp, options);
    options.log.trace('select: read "%s"', response);
    // Read the protocol response if we got the protocolId in return
    if (response === (0, _indexJs.PROTOCOL_ID)) {
        options.log.trace("select: reading protocol response");
        response = await _multistreamJs.readString(lp, options);
        options.log.trace('select: read "%s"', response);
    }
    // We're done
    if (response === protocol) return {
        stream: lp.unwrap(),
        protocol
    };
    // We haven't gotten a valid ack, try the other protocols
    for (const protocol of protocols){
        options.log.trace('select: write "%s"', protocol);
        await _multistreamJs.write(lp, (0, _fromString.fromString)(`${protocol}\n`), options);
        options.log.trace("select: reading protocol response");
        const response = await _multistreamJs.readString(lp, options);
        options.log.trace('select: read "%s" for "%s"', response, protocol);
        if (response === protocol) return {
            stream: lp.unwrap(),
            protocol
        };
    }
    throw new (0, _interface.CodeError)("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
}
/**
 * Optimistically negotiates a protocol.
 *
 * It *does not* block writes waiting for the other end to respond. Instead, it
 * simply assumes the negotiation went successfully and starts writing data.
 *
 * Use when it is known that the receiver supports the desired protocol.
 */ function optimisticSelect(stream, protocol, options) {
    const originalSink = stream.sink.bind(stream);
    const originalSource = stream.source;
    let negotiated = false;
    let negotiating = false;
    const doneNegotiating = (0, _pDeferDefault.default)();
    let sentProtocol = false;
    let sendingProtocol = false;
    const doneSendingProtocol = (0, _pDeferDefault.default)();
    let readProtocol = false;
    let readingProtocol = false;
    const doneReadingProtocol = (0, _pDeferDefault.default)();
    const lp = (0, _itLengthPrefixedStream.lpStream)({
        sink: originalSink,
        source: originalSource
    }, {
        ...options,
        maxDataLength: (0, _constantsJs.MAX_PROTOCOL_LENGTH)
    });
    stream.sink = async (source)=>{
        const { sink } = lp.unwrap();
        await sink(async function*() {
            let sentData = false;
            for await (const buf of source){
                // started reading before the source yielded, wait for protocol send
                if (sendingProtocol) await doneSendingProtocol.promise;
                // writing before reading, send the protocol and the first chunk of data
                if (!sentProtocol) {
                    sendingProtocol = true;
                    options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', (0, _indexJs.PROTOCOL_ID), protocol, buf.byteLength);
                    const protocolString = `${protocol}\n`;
                    // send protocols in first chunk of data written to transport
                    yield new (0, _uint8Arraylist.Uint8ArrayList)(Uint8Array.from([
                        19
                    ]), (0, _fromString.fromString)(`${(0, _indexJs.PROTOCOL_ID)}\n`), _uint8Varint.encode(protocolString.length), (0, _fromString.fromString)(protocolString), buf).subarray();
                    options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', (0, _indexJs.PROTOCOL_ID), protocol, buf.byteLength);
                    sentProtocol = true;
                    sendingProtocol = false;
                    doneSendingProtocol.resolve();
                    // read the negotiation response but don't block more sending
                    negotiate().catch((err)=>{
                        options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
                    });
                } else yield buf;
                sentData = true;
            }
            // special case - the source passed to the sink has ended but we didn't
            // negotiated the protocol yet so do it now
            if (!sentData) await negotiate();
        }());
    };
    async function negotiate() {
        if (negotiating) {
            options.log.trace("optimistic: already negotiating %s stream", protocol);
            await doneNegotiating.promise;
            return;
        }
        negotiating = true;
        try {
            // we haven't sent the protocol yet, send it now
            if (!sentProtocol) {
                options.log.trace("optimistic: doing send protocol for %s stream", protocol);
                await doSendProtocol();
            }
            // if we haven't read the protocol response yet, do it now
            if (!readProtocol) {
                options.log.trace("optimistic: doing read protocol for %s stream", protocol);
                await doReadProtocol();
            }
        } finally{
            negotiating = false;
            negotiated = true;
            doneNegotiating.resolve();
        }
    }
    async function doSendProtocol() {
        if (sendingProtocol) {
            await doneSendingProtocol.promise;
            return;
        }
        sendingProtocol = true;
        try {
            options.log.trace('optimistic: write ["%s", "%s", data] in source', (0, _indexJs.PROTOCOL_ID), protocol);
            await lp.writeV([
                (0, _fromString.fromString)(`${(0, _indexJs.PROTOCOL_ID)}\n`),
                (0, _fromString.fromString)(`${protocol}\n`)
            ]);
            options.log.trace('optimistic: wrote ["%s", "%s", data] in source', (0, _indexJs.PROTOCOL_ID), protocol);
        } finally{
            sentProtocol = true;
            sendingProtocol = false;
            doneSendingProtocol.resolve();
        }
    }
    async function doReadProtocol() {
        if (readingProtocol) {
            await doneReadingProtocol.promise;
            return;
        }
        readingProtocol = true;
        try {
            options.log.trace("optimistic: reading multistream select header");
            let response = await _multistreamJs.readString(lp, options);
            options.log.trace('optimistic: read multistream select header "%s"', response);
            if (response === (0, _indexJs.PROTOCOL_ID)) response = await _multistreamJs.readString(lp, options);
            options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
            if (response !== protocol) throw new (0, _interface.CodeError)("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
        } finally{
            readProtocol = true;
            readingProtocol = false;
            doneReadingProtocol.resolve();
        }
    }
    stream.source = async function*() {
        // make sure we've done protocol negotiation before we read stream data
        await negotiate();
        options.log.trace('optimistic: reading data from "%s" stream', protocol);
        yield* lp.unwrap().source;
    }();
    if (stream.closeRead != null) {
        const originalCloseRead = stream.closeRead.bind(stream);
        stream.closeRead = async (opts)=>{
            // we need to read & write to negotiate the protocol so ensure we've done
            // this before closing the readable end of the stream
            if (!negotiated) await negotiate().catch((err)=>{
                options.log.error("could not negotiate protocol before close read", err);
            });
            // protocol has been negotiated, ok to close the readable end
            await originalCloseRead(opts);
        };
    }
    if (stream.closeWrite != null) {
        const originalCloseWrite = stream.closeWrite.bind(stream);
        stream.closeWrite = async (opts)=>{
            // we need to read & write to negotiate the protocol so ensure we've done
            // this before closing the writable end of the stream
            if (!negotiated) await negotiate().catch((err)=>{
                options.log.error("could not negotiate protocol before close write", err);
            });
            // protocol has been negotiated, ok to close the writable end
            await originalCloseWrite(opts);
        };
    }
    if (stream.close != null) {
        const originalClose = stream.close.bind(stream);
        stream.close = async (opts)=>{
            // if we are in the process of negotiation, let it finish before closing
            // because we may have unsent early data
            const tasks = [];
            if (sendingProtocol) tasks.push(doneSendingProtocol.promise);
            if (readingProtocol) tasks.push(doneReadingProtocol.promise);
            if (tasks.length > 0) // let the in-flight protocol negotiation finish gracefully
            await (0, _raceSignal.raceSignal)(Promise.all(tasks), opts?.signal);
            else {
                // no protocol negotiation attempt has occurred so don't start one
                negotiated = true;
                negotiating = false;
                doneNegotiating.resolve();
            }
            // protocol has been negotiated, ok to close the writable end
            await originalClose(opts);
        };
    }
    return {
        stream,
        protocol
    };
}

},{"@libp2p/interface":"b14bx","it-length-prefixed-stream":"abvhz","p-defer":"cWx93","race-signal":"dHlMT","uint8-varint":"3o84q","uint8arraylist":"1W1Ks","uint8arrays/from-string":"3YvUV","./constants.js":"7XVak","./multistream.js":"dXBkP","./index.js":"dyKgC","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"abvhz":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive length-prefixed byte arrays over streams.
 *
 * @example
 *
 * ```typescript
 * import { lpStream } from 'it-length-prefixed-stream'
 *
 * const stream = lpStream(duplex)
 *
 * // read the next length-prefixed chunk
 * const bytes = await stream.read()
 *
 * // write a length-prefixed chunk
 * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))
 *
 * // write several chunks, all individually length-prefixed
 * await stream.writeV([
 *   Uint8Array.from([0, 1, 2, 3, 4]),
 *   Uint8Array.from([5, 6, 7, 8, 9])
 * ])
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lpStream", ()=>lpStream);
var _itByteStream = require("it-byte-stream");
var _uint8Varint = require("uint8-varint");
var _uint8Arraylist = require("uint8arraylist");
class CodeError extends Error {
    code;
    constructor(message, code){
        super(message);
        this.code = code;
    }
}
function lpStream(duplex, opts = {}) {
    const bytes = (0, _itByteStream.byteStream)(duplex, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) // if max data length is set but max length length is not, calculate the
    // max length length needed to encode max data length
    opts.maxLengthLength = _uint8Varint.encodingLength(opts.maxDataLength);
    const decodeLength = opts?.lengthDecoder ?? _uint8Varint.decode;
    const encodeLength = opts?.lengthEncoder ?? _uint8Varint.encode;
    const W = {
        read: async (options)=>{
            let dataLength = -1;
            const lengthBuffer = new (0, _uint8Arraylist.Uint8ArrayList)();
            while(true){
                // read one byte at a time until we can decode a varint
                lengthBuffer.append(await bytes.read(1, options));
                try {
                    dataLength = decodeLength(lengthBuffer);
                } catch (err) {
                    if (err instanceof RangeError) continue;
                    throw err;
                }
                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) throw new CodeError("message length length too long", "ERR_MSG_LENGTH_TOO_LONG");
                if (dataLength > -1) break;
            }
            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) throw new CodeError("message length too long", "ERR_MSG_DATA_TOO_LONG");
            return bytes.read(dataLength, options);
        },
        write: async (data, options)=>{
            // encode, write
            await bytes.write(new (0, _uint8Arraylist.Uint8ArrayList)(encodeLength(data.byteLength), data), options);
        },
        writeV: async (data, options)=>{
            const list = new (0, _uint8Arraylist.Uint8ArrayList)(...data.flatMap((buf)=>[
                    encodeLength(buf.byteLength),
                    buf
                ]));
            // encode, write
            await bytes.write(list, options);
        },
        unwrap: ()=>{
            return bytes.unwrap();
        }
    };
    return W;
}

},{"it-byte-stream":"iUDOL","uint8-varint":"3o84q","uint8arraylist":"1W1Ks","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iUDOL":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive bytes over streams.
 *
 * @example
 *
 * ```typescript
 * import { byteStream } from 'it-byte-stream'
 *
 * const stream = byteStream(duplex)
 *
 * // read the next chunk
 * const bytes = await stream.read()
 *
 * // read the next five bytes
 * const fiveBytes = await stream.read(5)
 *
 * // write bytes into the stream
 * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CodeError", ()=>CodeError);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
parcelHelpers.export(exports, "byteStream", ()=>byteStream);
var _uint8Arraylist = require("uint8arraylist");
var _pushableJs = require("./pushable.js");
class CodeError extends Error {
    code;
    constructor(message, code){
        super(message);
        this.code = code;
    }
}
class AbortError extends CodeError {
    type;
    constructor(message){
        super(message, "ABORT_ERR");
        this.type = "aborted";
    }
}
function byteStream(duplex, opts) {
    const write = (0, _pushableJs.pushable)();
    duplex.sink(write).catch(async (err)=>{
        await write.end(err);
    });
    duplex.sink = async (source)=>{
        for await (const buf of source)await write.push(buf);
        await write.end();
    };
    let source = duplex.source;
    if (duplex.source[Symbol.iterator] != null) source = duplex.source[Symbol.iterator]();
    else if (duplex.source[Symbol.asyncIterator] != null) source = duplex.source[Symbol.asyncIterator]();
    const readBuffer = new (0, _uint8Arraylist.Uint8ArrayList)();
    const W = {
        read: async (bytes, options)=>{
            options?.signal?.throwIfAborted();
            let listener;
            const abortPromise = new Promise((resolve, reject)=>{
                listener = ()=>{
                    reject(new AbortError("Read aborted"));
                };
                options?.signal?.addEventListener("abort", listener);
            });
            try {
                if (bytes == null) {
                    // just read whatever arrives
                    const { done, value } = await Promise.race([
                        source.next(),
                        abortPromise
                    ]);
                    if (done === true) return new (0, _uint8Arraylist.Uint8ArrayList)();
                    return value;
                }
                while(readBuffer.byteLength < bytes){
                    const { value, done } = await Promise.race([
                        source.next(),
                        abortPromise
                    ]);
                    if (done === true) throw new CodeError("unexpected end of input", "ERR_UNEXPECTED_EOF");
                    readBuffer.append(value);
                }
                const buf = readBuffer.sublist(0, bytes);
                readBuffer.consume(bytes);
                return buf;
            } finally{
                if (listener != null) options?.signal?.removeEventListener("abort", listener);
            }
        },
        write: async (data, options)=>{
            options?.signal?.throwIfAborted();
            // just write
            if (data instanceof Uint8Array) await write.push(data, options);
            else await write.push(data.subarray(), options);
        },
        unwrap: ()=>{
            if (readBuffer.byteLength > 0) {
                const originalStream = duplex.source;
                duplex.source = async function*() {
                    if (opts?.yieldBytes === false) yield readBuffer;
                    else yield* readBuffer;
                    yield* originalStream;
                }();
            }
            return duplex;
        }
    };
    return W;
}

},{"uint8arraylist":"1W1Ks","./pushable.js":"kY4wt","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kY4wt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pushable", ()=>pushable);
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _raceSignal = require("race-signal");
var _indexJs = require("./index.js");
class QueuelessPushable {
    readNext;
    haveNext;
    ended;
    nextResult;
    constructor(){
        this.ended = false;
        this.readNext = (0, _pDeferDefault.default)();
        this.haveNext = (0, _pDeferDefault.default)();
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    async next() {
        if (this.nextResult == null) // wait for the supplier to push a value
        await this.haveNext.promise;
        if (this.nextResult == null) throw new Error("HaveNext promise resolved but nextResult was undefined");
        const nextResult = this.nextResult;
        this.nextResult = undefined;
        // signal to the supplier that we read the value
        this.readNext.resolve();
        this.readNext = (0, _pDeferDefault.default)();
        return nextResult;
    }
    async throw(err) {
        this.ended = true;
        if (err != null) this.haveNext.reject(err);
        const result = {
            done: true,
            value: undefined
        };
        return result;
    }
    async return() {
        const result = {
            done: true,
            value: undefined
        };
        await this._push(undefined);
        return result;
    }
    async push(value, options) {
        await this._push(value, options);
    }
    async end(err, options) {
        if (err != null) await this.throw(err);
        else // abortable return
        await this._push(undefined, options);
    }
    async _push(value, options) {
        if (value != null && this.ended) throw new Error("Cannot push value onto an ended pushable");
        // already have a value, wait for it to be read
        if (this.nextResult != null) {
            await this.readNext.promise;
            if (this.nextResult != null) throw new Error("NeedNext promise resolved but nextResult was not consumed");
        }
        if (value != null) this.nextResult = {
            done: false,
            value
        };
        else {
            this.ended = true;
            this.nextResult = {
                done: true,
                value: undefined
            };
        }
        // let the consumer know we have a new value
        this.haveNext.resolve();
        this.haveNext = (0, _pDeferDefault.default)();
        // wait for the consumer to have finished processing the value and requested
        // the next one or for the passed signal to abort the waiting
        await (0, _raceSignal.raceSignal)(this.readNext.promise, options?.signal, options);
    }
}
function pushable() {
    return new QueuelessPushable();
}

},{"p-defer":"cWx93","race-signal":"dHlMT","./index.js":"iUDOL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dXBkP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * `write` encodes and writes a single buffer
 */ parcelHelpers.export(exports, "write", ()=>write);
/**
 * `writeAll` behaves like `write`, except it encodes an array of items as a single write
 */ parcelHelpers.export(exports, "writeAll", ()=>writeAll);
/**
 * Read a length-prefixed buffer from the passed stream, stripping the final newline character
 */ parcelHelpers.export(exports, "read", ()=>read);
/**
 * Read a length-prefixed string from the passed stream, stripping the final newline character
 */ parcelHelpers.export(exports, "readString", ()=>readString);
var _interface = require("@libp2p/interface");
var _uint8Arraylist = require("uint8arraylist");
var _fromString = require("uint8arrays/from-string");
var _toString = require("uint8arrays/to-string");
const NewLine = (0, _fromString.fromString)("\n");
async function write(writer, buffer, options) {
    await writer.write(buffer, options);
}
async function writeAll(writer, buffers, options) {
    await writer.writeV(buffers, options);
}
async function read(reader, options) {
    const buf = await reader.read(options);
    if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
        options.log.error("Invalid mss message - missing newline", buf);
        throw new (0, _interface.CodeError)("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
    }
    return buf.sublist(0, -1); // Remove newline
}
async function readString(reader, options) {
    const buf = await read(reader, options);
    return (0, _toString.toString)(buf.subarray());
}

},{"@libp2p/interface":"b14bx","uint8arraylist":"1W1Ks","uint8arrays/from-string":"3YvUV","uint8arrays/to-string":"63irA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bwaht":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Handle multistream protocol selections for the given list of protocols.
 *
 * Note that after a protocol is handled `listener` can no longer be used.
 *
 * @param stream - A duplex iterable stream to listen on
 * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.
 * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will
 * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`
 * @example
 *
 * ```js
 * import { pipe } from 'it-pipe'
 * import * as mss from '@libp2p/multistream-select'
 * import { Mplex } from '@libp2p/mplex'
 *
 * const muxer = new Mplex({
 *   async onStream (muxedStream) {
 *   // mss.handle(handledProtocols)
 *   // Returns selected stream and protocol
 *   const { stream, protocol } = await mss.handle(muxedStream, [
 *     '/ipfs-dht/1.0.0',
 *     '/ipfs-bitswap/1.0.0'
 *   ])
 *
 *   // Typically here we'd call the handler function that was registered in
 *   // libp2p for the given protocol:
 *   // e.g. handlers[protocol].handler(stream)
 *   //
 *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:
 *   // try {
 *   //   await pipe(
 *   //     dhtStream,
 *   //     source => (async function * () {
 *   //       for await (const chunk of source)
 *   //         // Incoming DHT data -> process and yield to respond
 *   //     })(),
 *   //     dhtStream
 *   //   )
 *   // } catch (err) {
 *   //   // Error in stream
 *   // }
 *   }
 * })
 * ```
 */ parcelHelpers.export(exports, "handle", ()=>handle);
var _itLengthPrefixed = require("it-length-prefixed");
var _itLengthPrefixedStream = require("it-length-prefixed-stream");
var _uint8Arraylist = require("uint8arraylist");
var _fromString = require("uint8arrays/from-string");
var _constantsJs = require("./constants.js");
var _multistreamJs = require("./multistream.js");
async function handle(stream, protocols, options) {
    protocols = Array.isArray(protocols) ? protocols : [
        protocols
    ];
    options.log.trace("handle: available protocols %s", protocols);
    const lp = (0, _itLengthPrefixedStream.lpStream)(stream, {
        ...options,
        maxDataLength: (0, _constantsJs.MAX_PROTOCOL_LENGTH),
        maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
    });
    while(true){
        options.log.trace("handle: reading incoming string");
        const protocol = await _multistreamJs.readString(lp, options);
        options.log.trace('handle: read "%s"', protocol);
        if (protocol === (0, _constantsJs.PROTOCOL_ID)) {
            options.log.trace('handle: respond with "%s" for "%s"', (0, _constantsJs.PROTOCOL_ID), protocol);
            await _multistreamJs.write(lp, (0, _fromString.fromString)(`${(0, _constantsJs.PROTOCOL_ID)}\n`), options);
            options.log.trace('handle: responded with "%s" for "%s"', (0, _constantsJs.PROTOCOL_ID), protocol);
            continue;
        }
        if (protocols.includes(protocol)) {
            options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
            await _multistreamJs.write(lp, (0, _fromString.fromString)(`${protocol}\n`), options);
            options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
            return {
                stream: lp.unwrap(),
                protocol
            };
        }
        if (protocol === "ls") {
            // <varint-msg-len><varint-proto-name-len><proto-name>\n<varint-proto-name-len><proto-name>\n\n
            const protos = new (0, _uint8Arraylist.Uint8ArrayList)(...protocols.map((p)=>(0, _itLengthPrefixed.encode).single((0, _fromString.fromString)(`${p}\n`))), (0, _fromString.fromString)("\n"));
            options.log.trace('handle: respond with "%s" for %s', protocols, protocol);
            await _multistreamJs.write(lp, protos, options);
            options.log.trace('handle: responded with "%s" for %s', protocols, protocol);
            continue;
        }
        options.log('handle: respond with "na" for "%s"', protocol);
        await _multistreamJs.write(lp, (0, _fromString.fromString)("na\n"), options);
        options.log('handle: responded with "na" for "%s"', protocol);
    }
}

},{"it-length-prefixed":"lzCYq","it-length-prefixed-stream":"abvhz","uint8arraylist":"1W1Ks","uint8arrays/from-string":"3YvUV","./constants.js":"7XVak","./multistream.js":"dXBkP","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lzCYq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>(0, _encodeJs.encode));
parcelHelpers.export(exports, "decode", ()=>(0, _decodeJs.decode));
var _encodeJs = require("./encode.js");
var _decodeJs = require("./decode.js");

},{"./encode.js":"1YfgT","./decode.js":"17vhA","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1YfgT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
var _uint8Varint = require("uint8-varint");
var _uint8Arraylist = require("uint8arraylist");
var _alloc = require("uint8arrays/alloc");
var _utilsJs = require("./utils.js");
const defaultEncoder = (length)=>{
    const lengthLength = _uint8Varint.encodingLength(length);
    const lengthBuf = (0, _alloc.allocUnsafe)(lengthLength);
    _uint8Varint.encode(length, lengthBuf);
    defaultEncoder.bytes = lengthLength;
    return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode(source, options) {
    options = options ?? {};
    const encodeLength = options.lengthEncoder ?? defaultEncoder;
    function* maybeYield(chunk) {
        // length + data
        const length = encodeLength(chunk.byteLength);
        // yield only Uint8Arrays
        if (length instanceof Uint8Array) yield length;
        else yield* length;
        // yield only Uint8Arrays
        if (chunk instanceof Uint8Array) yield chunk;
        else yield* chunk;
    }
    if ((0, _utilsJs.isAsyncIterable)(source)) return async function*() {
        for await (const chunk of source)yield* maybeYield(chunk);
    }();
    return function*() {
        for (const chunk of source)yield* maybeYield(chunk);
    }();
}
encode.single = (chunk, options)=>{
    options = options ?? {};
    const encodeLength = options.lengthEncoder ?? defaultEncoder;
    return new (0, _uint8Arraylist.Uint8ArrayList)(encodeLength(chunk.byteLength), chunk);
};

},{"uint8-varint":"3o84q","uint8arraylist":"1W1Ks","uint8arrays/alloc":"9stB1","./utils.js":"lvINt","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lvINt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAsyncIterable", ()=>isAsyncIterable);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"17vhA":[function(require,module,exports) {
/* eslint max-depth: ["error", 6] */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_LENGTH_LENGTH", ()=>MAX_LENGTH_LENGTH);
parcelHelpers.export(exports, "MAX_DATA_LENGTH", ()=>MAX_DATA_LENGTH);
parcelHelpers.export(exports, "decode", ()=>decode);
var _errCode = require("err-code");
var _errCodeDefault = parcelHelpers.interopDefault(_errCode);
var _uint8Varint = require("uint8-varint");
var _uint8Arraylist = require("uint8arraylist");
var _utilsJs = require("./utils.js");
const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length
const MAX_DATA_LENGTH = 4194304;
var ReadMode;
(function(ReadMode) {
    ReadMode[ReadMode["LENGTH"] = 0] = "LENGTH";
    ReadMode[ReadMode["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
const defaultDecoder = (buf)=>{
    const length = _uint8Varint.decode(buf);
    defaultDecoder.bytes = _uint8Varint.encodingLength(length);
    return length;
};
defaultDecoder.bytes = 0;
function decode(source, options) {
    const buffer = new (0, _uint8Arraylist.Uint8ArrayList)();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
    function* maybeYield() {
        while(buffer.byteLength > 0){
            if (mode === ReadMode.LENGTH) // read length, ignore errors for short reads
            try {
                dataLength = lengthDecoder(buffer);
                if (dataLength < 0) throw (0, _errCodeDefault.default)(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
                if (dataLength > maxDataLength) throw (0, _errCodeDefault.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
                const dataLengthLength = lengthDecoder.bytes;
                buffer.consume(dataLengthLength);
                if (options?.onLength != null) options.onLength(dataLength);
                mode = ReadMode.DATA;
            } catch (err) {
                if (err instanceof RangeError) {
                    if (buffer.byteLength > maxLengthLength) throw (0, _errCodeDefault.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
                    break;
                }
                throw err;
            }
            if (mode === ReadMode.DATA) {
                if (buffer.byteLength < dataLength) break;
                const data = buffer.sublist(0, dataLength);
                buffer.consume(dataLength);
                if (options?.onData != null) options.onData(data);
                yield data;
                mode = ReadMode.LENGTH;
            }
        }
    }
    if ((0, _utilsJs.isAsyncIterable)(source)) return async function*() {
        for await (const buf of source){
            buffer.append(buf);
            yield* maybeYield();
        }
        if (buffer.byteLength > 0) throw (0, _errCodeDefault.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }();
    return function*() {
        for (const buf of source){
            buffer.append(buf);
            yield* maybeYield();
        }
        if (buffer.byteLength > 0) throw (0, _errCodeDefault.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }();
}
decode.fromReader = (reader, options)=>{
    let byteLength = 1; // Read single byte chunks until the length is known
    const varByteSource = async function*() {
        while(true)try {
            const { done, value } = await reader.next(byteLength);
            if (done === true) return;
            if (value != null) yield value;
        } catch (err) {
            if (err.code === "ERR_UNDER_READ") return {
                done: true,
                value: null
            };
            throw err;
        } finally{
            // Reset the byteLength so we continue to check for varints
            byteLength = 1;
        }
    }();
    /**
     * Once the length has been parsed, read chunk for that length
     */ const onLength = (l)=>{
        byteLength = l;
    };
    return decode(varByteSource, {
        ...options ?? {},
        onLength
    });
};

},{"err-code":"dUrrM","uint8-varint":"3o84q","uint8arraylist":"1W1Ks","./utils.js":"lvINt","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cEmLm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An implementation of the js-libp2p connection.
 * Any libp2p transport should use an upgrader to return this connection.
 */ parcelHelpers.export(exports, "ConnectionImpl", ()=>ConnectionImpl);
parcelHelpers.export(exports, "createConnection", ()=>createConnection);
var _interface = require("@libp2p/interface");
const CLOSE_TIMEOUT = 500;
class ConnectionImpl {
    /**
     * Connection identifier.
     */ id;
    /**
     * Observed multiaddr of the remote peer
     */ remoteAddr;
    /**
     * Remote peer id
     */ remotePeer;
    direction;
    timeline;
    multiplexer;
    encryption;
    status;
    transient;
    log;
    /**
     * User provided tags
     *
     */ tags;
    /**
     * Reference to the new stream function of the multiplexer
     */ _newStream;
    /**
     * Reference to the close function of the raw connection
     */ _close;
    _abort;
    /**
     * Reference to the getStreams function of the muxer
     */ _getStreams;
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */ constructor(init){
        const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
        this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
        this.remoteAddr = remoteAddr;
        this.remotePeer = remotePeer;
        this.direction = init.direction;
        this.status = "open";
        this.timeline = init.timeline;
        this.multiplexer = init.multiplexer;
        this.encryption = init.encryption;
        this.transient = init.transient ?? false;
        this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
        if (this.remoteAddr.getPeerId() == null) this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
        this._newStream = newStream;
        this._close = close;
        this._abort = abort;
        this._getStreams = getStreams;
        this.tags = [];
    }
    [Symbol.toStringTag] = "Connection";
    [(0, _interface.connectionSymbol)] = true;
    /**
     * Get all the streams of the muxer
     */ get streams() {
        return this._getStreams();
    }
    /**
     * Create a new stream from this connection
     */ async newStream(protocols, options) {
        if (this.status === "closing") throw new (0, _interface.CodeError)("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
        if (this.status === "closed") throw new (0, _interface.CodeError)("the connection is closed", "ERR_CONNECTION_CLOSED");
        if (!Array.isArray(protocols)) protocols = [
            protocols
        ];
        if (this.transient && options?.runOnTransientConnection !== true) throw new (0, _interface.CodeError)("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
        const stream = await this._newStream(protocols, options);
        stream.direction = "outbound";
        return stream;
    }
    /**
     * Close the connection
     */ async close(options = {}) {
        if (this.status === "closed" || this.status === "closing") return;
        this.log("closing connection to %a", this.remoteAddr);
        this.status = "closing";
        if (options.signal == null) {
            const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
            (0, _interface.setMaxListeners)(Infinity, signal);
            options = {
                ...options,
                signal
            };
        }
        try {
            this.log.trace("closing all streams");
            // close all streams gracefully - this can throw if we're not multiplexed
            await Promise.all(this.streams.map(async (s)=>s.close(options)));
            this.log.trace("closing underlying transport");
            // close raw connection
            await this._close(options);
            this.log.trace("updating timeline with close time");
            this.status = "closed";
            this.timeline.close = Date.now();
        } catch (err) {
            this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
            this.abort(err);
        }
    }
    abort(err) {
        this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
        this.status = "closing";
        this.streams.forEach((s)=>{
            s.abort(err);
        });
        this.log.error("all streams aborted", this.streams.length);
        // Abort raw connection
        this._abort(err);
        this.timeline.close = Date.now();
        this.status = "closed";
    }
}
function createConnection(init) {
    return new ConnectionImpl(init);
}

},{"@libp2p/interface":"b14bx","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7zAVS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "name", ()=>name);
const version = "1.2.3";
const name = "libp2p";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"l5BsY":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * The configured bootstrap peers will be discovered after the configured timeout. This will ensure there are some peers in the peer store for the node to use to discover other peers.
 *
 * They will be tagged with a tag with the name `'bootstrap'` tag, the value `50` and it will expire after two minutes which means the nodes connections may be closed if the maximum number of connections is reached.
 *
 * Clients that need constant connections to bootstrap nodes (e.g. browsers) can set the TTL to `Infinity`.
 *
 * ```TypeScript
 * import { createLibp2p } from 'libp2p'
 * import { bootstrap } from '@libp2p/bootstrap'
 * import { tcp } from 'libp2p/tcp'
 * import { noise } from '@libp2p/noise'
 * import { mplex } from '@libp2p/mplex'
 *
 * let options = {
 *   transports: [
 *     tcp()
 *   ],
 *   streamMuxers: [
 *     mplex()
 *   ],
 *   connectionEncryption: [
 *     noise()
 *   ],
 *   peerDiscovery: [
 *     bootstrap({
 *       list: [ // a list of bootstrap peer multiaddrs to connect to on node startup
 *         "/ip4/104.131.131.82/tcp/4001/ipfs/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ",
 *         "/dnsaddr/bootstrap.libp2p.io/ipfs/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
 *         "/dnsaddr/bootstrap.libp2p.io/ipfs/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa"
 *       ],
 *       timeout: 1000, // in ms,
 *       tagName: 'bootstrap',
 *       tagValue: 50,
 *       tagTTL: 120000 // in ms
 *     })
 *   ]
 * }
 *
 * const libp2p = await createLibp2p(options)
 *
 * libp2p.on('peer:discovery', function (peerId) {
 *   console.log('found peer: ', peerId.toB58String())
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bootstrap", ()=>bootstrap);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _mafmt = require("@multiformats/mafmt");
var _multiaddr = require("@multiformats/multiaddr");
const DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
const DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
const DEFAULT_BOOTSTRAP_TAG_TTL = 120000;
const DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1000;
/**
 * Emits 'peer' events on a regular interval for each peer in the provided list.
 */ class Bootstrap extends (0, _interface.TypedEventEmitter) {
    static tag = "bootstrap";
    log;
    timer;
    list;
    timeout;
    components;
    _init;
    constructor(components, options = {
        list: []
    }){
        if (options.list == null || options.list.length === 0) throw new Error("Bootstrap requires a list of peer addresses");
        super();
        this.components = components;
        this.log = components.logger.forComponent("libp2p:bootstrap");
        this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
        this.list = [];
        for (const candidate of options.list){
            if (!(0, _mafmt.P2P).matches(candidate)) {
                this.log.error("Invalid multiaddr");
                continue;
            }
            const ma = (0, _multiaddr.multiaddr)(candidate);
            const peerIdStr = ma.getPeerId();
            if (peerIdStr == null) {
                this.log.error("Invalid bootstrap multiaddr without peer id");
                continue;
            }
            const peerData = {
                id: (0, _peerId.peerIdFromString)(peerIdStr),
                multiaddrs: [
                    ma
                ]
            };
            this.list.push(peerData);
        }
        this._init = options;
    }
    [(0, _interface.peerDiscoverySymbol)] = this;
    [Symbol.toStringTag] = "@libp2p/bootstrap";
    isStarted() {
        return Boolean(this.timer);
    }
    /**
     * Start emitting events
     */ start() {
        if (this.isStarted()) return;
        this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
        this.timer = setTimeout(()=>{
            this._discoverBootstrapPeers().catch((err)=>{
                this.log.error(err);
            });
        }, this.timeout);
    }
    /**
     * Emit each address in the list as a PeerInfo
     */ async _discoverBootstrapPeers() {
        if (this.timer == null) return;
        for (const peerData of this.list){
            await this.components.peerStore.merge(peerData.id, {
                tags: {
                    [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
                        value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
                        ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
                    }
                }
            });
            // check we are still running
            if (this.timer == null) return;
            this.safeDispatchEvent("peer", {
                detail: peerData
            });
        }
    }
    /**
     * Stop emitting events
     */ stop() {
        if (this.timer != null) clearTimeout(this.timer);
        this.timer = undefined;
    }
}
function bootstrap(init) {
    return (components)=>new Bootstrap(components, init);
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@multiformats/mafmt":"djvEe","@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"djvEe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS4", ()=>DNS4);
parcelHelpers.export(exports, "DNS6", ()=>DNS6);
parcelHelpers.export(exports, "DNSADDR", ()=>DNSADDR);
parcelHelpers.export(exports, "DNS", ()=>DNS);
parcelHelpers.export(exports, "IP", ()=>IP);
parcelHelpers.export(exports, "TCP", ()=>TCP);
parcelHelpers.export(exports, "UDP", ()=>UDP);
parcelHelpers.export(exports, "UTP", ()=>UTP);
parcelHelpers.export(exports, "QUIC", ()=>QUIC);
parcelHelpers.export(exports, "QUICV1", ()=>QUICV1);
parcelHelpers.export(exports, "WebSockets", ()=>WebSockets);
parcelHelpers.export(exports, "WebSocketsSecure", ()=>WebSocketsSecure);
parcelHelpers.export(exports, "HTTP", ()=>HTTP);
parcelHelpers.export(exports, "HTTPS", ()=>HTTPS);
parcelHelpers.export(exports, "WebRTCDirect", ()=>WebRTCDirect);
parcelHelpers.export(exports, "WebTransport", ()=>WebTransport);
parcelHelpers.export(exports, "P2PWebRTCStar", ()=>P2PWebRTCStar);
parcelHelpers.export(exports, "WebSocketStar", ()=>WebSocketStar);
parcelHelpers.export(exports, "P2PWebRTCDirect", ()=>P2PWebRTCDirect);
parcelHelpers.export(exports, "Reliable", ()=>Reliable);
parcelHelpers.export(exports, "Stardust", ()=>Stardust);
parcelHelpers.export(exports, "Circuit", ()=>Circuit);
parcelHelpers.export(exports, "P2P", ()=>P2P);
parcelHelpers.export(exports, "IPFS", ()=>IPFS);
parcelHelpers.export(exports, "WebRTC", ()=>WebRTC);
var _multiaddr = require("@multiformats/multiaddr");
const DNS4 = base("dns4");
const DNS6 = base("dns6");
const DNSADDR = base("dnsaddr");
const DNS = or(base("dns"), DNSADDR, DNS4, DNS6);
const IP = or(base("ip4"), base("ip6"));
const TCP = or(and(IP, base("tcp")), and(DNS, base("tcp")));
const UDP = and(IP, base("udp"));
const UTP = and(UDP, base("utp"));
const QUIC = and(UDP, base("quic"));
const QUICV1 = and(UDP, base("quic-v1"));
const _WebSockets = or(and(TCP, base("ws")), and(DNS, base("ws")));
const WebSockets = or(and(_WebSockets, base("p2p")), _WebSockets);
const _WebSocketsSecure = or(and(TCP, base("wss")), and(DNS, base("wss")), and(TCP, base("tls"), base("ws")), and(DNS, base("tls"), base("ws")));
const WebSocketsSecure = or(and(_WebSocketsSecure, base("p2p")), _WebSocketsSecure);
const HTTP = or(and(TCP, base("http")), and(IP, base("http")), and(DNS, base("http")));
const HTTPS = or(and(TCP, base("https")), and(IP, base("https")), and(DNS, base("https")));
const _WebRTCDirect = and(UDP, base("webrtc-direct"), base("certhash"));
const WebRTCDirect = or(and(_WebRTCDirect, base("p2p")), _WebRTCDirect);
const _WebTransport = and(QUICV1, base("webtransport"), base("certhash"), base("certhash"));
const WebTransport = or(and(_WebTransport, base("p2p")), _WebTransport);
const P2PWebRTCStar = or(and(WebSockets, base("p2p-webrtc-star"), base("p2p")), and(WebSocketsSecure, base("p2p-webrtc-star"), base("p2p")), and(WebSockets, base("p2p-webrtc-star")), and(WebSocketsSecure, base("p2p-webrtc-star")));
const WebSocketStar = or(and(WebSockets, base("p2p-websocket-star"), base("p2p")), and(WebSocketsSecure, base("p2p-websocket-star"), base("p2p")), and(WebSockets, base("p2p-websocket-star")), and(WebSocketsSecure, base("p2p-websocket-star")));
const P2PWebRTCDirect = or(and(HTTP, base("p2p-webrtc-direct"), base("p2p")), and(HTTPS, base("p2p-webrtc-direct"), base("p2p")), and(HTTP, base("p2p-webrtc-direct")), and(HTTPS, base("p2p-webrtc-direct")));
const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
const Stardust = or(and(Reliable, base("p2p-stardust"), base("p2p")), and(Reliable, base("p2p-stardust")));
const _P2P = or(and(Reliable, base("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base("p2p"));
const _Circuit = or(and(_P2P, base("p2p-circuit"), _P2P), and(_P2P, base("p2p-circuit")), and(base("p2p-circuit"), _P2P), and(Reliable, base("p2p-circuit")), and(base("p2p-circuit"), Reliable), base("p2p-circuit"));
const CircuitRecursive = ()=>or(and(_Circuit, CircuitRecursive), _Circuit);
const Circuit = CircuitRecursive();
const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
const IPFS = P2P;
const WebRTC = or(and(Circuit, base("webrtc"), base("p2p")), and(Circuit, base("webrtc")), and(Reliable, base("webrtc"), base("p2p")), and(Reliable, base("webrtc")), base("webrtc"));
/*
 * Validation funcs
 */ function makeMatchesFunction(partialMatch) {
    function matches(a) {
        let ma;
        try {
            ma = (0, _multiaddr.multiaddr)(a);
        } catch (err) {
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const out = partialMatch(ma.protoNames());
        if (out === null) return false;
        if (out === true || out === false) return out;
        return out.length === 0;
    }
    return matches;
}
function and(...args) {
    function partialMatch(a) {
        if (a.length < args.length) return null;
        let out = a;
        args.some((arg)=>{
            out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
            if (Array.isArray(out)) a = out;
            if (out === null) return true;
            return false;
        });
        return out;
    }
    return {
        toString: function() {
            return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
}
function or(...args) {
    function partialMatch(a) {
        let out = null;
        args.some((arg)=>{
            const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
            if (res != null) {
                out = res;
                return true;
            }
            return false;
        });
        return out;
    }
    const result = {
        toString: function() {
            return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
    return result;
}
function base(n) {
    const name = n;
    function matches(a) {
        let ma;
        try {
            ma = (0, _multiaddr.multiaddr)(a);
        } catch (err) {
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const pnames = ma.protoNames();
        if (pnames.length === 1 && pnames[0] === name) return true;
        return false;
    }
    function partialMatch(protos) {
        if (protos.length === 0) return null;
        if (protos[0] === name) return protos.slice(1);
        return null;
    }
    return {
        toString: function() {
            return name;
        },
        matches,
        partialMatch
    };
}

},{"@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eSsJA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pureJsCrypto", ()=>(0, _jsJs.pureJsCrypto));
parcelHelpers.export(exports, "noise", ()=>noise);
var _noiseJs = require("./noise.js");
var _jsJs = require("./crypto/js.js");
function noise(init = {}) {
    return (components)=>new (0, _noiseJs.Noise)(components, init);
}

},{"./noise.js":"f7Zsy","./crypto/js.js":"aF5HF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"f7Zsy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Noise", ()=>Noise);
var _keys = require("@libp2p/crypto/keys");
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _itLengthPrefixed = require("it-length-prefixed");
var _itLengthPrefixedStream = require("it-length-prefixed-stream");
var _duplex = require("it-pair/duplex");
var _itPipe = require("it-pipe");
var _alloc = require("uint8arrays/alloc");
var _constantsJs = require("./constants.js");
var _indexJs = require("./crypto/index.js");
var _cryptoJs = require("./crypto.js");
var _encoderJs = require("./encoder.js");
var _metricsJs = require("./metrics.js");
var _performHandshakeJs = require("./performHandshake.js");
var _streamingJs = require("./streaming.js");
class Noise {
    protocol = "/noise";
    crypto;
    prologue;
    staticKey;
    extensions;
    metrics;
    components;
    constructor(components, init = {}){
        const { staticNoiseKey, extensions, crypto, prologueBytes } = init;
        const { metrics } = components;
        this.components = components;
        const _crypto = crypto ?? (0, _indexJs.defaultCrypto);
        this.crypto = (0, _cryptoJs.wrapCrypto)(_crypto);
        this.extensions = extensions;
        this.metrics = metrics ? (0, _metricsJs.registerMetrics)(metrics) : undefined;
        if (staticNoiseKey) // accepts x25519 private key of length 32
        this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
        else this.staticKey = _crypto.generateX25519KeyPair();
        this.prologue = prologueBytes ?? (0, _alloc.alloc)(0);
    }
    /**
     * Encrypt outgoing data to the remote party (handshake as initiator)
     *
     * @param localPeer - PeerId of the receiving peer
     * @param connection - streaming iterable duplex that will be encrypted
     * @param remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
     */ async secureOutbound(localPeer, connection, remotePeer) {
        const wrappedConnection = (0, _itLengthPrefixedStream.lpStream)(connection, {
            lengthEncoder: (0, _encoderJs.uint16BEEncode),
            lengthDecoder: (0, _encoderJs.uint16BEDecode),
            maxDataLength: (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES)
        });
        if (!localPeer.privateKey) throw new (0, _interface.CodeError)("local peerId does not contain private key", "ERR_NO_PRIVATE_KEY");
        const privateKey = await (0, _keys.unmarshalPrivateKey)(localPeer.privateKey);
        const remoteIdentityKey = remotePeer?.publicKey;
        const handshake = await this.performHandshakeInitiator(wrappedConnection, privateKey, remoteIdentityKey);
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        connection.source = conn.source;
        connection.sink = conn.sink;
        return {
            conn: connection,
            remoteExtensions: handshake.payload.extensions,
            remotePeer: await (0, _peerId.peerIdFromKeys)(handshake.payload.identityKey)
        };
    }
    /**
     * Decrypt incoming data (handshake as responder).
     *
     * @param localPeer - PeerId of the receiving peer.
     * @param connection - streaming iterable duplex that will be encrypted.
     * @param remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
     */ async secureInbound(localPeer, connection, remotePeer) {
        const wrappedConnection = (0, _itLengthPrefixedStream.lpStream)(connection, {
            lengthEncoder: (0, _encoderJs.uint16BEEncode),
            lengthDecoder: (0, _encoderJs.uint16BEDecode),
            maxDataLength: (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES)
        });
        if (!localPeer.privateKey) throw new (0, _interface.CodeError)("local peerId does not contain private key", "ERR_NO_PRIVATE_KEY");
        const privateKey = await (0, _keys.unmarshalPrivateKey)(localPeer.privateKey);
        const remoteIdentityKey = remotePeer?.publicKey;
        const handshake = await this.performHandshakeResponder(wrappedConnection, privateKey, remoteIdentityKey);
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        connection.source = conn.source;
        connection.sink = conn.sink;
        return {
            conn: connection,
            remoteExtensions: handshake.payload.extensions,
            remotePeer: await (0, _peerId.peerIdFromKeys)(handshake.payload.identityKey)
        };
    }
    /**
     * Perform XX handshake as initiator.
     */ async performHandshakeInitiator(connection, // TODO: pass private key in noise constructor via Components
    privateKey, remoteIdentityKey) {
        let result;
        try {
            result = await (0, _performHandshakeJs.performHandshakeInitiator)({
                connection,
                privateKey,
                remoteIdentityKey,
                log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
                crypto: this.crypto,
                prologue: this.prologue,
                s: this.staticKey,
                extensions: this.extensions
            });
            this.metrics?.xxHandshakeSuccesses.increment();
        } catch (e) {
            this.metrics?.xxHandshakeErrors.increment();
            throw e;
        }
        return result;
    }
    /**
     * Perform XX handshake as responder.
     */ async performHandshakeResponder(connection, // TODO: pass private key in noise constructor via Components
    privateKey, remoteIdentityKey) {
        let result;
        try {
            result = await (0, _performHandshakeJs.performHandshakeResponder)({
                connection,
                privateKey,
                remoteIdentityKey,
                log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
                crypto: this.crypto,
                prologue: this.prologue,
                s: this.staticKey,
                extensions: this.extensions
            });
            this.metrics?.xxHandshakeSuccesses.increment();
        } catch (e) {
            this.metrics?.xxHandshakeErrors.increment();
            throw e;
        }
        return result;
    }
    async createSecureConnection(connection, handshake) {
        // Create encryption box/unbox wrapper
        const [secure, user] = (0, _duplex.duplexPair)();
        const network = connection.unwrap();
        await (0, _itPipe.pipe)(secure, (0, _streamingJs.encryptStream)(handshake, this.metrics), network, (source)=>(0, _itLengthPrefixed.decode)(source, {
                lengthDecoder: (0, _encoderJs.uint16BEDecode)
            }), (0, _streamingJs.decryptStream)(handshake, this.metrics), secure // pipe to the wrapper
        );
        return user;
    }
}

},{"@libp2p/crypto/keys":"LlEWq","@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","it-length-prefixed":"lzCYq","it-length-prefixed-stream":"abvhz","it-pair/duplex":"dgmba","it-pipe":"hkKTV","uint8arrays/alloc":"9stB1","./constants.js":"cL95p","./crypto/index.js":"2gfwu","./crypto.js":"bOE41","./encoder.js":"ian3I","./metrics.js":"hxId4","./performHandshake.js":"aOLA5","./streaming.js":"lgXHj","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dgmba":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Two duplex streams that are attached to each other
 */ parcelHelpers.export(exports, "duplexPair", ()=>duplexPair);
var _indexJs = require("./index.js");
function duplexPair() {
    const a = (0, _indexJs.pair)();
    const b = (0, _indexJs.pair)();
    return [
        {
            source: a.source,
            sink: b.sink
        },
        {
            source: b.source,
            sink: a.sink
        }
    ];
}

},{"./index.js":"9AujM","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9AujM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A pair of streams where one drains from the other
 */ parcelHelpers.export(exports, "pair", ()=>pair);
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
function pair() {
    const deferred = (0, _pDeferDefault.default)();
    let piped = false;
    return {
        sink: async (source)=>{
            if (piped) throw new Error("already piped");
            piped = true;
            deferred.resolve(source);
        },
        source: async function*() {
            const source = await deferred.promise;
            yield* source;
        }()
    };
}

},{"p-defer":"cWx93","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hkKTV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pipe", ()=>pipe);
parcelHelpers.export(exports, "rawPipe", ()=>rawPipe);
var _itPushable = require("it-pushable");
var _itMerge = require("it-merge");
var _itMergeDefault = parcelHelpers.interopDefault(_itMerge);
function pipe(first, ...rest) {
    if (first == null) throw new Error("Empty pipeline");
    // Duplex at start: wrap in function and return duplex source
    if (isDuplex(first)) {
        const duplex = first;
        first = ()=>duplex.source;
    // Iterable at start: wrap in function
    } else if (isIterable(first) || isAsyncIterable(first)) {
        const source = first;
        first = ()=>source;
    }
    const fns = [
        first,
        ...rest
    ];
    if (fns.length > 1) // Duplex at end: use duplex sink
    {
        if (isDuplex(fns[fns.length - 1])) fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
    if (fns.length > 2) {
        // Duplex in the middle, consume source with duplex sink and return duplex source
        for(let i = 1; i < fns.length - 1; i++)if (isDuplex(fns[i])) fns[i] = duplexPipelineFn(fns[i]);
    }
    return rawPipe(...fns);
}
const rawPipe = (...fns)=>{
    let res;
    while(fns.length > 0)res = fns.shift()(res);
    return res;
};
const isAsyncIterable = (obj)=>{
    return obj?.[Symbol.asyncIterator] != null;
};
const isIterable = (obj)=>{
    return obj?.[Symbol.iterator] != null;
};
const isDuplex = (obj)=>{
    if (obj == null) return false;
    return obj.sink != null && obj.source != null;
};
const duplexPipelineFn = (duplex)=>{
    return (source)=>{
        const p = duplex.sink(source);
        if (p?.then != null) {
            const stream = (0, _itPushable.pushable)({
                objectMode: true
            });
            p.then(()=>{
                stream.end();
            }, (err)=>{
                stream.end(err);
            });
            let sourceWrap;
            const source = duplex.source;
            if (isAsyncIterable(source)) sourceWrap = async function*() {
                yield* source;
                stream.end();
            };
            else if (isIterable(source)) sourceWrap = function*() {
                yield* source;
                stream.end();
            };
            else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
            return (0, _itMergeDefault.default)(stream, sourceWrap());
        }
        return duplex.source;
    };
};

},{"it-pushable":"hxxEW","it-merge":"7FBsB","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cL95p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NOISE_MSG_MAX_LENGTH_BYTES", ()=>NOISE_MSG_MAX_LENGTH_BYTES);
parcelHelpers.export(exports, "NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG", ()=>NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG);
parcelHelpers.export(exports, "DUMP_SESSION_KEYS", ()=>DUMP_SESSION_KEYS);
const NOISE_MSG_MAX_LENGTH_BYTES = 65535;
const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2gfwu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultCrypto", ()=>defaultCrypto);
var _jsJs = require("./js.js");
const defaultCrypto = (0, _jsJs.pureJsCrypto);

},{"./js.js":"aF5HF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aF5HF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pureJsCrypto", ()=>pureJsCrypto);
var _chacha = require("@noble/ciphers/chacha");
var _ed25519 = require("@noble/curves/ed25519");
var _hkdf = require("@noble/hashes/hkdf");
var _sha256 = require("@noble/hashes/sha256");
const pureJsCrypto = {
    hashSHA256 (data) {
        return (0, _sha256.sha256)(data.subarray());
    },
    getHKDF (ck, ikm) {
        const prk = (0, _hkdf.extract)((0, _sha256.sha256), ikm, ck);
        const okmU8Array = (0, _hkdf.expand)((0, _sha256.sha256), prk, undefined, 96);
        const okm = okmU8Array;
        const k1 = okm.subarray(0, 32);
        const k2 = okm.subarray(32, 64);
        const k3 = okm.subarray(64, 96);
        return [
            k1,
            k2,
            k3
        ];
    },
    generateX25519KeyPair () {
        const secretKey = (0, _ed25519.x25519).utils.randomPrivateKey();
        const publicKey = (0, _ed25519.x25519).getPublicKey(secretKey);
        return {
            publicKey,
            privateKey: secretKey
        };
    },
    generateX25519KeyPairFromSeed (seed) {
        const publicKey = (0, _ed25519.x25519).getPublicKey(seed);
        return {
            publicKey,
            privateKey: seed
        };
    },
    generateX25519SharedKey (privateKey, publicKey) {
        return (0, _ed25519.x25519).getSharedSecret(privateKey.subarray(), publicKey.subarray());
    },
    chaCha20Poly1305Encrypt (plaintext, nonce, ad, k) {
        return (0, _chacha.chacha20poly1305)(k, nonce, ad).encrypt(plaintext.subarray());
    },
    chaCha20Poly1305Decrypt (ciphertext, nonce, ad, k, dst) {
        return (0, _chacha.chacha20poly1305)(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
    }
};

},{"@noble/ciphers/chacha":"jLRxF","@noble/curves/ed25519":"c62gb","@noble/hashes/hkdf":"gORgG","@noble/hashes/sha256":"hPfLW","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jLRxF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * hchacha helper method, used primarily in xchacha, to hash
 * key and nonce into key' and nonce'.
 * Same as chachaCore, but there doesn't seem to be a way to move the block
 * out without 25% performance hit.
 */ // prettier-ignore
parcelHelpers.export(exports, "hchacha", ()=>hchacha);
parcelHelpers.export(exports, "chacha20orig", ()=>chacha20orig);
parcelHelpers.export(exports, "chacha20", ()=>chacha20);
parcelHelpers.export(exports, "xchacha20", ()=>xchacha20);
parcelHelpers.export(exports, "chacha8", ()=>chacha8);
parcelHelpers.export(exports, "chacha12", ()=>chacha12);
parcelHelpers.export(exports, "_poly1305_aead", ()=>_poly1305_aead);
parcelHelpers.export(exports, "chacha20poly1305", ()=>chacha20poly1305);
parcelHelpers.export(exports, "xchacha20poly1305", ()=>xchacha20poly1305);
var _utilsJs = require("./utils.js");
var _poly1305Js = require("./_poly1305.js");
var _arxJs = require("./_arx.js");
// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase
// the diffusion per round, but had slightly less cryptanalysis.
// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf
/**
 * ChaCha core function.
 */ // prettier-ignore
function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter	Nonce   Nonce
    // Save state to temporary variables
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for(let r = 0; r < rounds; r += 2){
        x00 = x00 + x04 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x09, 7);
    }
    // Write output
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for(let r = 0; r < 20; r += 2){
        x00 = x00 + x04 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arxJs.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arxJs.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arxJs.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arxJs.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arxJs.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arxJs.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arxJs.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arxJs.rotl)(x04 ^ x09, 7);
    }
    let oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
}
const chacha20orig = /* @__PURE__ */ (0, _arxJs.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 8,
    allowShortKeys: true
});
const chacha20 = /* @__PURE__ */ (0, _arxJs.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
});
const xchacha20 = /* @__PURE__ */ (0, _arxJs.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
});
const chacha8 = /* @__PURE__ */ (0, _arxJs.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 8
});
const chacha12 = /* @__PURE__ */ (0, _arxJs.createCipher)(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 12
});
const ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
// Pad to digest size with zeros
const updatePadded = (h, msg)=>{
    h.update(msg);
    const left = msg.length % 16;
    if (left) h.update(ZEROS16.subarray(left));
};
const ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
    const authKey = fn(key, nonce, ZEROS32);
    const h = (0, _poly1305Js.poly1305).create(authKey);
    if (AAD) updatePadded(h, AAD);
    updatePadded(h, data);
    const num = new Uint8Array(16);
    const view = (0, _utilsJs.createView)(num);
    (0, _utilsJs.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);
    (0, _utilsJs.setBigUint64)(view, 8, BigInt(data.length), true);
    h.update(num);
    const res = h.digest();
    authKey.fill(0);
    return res;
}
const _poly1305_aead = (xorStream)=>(key, nonce, AAD)=>{
        const tagLength = 16;
        (0, _utilsJs.ensureBytes)(key, 32);
        (0, _utilsJs.ensureBytes)(nonce);
        return {
            encrypt: (plaintext, output)=>{
                const plength = plaintext.length;
                const clength = plength + tagLength;
                if (output) (0, _utilsJs.ensureBytes)(output, clength);
                else output = new Uint8Array(clength);
                xorStream(key, nonce, plaintext, output, 1);
                const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);
                output.set(tag, plength); // append tag
                return output;
            },
            decrypt: (ciphertext, output)=>{
                const clength = ciphertext.length;
                const plength = clength - tagLength;
                if (clength < tagLength) throw new Error(`encrypted data must be at least ${tagLength} bytes`);
                if (output) (0, _utilsJs.ensureBytes)(output, plength);
                else output = new Uint8Array(plength);
                const data = ciphertext.subarray(0, -tagLength);
                const passedTag = ciphertext.subarray(-tagLength);
                const tag = computeTag(xorStream, key, nonce, data, AAD);
                if (!(0, _utilsJs.equalBytes)(passedTag, tag)) throw new Error("invalid tag");
                xorStream(key, nonce, data, output, 1);
                return output;
            }
        };
    };
const chacha20poly1305 = /* @__PURE__ */ (0, _utilsJs.wrapCipher)({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, _poly1305_aead(chacha20));
const xchacha20poly1305 = /* @__PURE__ */ (0, _utilsJs.wrapCipher)({
    blockSize: 64,
    nonceLength: 24,
    tagLength: 16
}, _poly1305_aead(xchacha20));

},{"./utils.js":"gPwnI","./_poly1305.js":"bOfJw","./_arx.js":"e47mg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gPwnI":[function(require,module,exports) {
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ // Cast array to different type
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u8", ()=>u8);
parcelHelpers.export(exports, "u16", ()=>u16);
parcelHelpers.export(exports, "u32", ()=>u32);
parcelHelpers.export(exports, "createView", ()=>createView);
parcelHelpers.export(exports, "isLE", ()=>isLE);
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
// BE: Big Endian, LE: Little Endian
parcelHelpers.export(exports, "bytesToNumberBE", ()=>bytesToNumberBE);
parcelHelpers.export(exports, "numberToBytesBE", ()=>numberToBytesBE);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
// Returns control to thread each 'tick' ms to avoid blocking
parcelHelpers.export(exports, "asyncLoop", ()=>asyncLoop);
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
parcelHelpers.export(exports, "bytesToUtf8", ()=>bytesToUtf8);
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
parcelHelpers.export(exports, "checkOpts", ()=>checkOpts);
parcelHelpers.export(exports, "ensureBytes", ()=>ensureBytes);
// Compares 2 u8a-s in kinda constant time
parcelHelpers.export(exports, "equalBytes", ()=>equalBytes);
// For runtime check if class implements interface
parcelHelpers.export(exports, "Hash", ()=>Hash);
parcelHelpers.export(exports, "wrapCipher", ()=>wrapCipher);
// Polyfill for Safari 14
parcelHelpers.export(exports, "setBigUint64", ()=>setBigUint64);
parcelHelpers.export(exports, "u64Lengths", ()=>u64Lengths);
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u16 = (arr)=>new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
if (!isLE) throw new Error("Non little-endian hardware is not supported");
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!isBytes(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    // Big Endian
    return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    else if (isBytes(data)) data = data.slice();
    else throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        if (!isBytes(a)) throw new Error("Uint8Array expected");
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj)=>Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts))) throw new Error("options must be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
function ensureBytes(b, len) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (typeof len === "number") {
        if (b.length !== len) throw new Error(`Uint8Array length ${len} expected`);
    }
}
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
class Hash {
}
const wrapCipher = (params, c)=>{
    Object.assign(c, params);
    return c;
};
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function u64Lengths(ciphertext, AAD) {
    const num = new Uint8Array(16);
    const view = createView(num);
    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);
    setBigUint64(view, 8, BigInt(ciphertext.length), true);
    return num;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bOfJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrapConstructorWithKey", ()=>wrapConstructorWithKey);
parcelHelpers.export(exports, "poly1305", ()=>poly1305);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
// Poly1305 is a fast and parallel secret-key message-authentication code.
// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf
// https://datatracker.ietf.org/doc/html/rfc8439
// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna
const u8to16 = (a, i)=>a[i++] & 0xff | (a[i++] & 0xff) << 8;
class Poly1305 {
    constructor(key){
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = (0, _utilsJs.toBytes)(key);
        (0, _utilsJs.ensureBytes)(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47
        this.r[0] = t0 & 0x1fff;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f;
        for(let i = 0; i < 8; i++)this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
        const hibit = isLast ? 0 : 2048;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data, offset + 0);
        const t1 = u8to16(data, offset + 2);
        const t2 = u8to16(data, offset + 4);
        const t3 = u8to16(data, offset + 6);
        const t4 = u8to16(data, offset + 8);
        const t5 = u8to16(data, offset + 10);
        const t6 = u8to16(data, offset + 12);
        const t7 = u8to16(data, offset + 14);
        let h0 = h[0] + (t0 & 0x1fff);
        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 0x1fff);
        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 0x1fff);
        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 0x1fff);
        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 0x1fff);
        let h5 = h[5] + (t4 >>> 1 & 0x1fff);
        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 0x1fff);
        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 0x1fff);
        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 0x1fff);
        let h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 0x1fff;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 0x1fff;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 0x1fff;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 0x1fff;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 0x1fff;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 0x1fff;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 0x1fff;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 0x1fff;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 0x1fff;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 0x1fff;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 0x1fff;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 0x1fff;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 0x1fff;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 0x1fff;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 0x1fff;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 0x1fff;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 0x1fff;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 0x1fff;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 0x1fff;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 0x1fff;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 0x1fff;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
    }
    finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 0x1fff;
        for(let i = 2; i < 10; i++){
            h[i] += c;
            c = h[i] >>> 13;
            h[i] &= 0x1fff;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 0x1fff;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 0x1fff;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(let i = 1; i < 10; i++){
            g[i] = h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 8192;
        let mask = (c ^ 1) - 1;
        for(let i = 0; i < 10; i++)g[i] &= mask;
        mask = ~mask;
        for(let i = 0; i < 10; i++)h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 0xffff;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 0xffff;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 0xffff;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 0xffff;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 0xffff;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 0xffff;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 0xffff;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 0xffff;
        let f = h[0] + pad[0];
        h[0] = f & 0xffff;
        for(let i = 1; i < 8; i++){
            f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
            h[i] = f & 0xffff;
        }
    }
    update(data) {
        (0, _assertJs.exists)(this);
        const { buffer, blockLen } = this;
        data = (0, _utilsJs.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input
            if (take === blockLen) {
                for(; blockLen <= len - pos; pos += blockLen)this.process(data, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(buffer, 0, false);
                this.pos = 0;
            }
        }
        return this;
    }
    destroy() {
        this.h.fill(0);
        this.r.fill(0);
        this.buffer.fill(0);
        this.pad.fill(0);
    }
    digestInto(out) {
        (0, _assertJs.exists)(this);
        (0, _assertJs.output)(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
            buffer[pos++] = 1;
            // buffer.subarray(pos).fill(0);
            for(; pos < 16; pos++)buffer[pos] = 0;
            this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for(let i = 0; i < 8; i++){
            out[opos++] = h[i] >>> 0;
            out[opos++] = h[i] >>> 8;
        }
        return out;
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
}
function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key)=>hashCons(key).update((0, _utilsJs.toBytes)(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key)=>hashCons(key);
    return hashC;
}
const poly1305 = wrapConstructorWithKey((key)=>new Poly1305(key));

},{"./_assert.js":"4jr5Y","./utils.js":"gPwnI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4jr5Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "bool", ()=>bool);
parcelHelpers.export(exports, "bytes", ()=>bytes);
parcelHelpers.export(exports, "hash", ()=>hash);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "output", ()=>output);
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`boolean expected, not ${b}`);
}
// TODO: merge with utils
function isBytes(a) {
    return a != null && typeof a === "object" && (a instanceof Uint8Array || a.constructor.name === "Uint8Array");
}
function bytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== "function" || typeof hash.create !== "function") throw new Error("hash must be wrapped by utils.wrapConstructor");
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"e47mg":[function(require,module,exports) {
// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotl", ()=>rotl);
parcelHelpers.export(exports, "createCipher", ()=>createCipher);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
/*
RFC8439 requires multi-step cipher stream, where
authKey starts with counter: 0, actual msg with counter: 1.

For this, we need a way to re-use nonce / counter:

    const counter = new Uint8Array(4);
    chacha(..., counter, ...); // counter is now 1
    chacha(..., counter, ...); // counter is now 2

This is complicated:

- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB
- Original papers don't allow mutating counters
- Counter overflow is undefined [^1]
- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it
- Caveat: Cannot be re-used through all cases:
- * chacha has (counter | nonce)
- * xchacha has (nonce16 | counter | nonce16)
- Idea B: separate nonce / counter and provide separate API for counter re-use
- Caveat: there are different counter sizes depending on an algorithm.
- salsa & chacha also differ in structures of key & sigma:
  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]
  chacha:       s(4) | k(8) | ctr(1) | nonce(3)
  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)
- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`
- Caveat: we can't re-use counter array

xchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal
(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).

[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/
[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2
*/ const sigma16 = (0, _utilsJs.utf8ToBytes)("expand 16-byte k");
const sigma32 = (0, _utilsJs.utf8ToBytes)("expand 32-byte k");
const sigma16_32 = (0, _utilsJs.u32)(sigma16);
const sigma32_32 = (0, _utilsJs.u32)(sigma32);
function rotl(a, b) {
    return a << b | a >>> 32 - b;
}
// Is byte array aligned to 4 byte offset (u32)?
function isAligned32(b) {
    return b.byteOffset % 4 === 0;
}
// Salsa and Chacha block length is always 512-bit
const BLOCK_LEN = 64;
const BLOCK_LEN32 = 16;
// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]
// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]
const MAX_COUNTER = 2 ** 32 - 1;
const U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = (0, _utilsJs.u32)(block);
    // Make sure that buffers aligned to 4 bytes
    const isAligned = isAligned32(data) && isAligned32(output);
    const d32 = isAligned ? (0, _utilsJs.u32)(data) : U32_EMPTY;
    const o32 = isAligned ? (0, _utilsJs.u32)(output) : U32_EMPTY;
    for(let pos = 0; pos < len; counter++){
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER) throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        // aligned to 4 bytes
        if (isAligned && take === BLOCK_LEN) {
            const pos32 = pos / 4;
            if (pos % 4 !== 0) throw new Error("arx: invalid block position");
            for(let j = 0, posj; j < BLOCK_LEN32; j++){
                posj = pos32 + j;
                o32[posj] = d32[posj] ^ b32[j];
            }
            pos += BLOCK_LEN;
            continue;
        }
        for(let j = 0, posj; j < take; j++){
            posj = pos + j;
            output[posj] = data[posj] ^ block[j];
        }
        pos += take;
    }
}
function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, _utilsJs.checkOpts)({
        allowShortKeys: false,
        counterLength: 8,
        counterRight: false,
        rounds: 20
    }, opts);
    if (typeof core !== "function") throw new Error("core must be a function");
    (0, _assertJs.number)(counterLength);
    (0, _assertJs.number)(rounds);
    (0, _assertJs.bool)(counterRight);
    (0, _assertJs.bool)(allowShortKeys);
    return (key, nonce, data, output, counter = 0)=>{
        (0, _assertJs.bytes)(key);
        (0, _assertJs.bytes)(nonce);
        (0, _assertJs.bytes)(data);
        const len = data.length;
        if (!output) output = new Uint8Array(len);
        (0, _assertJs.bytes)(output);
        (0, _assertJs.number)(counter);
        if (counter < 0 || counter >= MAX_COUNTER) throw new Error("arx: counter overflow");
        if (output.length < len) throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        // Key & sigma
        // key=16 -> sigma16, k=key|key
        // key=32 -> sigma32, k=key
        let l = key.length, k, sigma;
        if (l === 32) {
            k = key.slice();
            toClean.push(k);
            sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
            k = new Uint8Array(32);
            k.set(key);
            k.set(key, 16);
            sigma = sigma16_32;
            toClean.push(k);
        } else throw new Error(`arx: invalid 32-byte key, got length=${l}`);
        // Nonce
        // salsa20:      8   (8-byte counter)
        // chacha20orig: 8   (8-byte counter)
        // chacha20:     12  (4-byte counter)
        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)
        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)
        // Align nonce to 4 bytes
        if (!isAligned32(nonce)) {
            nonce = nonce.slice();
            toClean.push(nonce);
        }
        const k32 = (0, _utilsJs.u32)(k);
        // hsalsa & hchacha: handle extended nonce
        if (extendNonceFn) {
            if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);
            extendNonceFn(sigma, k32, (0, _utilsJs.u32)(nonce.subarray(0, 16)), k32);
            nonce = nonce.subarray(16);
        }
        // Handle nonce counter
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length) throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        // Pad counter when nonce is 64 bit
        if (nonceNcLen !== 12) {
            const nc = new Uint8Array(12);
            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
            nonce = nc;
            toClean.push(nonce);
        }
        const n32 = (0, _utilsJs.u32)(nonce);
        runCipher(core, sigma, k32, n32, data, output, counter, rounds);
        while(toClean.length > 0)toClean.pop().fill(0);
        return output;
    };
}

},{"./_assert.js":"4jr5Y","./utils.js":"gPwnI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gORgG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// HKDF (RFC 5869)
// https://soatok.blog/2021/11/17/understanding-hkdf/
/**
 * HKDF-Extract(IKM, salt) -> PRK
 * Arguments position differs from spec (IKM is first one, since it is not optional)
 * @param hash
 * @param ikm
 * @param salt
 * @returns
 */ parcelHelpers.export(exports, "extract", ()=>extract);
/**
 * HKDF-expand from the spec.
 * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
 * @param info - optional context and application specific information (can be a zero-length string)
 * @param length - length of output keying material in octets
 */ parcelHelpers.export(exports, "expand", ()=>expand);
parcelHelpers.export(exports, "hkdf", ()=>hkdf);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
var _hmacJs = require("./hmac.js");
function extract(hash, ikm, salt) {
    (0, _assertJs.hash)(hash);
    // NOTE: some libraries treat zero-length array as 'not provided';
    // we don't, since we have undefined as 'not provided'
    // https://github.com/RustCrypto/KDFs/issues/15
    if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros
    return (0, _hmacJs.hmac)(hash, (0, _utilsJs.toBytes)(salt), (0, _utilsJs.toBytes)(ikm));
}
// HKDF-Expand(PRK, info, L) -> OKM
const HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([
    0
]);
const EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand(hash, prk, info, length = 32) {
    (0, _assertJs.hash)(hash);
    (0, _assertJs.number)(length);
    if (length > 255 * hash.outputLen) throw new Error("Length should be <= 255*HashLen");
    const blocks = Math.ceil(length / hash.outputLen);
    if (info === undefined) info = EMPTY_BUFFER;
    // first L(ength) octets of T
    const okm = new Uint8Array(blocks * hash.outputLen);
    // Re-use HMAC instance between blocks
    const HMAC = (0, _hmacJs.hmac).create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for(let counter = 0; counter < blocks; counter++){
        HKDF_COUNTER[0] = counter + 1;
        // T(0) = empty string (zero length)
        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)
        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
        okm.set(T, hash.outputLen * counter);
        HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    T.fill(0);
    HKDF_COUNTER.fill(0);
    return okm.slice(0, length);
}
const hkdf = (hash, ikm, salt, info, length)=>expand(hash, extract(hash, ikm, salt), info, length);

},{"./_assert.js":"5Bz9G","./utils.js":"eYkBB","./hmac.js":"1S2SD","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bOE41":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrapCrypto", ()=>wrapCrypto);
function wrapCrypto(crypto) {
    return {
        generateKeypair: crypto.generateX25519KeyPair,
        dh: (keypair, publicKey)=>crypto.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
        encrypt: crypto.chaCha20Poly1305Encrypt,
        decrypt: crypto.chaCha20Poly1305Decrypt,
        hash: crypto.hashSHA256,
        hkdf: crypto.getHKDF
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ian3I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint16BEEncode", ()=>uint16BEEncode);
parcelHelpers.export(exports, "uint16BEDecode", ()=>uint16BEDecode);
var _uint8Arraylist = require("uint8arraylist");
var _alloc = require("uint8arrays/alloc");
const uint16BEEncode = (value)=>{
    const target = (0, _alloc.allocUnsafe)(2);
    target[0] = value >> 8;
    target[1] = value;
    return target;
};
uint16BEEncode.bytes = 2;
const uint16BEDecode = (data)=>{
    if (data.length < 2) throw RangeError("Could not decode int16BE");
    if (data instanceof Uint8Array) {
        let value = 0;
        value += data[0] << 8;
        value += data[1];
        return value;
    }
    return data.getUint16(0);
};
uint16BEDecode.bytes = 2;

},{"uint8arraylist":"1W1Ks","uint8arrays/alloc":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hxId4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerMetrics", ()=>registerMetrics);
function registerMetrics(metrics) {
    return {
        xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
            help: "Total count of noise xxHandshakes successes_"
        }),
        xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
            help: "Total count of noise xxHandshakes errors"
        }),
        encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
            help: "Total count of noise encrypted packets successfully"
        }),
        decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
            help: "Total count of noise decrypted packets"
        }),
        decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
            help: "Total count of noise decrypt errors"
        })
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aOLA5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "performHandshakeInitiator", ()=>performHandshakeInitiator);
parcelHelpers.export(exports, "performHandshakeResponder", ()=>performHandshakeResponder);
var _loggerJs = require("./logger.js");
var _protocolJs = require("./protocol.js");
var _utilsJs = require("./utils.js");
async function performHandshakeInitiator(init) {
    const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init;
    const payload = await (0, _utilsJs.createHandshakePayload)(privateKey, s.publicKey, extensions);
    const xx = new (0, _protocolJs.XXHandshakeState)({
        crypto,
        protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
        initiator: true,
        prologue,
        s
    });
    (0, _loggerJs.logLocalStaticKeys)(xx.s, log);
    log.trace("Stage 0 - Initiator starting to send first message.");
    await connection.write(xx.writeMessageA((0, _protocolJs.ZEROLEN)));
    log.trace("Stage 0 - Initiator finished sending first message.");
    (0, _loggerJs.logLocalEphemeralKeys)(xx.e, log);
    log.trace("Stage 1 - Initiator waiting to receive first message from responder...");
    const plaintext = xx.readMessageB(await connection.read());
    log.trace("Stage 1 - Initiator received the message.");
    (0, _loggerJs.logRemoteEphemeralKey)(xx.re, log);
    (0, _loggerJs.logRemoteStaticKey)(xx.rs, log);
    log.trace("Initiator going to check remote's signature...");
    const receivedPayload = await (0, _utilsJs.decodeHandshakePayload)(plaintext, xx.rs, remoteIdentityKey);
    log.trace("All good with the signature!");
    log.trace("Stage 2 - Initiator sending third handshake message.");
    await connection.write(xx.writeMessageC(payload));
    log.trace("Stage 2 - Initiator sent message with signed payload.");
    const [cs1, cs2] = xx.ss.split();
    (0, _loggerJs.logCipherState)(cs1, cs2, log);
    return {
        payload: receivedPayload,
        encrypt: (plaintext)=>cs1.encryptWithAd((0, _protocolJs.ZEROLEN), plaintext),
        decrypt: (ciphertext, dst)=>cs2.decryptWithAd((0, _protocolJs.ZEROLEN), ciphertext, dst)
    };
}
async function performHandshakeResponder(init) {
    const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init;
    const payload = await (0, _utilsJs.createHandshakePayload)(privateKey, s.publicKey, extensions);
    const xx = new (0, _protocolJs.XXHandshakeState)({
        crypto,
        protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
        initiator: false,
        prologue,
        s
    });
    (0, _loggerJs.logLocalStaticKeys)(xx.s, log);
    log.trace("Stage 0 - Responder waiting to receive first message.");
    xx.readMessageA(await connection.read());
    log.trace("Stage 0 - Responder received first message.");
    (0, _loggerJs.logRemoteEphemeralKey)(xx.re, log);
    log.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
    await connection.write(xx.writeMessageB(payload));
    log.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
    (0, _loggerJs.logLocalEphemeralKeys)(xx.e, log);
    log.trace("Stage 2 - Responder waiting for third handshake message...");
    const plaintext = xx.readMessageC(await connection.read());
    log.trace("Stage 2 - Responder received the message, finished handshake.");
    const receivedPayload = await (0, _utilsJs.decodeHandshakePayload)(plaintext, xx.rs, remoteIdentityKey);
    const [cs1, cs2] = xx.ss.split();
    (0, _loggerJs.logCipherState)(cs1, cs2, log);
    return {
        payload: receivedPayload,
        encrypt: (plaintext)=>cs2.encryptWithAd((0, _protocolJs.ZEROLEN), plaintext),
        decrypt: (ciphertext, dst)=>cs1.decryptWithAd((0, _protocolJs.ZEROLEN), ciphertext, dst)
    };
}

},{"./logger.js":"a0ZP9","./protocol.js":"1hFvf","./utils.js":"3nHqf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"a0ZP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logLocalStaticKeys", ()=>logLocalStaticKeys);
parcelHelpers.export(exports, "logLocalEphemeralKeys", ()=>logLocalEphemeralKeys);
parcelHelpers.export(exports, "logRemoteStaticKey", ()=>logRemoteStaticKey);
parcelHelpers.export(exports, "logRemoteEphemeralKey", ()=>logRemoteEphemeralKey);
parcelHelpers.export(exports, "logCipherState", ()=>logCipherState);
var _toString = require("uint8arrays/to-string");
var _constantsJs = require("./constants.js");
function logLocalStaticKeys(s, keyLogger) {
    if (!keyLogger.enabled || !(0, _constantsJs.DUMP_SESSION_KEYS)) return;
    if (s) {
        keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${(0, _toString.toString)(s.publicKey, "hex")}`);
        keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${(0, _toString.toString)(s.privateKey, "hex")}`);
    } else keyLogger("Missing local static keys.");
}
function logLocalEphemeralKeys(e, keyLogger) {
    if (!keyLogger.enabled || !(0, _constantsJs.DUMP_SESSION_KEYS)) return;
    if (e) {
        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${(0, _toString.toString)(e.publicKey, "hex")}`);
        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${(0, _toString.toString)(e.privateKey, "hex")}`);
    } else keyLogger("Missing local ephemeral keys.");
}
function logRemoteStaticKey(rs, keyLogger) {
    if (!keyLogger.enabled || !(0, _constantsJs.DUMP_SESSION_KEYS)) return;
    if (rs) keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${(0, _toString.toString)(rs.subarray(), "hex")}`);
    else keyLogger("Missing remote static public key.");
}
function logRemoteEphemeralKey(re, keyLogger) {
    if (!keyLogger.enabled || !(0, _constantsJs.DUMP_SESSION_KEYS)) return;
    if (re) keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${(0, _toString.toString)(re.subarray(), "hex")}`);
    else keyLogger("Missing remote ephemeral keys.");
}
function logCipherState(cs1, cs2, keyLogger) {
    if (!keyLogger.enabled || !(0, _constantsJs.DUMP_SESSION_KEYS)) return;
    keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && (0, _toString.toString)(cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && (0, _toString.toString)(cs2.k, "hex")}`);
}

},{"uint8arrays/to-string":"63irA","./constants.js":"cL95p","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1hFvf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZEROLEN", ()=>ZEROLEN);
parcelHelpers.export(exports, "CipherState", ()=>CipherState);
parcelHelpers.export(exports, "SymmetricState", ()=>SymmetricState);
parcelHelpers.export(exports, "AbstractHandshakeState", ()=>AbstractHandshakeState);
/**
 * A IHandshakeState that's optimized for the XX pattern
 */ parcelHelpers.export(exports, "XXHandshakeState", ()=>XXHandshakeState);
var _uint8Arraylist = require("uint8arraylist");
var _uint8Arrays = require("uint8arrays");
var _alloc = require("uint8arrays/alloc");
var _errorsJs = require("./errors.js");
var _nonceJs = require("./nonce.js");
const ZEROLEN = (0, _alloc.alloc)(0);
class CipherState {
    k;
    n;
    crypto;
    constructor(crypto, k, n = 0){
        this.crypto = crypto;
        this.k = k;
        this.n = new (0, _nonceJs.Nonce)(n);
    }
    hasKey() {
        return Boolean(this.k);
    }
    encryptWithAd(ad, plaintext) {
        if (!this.hasKey()) return plaintext;
        this.n.assertValue();
        const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
        this.n.increment();
        return e;
    }
    decryptWithAd(ad, ciphertext, dst) {
        if (!this.hasKey()) return ciphertext;
        this.n.assertValue();
        const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
        this.n.increment();
        return plaintext;
    }
}
class SymmetricState {
    cs;
    ck;
    h;
    crypto;
    constructor(crypto, protocolName){
        this.crypto = crypto;
        const protocolNameBytes = (0, _uint8Arrays.fromString)(protocolName, "utf-8");
        this.h = hashProtocolName(crypto, protocolNameBytes);
        this.ck = this.h;
        this.cs = new CipherState(crypto);
    }
    mixKey(ikm) {
        const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
        this.ck = ck;
        this.cs = new CipherState(this.crypto, tempK);
    }
    mixHash(data) {
        this.h = this.crypto.hash(new (0, _uint8Arraylist.Uint8ArrayList)(this.h, data));
    }
    encryptAndHash(plaintext) {
        const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
        this.mixHash(ciphertext);
        return ciphertext;
    }
    decryptAndHash(ciphertext) {
        const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
        this.mixHash(ciphertext);
        return plaintext;
    }
    split() {
        const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
        return [
            new CipherState(this.crypto, tempK1),
            new CipherState(this.crypto, tempK2)
        ];
    }
}
class AbstractHandshakeState {
    ss;
    s;
    e;
    rs;
    re;
    initiator;
    crypto;
    constructor(init){
        const { crypto, protocolName, prologue, initiator, s, e, rs, re } = init;
        this.crypto = crypto;
        this.ss = new SymmetricState(crypto, protocolName);
        this.ss.mixHash(prologue);
        this.initiator = initiator;
        this.s = s;
        this.e = e;
        this.rs = rs;
        this.re = re;
    }
    writeE() {
        if (this.e) throw new Error("ephemeral keypair is already set");
        const e = this.crypto.generateKeypair();
        this.ss.mixHash(e.publicKey);
        this.e = e;
        return e.publicKey;
    }
    writeS() {
        if (!this.s) throw new Error("static keypair is not set");
        return this.ss.encryptAndHash(this.s.publicKey);
    }
    writeEE() {
        if (!this.e) throw new Error("ephemeral keypair is not set");
        if (!this.re) throw new Error("remote ephemeral public key is not set");
        this.ss.mixKey(this.crypto.dh(this.e, this.re));
    }
    writeES() {
        if (this.initiator) {
            if (!this.e) throw new Error("ephemeral keypair is not set");
            if (!this.rs) throw new Error("remote static public key is not set");
            this.ss.mixKey(this.crypto.dh(this.e, this.rs));
        } else {
            if (!this.s) throw new Error("static keypair is not set");
            if (!this.re) throw new Error("remote ephemeral public key is not set");
            this.ss.mixKey(this.crypto.dh(this.s, this.re));
        }
    }
    writeSE() {
        if (this.initiator) {
            if (!this.s) throw new Error("static keypair is not set");
            if (!this.re) throw new Error("remote ephemeral public key is not set");
            this.ss.mixKey(this.crypto.dh(this.s, this.re));
        } else {
            if (!this.e) throw new Error("ephemeral keypair is not set");
            if (!this.rs) throw new Error("remote static public key is not set");
            this.ss.mixKey(this.crypto.dh(this.e, this.rs));
        }
    }
    readE(message, offset = 0) {
        if (this.re) throw new Error("remote ephemeral public key is already set");
        if (message.byteLength < offset + 32) throw new Error("message is not long enough");
        this.re = message.sublist(offset, offset + 32);
        this.ss.mixHash(this.re);
    }
    readS(message, offset = 0) {
        if (this.rs) throw new Error("remote static public key is already set");
        const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
        if (message.byteLength < offset + cipherLength) throw new Error("message is not long enough");
        const temp = message.sublist(offset, offset + cipherLength);
        this.rs = this.ss.decryptAndHash(temp);
        return cipherLength;
    }
    readEE() {
        this.writeEE();
    }
    readES() {
        this.writeES();
    }
    readSE() {
        this.writeSE();
    }
}
class XXHandshakeState extends AbstractHandshakeState {
    // e
    writeMessageA(payload) {
        return new (0, _uint8Arraylist.Uint8ArrayList)(this.writeE(), this.ss.encryptAndHash(payload));
    }
    // e, ee, s, es
    writeMessageB(payload) {
        const e = this.writeE();
        this.writeEE();
        const encS = this.writeS();
        this.writeES();
        return new (0, _uint8Arraylist.Uint8ArrayList)(e, encS, this.ss.encryptAndHash(payload));
    }
    // s, se
    writeMessageC(payload) {
        const encS = this.writeS();
        this.writeSE();
        return new (0, _uint8Arraylist.Uint8ArrayList)(encS, this.ss.encryptAndHash(payload));
    }
    // e
    readMessageA(message) {
        try {
            this.readE(message);
            return this.ss.decryptAndHash(message.sublist(32));
        } catch (e) {
            throw new (0, _errorsJs.InvalidCryptoExchangeError)(`handshake stage 0 validation fail: ${e.message}`);
        }
    }
    // e, ee, s, es
    readMessageB(message) {
        try {
            this.readE(message);
            this.readEE();
            const consumed = this.readS(message, 32);
            this.readES();
            return this.ss.decryptAndHash(message.sublist(32 + consumed));
        } catch (e) {
            throw new (0, _errorsJs.InvalidCryptoExchangeError)(`handshake stage 1 validation fail: ${e.message}`);
        }
    }
    // s, se
    readMessageC(message) {
        try {
            const consumed = this.readS(message);
            this.readSE();
            return this.ss.decryptAndHash(message.sublist(consumed));
        } catch (e) {
            throw new (0, _errorsJs.InvalidCryptoExchangeError)(`handshake stage 2 validation fail: ${e.message}`);
        }
    }
}
function hashProtocolName(crypto, protocolName) {
    if (protocolName.length <= 32) {
        const h = (0, _alloc.alloc)(32);
        h.set(protocolName);
        return h;
    } else return crypto.hash(protocolName);
}

},{"uint8arraylist":"1W1Ks","uint8arrays":"2e0DO","uint8arrays/alloc":"9stB1","./errors.js":"87fNQ","./nonce.js":"lkpzb","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2e0DO":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * `Uint8Array`s bring memory-efficient(ish) byte handling to browsers - they are similar to Node.js `Buffer`s but lack a lot of the utility methods present on that class.
 *
 * This module exports a number of function that let you do common operations - joining Uint8Arrays together, seeing if they have the same contents etc.
 *
 * Since Node.js `Buffer`s are also `Uint8Array`s, it falls back to `Buffer` internally where it makes sense for performance reasons.
 *
 * ## alloc(size)
 *
 * Create a new `Uint8Array`. If `globalThis.Buffer` is defined, it will be used in preference to `globalThis.Uint8Array`.
 *
 * ### Example
 *
 * ```js
 * import { alloc } from 'uint8arrays/alloc'
 *
 * const buf = alloc(100)
 * ```
 *
 * ## allocUnsafe(size)
 *
 * Create a new `Uint8Array`. If `globalThis.Buffer` is defined, it will be used in preference to `globalThis.Uint8Array`.
 *
 * On platforms that support it, memory referenced by the returned `Uint8Array` will not be initialized.
 *
 * ### Example
 *
 * ```js
 * import { allocUnsafe } from 'uint8arrays/alloc'
 *
 * const buf = allocUnsafe(100)
 * ```
 *
 * ## compare(a, b)
 *
 * Compare two `Uint8Arrays`
 *
 * ### Example
 *
 * ```js
 * import { compare } from 'uint8arrays/compare'
 *
 * const arrays = [
 *   Uint8Array.from([3, 4, 5]),
 *   Uint8Array.from([0, 1, 2])
 * ]
 *
 * const sorted = arrays.sort(compare)
 *
 * console.info(sorted)
 * // [
 * //    Uint8Array[0, 1, 2]
 * //    Uint8Array[3, 4, 5]
 * // ]
 * ```
 *
 * ## concat(arrays, \[length])
 *
 * Concatenate one or more `Uint8Array`s and return a `Uint8Array` with their contents.
 *
 * If you know the length of the arrays, pass it as a second parameter, otherwise it will be calculated by traversing the list of arrays.
 *
 * ### Example
 *
 * ```js
 * import { concat } from 'uint8arrays/concat'
 *
 * const arrays = [
 *   Uint8Array.from([0, 1, 2]),
 *   Uint8Array.from([3, 4, 5])
 * ]
 *
 * const all = concat(arrays, 6)
 *
 * console.info(all)
 * // Uint8Array[0, 1, 2, 3, 4, 5]
 * ```
 *
 * ## equals(a, b)
 *
 * Returns true if the two arrays are the same array or if they have the same length and contents.
 *
 * ### Example
 *
 * ```js
 * import { equals } from 'uint8arrays/equals'
 *
 * const a = Uint8Array.from([0, 1, 2])
 * const b = Uint8Array.from([3, 4, 5])
 * const c = Uint8Array.from([0, 1, 2])
 *
 * console.info(equals(a, b)) // false
 * console.info(equals(a, c)) // true
 * console.info(equals(a, a)) // true
 * ```
 *
 * ## fromString(string, encoding = 'utf8')
 *
 * Returns a new `Uint8Array` created from the passed string and interpreted as the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { fromString } from 'uint8arrays/from-string'
 *
 * console.info(fromString('hello world')) // Uint8Array[104, 101 ...
 * console.info(fromString('00010203aabbcc', 'base16')) // Uint8Array[0, 1 ...
 * console.info(fromString('AAECA6q7zA', 'base64')) // Uint8Array[0, 1 ...
 * console.info(fromString('01234', 'ascii')) // Uint8Array[48, 49 ...
 * ```
 *
 * ## toString(array, encoding = 'utf8')
 *
 * Returns a string created from the passed `Uint8Array` in the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { toString } from 'uint8arrays/to-string'
 *
 * console.info(toString(Uint8Array.from([104, 101...]))) // 'hello world'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base16')) // '00010203aabbcc'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base64')) // 'AAECA6q7zA'
 * console.info(toString(Uint8Array.from([48, 49, 50...]), 'ascii')) // '01234'
 * ```
 *
 * ## xor(a, b)
 *
 * Returns a `Uint8Array` containing `a` and `b` xored together.
 *
 * ### Example
 *
 * ```js
 * import { xor } from 'uint8arrays/xor'
 *
 * console.info(xor(Uint8Array.from([1, 0]), Uint8Array.from([0, 1]))) // Uint8Array[1, 1]
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compare", ()=>(0, _compareJs.compare));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "equals", ()=>(0, _equalsJs.equals));
parcelHelpers.export(exports, "fromString", ()=>(0, _fromStringJs.fromString));
parcelHelpers.export(exports, "toString", ()=>(0, _toStringJs.toString));
parcelHelpers.export(exports, "xor", ()=>(0, _xorJs.xor));
var _compareJs = require("./compare.js");
var _concatJs = require("./concat.js");
var _equalsJs = require("./equals.js");
var _fromStringJs = require("./from-string.js");
var _toStringJs = require("./to-string.js");
var _xorJs = require("./xor.js");

},{"./compare.js":"soU5b","./concat.js":"byG2b","./equals.js":"CKVqX","./from-string.js":"3YvUV","./to-string.js":"63irA","./xor.js":"6UuEx","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"soU5b":[function(require,module,exports) {
/**
 * Can be used with Array.sort to sort and array with Uint8Array entries
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compare", ()=>compare);
function compare(a, b) {
    if (globalThis.Buffer != null) return globalThis.Buffer.compare(a, b);
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
    }
    if (a.byteLength > b.byteLength) return 1;
    if (a.byteLength < b.byteLength) return -1;
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6UuEx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the xor distance between two arrays
 */ parcelHelpers.export(exports, "xor", ()=>xor);
var _allocJs = require("./alloc.js");
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function xor(a, b) {
    if (a.length !== b.length) throw new Error("Inputs should have the same length");
    const result = (0, _allocJs.allocUnsafe)(a.length);
    for(let i = 0; i < a.length; i++)result[i] = a[i] ^ b[i];
    return (0, _asUint8ArrayJs.asUint8Array)(result);
}

},{"./alloc.js":"9stB1","./util/as-uint8array.js":"lTef0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"87fNQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnexpectedPeerError", ()=>UnexpectedPeerError);
parcelHelpers.export(exports, "InvalidCryptoExchangeError", ()=>InvalidCryptoExchangeError);
class UnexpectedPeerError extends Error {
    code;
    constructor(message = "Unexpected Peer"){
        super(message);
        this.code = UnexpectedPeerError.code;
    }
    static code = "ERR_UNEXPECTED_PEER";
}
class InvalidCryptoExchangeError extends Error {
    code;
    constructor(message = "Invalid crypto exchange"){
        super(message);
        this.code = InvalidCryptoExchangeError.code;
    }
    static code = "ERR_INVALID_CRYPTO_EXCHANGE";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lkpzb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN_NONCE", ()=>MIN_NONCE);
parcelHelpers.export(exports, "MAX_NONCE", ()=>MAX_NONCE);
/**
 * The nonce is an uint that's increased over time.
 * Maintaining different representations help improve performance.
 */ parcelHelpers.export(exports, "Nonce", ()=>Nonce);
var _alloc = require("uint8arrays/alloc");
const MIN_NONCE = 0;
const MAX_NONCE = 0xffffffff;
const ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
class Nonce {
    n;
    bytes;
    view;
    constructor(n = MIN_NONCE){
        this.n = n;
        this.bytes = (0, _alloc.alloc)(12);
        this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
        this.view.setUint32(4, n, true);
    }
    increment() {
        this.n++;
        // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.
        this.view.setUint32(4, this.n, true);
    }
    getBytes() {
        return this.bytes;
    }
    getUint64() {
        return this.n;
    }
    assertValue() {
        if (this.n > MAX_NONCE) throw new Error(ERR_MAX_NONCE);
    }
}

},{"uint8arrays/alloc":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3nHqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createHandshakePayload", ()=>createHandshakePayload);
parcelHelpers.export(exports, "decodeHandshakePayload", ()=>decodeHandshakePayload);
parcelHelpers.export(exports, "getSignaturePayload", ()=>getSignaturePayload);
var _keys = require("@libp2p/crypto/keys");
var _uint8Arraylist = require("uint8arraylist");
var _uint8Arrays = require("uint8arrays");
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
var _errorsJs = require("./errors.js");
var _payloadJs = require("./proto/payload.js");
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
    return (0, _payloadJs.NoiseHandshakePayload).encode({
        identityKey: privateKey.public.bytes,
        identitySig,
        extensions
    });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
    try {
        const payload = (0, _payloadJs.NoiseHandshakePayload).decode(payloadBytes);
        if (remoteIdentityKey) {
            const remoteIdentityKeyBytes = remoteIdentityKey.subarray();
            if (!(0, _uint8Arrays.equals)(remoteIdentityKeyBytes, payload.identityKey)) throw new Error(`Payload identity key ${(0, _uint8Arrays.toString)(payload.identityKey, "hex")} does not match expected remote identity key ${(0, _uint8Arrays.toString)(remoteIdentityKeyBytes, "hex")}`);
        }
        if (!remoteStaticKey) throw new Error("Remote static does not exist");
        const signaturePayload = getSignaturePayload(remoteStaticKey);
        const publicKey = (0, _keys.unmarshalPublicKey)(payload.identityKey);
        if (!await publicKey.verify(signaturePayload, payload.identitySig)) throw new Error("Invalid payload signature");
        return payload;
    } catch (e) {
        throw new (0, _errorsJs.UnexpectedPeerError)(e.message);
    }
}
function getSignaturePayload(publicKey) {
    const prefix = (0, _fromString.fromString)("noise-libp2p-static-key:");
    if (publicKey instanceof Uint8Array) return (0, _concat.concat)([
        prefix,
        publicKey
    ], prefix.length + publicKey.length);
    publicKey.prepend(prefix);
    return publicKey;
}

},{"@libp2p/crypto/keys":"LlEWq","uint8arraylist":"1W1Ks","uint8arrays":"2e0DO","uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","./errors.js":"87fNQ","./proto/payload.js":"k5BVv","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"k5BVv":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoiseExtensions", ()=>NoiseExtensions);
parcelHelpers.export(exports, "NoiseHandshakePayload", ()=>NoiseHandshakePayload);
var _protonsRuntime = require("protons-runtime");
var _alloc = require("uint8arrays/alloc");
var NoiseExtensions;
(function(NoiseExtensions) {
    let _codec;
    NoiseExtensions.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.webtransportCerthashes != null) for (const value of obj.webtransportCerthashes){
                w.uint32(10);
                w.bytes(value);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                webtransportCerthashes: []
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.webtransportCerthashes.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    NoiseExtensions.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, NoiseExtensions.codec());
    };
    NoiseExtensions.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, NoiseExtensions.codec());
    };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload) {
    let _codec;
    NoiseHandshakePayload.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.identityKey);
            }
            if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
                w.uint32(18);
                w.bytes(obj.identitySig);
            }
            if (obj.extensions != null) {
                w.uint32(34);
                NoiseExtensions.codec().encode(obj.extensions, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                identityKey: (0, _alloc.alloc)(0),
                identitySig: (0, _alloc.alloc)(0)
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.identityKey = reader.bytes();
                        break;
                    case 2:
                        obj.identitySig = reader.bytes();
                        break;
                    case 4:
                        obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    NoiseHandshakePayload.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, NoiseHandshakePayload.codec());
    };
    NoiseHandshakePayload.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, NoiseHandshakePayload.codec());
    };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

},{"protons-runtime":"iJEgs","uint8arrays/alloc":"9stB1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lgXHj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Returns generator that encrypts payload from the user
parcelHelpers.export(exports, "encryptStream", ()=>encryptStream);
// Decrypt received payload to the user
parcelHelpers.export(exports, "decryptStream", ()=>decryptStream);
var _uint8Arraylist = require("uint8arraylist");
var _constantsJs = require("./constants.js");
var _encoderJs = require("./encoder.js");
const CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake, metrics) {
    return async function*(source) {
        for await (const chunk of source)for(let i = 0; i < chunk.length; i += (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG)){
            let end = i + (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG);
            if (end > chunk.length) end = chunk.length;
            let data;
            if (chunk instanceof Uint8Array) data = handshake.encrypt(chunk.subarray(i, end));
            else data = handshake.encrypt(chunk.sublist(i, end));
            metrics?.encryptedPackets.increment();
            yield new (0, _uint8Arraylist.Uint8ArrayList)((0, _encoderJs.uint16BEEncode)(data.byteLength), data);
        }
    };
}
function decryptStream(handshake, metrics) {
    return async function*(source) {
        for await (const chunk of source)for(let i = 0; i < chunk.length; i += (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES)){
            let end = i + (0, _constantsJs.NOISE_MSG_MAX_LENGTH_BYTES);
            if (end > chunk.length) end = chunk.length;
            if (end - CHACHA_TAG_LENGTH < i) throw new Error("Invalid chunk");
            const encrypted = chunk.sublist(i, end);
            // memory allocation is not cheap so reuse the encrypted Uint8Array
            // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164
            // this is ok because chacha20 reads bytes one by one and don't reread after that
            // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48
            const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
            try {
                const plaintext = handshake.decrypt(encrypted, dst);
                metrics?.decryptedPackets.increment();
                yield plaintext;
            } catch (e) {
                metrics?.decryptErrors.increment();
                throw e;
            }
        }
    };
}

},{"uint8arraylist":"1W1Ks","./constants.js":"cL95p","./encoder.js":"ian3I","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7mg3b":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).
 *
 * @example Configure libp2p with Yamux
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { yamux } from '@chainsafe/libp2p-yamux'
 *
 * const node = await createLibp2p({
 *   // ... other options
 *   streamMuxers: [
 *     yamux()
 *   ]
 * })
 * ```
 *
 * @example Using the low-level API
 *
 * ```js
 * import { yamux } from '@chainsafe/libp2p-yamux'
 * import { pipe } from 'it-pipe'
 * import { duplexPair } from 'it-pair/duplex'
 * import all from 'it-all'
 *
 * // Connect two yamux muxers to demo basic stream multiplexing functionality
 *
 * const clientMuxer = yamux({
 *   client: true,
 *   onIncomingStream: stream => {
 *     // echo data on incoming streams
 *     pipe(stream, stream)
 *   },
 *   onStreamEnd: stream => {
 *     // do nothing
 *   }
 * })()
 *
 * const serverMuxer = yamux({
 *   client: false,
 *   onIncomingStream: stream => {
 *     // echo data on incoming streams
 *     pipe(stream, stream)
 *   },
 *   onStreamEnd: stream => {
 *     // do nothing
 *   }
 * })()
 *
 * // `p` is our "connections", what we use to connect the two sides
 * // In a real application, a connection is usually to a remote computer
 * const p = duplexPair()
 *
 * // connect the muxers together
 * pipe(p[0], clientMuxer, p[0])
 * pipe(p[1], serverMuxer, p[1])
 *
 * // now either side can open streams
 * const stream0 = clientMuxer.newStream()
 * const stream1 = serverMuxer.newStream()
 *
 * // Send some data to the other side
 * const encoder = new TextEncoder()
 * const data = [encoder.encode('hello'), encoder.encode('world')]
 * pipe(data, stream0)
 *
 * // Receive data back
 * const result = await pipe(stream0, all)
 *
 * // close a stream
 * stream1.close()
 *
 * // close the muxer
 * clientMuxer.close()
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GoAwayCode", ()=>(0, _frameJs.GoAwayCode));
parcelHelpers.export(exports, "yamux", ()=>yamux);
var _muxerJs = require("./muxer.js");
var _frameJs = require("./frame.js");
function yamux(init = {}) {
    return (components)=>new (0, _muxerJs.Yamux)(components, init);
}

},{"./muxer.js":"rEjFW","./frame.js":"4oU0I","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"rEjFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Yamux", ()=>Yamux);
parcelHelpers.export(exports, "YamuxMuxer", ()=>YamuxMuxer);
var _interface = require("@libp2p/interface");
var _getIterator = require("get-iterator");
var _itPushable = require("it-pushable");
var _uint8Arraylist = require("uint8arraylist");
var _configJs = require("./config.js");
var _constantsJs = require("./constants.js");
var _decodeJs = require("./decode.js");
var _encodeJs = require("./encode.js");
var _frameJs = require("./frame.js");
var _streamJs = require("./stream.js");
const YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
const CLOSE_TIMEOUT = 500;
class Yamux {
    protocol = YAMUX_PROTOCOL_ID;
    _components;
    _init;
    constructor(components, init = {}){
        this._components = components;
        this._init = init;
    }
    createStreamMuxer(init) {
        return new YamuxMuxer(this._components, {
            ...this._init,
            ...init
        });
    }
}
class YamuxMuxer {
    protocol = YAMUX_PROTOCOL_ID;
    source;
    sink;
    config;
    log;
    logger;
    /** Used to close the muxer from either the sink or source */ closeController;
    /** The next stream id to be used when initiating a new stream */ nextStreamID;
    /** Primary stream mapping, streamID => stream */ _streams;
    /** The next ping id to be used when pinging */ nextPingID;
    /** Tracking info for the currently active ping */ activePing;
    /** Round trip time */ rtt;
    /** True if client, false if server */ client;
    localGoAway;
    remoteGoAway;
    /** Number of tracked inbound streams */ numInboundStreams;
    /** Number of tracked outbound streams */ numOutboundStreams;
    onIncomingStream;
    onStreamEnd;
    constructor(components, init){
        this.client = init.direction === "outbound";
        this.config = {
            ...(0, _configJs.defaultConfig),
            ...init
        };
        this.logger = components.logger;
        this.log = this.logger.forComponent("libp2p:yamux");
        (0, _configJs.verifyConfig)(this.config);
        this.closeController = new AbortController();
        (0, _interface.setMaxListeners)(Infinity, this.closeController.signal);
        this.onIncomingStream = init.onIncomingStream;
        this.onStreamEnd = init.onStreamEnd;
        this._streams = new Map();
        this.source = (0, _itPushable.pushable)({
            onEnd: ()=>{
                this.log?.trace("muxer source ended");
                this._streams.forEach((stream)=>{
                    stream.destroy();
                });
            }
        });
        this.sink = async (source)=>{
            const shutDownListener = ()=>{
                const iterator = (0, _getIterator.getIterator)(source);
                if (iterator.return != null) {
                    const res = iterator.return();
                    if (isPromise(res)) res.catch((err)=>{
                        this.log?.("could not cause sink source to return", err);
                    });
                }
            };
            let reason, error;
            try {
                const decoder = new (0, _decodeJs.Decoder)(source);
                try {
                    this.closeController.signal.addEventListener("abort", shutDownListener);
                    for await (const frame of decoder.emitFrames())await this.handleFrame(frame.header, frame.readData);
                } finally{
                    this.closeController.signal.removeEventListener("abort", shutDownListener);
                }
                reason = (0, _frameJs.GoAwayCode).NormalTermination;
            } catch (err) {
                // either a protocol or internal error
                const errCode = err.code;
                if ((0, _constantsJs.PROTOCOL_ERRORS).has(errCode)) {
                    this.log?.error("protocol error in sink", err);
                    reason = (0, _frameJs.GoAwayCode).ProtocolError;
                } else {
                    this.log?.error("internal error in sink", err);
                    reason = (0, _frameJs.GoAwayCode).InternalError;
                }
                error = err;
            }
            this.log?.trace("muxer sink ended");
            if (error != null) this.abort(error, reason);
            else await this.close({
                reason
            });
        };
        this.numInboundStreams = 0;
        this.numOutboundStreams = 0;
        // client uses odd streamIDs, server uses even streamIDs
        this.nextStreamID = this.client ? 1 : 2;
        this.nextPingID = 0;
        this.rtt = -1;
        this.log?.trace("muxer created");
        if (this.config.enableKeepAlive) this.keepAliveLoop().catch((e)=>this.log?.error("keepalive error: %s", e));
        // send an initial ping to establish RTT
        this.ping().catch((e)=>this.log?.error("ping error: %s", e));
    }
    get streams() {
        return Array.from(this._streams.values());
    }
    newStream(name) {
        if (this.remoteGoAway !== undefined) throw new (0, _interface.CodeError)("muxer closed remotely", (0, _constantsJs.ERR_MUXER_REMOTE_CLOSED));
        if (this.localGoAway !== undefined) throw new (0, _interface.CodeError)("muxer closed locally", (0, _constantsJs.ERR_MUXER_LOCAL_CLOSED));
        const id = this.nextStreamID;
        this.nextStreamID += 2;
        // check against our configured maximum number of outbound streams
        if (this.numOutboundStreams >= this.config.maxOutboundStreams) throw new (0, _interface.CodeError)("max outbound streams exceeded", (0, _constantsJs.ERR_MAX_OUTBOUND_STREAMS_EXCEEDED));
        this.log?.trace("new outgoing stream id=%s", id);
        const stream = this._newStream(id, name, (0, _streamJs.StreamState).Init, "outbound");
        this._streams.set(id, stream);
        this.numOutboundStreams++;
        // send a window update to open the stream on the receiver end
        stream.sendWindowUpdate();
        return stream;
    }
    /**
     * Initiate a ping and wait for a response
     *
     * Note: only a single ping will be initiated at a time.
     * If a ping is already in progress, a new ping will not be initiated.
     *
     * @returns the round-trip-time in milliseconds
     */ async ping() {
        if (this.remoteGoAway !== undefined) throw new (0, _interface.CodeError)("muxer closed remotely", (0, _constantsJs.ERR_MUXER_REMOTE_CLOSED));
        if (this.localGoAway !== undefined) throw new (0, _interface.CodeError)("muxer closed locally", (0, _constantsJs.ERR_MUXER_LOCAL_CLOSED));
        // An active ping does not yet exist, handle the process here
        if (this.activePing === undefined) {
            // create active ping
            let _resolve = ()=>{};
            this.activePing = {
                id: this.nextPingID++,
                // this promise awaits resolution or the close controller aborting
                promise: new Promise((resolve, reject)=>{
                    const closed = ()=>{
                        reject(new (0, _interface.CodeError)("muxer closed locally", (0, _constantsJs.ERR_MUXER_LOCAL_CLOSED)));
                    };
                    this.closeController.signal.addEventListener("abort", closed, {
                        once: true
                    });
                    _resolve = ()=>{
                        this.closeController.signal.removeEventListener("abort", closed);
                        resolve();
                    };
                }),
                resolve: _resolve
            };
            // send ping
            const start = Date.now();
            this.sendPing(this.activePing.id);
            // await pong
            try {
                await this.activePing.promise;
            } finally{
                // clean-up active ping
                delete this.activePing;
            }
            // update rtt
            const end = Date.now();
            this.rtt = end - start;
        } else // an active ping is already in progress, piggyback off that
        await this.activePing.promise;
        return this.rtt;
    }
    /**
     * Get the ping round trip time
     *
     * Note: Will return 0 if no successful ping has yet been completed
     *
     * @returns the round-trip-time in milliseconds
     */ getRTT() {
        return this.rtt;
    }
    /**
     * Close the muxer
     */ async close(options = {}) {
        if (this.closeController.signal.aborted) // already closed
        return;
        const reason = options?.reason ?? (0, _frameJs.GoAwayCode).NormalTermination;
        this.log?.trace("muxer close reason=%s", reason);
        if (options.signal == null) {
            const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
            (0, _interface.setMaxListeners)(Infinity, signal);
            options = {
                ...options,
                signal
            };
        }
        try {
            await Promise.all([
                ...this._streams.values()
            ].map(async (s)=>s.close(options)));
            // send reason to the other side, allow the other side to close gracefully
            this.sendGoAway(reason);
            this._closeMuxer();
        } catch (err) {
            this.abort(err);
        }
    }
    abort(err, reason) {
        if (this.closeController.signal.aborted) // already closed
        return;
        reason = reason ?? (0, _frameJs.GoAwayCode).InternalError;
        // If reason was provided, use that, otherwise use the presence of `err` to determine the reason
        this.log?.error("muxer abort reason=%s error=%s", reason, err);
        // Abort all underlying streams
        for (const stream of this._streams.values())stream.abort(err);
        // send reason to the other side, allow the other side to close gracefully
        this.sendGoAway(reason);
        this._closeMuxer();
    }
    isClosed() {
        return this.closeController.signal.aborted;
    }
    /**
     * Called when either the local or remote shuts down the muxer
     */ _closeMuxer() {
        // stop the sink and any other processes
        this.closeController.abort();
        // stop the source
        this.source.end();
    }
    /** Create a new stream */ _newStream(id, name, state, direction) {
        if (this._streams.get(id) != null) throw new (0, _interface.CodeError)("Stream already exists", (0, _constantsJs.ERR_STREAM_ALREADY_EXISTS), {
            id
        });
        const stream = new (0, _streamJs.YamuxStream)({
            id: id.toString(),
            name,
            state,
            direction,
            sendFrame: this.sendFrame.bind(this),
            onEnd: ()=>{
                this.closeStream(id);
                this.onStreamEnd?.(stream);
            },
            log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),
            config: this.config,
            getRTT: this.getRTT.bind(this)
        });
        return stream;
    }
    /**
     * closeStream is used to close a stream once both sides have
     * issued a close.
     */ closeStream(id) {
        if (this.client === (id % 2 === 0)) this.numInboundStreams--;
        else this.numOutboundStreams--;
        this._streams.delete(id);
    }
    async keepAliveLoop() {
        const abortPromise = new Promise((_resolve, reject)=>{
            this.closeController.signal.addEventListener("abort", reject, {
                once: true
            });
        });
        this.log?.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
        while(true){
            let timeoutId;
            try {
                await Promise.race([
                    abortPromise,
                    new Promise((resolve)=>{
                        timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
                    })
                ]);
                this.ping().catch((e)=>this.log?.error("ping error: %s", e));
            } catch (e) {
                // closed
                clearInterval(timeoutId);
                return;
            }
        }
    }
    async handleFrame(header, readData) {
        const { streamID, type, length } = header;
        this.log?.trace("received frame %o", header);
        if (streamID === 0) switch(type){
            case (0, _frameJs.FrameType).Ping:
                this.handlePing(header);
                return;
            case (0, _frameJs.FrameType).GoAway:
                this.handleGoAway(length);
                return;
            default:
                // Invalid state
                throw new (0, _interface.CodeError)("Invalid frame type", (0, _constantsJs.ERR_INVALID_FRAME), {
                    header
                });
        }
        else switch(header.type){
            case (0, _frameJs.FrameType).Data:
            case (0, _frameJs.FrameType).WindowUpdate:
                await this.handleStreamMessage(header, readData);
                return;
            default:
                // Invalid state
                throw new (0, _interface.CodeError)("Invalid frame type", (0, _constantsJs.ERR_INVALID_FRAME), {
                    header
                });
        }
    }
    handlePing(header) {
        // If the ping  is initiated by the sender, send a response
        if (header.flag === (0, _frameJs.Flag).SYN) {
            this.log?.trace("received ping request pingId=%s", header.length);
            this.sendPing(header.length, (0, _frameJs.Flag).ACK);
        } else if (header.flag === (0, _frameJs.Flag).ACK) {
            this.log?.trace("received ping response pingId=%s", header.length);
            this.handlePingResponse(header.length);
        } else // Invalid state
        throw new (0, _interface.CodeError)("Invalid frame flag", (0, _constantsJs.ERR_INVALID_FRAME), {
            header
        });
    }
    handlePingResponse(pingId) {
        if (this.activePing === undefined) // this ping was not requested
        throw new (0, _interface.CodeError)("ping not requested", (0, _constantsJs.ERR_UNREQUESTED_PING));
        if (this.activePing.id !== pingId) // this ping doesn't match our active ping request
        throw new (0, _interface.CodeError)("ping doesn't match our id", (0, _constantsJs.ERR_NOT_MATCHING_PING));
        // valid ping response
        this.activePing.resolve();
    }
    handleGoAway(reason) {
        this.log?.trace("received GoAway reason=%s", (0, _frameJs.GoAwayCode)[reason] ?? "unknown");
        this.remoteGoAway = reason;
        // If the other side is friendly, they would have already closed all streams before sending a GoAway
        // In case they weren't, reset all streams
        for (const stream of this._streams.values())stream.reset();
        this._closeMuxer();
    }
    async handleStreamMessage(header, readData) {
        const { streamID, flag, type } = header;
        if ((flag & (0, _frameJs.Flag).SYN) === (0, _frameJs.Flag).SYN) this.incomingStream(streamID);
        const stream = this._streams.get(streamID);
        if (stream === undefined) {
            if (type === (0, _frameJs.FrameType).Data) {
                this.log?.("discarding data for stream id=%s", streamID);
                if (readData === undefined) throw new Error("unreachable");
                await readData();
            } else this.log?.("frame for missing stream id=%s", streamID);
            return;
        }
        switch(type){
            case (0, _frameJs.FrameType).WindowUpdate:
                stream.handleWindowUpdate(header);
                return;
            case (0, _frameJs.FrameType).Data:
                if (readData === undefined) throw new Error("unreachable");
                await stream.handleData(header, readData);
                return;
            default:
                throw new Error("unreachable");
        }
    }
    incomingStream(id) {
        if (this.client !== (id % 2 === 0)) throw new (0, _interface.CodeError)("both endpoints are clients", (0, _constantsJs.ERR_BOTH_CLIENTS));
        if (this._streams.has(id)) return;
        this.log?.trace("new incoming stream id=%s", id);
        if (this.localGoAway !== undefined) {
            // reject (reset) immediately if we are doing a go away
            this.sendFrame({
                type: (0, _frameJs.FrameType).WindowUpdate,
                flag: (0, _frameJs.Flag).RST,
                streamID: id,
                length: 0
            });
            return;
        }
        // check against our configured maximum number of inbound streams
        if (this.numInboundStreams >= this.config.maxInboundStreams) {
            this.log?.("maxIncomingStreams exceeded, forcing stream reset");
            this.sendFrame({
                type: (0, _frameJs.FrameType).WindowUpdate,
                flag: (0, _frameJs.Flag).RST,
                streamID: id,
                length: 0
            });
            return;
        }
        // allocate a new stream
        const stream = this._newStream(id, undefined, (0, _streamJs.StreamState).SYNReceived, "inbound");
        this.numInboundStreams++;
        // the stream should now be tracked
        this._streams.set(id, stream);
        this.onIncomingStream?.(stream);
    }
    sendFrame(header, data) {
        this.log?.trace("sending frame %o", header);
        if (header.type === (0, _frameJs.FrameType).Data) {
            if (data === undefined) throw new (0, _interface.CodeError)("invalid frame", (0, _constantsJs.ERR_INVALID_FRAME));
            this.source.push(new (0, _uint8Arraylist.Uint8ArrayList)((0, _encodeJs.encodeHeader)(header), data));
        } else this.source.push((0, _encodeJs.encodeHeader)(header));
    }
    sendPing(pingId, flag = (0, _frameJs.Flag).SYN) {
        if (flag === (0, _frameJs.Flag).SYN) this.log?.trace("sending ping request pingId=%s", pingId);
        else this.log?.trace("sending ping response pingId=%s", pingId);
        this.sendFrame({
            type: (0, _frameJs.FrameType).Ping,
            flag,
            streamID: 0,
            length: pingId
        });
    }
    sendGoAway(reason = (0, _frameJs.GoAwayCode).NormalTermination) {
        this.log?.("sending GoAway reason=%s", (0, _frameJs.GoAwayCode)[reason]);
        this.localGoAway = reason;
        this.sendFrame({
            type: (0, _frameJs.FrameType).GoAway,
            flag: 0,
            streamID: 0,
            length: reason
        });
    }
}
function isPromise(thing) {
    return thing != null && typeof thing.then === "function";
}

},{"@libp2p/interface":"b14bx","get-iterator":"i5lLf","it-pushable":"hxxEW","uint8arraylist":"1W1Ks","./config.js":"kwQu6","./constants.js":"l3Chh","./decode.js":"7dViU","./encode.js":"g6gLy","./frame.js":"4oU0I","./stream.js":"8Ak5K","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"i5lLf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getIterator", ()=>getIterator);
function getIterator(obj) {
    if (obj != null) {
        if (typeof obj[Symbol.iterator] === "function") return obj[Symbol.iterator]();
        if (typeof obj[Symbol.asyncIterator] === "function") return obj[Symbol.asyncIterator]();
        if (typeof obj.next === "function") return obj; // probably an iterator
    }
    throw new Error("argument is not an iterator or iterable");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kwQu6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultConfig", ()=>defaultConfig);
parcelHelpers.export(exports, "verifyConfig", ()=>verifyConfig);
var _interface = require("@libp2p/interface");
var _constantsJs = require("./constants.js");
const defaultConfig = {
    enableKeepAlive: true,
    keepAliveInterval: 30000,
    maxInboundStreams: 1000,
    maxOutboundStreams: 1000,
    initialStreamWindowSize: (0, _constantsJs.INITIAL_STREAM_WINDOW),
    maxStreamWindowSize: (0, _constantsJs.MAX_STREAM_WINDOW),
    maxMessageSize: 65536
};
function verifyConfig(config) {
    if (config.keepAliveInterval <= 0) throw new (0, _interface.CodeError)("keep-alive interval must be positive", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.maxInboundStreams < 0) throw new (0, _interface.CodeError)("max inbound streams must be larger or equal 0", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.maxOutboundStreams < 0) throw new (0, _interface.CodeError)("max outbound streams must be larger or equal 0", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.initialStreamWindowSize < (0, _constantsJs.INITIAL_STREAM_WINDOW)) throw new (0, _interface.CodeError)("InitialStreamWindowSize must be larger or equal 256 kB", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.maxStreamWindowSize < config.initialStreamWindowSize) throw new (0, _interface.CodeError)("MaxStreamWindowSize must be larger than the InitialStreamWindowSize", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.maxStreamWindowSize > 2 ** 32 - 1) throw new (0, _interface.CodeError)("MaxStreamWindowSize must be less than equal MAX_UINT32", (0, _constantsJs.ERR_INVALID_CONFIG));
    if (config.maxMessageSize < 1024) throw new (0, _interface.CodeError)("MaxMessageSize must be greater than a kilobyte", (0, _constantsJs.ERR_INVALID_CONFIG));
}

},{"@libp2p/interface":"b14bx","./constants.js":"l3Chh","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"l3Chh":[function(require,module,exports) {
// Protocol violation errors
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ERR_INVALID_FRAME", ()=>ERR_INVALID_FRAME);
parcelHelpers.export(exports, "ERR_UNREQUESTED_PING", ()=>ERR_UNREQUESTED_PING);
parcelHelpers.export(exports, "ERR_NOT_MATCHING_PING", ()=>ERR_NOT_MATCHING_PING);
parcelHelpers.export(exports, "ERR_STREAM_ALREADY_EXISTS", ()=>ERR_STREAM_ALREADY_EXISTS);
parcelHelpers.export(exports, "ERR_DECODE_INVALID_VERSION", ()=>ERR_DECODE_INVALID_VERSION);
parcelHelpers.export(exports, "ERR_BOTH_CLIENTS", ()=>ERR_BOTH_CLIENTS);
parcelHelpers.export(exports, "ERR_RECV_WINDOW_EXCEEDED", ()=>ERR_RECV_WINDOW_EXCEEDED);
parcelHelpers.export(exports, "PROTOCOL_ERRORS", ()=>PROTOCOL_ERRORS);
parcelHelpers.export(exports, "ERR_INVALID_CONFIG", ()=>ERR_INVALID_CONFIG);
parcelHelpers.export(exports, "ERR_MUXER_LOCAL_CLOSED", ()=>ERR_MUXER_LOCAL_CLOSED);
parcelHelpers.export(exports, "ERR_MUXER_REMOTE_CLOSED", ()=>ERR_MUXER_REMOTE_CLOSED);
parcelHelpers.export(exports, "ERR_STREAM_RESET", ()=>ERR_STREAM_RESET);
parcelHelpers.export(exports, "ERR_STREAM_ABORT", ()=>ERR_STREAM_ABORT);
parcelHelpers.export(exports, "ERR_MAX_OUTBOUND_STREAMS_EXCEEDED", ()=>ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);
parcelHelpers.export(exports, "ERR_DECODE_IN_PROGRESS", ()=>ERR_DECODE_IN_PROGRESS);
parcelHelpers.export(exports, "INITIAL_STREAM_WINDOW", ()=>INITIAL_STREAM_WINDOW);
parcelHelpers.export(exports, "MAX_STREAM_WINDOW", ()=>MAX_STREAM_WINDOW);
const ERR_INVALID_FRAME = "ERR_INVALID_FRAME";
const ERR_UNREQUESTED_PING = "ERR_UNREQUESTED_PING";
const ERR_NOT_MATCHING_PING = "ERR_NOT_MATCHING_PING";
const ERR_STREAM_ALREADY_EXISTS = "ERR_STREAM_ALREADY_EXISTS";
const ERR_DECODE_INVALID_VERSION = "ERR_DECODE_INVALID_VERSION";
const ERR_BOTH_CLIENTS = "ERR_BOTH_CLIENTS";
const ERR_RECV_WINDOW_EXCEEDED = "ERR_RECV_WINDOW_EXCEEDED";
const PROTOCOL_ERRORS = new Set([
    ERR_INVALID_FRAME,
    ERR_UNREQUESTED_PING,
    ERR_NOT_MATCHING_PING,
    ERR_STREAM_ALREADY_EXISTS,
    ERR_DECODE_INVALID_VERSION,
    ERR_BOTH_CLIENTS,
    ERR_RECV_WINDOW_EXCEEDED
]);
const ERR_INVALID_CONFIG = "ERR_INVALID_CONFIG";
const ERR_MUXER_LOCAL_CLOSED = "ERR_MUXER_LOCAL_CLOSED";
const ERR_MUXER_REMOTE_CLOSED = "ERR_MUXER_REMOTE_CLOSED";
const ERR_STREAM_RESET = "ERR_STREAM_RESET";
const ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
const ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = "ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED";
const ERR_DECODE_IN_PROGRESS = "ERR_DECODE_IN_PROGRESS";
const INITIAL_STREAM_WINDOW = 262144;
const MAX_STREAM_WINDOW = 16777216;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7dViU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Decode a header from the front of a buffer
 *
 * @param data - Assumed to have enough bytes for a header
 */ parcelHelpers.export(exports, "decodeHeader", ()=>decodeHeader);
/**
 * Decodes yamux frames from a source
 */ parcelHelpers.export(exports, "Decoder", ()=>Decoder);
/**
 * Strip the `return` method from a `Source`
 */ parcelHelpers.export(exports, "returnlessSource", ()=>returnlessSource);
var _interface = require("@libp2p/interface");
var _uint8Arraylist = require("uint8arraylist");
var _constantsJs = require("./constants.js");
var _frameJs = require("./frame.js");
// used to bitshift in decoding
// native bitshift can overflow into a negative number, so we bitshift by multiplying by a power of 2
const twoPow24 = 2 ** 24;
function decodeHeader(data) {
    if (data[0] !== (0, _frameJs.YAMUX_VERSION)) throw new (0, _interface.CodeError)("Invalid frame version", (0, _constantsJs.ERR_DECODE_INVALID_VERSION));
    return {
        type: data[1],
        flag: (data[2] << 8) + data[3],
        streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
        length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
    };
}
class Decoder {
    source;
    /** Buffer for in-progress frames */ buffer;
    /** Used to sanity check against decoding while in an inconsistent state */ frameInProgress;
    constructor(source){
        // Normally, when entering a for-await loop with an iterable/async iterable, the only ways to exit the loop are:
        // 1. exhaust the iterable
        // 2. throw an error - slow, undesirable if there's not actually an error
        // 3. break or return - calls the iterable's `return` method, finalizing the iterable, no more iteration possible
        //
        // In this case, we want to enter (and exit) a for-await loop per chunked data frame and continue processing the iterable.
        // To do this, we strip the `return` method from the iterator and can now `break` early and continue iterating.
        // Exiting the main for-await is still possible via 1. and 2.
        this.source = returnlessSource(source);
        this.buffer = new (0, _uint8Arraylist.Uint8ArrayList)();
        this.frameInProgress = false;
    }
    /**
     * Emits frames from the decoder source.
     *
     * Note: If `readData` is emitted, it _must_ be called before the next iteration
     * Otherwise an error is thrown
     */ async *emitFrames() {
        for await (const chunk of this.source){
            this.buffer.append(chunk);
            // Loop to consume as many bytes from the buffer as possible
            // Eg: when a single chunk contains several frames
            while(true){
                const header = this.readHeader();
                if (header === undefined) break;
                const { type, length } = header;
                if (type === (0, _frameJs.FrameType).Data) {
                    // This is a data frame, the frame body must still be read
                    // `readData` must be called before the next iteration here
                    this.frameInProgress = true;
                    yield {
                        header,
                        readData: this.readBytes.bind(this, length)
                    };
                } else yield {
                    header
                };
            }
        }
    }
    readHeader() {
        // Sanity check to ensure a header isn't read when another frame is partially decoded
        // In practice this shouldn't happen
        if (this.frameInProgress) throw new (0, _interface.CodeError)("decoding frame already in progress", (0, _constantsJs.ERR_DECODE_IN_PROGRESS));
        if (this.buffer.length < (0, _frameJs.HEADER_LENGTH)) // not enough data yet
        return;
        const header = decodeHeader(this.buffer.subarray(0, (0, _frameJs.HEADER_LENGTH)));
        this.buffer.consume((0, _frameJs.HEADER_LENGTH));
        return header;
    }
    async readBytes(length) {
        if (this.buffer.length < length) for await (const chunk of this.source){
            this.buffer.append(chunk);
            if (this.buffer.length >= length) break;
        }
        const out = this.buffer.sublist(0, length);
        this.buffer.consume(length);
        // The next frame can now be decoded
        this.frameInProgress = false;
        return out;
    }
}
function returnlessSource(source) {
    if (source[Symbol.iterator] !== undefined) {
        const iterator = source[Symbol.iterator]();
        iterator.return = undefined;
        return {
            [Symbol.iterator] () {
                return iterator;
            }
        };
    } else if (source[Symbol.asyncIterator] !== undefined) {
        const iterator = source[Symbol.asyncIterator]();
        iterator.return = undefined;
        return {
            [Symbol.asyncIterator] () {
                return iterator;
            }
        };
    } else throw new Error("a source must be either an iterable or an async iterable");
}

},{"@libp2p/interface":"b14bx","uint8arraylist":"1W1Ks","./constants.js":"l3Chh","./frame.js":"4oU0I","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4oU0I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FrameType", ()=>FrameType);
parcelHelpers.export(exports, "Flag", ()=>Flag);
parcelHelpers.export(exports, "YAMUX_VERSION", ()=>YAMUX_VERSION);
parcelHelpers.export(exports, "GoAwayCode", ()=>GoAwayCode);
parcelHelpers.export(exports, "HEADER_LENGTH", ()=>HEADER_LENGTH);
parcelHelpers.export(exports, "stringifyHeader", ()=>stringifyHeader);
var FrameType;
(function(FrameType) {
    /** Used to transmit data. May transmit zero length payloads depending on the flags. */ FrameType[FrameType["Data"] = 0] = "Data";
    /** Used to updated the senders receive window size. This is used to implement per-session flow control. */ FrameType[FrameType["WindowUpdate"] = 1] = "WindowUpdate";
    /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */ FrameType[FrameType["Ping"] = 2] = "Ping";
    /** Used to close a session. */ FrameType[FrameType["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag) {
    /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */ Flag[Flag["SYN"] = 1] = "SYN";
    /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */ Flag[Flag["ACK"] = 2] = "ACK";
    /** Performs a half-close of a stream. May be sent with a data message or window update. */ Flag[Flag["FIN"] = 4] = "FIN";
    /** Reset a stream immediately. May be sent with a data or window update message. */ Flag[Flag["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
const flagCodes = Object.values(Flag).filter((x)=>typeof x !== "string");
const YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode) {
    GoAwayCode[GoAwayCode["NormalTermination"] = 0] = "NormalTermination";
    GoAwayCode[GoAwayCode["ProtocolError"] = 1] = "ProtocolError";
    GoAwayCode[GoAwayCode["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
const HEADER_LENGTH = 12;
function stringifyHeader(header) {
    const flags = flagCodes.filter((f)=>(header.flag & f) === f).map((f)=>Flag[f]).join("|");
    return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"g6gLy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeHeader", ()=>encodeHeader);
var _frameJs = require("./frame.js");
function encodeHeader(header) {
    const frame = new Uint8Array((0, _frameJs.HEADER_LENGTH));
    // always assume version 0
    // frameView.setUint8(0, header.version)
    frame[1] = header.type;
    frame[2] = header.flag >>> 8;
    frame[3] = header.flag;
    frame[4] = header.streamID >>> 24;
    frame[5] = header.streamID >>> 16;
    frame[6] = header.streamID >>> 8;
    frame[7] = header.streamID;
    frame[8] = header.length >>> 24;
    frame[9] = header.length >>> 16;
    frame[10] = header.length >>> 8;
    frame[11] = header.length;
    return frame;
}

},{"./frame.js":"4oU0I","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8Ak5K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StreamState", ()=>StreamState);
/** YamuxStream is used to represent a logical stream within a session */ parcelHelpers.export(exports, "YamuxStream", ()=>YamuxStream);
var _interface = require("@libp2p/interface");
var _abstractStream = require("@libp2p/utils/abstract-stream");
var _itForeach = require("it-foreach");
var _itForeachDefault = parcelHelpers.interopDefault(_itForeach);
var _constantsJs = require("./constants.js");
var _frameJs = require("./frame.js");
var StreamState;
(function(StreamState) {
    StreamState[StreamState["Init"] = 0] = "Init";
    StreamState[StreamState["SYNSent"] = 1] = "SYNSent";
    StreamState[StreamState["SYNReceived"] = 2] = "SYNReceived";
    StreamState[StreamState["Established"] = 3] = "Established";
    StreamState[StreamState["Finished"] = 4] = "Finished";
})(StreamState || (StreamState = {}));
class YamuxStream extends (0, _abstractStream.AbstractStream) {
    name;
    state;
    config;
    _id;
    /** The number of available bytes to send */ sendWindowCapacity;
    /** Callback to notify that the sendWindowCapacity has been updated */ sendWindowCapacityUpdate;
    /** The number of bytes available to receive in a full window */ recvWindow;
    /** The number of available bytes to receive */ recvWindowCapacity;
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */ epochStart;
    getRTT;
    sendFrame;
    constructor(init){
        super({
            ...init,
            onEnd: (err)=>{
                this.state = StreamState.Finished;
                init.onEnd?.(err);
            }
        });
        this.config = init.config;
        this._id = parseInt(init.id, 10);
        this.name = init.name;
        this.state = init.state;
        this.sendWindowCapacity = (0, _constantsJs.INITIAL_STREAM_WINDOW);
        this.recvWindow = this.config.initialStreamWindowSize;
        this.recvWindowCapacity = this.recvWindow;
        this.epochStart = Date.now();
        this.getRTT = init.getRTT;
        this.sendFrame = init.sendFrame;
        this.source = (0, _itForeachDefault.default)(this.source, ()=>{
            this.sendWindowUpdate();
        });
    }
    /**
     * Send a message to the remote muxer informing them a new stream is being
     * opened.
     *
     * This is a noop for Yamux because the first window update is sent when
     * .newStream is called on the muxer which opens the stream on the remote.
     */ async sendNewStream() {}
    /**
     * Send a data message to the remote muxer
     */ async sendData(buf, options = {}) {
        buf = buf.sublist();
        // send in chunks, waiting for window updates
        while(buf.byteLength !== 0){
            // wait for the send window to refill
            if (this.sendWindowCapacity === 0) {
                this.log?.trace("wait for send window capacity, status %s", this.status);
                await this.waitForSendWindowCapacity(options);
                // check we didn't close while waiting for send window capacity
                if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
                    this.log?.trace("%s while waiting for send window capacity", this.status);
                    return;
                }
            }
            // send as much as we can
            const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - (0, _frameJs.HEADER_LENGTH), buf.length);
            const flags = this.getSendFlags();
            this.sendFrame({
                type: (0, _frameJs.FrameType).Data,
                flag: flags,
                streamID: this._id,
                length: toSend
            }, buf.sublist(0, toSend));
            this.sendWindowCapacity -= toSend;
            buf.consume(toSend);
        }
    }
    /**
     * Send a reset message to the remote muxer
     */ async sendReset() {
        this.sendFrame({
            type: (0, _frameJs.FrameType).WindowUpdate,
            flag: (0, _frameJs.Flag).RST,
            streamID: this._id,
            length: 0
        });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be sent by this end of the stream
     */ async sendCloseWrite() {
        const flags = this.getSendFlags() | (0, _frameJs.Flag).FIN;
        this.sendFrame({
            type: (0, _frameJs.FrameType).WindowUpdate,
            flag: flags,
            streamID: this._id,
            length: 0
        });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be read by this end of the stream
     */ async sendCloseRead() {}
    /**
     * Wait for the send window to be non-zero
     *
     * Will throw with ERR_STREAM_ABORT if the stream gets aborted
     */ async waitForSendWindowCapacity(options = {}) {
        if (this.sendWindowCapacity > 0) return;
        let resolve;
        let reject;
        const abort = ()=>{
            if (this.status === "open" || this.status === "closing") reject(new (0, _interface.CodeError)("stream aborted", (0, _constantsJs.ERR_STREAM_ABORT)));
            else // the stream was closed already, ignore the failure to send
            resolve();
        };
        options.signal?.addEventListener("abort", abort);
        try {
            await new Promise((_resolve, _reject)=>{
                this.sendWindowCapacityUpdate = ()=>{
                    _resolve();
                };
                reject = _reject;
                resolve = _resolve;
            });
        } finally{
            options.signal?.removeEventListener("abort", abort);
        }
    }
    /**
     * handleWindowUpdate is called when the stream receives a window update frame
     */ handleWindowUpdate(header) {
        this.log?.trace("stream received window update id=%s", this._id);
        this.processFlags(header.flag);
        // increase send window
        const available = this.sendWindowCapacity;
        this.sendWindowCapacity += header.length;
        // if the update increments a 0 availability, notify the stream that sending can resume
        if (available === 0 && header.length > 0) this.sendWindowCapacityUpdate?.();
    }
    /**
     * handleData is called when the stream receives a data frame
     */ async handleData(header, readData) {
        this.log?.trace("stream received data id=%s", this._id);
        this.processFlags(header.flag);
        // check that our recv window is not exceeded
        if (this.recvWindowCapacity < header.length) throw new (0, _interface.CodeError)("receive window exceeded", (0, _constantsJs.ERR_RECV_WINDOW_EXCEEDED), {
            available: this.recvWindowCapacity,
            recv: header.length
        });
        const data = await readData();
        this.recvWindowCapacity -= header.length;
        this.sourcePush(data);
    }
    /**
     * processFlags is used to update the state of the stream based on set flags, if any.
     */ processFlags(flags) {
        if ((flags & (0, _frameJs.Flag).ACK) === (0, _frameJs.Flag).ACK) {
            if (this.state === StreamState.SYNSent) this.state = StreamState.Established;
        }
        if ((flags & (0, _frameJs.Flag).FIN) === (0, _frameJs.Flag).FIN) this.remoteCloseWrite();
        if ((flags & (0, _frameJs.Flag).RST) === (0, _frameJs.Flag).RST) this.reset();
    }
    /**
     * getSendFlags determines any flags that are appropriate
     * based on the current stream state.
     *
     * The state is updated as a side-effect.
     */ getSendFlags() {
        switch(this.state){
            case StreamState.Init:
                this.state = StreamState.SYNSent;
                return (0, _frameJs.Flag).SYN;
            case StreamState.SYNReceived:
                this.state = StreamState.Established;
                return (0, _frameJs.Flag).ACK;
            default:
                return 0;
        }
    }
    /**
     * potentially sends a window update enabling further writes to take place.
     */ sendWindowUpdate() {
        // determine the flags if any
        const flags = this.getSendFlags();
        // If the stream has already been established
        // and we've processed data within the time it takes for 4 round trips
        // then we (up to) double the recvWindow
        const now = Date.now();
        const rtt = this.getRTT();
        if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32
        this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
        if (this.recvWindowCapacity >= this.recvWindow && flags === 0) // a window update isn't needed
        return;
        // update the receive window
        const delta = this.recvWindow - this.recvWindowCapacity;
        this.recvWindowCapacity = this.recvWindow;
        // update the epoch start
        this.epochStart = now;
        // send window update
        this.sendFrame({
            type: (0, _frameJs.FrameType).WindowUpdate,
            flag: flags,
            streamID: this._id,
            length: delta
        });
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/utils/abstract-stream":"haPwJ","it-foreach":"ksAoM","./constants.js":"l3Chh","./frame.js":"4oU0I","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"haPwJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbstractStream", ()=>AbstractStream);
var _interface = require("@libp2p/interface");
var _itPushable = require("it-pushable");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _raceSignal = require("race-signal");
var _uint8Arraylist = require("uint8arraylist");
var _closeSourceJs = require("./close-source.js");
const ERR_STREAM_RESET = "ERR_STREAM_RESET";
const ERR_SINK_INVALID_STATE = "ERR_SINK_INVALID_STATE";
const DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000;
function isPromise(thing) {
    if (thing == null) return false;
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
class AbstractStream {
    id;
    direction;
    timeline;
    protocol;
    metadata;
    source;
    status;
    readStatus;
    writeStatus;
    log;
    sinkController;
    sinkEnd;
    closed;
    endErr;
    streamSource;
    onEnd;
    onCloseRead;
    onCloseWrite;
    onReset;
    onAbort;
    sendCloseWriteTimeout;
    sendingData;
    constructor(init){
        this.sinkController = new AbortController();
        this.sinkEnd = (0, _pDeferDefault.default)();
        this.closed = (0, _pDeferDefault.default)();
        this.log = init.log;
        // stream status
        this.status = "open";
        this.readStatus = "ready";
        this.writeStatus = "ready";
        this.id = init.id;
        this.metadata = init.metadata ?? {};
        this.direction = init.direction;
        this.timeline = {
            open: Date.now()
        };
        this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
        this.onEnd = init.onEnd;
        this.onCloseRead = init?.onCloseRead;
        this.onCloseWrite = init?.onCloseWrite;
        this.onReset = init?.onReset;
        this.onAbort = init?.onAbort;
        this.source = this.streamSource = (0, _itPushable.pushable)({
            onEnd: (err)=>{
                if (err != null) this.log.trace("source ended with error", err);
                else this.log.trace("source ended");
                this.onSourceEnd(err);
            }
        });
        // necessary because the libp2p upgrader wraps the sink function
        this.sink = this.sink.bind(this);
    }
    async sink(source) {
        if (this.writeStatus !== "ready") throw new (0, _interface.CodeError)(`writable end state is "${this.writeStatus}" not "ready"`, ERR_SINK_INVALID_STATE);
        try {
            this.writeStatus = "writing";
            const options = {
                signal: this.sinkController.signal
            };
            if (this.direction === "outbound") {
                const res = this.sendNewStream(options);
                if (isPromise(res)) await res;
            }
            const abortListener = ()=>{
                (0, _closeSourceJs.closeSource)(source, this.log);
            };
            try {
                this.sinkController.signal.addEventListener("abort", abortListener);
                this.log.trace("sink reading from source");
                for await (let data of source){
                    data = data instanceof Uint8Array ? new (0, _uint8Arraylist.Uint8ArrayList)(data) : data;
                    const res = this.sendData(data, options);
                    if (isPromise(res)) {
                        this.sendingData = (0, _pDeferDefault.default)();
                        await res;
                        this.sendingData.resolve();
                        this.sendingData = undefined;
                    }
                }
            } finally{
                this.sinkController.signal.removeEventListener("abort", abortListener);
            }
            this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
            if (this.writeStatus === "writing") {
                this.writeStatus = "closing";
                this.log.trace("send close write to remote");
                await this.sendCloseWrite({
                    signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
                });
                this.writeStatus = "closed";
            }
            this.onSinkEnd();
        } catch (err) {
            this.log.trace("sink ended with error, calling abort with error", err);
            this.abort(err);
            throw err;
        } finally{
            this.log.trace("resolve sink end");
            this.sinkEnd.resolve();
        }
    }
    onSourceEnd(err) {
        if (this.timeline.closeRead != null) return;
        this.timeline.closeRead = Date.now();
        this.readStatus = "closed";
        if (err != null && this.endErr == null) this.endErr = err;
        this.onCloseRead?.();
        if (this.timeline.closeWrite != null) {
            this.log.trace("source and sink ended");
            this.timeline.close = Date.now();
            if (this.status !== "aborted" && this.status !== "reset") this.status = "closed";
            if (this.onEnd != null) this.onEnd(this.endErr);
            this.closed.resolve();
        } else this.log.trace("source ended, waiting for sink to end");
    }
    onSinkEnd(err) {
        if (this.timeline.closeWrite != null) return;
        this.timeline.closeWrite = Date.now();
        this.writeStatus = "closed";
        if (err != null && this.endErr == null) this.endErr = err;
        this.onCloseWrite?.();
        if (this.timeline.closeRead != null) {
            this.log.trace("sink and source ended");
            this.timeline.close = Date.now();
            if (this.status !== "aborted" && this.status !== "reset") this.status = "closed";
            if (this.onEnd != null) this.onEnd(this.endErr);
            this.closed.resolve();
        } else this.log.trace("sink ended, waiting for source to end");
    }
    // Close for both Reading and Writing
    async close(options) {
        this.log.trace("closing gracefully");
        this.status = "closing";
        // wait for read and write ends to close
        await (0, _raceSignal.raceSignal)(Promise.all([
            this.closeWrite(options),
            this.closeRead(options),
            this.closed.promise
        ]), options?.signal);
        this.status = "closed";
        this.log.trace("closed gracefully");
    }
    async closeRead(options = {}) {
        if (this.readStatus === "closing" || this.readStatus === "closed") return;
        this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
        const readStatus = this.readStatus;
        this.readStatus = "closing";
        if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
            this.log.trace("send close read to remote");
            await this.sendCloseRead(options);
        }
        if (readStatus === "ready") {
            this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
            this.streamSource.end();
        }
        this.log.trace("closed readable end of stream");
    }
    async closeWrite(options = {}) {
        if (this.writeStatus === "closing" || this.writeStatus === "closed") return;
        this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
        if (this.writeStatus === "ready") {
            this.log.trace("sink was never sunk, sink an empty array");
            await (0, _raceSignal.raceSignal)(this.sink([]), options.signal);
        }
        if (this.writeStatus === "writing") {
            // try to let sending outgoing data succeed
            if (this.sendingData != null) await (0, _raceSignal.raceSignal)(this.sendingData.promise, options.signal);
            // stop reading from the source passed to `.sink`
            this.log.trace("aborting source passed to .sink");
            this.sinkController.abort();
            await (0, _raceSignal.raceSignal)(this.sinkEnd.promise, options.signal);
        }
        this.writeStatus = "closed";
        this.log.trace("closed writable end of stream");
    }
    /**
     * Close immediately for reading and writing and send a reset message (local
     * error)
     */ abort(err) {
        if (this.status === "closed" || this.status === "aborted" || this.status === "reset") return;
        this.log("abort with error", err);
        // try to send a reset message
        this.log("try to send reset to remote");
        const res = this.sendReset();
        if (isPromise(res)) res.catch((err)=>{
            this.log.error("error sending reset message", err);
        });
        this.status = "aborted";
        this.timeline.abort = Date.now();
        this._closeSinkAndSource(err);
        this.onAbort?.(err);
    }
    /**
     * Receive a reset message - close immediately for reading and writing (remote
     * error)
     */ reset() {
        if (this.status === "closed" || this.status === "aborted" || this.status === "reset") return;
        const err = new (0, _interface.CodeError)("stream reset", ERR_STREAM_RESET);
        this.status = "reset";
        this.timeline.reset = Date.now();
        this._closeSinkAndSource(err);
        this.onReset?.();
    }
    _closeSinkAndSource(err) {
        this._closeSink(err);
        this._closeSource(err);
    }
    _closeSink(err) {
        // if the sink function is running, cause it to end
        if (this.writeStatus === "writing") {
            this.log.trace("end sink source");
            this.sinkController.abort();
        }
        this.onSinkEnd(err);
    }
    _closeSource(err) {
        // if the source is not ending, end it
        if (this.readStatus !== "closing" && this.readStatus !== "closed") {
            this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
            this.readStatus = "closing";
            this.streamSource.end(err);
        }
    }
    /**
     * The remote closed for writing so we should expect to receive no more
     * messages
     */ remoteCloseWrite() {
        if (this.readStatus === "closing" || this.readStatus === "closed") {
            this.log("received remote close write but local source is already closed");
            return;
        }
        this.log.trace("remote close write");
        this._closeSource();
    }
    /**
     * The remote closed for reading so we should not send any more
     * messages
     */ remoteCloseRead() {
        if (this.writeStatus === "closing" || this.writeStatus === "closed") {
            this.log("received remote close read but local sink is already closed");
            return;
        }
        this.log.trace("remote close read");
        this._closeSink();
    }
    /**
     * The underlying muxer has closed, no more messages can be sent or will
     * be received, close immediately to free up resources
     */ destroy() {
        if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
            this.log("received destroy but we are already closed");
            return;
        }
        this.log.trace("stream destroyed");
        this._closeSinkAndSource();
    }
    /**
     * When an extending class reads data from it's implementation-specific source,
     * call this method to allow the stream consumer to read the data.
     */ sourcePush(data) {
        this.streamSource.push(data);
    }
    /**
     * Returns the amount of unread data - can be used to prevent large amounts of
     * data building up when the stream consumer is too slow.
     */ sourceReadableLength() {
        return this.streamSource.readableLength;
    }
}

},{"@libp2p/interface":"b14bx","it-pushable":"hxxEW","p-defer":"cWx93","race-signal":"dHlMT","uint8arraylist":"1W1Ks","./close-source.js":"jHRRF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jHRRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "closeSource", ()=>closeSource);
var _getIterator = require("get-iterator");
var _isPromiseJs = require("./is-promise.js");
function closeSource(source, log) {
    const res = (0, _getIterator.getIterator)(source).return?.();
    if ((0, _isPromiseJs.isPromise)(res)) res.catch((err)=>{
        log.error("could not cause iterator to return", err);
    });
}

},{"get-iterator":"i5lLf","./is-promise.js":"hbsO9","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hbsO9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
function isPromise(thing) {
    if (thing == null) return false;
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ksAoM":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Calls a function for each value in an (async)iterable.
 *
 * The function can be sync or async.
 *
 * Async functions can be awaited on so may slow down processing of the (async)iterable.
 *
 * @example
 *
 * ```javascript
 * import each from 'it-foreach'
 * import drain from 'it-drain'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * // prints 0, 1, 2, 3, 4
 * const arr = drain(
 *   each(values, console.info)
 * )
 * ```
 *
 * Async sources and callbacks must be awaited:
 *
 * ```javascript
 * import each from 'it-foreach'
 * import drain from 'it-drain'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * // prints 0, 1, 2, 3, 4
 * const arr = await drain(
 *   each(values(), console.info)
 * )
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itPeekable = require("it-peekable");
var _itPeekableDefault = parcelHelpers.interopDefault(_itPeekable);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function isPromise(thing) {
    return thing?.then != null;
}
function forEach(source, fn) {
    if (isAsyncIterable(source)) return async function*() {
        for await (const val of source){
            const res = fn(val);
            if (isPromise(res)) await res;
            yield val;
        }
    }();
    // if fn function returns a promise we have to return an async generator
    const peekable = (0, _itPeekableDefault.default)(source);
    const { value, done } = peekable.next();
    if (done === true) return function*() {}();
    const res = fn(value);
    if (typeof res?.then === "function") return async function*() {
        yield value;
        for await (const val of peekable){
            const res = fn(val);
            if (isPromise(res)) await res;
            yield val;
        }
    }();
    const func = fn;
    return function*() {
        yield value;
        for (const val of peekable){
            func(val);
            yield val;
        }
    }();
}
exports.default = forEach;

},{"it-peekable":"2V0IL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hZ6qV":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * The `circuitRelayTransport` allows libp2p to dial and listen on [Circuit Relay](https://docs.libp2p.io/concepts/nat/circuit-relay/)
 * addresses.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { circuitRelayTransport } from '@libp2p/circuit-relay-v2'
 *
 * const node = await createLibp2p({
 *   transports: [
 *     circuitRelayTransport()
 *   ]
 * })
 * ```
 *
 * The `circuitRelayServer` function allows libp2p to function as a [Circuit Relay](https://docs.libp2p.io/concepts/nat/circuit-relay/)
 * server.  This will not work in browsers.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { circuitRelayServer } from '@libp2p/circuit-relay-v2'
 *
 * const node = await createLibp2p({
 *   services: [
 *     circuitRelay: circuitRelayServer()
 *   ]
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "circuitRelayServer", ()=>(0, _indexJs.circuitRelayServer));
parcelHelpers.export(exports, "circuitRelayTransport", ()=>(0, _indexJs1.circuitRelayTransport));
parcelHelpers.export(exports, "RELAY_V2_HOP_CODEC", ()=>(0, _constantsJs.RELAY_V2_HOP_CODEC));
parcelHelpers.export(exports, "RELAY_V2_STOP_CODEC", ()=>(0, _constantsJs.RELAY_V2_STOP_CODEC));
var _indexJs = require("./server/index.js");
var _indexJs1 = require("./transport/index.js");
var _constantsJs = require("./constants.js");

},{"./server/index.js":false,"./transport/index.js":"1LdRf","./constants.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1LdRf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "circuitRelayTransport", ()=>circuitRelayTransport);
var _interface = require("@libp2p/interface");
var _discoveryJs = require("./discovery.js");
var _reservationStoreJs = require("./reservation-store.js");
var _transportJs = require("./transport.js");
function circuitRelayTransport(init = {}) {
    return (components)=>{
        return new (0, _transportJs.CircuitRelayTransport)(components, init);
    };
}

},{"@libp2p/interface":"b14bx","./discovery.js":"7OtEk","./reservation-store.js":"c9O6d","./transport.js":"1H4Sy","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7OtEk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * ReservationManager automatically makes a circuit v2 reservation on any connected
 * peers that support the circuit v2 HOP protocol.
 */ parcelHelpers.export(exports, "RelayDiscovery", ()=>RelayDiscovery);
var _interface = require("@libp2p/interface");
var _constantsJs = require("../constants.js");
var _utilsJs = require("../utils.js");
class RelayDiscovery extends (0, _interface.TypedEventEmitter) {
    peerId;
    peerStore;
    contentRouting;
    registrar;
    started;
    topologyId;
    log;
    constructor(components){
        super();
        this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
        this.started = false;
        this.peerId = components.peerId;
        this.peerStore = components.peerStore;
        this.contentRouting = components.contentRouting;
        this.registrar = components.registrar;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        // register a topology listener for when new peers are encountered
        // that support the hop protocol
        this.topologyId = await this.registrar.register((0, _constantsJs.RELAY_V2_HOP_CODEC), {
            notifyOnTransient: true,
            onConnect: (peerId)=>{
                this.safeDispatchEvent("relay:discover", {
                    detail: peerId
                });
            }
        });
        this.started = true;
    }
    afterStart() {
        this.discover().catch((err)=>{
            this.log.error("error discovering relays", err);
        });
    }
    stop() {
        if (this.topologyId != null) this.registrar.unregister(this.topologyId);
        this.started = false;
    }
    /**
     * Try to listen on available hop relay connections.
     * The following order will happen while we do not have enough relays:
     *
     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected
     * 2. Dial and try to listen on the peers we know that support hop but are not connected
     * 3. Search the network
     */ async discover() {
        this.log("searching peer store for relays");
        const peers = await this.peerStore.all({
            filters: [
                // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
                (peer)=>{
                    return peer.protocols.includes((0, _constantsJs.RELAY_V2_HOP_CODEC));
                }
            ],
            orders: [
                ()=>Math.random() < 0.5 ? 1 : -1
            ]
        });
        for (const peer of peers){
            this.log("found relay peer %p in content peer store", peer.id);
            this.safeDispatchEvent("relay:discover", {
                detail: peer.id
            });
        }
        this.log("found %d relay peers in peer store", peers.length);
        try {
            this.log("searching content routing for relays");
            const cid = await (0, _utilsJs.namespaceToCid)((0, _constantsJs.RELAY_RENDEZVOUS_NS));
            let found = 0;
            for await (const provider of this.contentRouting.findProviders(cid))if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {
                const peerId = provider.id;
                found++;
                await this.peerStore.merge(peerId, {
                    multiaddrs: provider.multiaddrs
                });
                this.log("found relay peer %p in content routing", peerId);
                this.safeDispatchEvent("relay:discover", {
                    detail: peerId
                });
            }
            this.log("found %d relay peers in content routing", found);
        } catch (err) {
            this.log.error("failed when finding relays on the network", err);
        }
    }
}

},{"@libp2p/interface":"b14bx","../constants.js":"7uPiW","../utils.js":"dpUIE","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7uPiW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ADVERTISE_BOOT_DELAY", ()=>ADVERTISE_BOOT_DELAY);
parcelHelpers.export(exports, "ADVERTISE_TTL", ()=>ADVERTISE_TTL);
parcelHelpers.export(exports, "CIRCUIT_PROTO_CODE", ()=>CIRCUIT_PROTO_CODE);
parcelHelpers.export(exports, "RELAY_RENDEZVOUS_NS", ()=>RELAY_RENDEZVOUS_NS);
parcelHelpers.export(exports, "DEFAULT_MAX_RESERVATION_STORE_SIZE", ()=>DEFAULT_MAX_RESERVATION_STORE_SIZE);
parcelHelpers.export(exports, "DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL", ()=>DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL);
parcelHelpers.export(exports, "DEFAULT_MAX_RESERVATION_TTL", ()=>DEFAULT_MAX_RESERVATION_TTL);
parcelHelpers.export(exports, "DEFAULT_RESERVATION_CONCURRENCY", ()=>DEFAULT_RESERVATION_CONCURRENCY);
parcelHelpers.export(exports, "RELAY_SOURCE_TAG", ()=>RELAY_SOURCE_TAG);
parcelHelpers.export(exports, "RELAY_TAG", ()=>RELAY_TAG);
parcelHelpers.export(exports, "DEFAULT_DURATION_LIMIT", ()=>DEFAULT_DURATION_LIMIT);
parcelHelpers.export(exports, "DEFAULT_DATA_LIMIT", ()=>DEFAULT_DATA_LIMIT);
parcelHelpers.export(exports, "RELAY_V2_HOP_CODEC", ()=>RELAY_V2_HOP_CODEC);
parcelHelpers.export(exports, "RELAY_V2_STOP_CODEC", ()=>RELAY_V2_STOP_CODEC);
parcelHelpers.export(exports, "DEFAULT_HOP_TIMEOUT", ()=>DEFAULT_HOP_TIMEOUT);
parcelHelpers.export(exports, "DEFAULT_ADVERT_BOOT_DELAY", ()=>DEFAULT_ADVERT_BOOT_DELAY);
parcelHelpers.export(exports, "MAX_CONNECTIONS", ()=>MAX_CONNECTIONS);
parcelHelpers.export(exports, "ERR_NO_ROUTERS_AVAILABLE", ()=>ERR_NO_ROUTERS_AVAILABLE);
parcelHelpers.export(exports, "ERR_RELAYED_DIAL", ()=>ERR_RELAYED_DIAL);
parcelHelpers.export(exports, "ERR_HOP_REQUEST_FAILED", ()=>ERR_HOP_REQUEST_FAILED);
parcelHelpers.export(exports, "ERR_TRANSFER_LIMIT_EXCEEDED", ()=>ERR_TRANSFER_LIMIT_EXCEEDED);
const second = 1000;
const minute = 60 * second;
const ADVERTISE_BOOT_DELAY = 15 * minute;
const ADVERTISE_TTL = 30 * minute;
const CIRCUIT_PROTO_CODE = 290;
const RELAY_RENDEZVOUS_NS = "/libp2p/relay";
const DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
const DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second;
const DEFAULT_MAX_RESERVATION_TTL = 120 * minute;
const DEFAULT_RESERVATION_CONCURRENCY = 1;
const RELAY_SOURCE_TAG = "circuit-relay-source";
const RELAY_TAG = "circuit-relay-relay";
const DEFAULT_DURATION_LIMIT = 2 * minute;
const DEFAULT_DATA_LIMIT = BigInt(131072);
const RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
const RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
const DEFAULT_HOP_TIMEOUT = 30 * second;
const DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
const MAX_CONNECTIONS = 300;
const ERR_NO_ROUTERS_AVAILABLE = "ERR_NO_ROUTERS_AVAILABLE";
const ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL";
const ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED";
const ERR_TRANSFER_LIMIT_EXCEEDED = "ERR_TRANSFER_LIMIT_EXCEEDED";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dpUIE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createLimitedRelay", ()=>createLimitedRelay);
/**
 * Convert a namespace string into a cid
 */ parcelHelpers.export(exports, "namespaceToCid", ()=>namespaceToCid);
/**
 * returns number of ms between now and expiration time
 */ parcelHelpers.export(exports, "getExpirationMilliseconds", ()=>getExpirationMilliseconds);
var _interface = require("@libp2p/interface");
var _anySignal = require("any-signal");
var _cid = require("multiformats/cid");
var _sha2 = require("multiformats/hashes/sha2");
var _constantsJs = require("./constants.js");
async function* countStreamBytes(source, limit, options) {
    const limitBytes = limit.remaining;
    for await (const buf of source){
        const len = BigInt(buf.byteLength);
        if (limit.remaining - len < 0) {
            // this is a safe downcast since len is guarantee to be in the range for a number
            const remaining = Number(limit.remaining);
            limit.remaining = 0n;
            try {
                if (remaining !== 0) yield buf.subarray(0, remaining);
            } catch (err) {
                options.log.error(err);
            }
            throw new (0, _interface.CodeError)(`data limit of ${limitBytes} bytes exceeded`, (0, _constantsJs.ERR_TRANSFER_LIMIT_EXCEEDED));
        }
        limit.remaining -= len;
        yield buf;
    }
}
function createLimitedRelay(src, dst, abortSignal, limit, options) {
    function abortStreams(err) {
        src.abort(err);
        dst.abort(err);
    }
    const signals = [
        abortSignal
    ];
    if (limit?.duration != null) signals.push(AbortSignal.timeout(limit.duration));
    const signal = (0, _anySignal.anySignal)(signals);
    let srcDstFinished = false;
    let dstSrcFinished = false;
    let dataLimit;
    if (limit?.data != null) dataLimit = {
        remaining: limit.data
    };
    queueMicrotask(()=>{
        const onAbort = ()=>{
            dst.abort(new (0, _interface.CodeError)(`duration limit of ${limit?.duration} ms exceeded`, (0, _constantsJs.ERR_TRANSFER_LIMIT_EXCEEDED)));
        };
        signal.addEventListener("abort", onAbort, {
            once: true
        });
        dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options)).catch((err)=>{
            options.log.error("error while relaying streams src -> dst", err);
            abortStreams(err);
        }).finally(()=>{
            srcDstFinished = true;
            if (dstSrcFinished) {
                signal.removeEventListener("abort", onAbort);
                signal.clear();
            }
        });
    });
    queueMicrotask(()=>{
        const onAbort = ()=>{
            src.abort(new (0, _interface.CodeError)(`duration limit of ${limit?.duration} ms exceeded`, (0, _constantsJs.ERR_TRANSFER_LIMIT_EXCEEDED)));
        };
        signal.addEventListener("abort", onAbort, {
            once: true
        });
        src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options)).catch((err)=>{
            options.log.error("error while relaying streams dst -> src", err);
            abortStreams(err);
        }).finally(()=>{
            dstSrcFinished = true;
            if (srcDstFinished) {
                signal.removeEventListener("abort", onAbort);
                signal.clear();
            }
        });
    });
}
async function namespaceToCid(namespace) {
    const bytes = new TextEncoder().encode(namespace);
    const hash = await (0, _sha2.sha256).digest(bytes);
    return (0, _cid.CID).createV0(hash);
}
function getExpirationMilliseconds(expireTimeSeconds) {
    const expireTimeMillis = expireTimeSeconds * BigInt(1000);
    const currentTime = new Date().getTime();
    // downcast to number to use with setTimeout
    return Number(expireTimeMillis - BigInt(currentTime));
}

},{"@libp2p/interface":"b14bx","any-signal":"j05UB","multiformats/cid":"1oUcK","multiformats/hashes/sha2":"9qYCS","./constants.js":"7uPiW","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"c9O6d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReservationStore", ()=>ReservationStore);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _peerQueue = require("@libp2p/utils/peer-queue");
var _multiaddr = require("@multiformats/multiaddr");
var _itProtobufStream = require("it-protobuf-stream");
var _equals = require("uint8arrays/equals");
var _constantsJs = require("../constants.js");
var _indexJs = require("../pb/index.js");
var _utilsJs = require("../utils.js");
// allow refreshing a relay reservation if it will expire in the next 10 minutes
const REFRESH_WINDOW = 600000;
// try to refresh relay reservations 5 minutes before expiry
const REFRESH_TIMEOUT = 300000;
// minimum duration before which a reservation must not be refreshed
const REFRESH_TIMEOUT_MIN = 30000;
class ReservationStore extends (0, _interface.TypedEventEmitter) {
    peerId;
    connectionManager;
    transportManager;
    peerStore;
    events;
    reserveQueue;
    reservations;
    maxDiscoveredRelays;
    maxReservationQueueLength;
    reservationCompletionTimeout;
    started;
    log;
    constructor(components, init){
        super();
        this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
        this.peerId = components.peerId;
        this.connectionManager = components.connectionManager;
        this.transportManager = components.transportManager;
        this.peerStore = components.peerStore;
        this.events = components.events;
        this.reservations = new (0, _peerCollections.PeerMap)();
        this.maxDiscoveredRelays = init?.discoverRelays ?? 0;
        this.maxReservationQueueLength = init?.maxReservationQueueLength ?? 100;
        this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? 10000;
        this.started = false;
        // ensure we don't listen on multiple relays simultaneously
        this.reserveQueue = new (0, _peerQueue.PeerQueue)({
            concurrency: init?.reservationConcurrency ?? (0, _constantsJs.DEFAULT_RESERVATION_CONCURRENCY),
            metricName: "libp2p_relay_reservation_queue",
            metrics: components.metrics
        });
        // When a peer disconnects, if we had a reservation on that peer
        // remove the reservation and multiaddr and maybe trigger search
        // for new relays
        this.events.addEventListener("peer:disconnect", (evt)=>{
            this.#removeRelay(evt.detail);
        });
    }
    isStarted() {
        return this.started;
    }
    start() {
        this.started = true;
    }
    stop() {
        this.reserveQueue.clear();
        this.reservations.forEach(({ timeout })=>{
            clearTimeout(timeout);
        });
        this.reservations.clear();
        this.started = false;
    }
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed connection
     * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot
     * on the remote peer
     */ async addRelay(peerId, type) {
        if (this.peerId.equals(peerId)) {
            this.log("not trying to use self as relay");
            return;
        }
        if (this.reserveQueue.size > this.maxReservationQueueLength) {
            this.log("not adding relay as the queue is full");
            return;
        }
        if (this.reserveQueue.has(peerId)) {
            this.log("relay peer is already in the reservation queue");
            return;
        }
        this.log("add relay %p", peerId);
        await this.reserveQueue.add(async ()=>{
            try {
                // allow refresh of an existing reservation if it is about to expire
                const existingReservation = this.reservations.get(peerId);
                if (existingReservation != null) {
                    if ((0, _utilsJs.getExpirationMilliseconds)(existingReservation.reservation.expire) > REFRESH_WINDOW) {
                        this.log("already have reservation on relay peer %p and it expires in more than 10 minutes", peerId);
                        return;
                    }
                    clearTimeout(existingReservation.timeout);
                    this.reservations.delete(peerId);
                }
                if (type === "discovered" && [
                    ...this.reservations.values()
                ].reduce((acc, curr)=>{
                    if (curr.type === "discovered") acc++;
                    return acc;
                }, 0) >= this.maxDiscoveredRelays) {
                    this.log("already have enough discovered relays");
                    return;
                }
                const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
                const connection = await this.connectionManager.openConnection(peerId, {
                    signal
                });
                if (connection.remoteAddr.protoNames().includes("p2p-circuit")) {
                    this.log("not creating reservation over relayed connection");
                    return;
                }
                const reservation = await this.#createReservation(connection, {
                    signal
                });
                this.log("created reservation on relay peer %p", peerId);
                const expiration = (0, _utilsJs.getExpirationMilliseconds)(reservation.expire);
                // sets a lower bound on the timeout, and also don't let it go over
                // 2^31 - 1 (setTimeout will only accept signed 32 bit integers)
                const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
                const timeout = setTimeout(()=>{
                    this.addRelay(peerId, type).catch((err)=>{
                        this.log.error("could not refresh reservation to relay %p", peerId, err);
                    });
                }, timeoutDuration);
                // we've managed to create a reservation successfully
                this.reservations.set(peerId, {
                    timeout,
                    reservation,
                    type
                });
                // ensure we don't close the connection to the relay
                await this.peerStore.merge(peerId, {
                    tags: {
                        [(0, _constantsJs.RELAY_TAG)]: {
                            value: 1,
                            ttl: expiration
                        }
                    }
                });
                // listen on multiaddr that only the circuit transport is listening for
                await this.transportManager.listen([
                    (0, _multiaddr.multiaddr)(`/p2p/${peerId.toString()}/p2p-circuit`)
                ]);
            } catch (err) {
                this.log.error("could not reserve slot on %p", peerId, err);
                // cancel the renewal timeout if it's been set
                const reservation = this.reservations.get(peerId);
                if (reservation != null) clearTimeout(reservation.timeout);
                // if listening failed, remove the reservation
                this.reservations.delete(peerId);
            }
        }, {
            peerId
        });
    }
    hasReservation(peerId) {
        return this.reservations.has(peerId);
    }
    getReservation(peerId) {
        return this.reservations.get(peerId)?.reservation;
    }
    async #createReservation(connection, options) {
        options.signal?.throwIfAborted();
        this.log("requesting reservation from %p", connection.remotePeer);
        const stream = await connection.newStream((0, _constantsJs.RELAY_V2_HOP_CODEC), options);
        const pbstr = (0, _itProtobufStream.pbStream)(stream);
        const hopstr = pbstr.pb((0, _indexJs.HopMessage));
        await hopstr.write({
            type: (0, _indexJs.HopMessage).Type.RESERVE
        }, options);
        let response;
        try {
            response = await hopstr.read(options);
        } catch (err) {
            this.log.error("error parsing reserve message response from %p because", connection.remotePeer, err);
            stream.abort(err);
            throw err;
        } finally{
            await stream.close();
        }
        if (response.status === (0, _indexJs.Status).OK && response.reservation != null) {
            // check that the returned relay has the relay address - this can be
            // omitted when requesting a reservation from a go-libp2p relay we
            // already have a reservation on
            let hasRelayAddress = false;
            const relayAddressBytes = connection.remoteAddr.bytes;
            for (const buf of response.reservation.addrs)if ((0, _equals.equals)(relayAddressBytes, buf)) {
                hasRelayAddress = true;
                break;
            }
            if (!hasRelayAddress) response.reservation.addrs.push(relayAddressBytes);
            return response.reservation;
        }
        const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
        this.log.error(errMsg);
        throw new Error(errMsg);
    }
    /**
     * Remove listen relay
     */ #removeRelay(peerId) {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation == null) return;
        this.log("connection to relay %p closed, removing reservation from local store", peerId);
        clearTimeout(existingReservation.timeout);
        this.reservations.delete(peerId);
        this.safeDispatchEvent("relay:removed", {
            detail: peerId
        });
        if (this.reservations.size < this.maxDiscoveredRelays) {
            this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
            this.safeDispatchEvent("relay:not-enough-relays", {});
        }
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","@libp2p/utils/peer-queue":"98WyE","@multiformats/multiaddr":"7Qpz2","it-protobuf-stream":"gV3cl","uint8arrays/equals":"CKVqX","../constants.js":"7uPiW","../pb/index.js":"cdQcJ","../utils.js":"dpUIE","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gV3cl":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive length-prefixed Protobuf encoded
 * messages over streams.
 *
 * @example
 *
 * ```typescript
 * import { pbStream } from 'it-protobuf-stream'
 * import { MessageType } from './src/my-message-type.js'
 *
 * // RequestType and ResponseType have been generate from `.proto` files and have
 * // `.encode` and `.decode` methods for serialization/deserialization
 *
 * const stream = pbStream(duplex)
 *
 * // write a message to the stream
 * stream.write({
 *   foo: 'bar'
 * }, MessageType)
 *
 * // read a message from the stream
 * const res = await stream.read(MessageType)
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pbStream", ()=>pbStream);
var _itLengthPrefixedStream = require("it-length-prefixed-stream");
function pbStream(duplex, opts) {
    const lp = (0, _itLengthPrefixedStream.lpStream)(duplex, opts);
    const W = {
        read: async (proto, options)=>{
            // readLP, decode
            const value = await lp.read(options);
            return proto.decode(value);
        },
        write: async (message, proto, options)=>{
            // encode, writeLP
            await lp.write(proto.encode(message), options);
        },
        writeV: async (messages, proto, options)=>{
            // encode, writeLP
            await lp.writeV(messages.map((message)=>proto.encode(message)), options);
        },
        pb: (proto)=>{
            return {
                read: async (options)=>W.read(proto, options),
                write: async (d, options)=>W.write(d, proto, options),
                writeV: async (d, options)=>W.writeV(d, proto, options),
                unwrap: ()=>W
            };
        },
        unwrap: ()=>{
            return lp.unwrap();
        }
    };
    return W;
}

},{"it-length-prefixed-stream":"abvhz","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cdQcJ":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HopMessage", ()=>HopMessage);
parcelHelpers.export(exports, "StopMessage", ()=>StopMessage);
parcelHelpers.export(exports, "Peer", ()=>Peer);
parcelHelpers.export(exports, "Reservation", ()=>Reservation);
parcelHelpers.export(exports, "Limit", ()=>Limit);
parcelHelpers.export(exports, "Status", ()=>Status);
parcelHelpers.export(exports, "ReservationVoucher", ()=>ReservationVoucher);
var _protonsRuntime = require("protons-runtime");
var HopMessage;
(function(HopMessage) {
    let Type;
    (function(Type) {
        Type["RESERVE"] = "RESERVE";
        Type["CONNECT"] = "CONNECT";
        Type["STATUS"] = "STATUS";
    })(Type = HopMessage.Type || (HopMessage.Type = {}));
    let __TypeValues;
    (function(__TypeValues) {
        __TypeValues[__TypeValues["RESERVE"] = 0] = "RESERVE";
        __TypeValues[__TypeValues["CONNECT"] = 1] = "CONNECT";
        __TypeValues[__TypeValues["STATUS"] = 2] = "STATUS";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type) {
        Type.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__TypeValues);
        };
    })(Type = HopMessage.Type || (HopMessage.Type = {}));
    let _codec;
    HopMessage.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.type != null) {
                w.uint32(8);
                HopMessage.Type.codec().encode(obj.type, w);
            }
            if (obj.peer != null) {
                w.uint32(18);
                Peer.codec().encode(obj.peer, w);
            }
            if (obj.reservation != null) {
                w.uint32(26);
                Reservation.codec().encode(obj.reservation, w);
            }
            if (obj.limit != null) {
                w.uint32(34);
                Limit.codec().encode(obj.limit, w);
            }
            if (obj.status != null) {
                w.uint32(40);
                Status.codec().encode(obj.status, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.type = HopMessage.Type.codec().decode(reader);
                        break;
                    case 2:
                        obj.peer = Peer.codec().decode(reader, reader.uint32());
                        break;
                    case 3:
                        obj.reservation = Reservation.codec().decode(reader, reader.uint32());
                        break;
                    case 4:
                        obj.limit = Limit.codec().decode(reader, reader.uint32());
                        break;
                    case 5:
                        obj.status = Status.codec().decode(reader);
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    HopMessage.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, HopMessage.codec());
    };
    HopMessage.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, HopMessage.codec());
    };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage) {
    let Type;
    (function(Type) {
        Type["CONNECT"] = "CONNECT";
        Type["STATUS"] = "STATUS";
    })(Type = StopMessage.Type || (StopMessage.Type = {}));
    let __TypeValues;
    (function(__TypeValues) {
        __TypeValues[__TypeValues["CONNECT"] = 0] = "CONNECT";
        __TypeValues[__TypeValues["STATUS"] = 1] = "STATUS";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type) {
        Type.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__TypeValues);
        };
    })(Type = StopMessage.Type || (StopMessage.Type = {}));
    let _codec;
    StopMessage.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.type != null) {
                w.uint32(8);
                StopMessage.Type.codec().encode(obj.type, w);
            }
            if (obj.peer != null) {
                w.uint32(18);
                Peer.codec().encode(obj.peer, w);
            }
            if (obj.limit != null) {
                w.uint32(26);
                Limit.codec().encode(obj.limit, w);
            }
            if (obj.status != null) {
                w.uint32(32);
                Status.codec().encode(obj.status, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.type = StopMessage.Type.codec().decode(reader);
                        break;
                    case 2:
                        obj.peer = Peer.codec().decode(reader, reader.uint32());
                        break;
                    case 3:
                        obj.limit = Limit.codec().decode(reader, reader.uint32());
                        break;
                    case 4:
                        obj.status = Status.codec().decode(reader);
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    StopMessage.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, StopMessage.codec());
    };
    StopMessage.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, StopMessage.codec());
    };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer) {
    let _codec;
    Peer.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.id != null && obj.id.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.id);
            }
            if (obj.addrs != null) for (const value of obj.addrs){
                w.uint32(18);
                w.bytes(value);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                id: new Uint8Array(0),
                addrs: []
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.id = reader.bytes();
                        break;
                    case 2:
                        obj.addrs.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Peer.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Peer.codec());
    };
    Peer.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Peer.codec());
    };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation) {
    let _codec;
    Reservation.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.expire != null && obj.expire !== 0n) {
                w.uint32(8);
                w.uint64(obj.expire);
            }
            if (obj.addrs != null) for (const value of obj.addrs){
                w.uint32(18);
                w.bytes(value);
            }
            if (obj.voucher != null) {
                w.uint32(26);
                w.bytes(obj.voucher);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                expire: 0n,
                addrs: []
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.expire = reader.uint64();
                        break;
                    case 2:
                        obj.addrs.push(reader.bytes());
                        break;
                    case 3:
                        obj.voucher = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Reservation.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Reservation.codec());
    };
    Reservation.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Reservation.codec());
    };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit) {
    let _codec;
    Limit.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.duration != null) {
                w.uint32(8);
                w.uint32(obj.duration);
            }
            if (obj.data != null) {
                w.uint32(16);
                w.uint64(obj.data);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.duration = reader.uint32();
                        break;
                    case 2:
                        obj.data = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Limit.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Limit.codec());
    };
    Limit.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Limit.codec());
    };
})(Limit || (Limit = {}));
var Status;
(function(Status) {
    Status["UNUSED"] = "UNUSED";
    Status["OK"] = "OK";
    Status["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
    Status["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
    Status["PERMISSION_DENIED"] = "PERMISSION_DENIED";
    Status["CONNECTION_FAILED"] = "CONNECTION_FAILED";
    Status["NO_RESERVATION"] = "NO_RESERVATION";
    Status["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
    Status["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues) {
    __StatusValues[__StatusValues["UNUSED"] = 0] = "UNUSED";
    __StatusValues[__StatusValues["OK"] = 100] = "OK";
    __StatusValues[__StatusValues["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
    __StatusValues[__StatusValues["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
    __StatusValues[__StatusValues["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
    __StatusValues[__StatusValues["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
    __StatusValues[__StatusValues["NO_RESERVATION"] = 204] = "NO_RESERVATION";
    __StatusValues[__StatusValues["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
    __StatusValues[__StatusValues["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status) {
    Status.codec = ()=>{
        return (0, _protonsRuntime.enumeration)(__StatusValues);
    };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher) {
    let _codec;
    ReservationVoucher.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.relay != null && obj.relay.byteLength > 0) {
                w.uint32(10);
                w.bytes(obj.relay);
            }
            if (obj.peer != null && obj.peer.byteLength > 0) {
                w.uint32(18);
                w.bytes(obj.peer);
            }
            if (obj.expiration != null && obj.expiration !== 0n) {
                w.uint32(24);
                w.uint64(obj.expiration);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                relay: new Uint8Array(0),
                peer: new Uint8Array(0),
                expiration: 0n
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.relay = reader.bytes();
                        break;
                    case 2:
                        obj.peer = reader.bytes();
                        break;
                    case 3:
                        obj.expiration = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    ReservationVoucher.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, ReservationVoucher.codec());
    };
    ReservationVoucher.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, ReservationVoucher.codec());
    };
})(ReservationVoucher || (ReservationVoucher = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1H4Sy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircuitRelayTransport", ()=>CircuitRelayTransport);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _streamToMaConn = require("@libp2p/utils/stream-to-ma-conn");
var _mafmt = require("@multiformats/mafmt");
var _multiaddr = require("@multiformats/multiaddr");
var _itProtobufStream = require("it-protobuf-stream");
var _constantsJs = require("../constants.js");
var _indexJs = require("../pb/index.js");
var _discoveryJs = require("./discovery.js");
var _listenerJs = require("./listener.js");
var _reservationStoreJs = require("./reservation-store.js");
const isValidStop = (request)=>{
    if (request.peer == null) return false;
    try {
        request.peer.addrs.forEach((0, _multiaddr.multiaddr));
    } catch  {
        return false;
    }
    return true;
};
const defaults = {
    maxInboundStopStreams: (0, _constantsJs.MAX_CONNECTIONS),
    maxOutboundStopStreams: (0, _constantsJs.MAX_CONNECTIONS),
    stopTimeout: 30000
};
class CircuitRelayTransport {
    discovery;
    registrar;
    peerStore;
    connectionManager;
    transportManager;
    peerId;
    upgrader;
    addressManager;
    connectionGater;
    reservationStore;
    logger;
    maxInboundStopStreams;
    maxOutboundStopStreams;
    stopTimeout;
    started;
    log;
    constructor(components, init){
        this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
        this.registrar = components.registrar;
        this.peerStore = components.peerStore;
        this.connectionManager = components.connectionManager;
        this.transportManager = components.transportManager;
        this.logger = components.logger;
        this.peerId = components.peerId;
        this.upgrader = components.upgrader;
        this.addressManager = components.addressManager;
        this.connectionGater = components.connectionGater;
        this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
        this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
        this.stopTimeout = init.stopTimeout ?? defaults.stopTimeout;
        if (init.discoverRelays != null && init.discoverRelays > 0) {
            this.discovery = new (0, _discoveryJs.RelayDiscovery)(components);
            this.discovery.addEventListener("relay:discover", (evt)=>{
                this.reservationStore.addRelay(evt.detail, "discovered").catch((err)=>{
                    this.log.error("could not add discovered relay %p", evt.detail, err);
                });
            });
        }
        this.reservationStore = new (0, _reservationStoreJs.ReservationStore)(components, init);
        this.reservationStore.addEventListener("relay:not-enough-relays", ()=>{
            this.discovery?.discover().catch((err)=>{
                this.log.error("could not discover relays", err);
            });
        });
        this.started = false;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        this.reservationStore.start();
        await this.registrar.handle((0, _constantsJs.RELAY_V2_STOP_CODEC), (data)=>{
            this.onStop(data).catch((err)=>{
                this.log.error("error while handling STOP protocol", err);
                data.stream.abort(err);
            });
        }, {
            maxInboundStreams: this.maxInboundStopStreams,
            maxOutboundStreams: this.maxOutboundStopStreams,
            runOnTransientConnection: true
        });
        await this.discovery?.start();
        this.started = true;
    }
    afterStart() {
        this.discovery?.afterStart();
    }
    async stop() {
        this.discovery?.stop();
        this.reservationStore.stop();
        await this.registrar.unhandle((0, _constantsJs.RELAY_V2_STOP_CODEC));
        this.started = false;
    }
    [(0, _interface.transportSymbol)] = true;
    [Symbol.toStringTag] = "libp2p/circuit-relay-v2";
    /**
     * Dial a peer over a relay
     */ async dial(ma, options = {}) {
        if (ma.protoCodes().filter((code)=>code === (0, _constantsJs.CIRCUIT_PROTO_CODE)).length !== 1) {
            const errMsg = "Invalid circuit relay address";
            this.log.error(errMsg, ma);
            throw new (0, _interface.CodeError)(errMsg, (0, _constantsJs.ERR_RELAYED_DIAL));
        }
        // Check the multiaddr to see if it contains a relay and a destination peer
        const addrs = ma.toString().split("/p2p-circuit");
        const relayAddr = (0, _multiaddr.multiaddr)(addrs[0]);
        const destinationAddr = (0, _multiaddr.multiaddr)(addrs[addrs.length - 1]);
        const relayId = relayAddr.getPeerId();
        const destinationId = destinationAddr.getPeerId();
        if (relayId == null || destinationId == null) {
            const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;
            this.log.error(errMsg);
            throw new (0, _interface.CodeError)(errMsg, (0, _constantsJs.ERR_RELAYED_DIAL));
        }
        const relayPeer = (0, _peerId.peerIdFromString)(relayId);
        const destinationPeer = (0, _peerId.peerIdFromString)(destinationId);
        let disconnectOnFailure = false;
        const relayConnections = this.connectionManager.getConnections(relayPeer);
        let relayConnection = relayConnections[0];
        if (relayConnection == null) {
            await this.peerStore.merge(relayPeer, {
                multiaddrs: [
                    relayAddr
                ]
            });
            relayConnection = await this.connectionManager.openConnection(relayPeer, options);
            disconnectOnFailure = true;
        }
        let stream;
        try {
            stream = await relayConnection.newStream((0, _constantsJs.RELAY_V2_HOP_CODEC));
            return await this.connectV2({
                stream,
                connection: relayConnection,
                destinationPeer,
                destinationAddr,
                relayAddr,
                ma,
                disconnectOnFailure
            });
        } catch (err) {
            this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
            if (stream != null) stream.abort(err);
            disconnectOnFailure && await relayConnection.close();
            throw err;
        }
    }
    async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure }) {
        try {
            const pbstr = (0, _itProtobufStream.pbStream)(stream);
            const hopstr = pbstr.pb((0, _indexJs.HopMessage));
            await hopstr.write({
                type: (0, _indexJs.HopMessage).Type.CONNECT,
                peer: {
                    id: destinationPeer.toBytes(),
                    addrs: [
                        (0, _multiaddr.multiaddr)(destinationAddr).bytes
                    ]
                }
            });
            const status = await hopstr.read();
            if (status.status !== (0, _indexJs.Status).OK) throw new (0, _interface.CodeError)(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`, (0, _constantsJs.ERR_HOP_REQUEST_FAILED));
            const maConn = (0, _streamToMaConn.streamToMaConnection)({
                stream: pbstr.unwrap(),
                remoteAddr: ma,
                localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
                logger: this.logger
            });
            this.log("new outbound transient connection %a", maConn.remoteAddr);
            return await this.upgrader.upgradeOutbound(maConn, {
                transient: true
            });
        } catch (err) {
            this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);
            disconnectOnFailure && await connection.close();
            throw err;
        }
    }
    /**
     * Create a listener
     */ createListener(options) {
        return (0, _listenerJs.createListener)({
            connectionManager: this.connectionManager,
            relayStore: this.reservationStore,
            logger: this.logger
        });
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial on
     *
     * @param {Multiaddr[]} multiaddrs
     * @returns {Multiaddr[]}
     */ filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [
            multiaddrs
        ];
        return multiaddrs.filter((ma)=>{
            return _mafmt.Circuit.matches(ma);
        });
    }
    /**
     * An incoming STOP request means a remote peer wants to dial us via a relay
     */ async onStop({ connection, stream }) {
        if (!this.reservationStore.hasReservation(connection.remotePeer)) try {
            this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
            await this.transportManager.listen([
                connection.remoteAddr.encapsulate("/p2p-circuit")
            ]);
        } catch (err) {
            // failed to refresh our hitherto unknown relay reservation but allow the connection attempt anyway
            this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
        }
        const signal = AbortSignal.timeout(this.stopTimeout);
        const pbstr = (0, _itProtobufStream.pbStream)(stream).pb((0, _indexJs.StopMessage));
        const request = await pbstr.read({
            signal
        });
        this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
        if (request?.type === undefined) {
            this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
            await pbstr.write({
                type: (0, _indexJs.StopMessage).Type.STATUS,
                status: (0, _indexJs.Status).MALFORMED_MESSAGE
            }, {
                signal
            });
            await stream.close();
            return;
        }
        // Validate the STOP request has the required input
        if (request.type !== (0, _indexJs.StopMessage).Type.CONNECT) {
            this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
            await pbstr.write({
                type: (0, _indexJs.StopMessage).Type.STATUS,
                status: (0, _indexJs.Status).UNEXPECTED_MESSAGE
            }, {
                signal
            });
            await stream.close();
            return;
        }
        if (!isValidStop(request)) {
            this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
            await pbstr.write({
                type: (0, _indexJs.StopMessage).Type.STATUS,
                status: (0, _indexJs.Status).MALFORMED_MESSAGE
            }, {
                signal
            });
            await stream.close();
            return;
        }
        const remotePeerId = (0, _peerId.peerIdFromBytes)(request.peer.id);
        if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
            this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
            await pbstr.write({
                type: (0, _indexJs.StopMessage).Type.STATUS,
                status: (0, _indexJs.Status).PERMISSION_DENIED
            }, {
                signal
            });
            await stream.close();
            return;
        }
        this.log.trace("sending success response to %p", connection.remotePeer);
        await pbstr.write({
            type: (0, _indexJs.StopMessage).Type.STATUS,
            status: (0, _indexJs.Status).OK
        }, {
            signal
        });
        const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
        const localAddr = this.addressManager.getAddresses()[0];
        const maConn = (0, _streamToMaConn.streamToMaConnection)({
            stream: pbstr.unwrap().unwrap(),
            remoteAddr,
            localAddr,
            logger: this.logger
        });
        this.log("new inbound transient connection %a", maConn.remoteAddr);
        await this.upgrader.upgradeInbound(maConn, {
            transient: true
        });
        this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@libp2p/utils/stream-to-ma-conn":"3waEU","@multiformats/mafmt":"djvEe","@multiformats/multiaddr":"7Qpz2","it-protobuf-stream":"gV3cl","../constants.js":"7uPiW","../pb/index.js":"cdQcJ","./discovery.js":"7OtEk","./listener.js":"gbaqB","./reservation-store.js":"c9O6d","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3waEU":[function(require,module,exports) {
/**
 * Convert a duplex iterable into a MultiaddrConnection.
 * https://github.com/libp2p/interface-transport#multiaddrconnection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "streamToMaConnection", ()=>streamToMaConnection);
function streamToMaConnection(props) {
    const { stream, remoteAddr, logger } = props;
    const log = logger.forComponent("libp2p:stream:converter");
    let closedRead = false;
    let closedWrite = false;
    // piggyback on `stream.close` invocations to close maconn
    const streamClose = stream.close.bind(stream);
    stream.close = async (options)=>{
        await streamClose(options);
        close(true);
    };
    // piggyback on `stream.abort` invocations to close maconn
    const streamAbort = stream.abort.bind(stream);
    stream.abort = (err)=>{
        streamAbort(err);
        close(true);
    };
    // piggyback on `stream.sink` invocations to close maconn
    const streamSink = stream.sink.bind(stream);
    stream.sink = async (source)=>{
        try {
            await streamSink(source);
        } catch (err) {
            // If aborted we can safely ignore
            if (err.type !== "aborted") // If the source errored the socket will already have been destroyed by
            // toIterable.duplex(). If the socket errored it will already be
            // destroyed. There's nothing to do here except log the error & return.
            log.error("%s error in sink", remoteAddr, err);
        } finally{
            closedWrite = true;
            close();
        }
    };
    const maConn = {
        log,
        sink: stream.sink,
        source: async function*() {
            try {
                for await (const list of stream.source)if (list instanceof Uint8Array) yield list;
                else yield* list;
            } finally{
                closedRead = true;
                close();
            }
        }(),
        remoteAddr,
        timeline: {
            open: Date.now(),
            close: undefined
        },
        close: stream.close,
        abort: stream.abort
    };
    function close(force) {
        if (force === true) {
            closedRead = true;
            closedWrite = true;
        }
        if (closedRead && closedWrite && maConn.timeline.close == null) maConn.timeline.close = Date.now();
    }
    return maConn;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gbaqB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createListener", ()=>createListener);
var _interface = require("@libp2p/interface");
var _peerCollections = require("@libp2p/peer-collections");
var _multiaddr = require("@multiformats/multiaddr");
class CircuitRelayTransportListener extends (0, _interface.TypedEventEmitter) {
    connectionManager;
    relayStore;
    listeningAddrs;
    log;
    constructor(components){
        super();
        this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
        this.connectionManager = components.connectionManager;
        this.relayStore = components.relayStore;
        this.listeningAddrs = new (0, _peerCollections.PeerMap)();
        // remove listening addrs when a relay is removed
        this.relayStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    }
    _onRemoveRelayPeer = (evt)=>{
        this.#removeRelayPeer(evt.detail);
    };
    async listen(addr) {
        this.log("listen on %a", addr);
        // remove the circuit part to get the peer id of the relay
        const relayAddr = addr.decapsulate("/p2p-circuit");
        const relayConn = await this.connectionManager.openConnection(relayAddr);
        if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
            this.log("making reservation on peer %p", relayConn.remotePeer);
            // addRelay calls transportManager.listen which calls this listen method
            await this.relayStore.addRelay(relayConn.remotePeer, "configured");
            return;
        }
        const reservation = this.relayStore.getReservation(relayConn.remotePeer);
        if (reservation == null) throw new (0, _interface.CodeError)("Did not have reservation after making reservation", "ERR_NO_RESERVATION");
        if (this.listeningAddrs.has(relayConn.remotePeer)) {
            this.log("already listening on relay %p", relayConn.remotePeer);
            return;
        }
        // add all addresses from the relay reservation
        this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map((buf)=>{
            return (0, _multiaddr.multiaddr)(buf).encapsulate("/p2p-circuit");
        }));
        this.safeDispatchEvent("listening", {});
    }
    getAddrs() {
        return [
            ...this.listeningAddrs.values()
        ].flat();
    }
    async close() {}
    #removeRelayPeer(peerId) {
        const had = this.listeningAddrs.has(peerId);
        this.log("relay peer removed %p - had reservation", peerId, had);
        this.listeningAddrs.delete(peerId);
        if (had) {
            this.log.trace("removing relay event listener for peer %p", peerId);
            this.relayStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
            // Announce listen addresses change
            this.safeDispatchEvent("close", {});
        }
    }
}
function createListener(options) {
    return new CircuitRelayTransportListener(options);
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-collections":"jqBHH","@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ddGSU":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { identify } from '@libp2p/identify'
 *
 * const node = await createLibp2p({
 *   // ...other options
 *   services: {
 *     identify: identify()
 *   }
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicodecs", ()=>multicodecs);
parcelHelpers.export(exports, "identify", ()=>identify);
var _constsJs = require("./consts.js");
var _identifyJs = require("./identify.js");
const multicodecs = {
    IDENTIFY: (0, _constsJs.MULTICODEC_IDENTIFY),
    IDENTIFY_PUSH: (0, _constsJs.MULTICODEC_IDENTIFY_PUSH)
};
function identify(init = {}) {
    return (components)=>new (0, _identifyJs.Identify)(components, init);
}

},{"./consts.js":"7YpdN","./identify.js":"evVNs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7YpdN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PROTOCOL_VERSION", ()=>PROTOCOL_VERSION);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY", ()=>MULTICODEC_IDENTIFY);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY_PUSH", ()=>MULTICODEC_IDENTIFY_PUSH);
parcelHelpers.export(exports, "IDENTIFY_PROTOCOL_VERSION", ()=>IDENTIFY_PROTOCOL_VERSION);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY_PROTOCOL_NAME", ()=>MULTICODEC_IDENTIFY_PROTOCOL_NAME);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME", ()=>MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY_PROTOCOL_VERSION", ()=>MULTICODEC_IDENTIFY_PROTOCOL_VERSION);
parcelHelpers.export(exports, "MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION", ()=>MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION);
const PROTOCOL_VERSION = "ipfs/0.1.0"; // deprecated
const MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0"; // deprecated
const MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0"; // deprecated
const IDENTIFY_PROTOCOL_VERSION = "0.1.0";
const MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"evVNs":[function(require,module,exports) {
/* eslint-disable complexity */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Identify", ()=>Identify);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _peerRecord = require("@libp2p/peer-record");
var _multiaddr = require("@multiformats/multiaddr");
var _multiaddrMatcher = require("@multiformats/multiaddr-matcher");
var _itProtobufStream = require("it-protobuf-stream");
var _fromString = require("uint8arrays/from-string");
var _toString = require("uint8arrays/to-string");
var _wherearewe = require("wherearewe");
var _constsJs = require("./consts.js");
var _messageJs = require("./pb/message.js");
// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52
const MAX_IDENTIFY_MESSAGE_SIZE = 8192;
const defaultValues = {
    protocolPrefix: "ipfs",
    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
    timeout: 60000,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1,
    maxObservedAddresses: 10,
    maxIdentifyMessageSize: 8192,
    runOnConnectionOpen: true,
    runOnTransientConnection: true
};
class Identify {
    identifyProtocolStr;
    identifyPushProtocolStr;
    host;
    started;
    timeout;
    peerId;
    peerStore;
    registrar;
    connectionManager;
    addressManager;
    maxInboundStreams;
    maxOutboundStreams;
    maxPushIncomingStreams;
    maxPushOutgoingStreams;
    maxIdentifyMessageSize;
    maxObservedAddresses;
    events;
    runOnTransientConnection;
    log;
    constructor(components, init = {}){
        this.started = false;
        this.peerId = components.peerId;
        this.peerStore = components.peerStore;
        this.registrar = components.registrar;
        this.addressManager = components.addressManager;
        this.connectionManager = components.connectionManager;
        this.events = components.events;
        this.log = components.logger.forComponent("libp2p:identify");
        this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${0, _constsJs.MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${0, _constsJs.MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
        this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${0, _constsJs.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${0, _constsJs.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
        this.timeout = init.timeout ?? defaultValues.timeout;
        this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
        this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
        this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams;
        this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams;
        this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize;
        this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
        this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;
        // Store self host metadata
        this.host = {
            protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${0, _constsJs.IDENTIFY_PROTOCOL_VERSION}`,
            agentVersion: init.agentVersion ?? `${components.nodeInfo.name}/${components.nodeInfo.version}`
        };
        if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) // When a new connection happens, trigger identify
        components.events.addEventListener("connection:open", (evt)=>{
            const connection = evt.detail;
            this.identify(connection).catch((err)=>{
                this.log.error("error during identify trigged by connection:open", err);
            });
        });
        // When self peer record changes, trigger identify-push
        components.events.addEventListener("self:peer:update", (evt)=>{
            this.push().catch((err)=>{
                this.log.error(err);
            });
        });
        // Append user agent version to default AGENT_VERSION depending on the environment
        if (this.host.agentVersion === `${components.nodeInfo.name}/${components.nodeInfo.version}`) {
            if ((0, _wherearewe.isNode) || (0, _wherearewe.isElectronMain)) this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
            else if ((0, _wherearewe.isBrowser) || (0, _wherearewe.isWebWorker) || (0, _wherearewe.isElectronRenderer) || (0, _wherearewe.isReactNative)) this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
        }
    }
    isStarted() {
        return this.started;
    }
    async start() {
        if (this.started) return;
        await this.peerStore.merge(this.peerId, {
            metadata: {
                AgentVersion: (0, _fromString.fromString)(this.host.agentVersion),
                ProtocolVersion: (0, _fromString.fromString)(this.host.protocolVersion)
            }
        });
        await this.registrar.handle(this.identifyProtocolStr, (data)=>{
            this._handleIdentify(data).catch((err)=>{
                this.log.error(err);
            });
        }, {
            maxInboundStreams: this.maxInboundStreams,
            maxOutboundStreams: this.maxOutboundStreams,
            runOnTransientConnection: this.runOnTransientConnection
        });
        await this.registrar.handle(this.identifyPushProtocolStr, (data)=>{
            this._handlePush(data).catch((err)=>{
                this.log.error(err);
            });
        }, {
            maxInboundStreams: this.maxPushIncomingStreams,
            maxOutboundStreams: this.maxPushOutgoingStreams,
            runOnTransientConnection: this.runOnTransientConnection
        });
        this.started = true;
    }
    async stop() {
        await this.registrar.unhandle(this.identifyProtocolStr);
        await this.registrar.unhandle(this.identifyPushProtocolStr);
        this.started = false;
    }
    /**
     * Send an Identify Push update to the list of connections
     */ async pushToConnections(connections) {
        const listenAddresses = this.addressManager.getAddresses().map((ma)=>ma.decapsulateCode((0, _multiaddr.protocols)("p2p").code));
        const peerRecord = new (0, _peerRecord.PeerRecord)({
            peerId: this.peerId,
            multiaddrs: listenAddresses
        });
        const signedPeerRecord = await (0, _peerRecord.RecordEnvelope).seal(peerRecord, this.peerId);
        const supportedProtocols = this.registrar.getProtocols();
        const peer = await this.peerStore.get(this.peerId);
        const agentVersion = (0, _toString.toString)(peer.metadata.get("AgentVersion") ?? (0, _fromString.fromString)(this.host.agentVersion));
        const protocolVersion = (0, _toString.toString)(peer.metadata.get("ProtocolVersion") ?? (0, _fromString.fromString)(this.host.protocolVersion));
        const pushes = connections.map(async (connection)=>{
            let stream;
            const signal = AbortSignal.timeout(this.timeout);
            (0, _interface.setMaxListeners)(Infinity, signal);
            try {
                stream = await connection.newStream(this.identifyPushProtocolStr, {
                    signal,
                    runOnTransientConnection: this.runOnTransientConnection
                });
                const pb = (0, _itProtobufStream.pbStream)(stream, {
                    maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
                }).pb((0, _messageJs.Identify));
                await pb.write({
                    listenAddrs: listenAddresses.map((ma)=>ma.bytes),
                    signedPeerRecord: signedPeerRecord.marshal(),
                    protocols: supportedProtocols,
                    agentVersion,
                    protocolVersion
                }, {
                    signal
                });
                await stream.close({
                    signal
                });
            } catch (err) {
                // Just log errors
                this.log.error("could not push identify update to peer", err);
                stream?.abort(err);
            }
        });
        await Promise.all(pushes);
    }
    /**
     * Calls `push` on all peer connections
     */ async push() {
        // Do not try to push if we are not running
        if (!this.isStarted()) return;
        const connections = [];
        await Promise.all(this.connectionManager.getConnections().map(async (conn)=>{
            try {
                const peer = await this.peerStore.get(conn.remotePeer);
                if (!peer.protocols.includes(this.identifyPushProtocolStr)) return;
                connections.push(conn);
            } catch (err) {
                if (err.code !== (0, _interface.ERR_NOT_FOUND)) throw err;
            }
        }));
        await this.pushToConnections(connections);
    }
    async _identify(connection, options = {}) {
        let stream;
        if (options.signal == null) {
            const signal = AbortSignal.timeout(this.timeout);
            (0, _interface.setMaxListeners)(Infinity, signal);
            options = {
                ...options,
                signal
            };
        }
        try {
            stream = await connection.newStream(this.identifyProtocolStr, {
                ...options,
                runOnTransientConnection: this.runOnTransientConnection
            });
            const pb = (0, _itProtobufStream.pbStream)(stream, {
                maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
            }).pb((0, _messageJs.Identify));
            const message = await pb.read(options);
            await stream.close(options);
            return message;
        } catch (err) {
            this.log.error("error while reading identify message", err);
            stream?.abort(err);
            throw err;
        }
    }
    async identify(connection, options = {}) {
        const message = await this._identify(connection, options);
        const { publicKey, protocols, observedAddr } = message;
        if (publicKey == null) throw new (0, _interface.CodeError)("public key was missing from identify message", "ERR_MISSING_PUBLIC_KEY");
        const id = await (0, _peerId.peerIdFromKeys)(publicKey);
        if (!connection.remotePeer.equals(id)) throw new (0, _interface.CodeError)("identified peer does not match the expected peer", "ERR_INVALID_PEER");
        if (this.peerId.equals(id)) throw new (0, _interface.CodeError)("identified peer is our own peer id?", "ERR_INVALID_PEER");
        // Get the observedAddr if there is one
        const cleanObservedAddr = getCleanMultiaddr(observedAddr);
        this.log("identify completed for peer %p and protocols %o", id, protocols);
        this.log("our observed address is %a", cleanObservedAddr);
        if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
            this.log("storing our observed address %a", cleanObservedAddr);
            this.addressManager.addObservedAddr(cleanObservedAddr);
        }
        return this.#consumeIdentifyMessage(connection, message);
    }
    /**
     * Sends the `Identify` response with the Signed Peer Record
     * to the requesting peer over the given `connection`
     */ async _handleIdentify(data) {
        const { connection, stream } = data;
        const signal = AbortSignal.timeout(this.timeout);
        (0, _interface.setMaxListeners)(Infinity, signal);
        try {
            const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
            const peerData = await this.peerStore.get(this.peerId);
            const multiaddrs = this.addressManager.getAddresses().map((ma)=>ma.decapsulateCode((0, _multiaddr.protocols)("p2p").code));
            let signedPeerRecord = peerData.peerRecordEnvelope;
            if (multiaddrs.length > 0 && signedPeerRecord == null) {
                const peerRecord = new (0, _peerRecord.PeerRecord)({
                    peerId: this.peerId,
                    multiaddrs
                });
                const envelope = await (0, _peerRecord.RecordEnvelope).seal(peerRecord, this.peerId);
                signedPeerRecord = envelope.marshal().subarray();
            }
            let observedAddr = connection.remoteAddr.bytes;
            if (!(0, _multiaddrMatcher.IP_OR_DOMAIN).matches(connection.remoteAddr)) observedAddr = undefined;
            const pb = (0, _itProtobufStream.pbStream)(stream).pb((0, _messageJs.Identify));
            await pb.write({
                protocolVersion: this.host.protocolVersion,
                agentVersion: this.host.agentVersion,
                publicKey,
                listenAddrs: multiaddrs.map((addr)=>addr.bytes),
                signedPeerRecord,
                observedAddr,
                protocols: peerData.protocols
            }, {
                signal
            });
            await stream.close({
                signal
            });
        } catch (err) {
            this.log.error("could not respond to identify request", err);
            stream.abort(err);
        }
    }
    /**
     * Reads the Identify Push message from the given `connection`
     */ async _handlePush(data) {
        const { connection, stream } = data;
        try {
            if (this.peerId.equals(connection.remotePeer)) throw new Error("received push from ourselves?");
            const options = {
                signal: AbortSignal.timeout(this.timeout)
            };
            const pb = (0, _itProtobufStream.pbStream)(stream, {
                maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
            }).pb((0, _messageJs.Identify));
            const message = await pb.read(options);
            await stream.close(options);
            await this.#consumeIdentifyMessage(connection, message);
        } catch (err) {
            this.log.error("received invalid message", err);
            stream.abort(err);
            return;
        }
        this.log("handled push from %p", connection.remotePeer);
    }
    async #consumeIdentifyMessage(connection, message) {
        this.log("received identify from %p", connection.remotePeer);
        if (message == null) throw new (0, _interface.CodeError)("message was null or undefined", "ERR_INVALID_MESSAGE");
        const peer = {};
        if (message.listenAddrs.length > 0) peer.addresses = message.listenAddrs.map((buf)=>({
                isCertified: false,
                multiaddr: (0, _multiaddr.multiaddr)(buf)
            }));
        if (message.protocols.length > 0) peer.protocols = message.protocols;
        if (message.publicKey != null) {
            peer.publicKey = message.publicKey;
            const peerId = await (0, _peerId.peerIdFromKeys)(message.publicKey);
            if (!peerId.equals(connection.remotePeer)) throw new (0, _interface.CodeError)("public key did not match remote PeerId", "ERR_INVALID_PUBLIC_KEY");
        }
        let output;
        // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer
        if (message.signedPeerRecord != null) {
            this.log("received signedPeerRecord from %p", connection.remotePeer);
            let peerRecordEnvelope = message.signedPeerRecord;
            const envelope = await (0, _peerRecord.RecordEnvelope).openAndCertify(peerRecordEnvelope, (0, _peerRecord.PeerRecord).DOMAIN);
            let peerRecord = (0, _peerRecord.PeerRecord).createFromProtobuf(envelope.payload);
            // Verify peerId
            if (!peerRecord.peerId.equals(envelope.peerId)) throw new (0, _interface.CodeError)("signing key does not match PeerId in the PeerRecord", "ERR_INVALID_SIGNING_KEY");
            // Make sure remote peer is the one sending the record
            if (!connection.remotePeer.equals(peerRecord.peerId)) throw new (0, _interface.CodeError)("signing key does not match remote PeerId", "ERR_INVALID_PEER_RECORD_KEY");
            let existingPeer;
            try {
                existingPeer = await this.peerStore.get(peerRecord.peerId);
            } catch (err) {
                if (err.code !== "ERR_NOT_FOUND") throw err;
            }
            if (existingPeer != null) {
                // don't lose any existing metadata
                peer.metadata = existingPeer.metadata;
                // if we have previously received a signed record for this peer, compare it to the incoming one
                if (existingPeer.peerRecordEnvelope != null) {
                    const storedEnvelope = await (0, _peerRecord.RecordEnvelope).createFromProtobuf(existingPeer.peerRecordEnvelope);
                    const storedRecord = (0, _peerRecord.PeerRecord).createFromProtobuf(storedEnvelope.payload);
                    // ensure seq is greater than, or equal to, the last received
                    if (storedRecord.seqNumber >= peerRecord.seqNumber) {
                        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
                        peerRecord = storedRecord;
                        peerRecordEnvelope = existingPeer.peerRecordEnvelope;
                    }
                }
            }
            // store the signed record for next time
            peer.peerRecordEnvelope = peerRecordEnvelope;
            // override the stored addresses with the signed multiaddrs
            peer.addresses = peerRecord.multiaddrs.map((multiaddr)=>({
                    isCertified: true,
                    multiaddr
                }));
            output = {
                seq: peerRecord.seqNumber,
                addresses: peerRecord.multiaddrs
            };
        } else this.log("%p did not send a signed peer record", connection.remotePeer);
        this.log("patching %p with", connection.remotePeer, peer);
        await this.peerStore.patch(connection.remotePeer, peer);
        if (message.agentVersion != null || message.protocolVersion != null) {
            const metadata = {};
            if (message.agentVersion != null) metadata.AgentVersion = (0, _fromString.fromString)(message.agentVersion);
            if (message.protocolVersion != null) metadata.ProtocolVersion = (0, _fromString.fromString)(message.protocolVersion);
            this.log("merging %p metadata", connection.remotePeer, metadata);
            await this.peerStore.merge(connection.remotePeer, {
                metadata
            });
        }
        const result = {
            peerId: connection.remotePeer,
            protocolVersion: message.protocolVersion,
            agentVersion: message.agentVersion,
            publicKey: message.publicKey,
            listenAddrs: message.listenAddrs.map((buf)=>(0, _multiaddr.multiaddr)(buf)),
            observedAddr: message.observedAddr == null ? undefined : (0, _multiaddr.multiaddr)(message.observedAddr),
            protocols: message.protocols,
            signedPeerRecord: output,
            connection
        };
        this.events.safeDispatchEvent("peer:identify", {
            detail: result
        });
        return result;
    }
}
/**
 * Takes the `addr` and converts it to a Multiaddr if possible
 */ function getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) try {
        return (0, _multiaddr.multiaddr)(addr);
    } catch  {}
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@libp2p/peer-record":"2OBzm","@multiformats/multiaddr":"7Qpz2","@multiformats/multiaddr-matcher":"8GlCq","it-protobuf-stream":"gV3cl","uint8arrays/from-string":"3YvUV","uint8arrays/to-string":"63irA","wherearewe":"5237b","./consts.js":"7YpdN","./pb/message.js":"iBqcZ","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5237b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEnvWithDom", ()=>isEnvWithDom);
parcelHelpers.export(exports, "isElectron", ()=>isElectron);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isElectronMain", ()=>isElectronMain);
parcelHelpers.export(exports, "isElectronRenderer", ()=>isElectronRenderer);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isWebWorker", ()=>isWebWorker);
parcelHelpers.export(exports, "isTest", ()=>isTest);
parcelHelpers.export(exports, "isReactNative", ()=>isReactNative);
var _isElectron = require("is-electron");
var _isElectronDefault = parcelHelpers.interopDefault(_isElectron);
const isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
const isElectron = (0, _isElectronDefault.default)();
const isBrowser = isEnvWithDom && !isElectron;
const isElectronMain = isElectron && !isEnvWithDom;
const isElectronRenderer = isElectron && isEnvWithDom;
const isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
const isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
const isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (()=>"_")() + "ENV"] === "test";
const isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

},{"is-electron":"bGmBa","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bGmBa":[function(require,module,exports) {
// https://github.com/electron/electron/issues/2288
var process = require("3c332542338522a4");
function isElectron() {
    // Renderer process
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") return true;
    // Main process
    if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) return true;
    // Detect the user agent when the `nodeIntegration` option is set to false
    if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) return true;
    return false;
}
module.exports = isElectron;

},{"3c332542338522a4":"d5jf4"}],"iBqcZ":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Identify", ()=>Identify);
var _protonsRuntime = require("protons-runtime");
var Identify;
(function(Identify) {
    let _codec;
    Identify.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.protocolVersion != null) {
                w.uint32(42);
                w.string(obj.protocolVersion);
            }
            if (obj.agentVersion != null) {
                w.uint32(50);
                w.string(obj.agentVersion);
            }
            if (obj.publicKey != null) {
                w.uint32(10);
                w.bytes(obj.publicKey);
            }
            if (obj.listenAddrs != null) for (const value of obj.listenAddrs){
                w.uint32(18);
                w.bytes(value);
            }
            if (obj.observedAddr != null) {
                w.uint32(34);
                w.bytes(obj.observedAddr);
            }
            if (obj.protocols != null) for (const value of obj.protocols){
                w.uint32(26);
                w.string(value);
            }
            if (obj.signedPeerRecord != null) {
                w.uint32(66);
                w.bytes(obj.signedPeerRecord);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {
                listenAddrs: [],
                protocols: []
            };
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 5:
                        obj.protocolVersion = reader.string();
                        break;
                    case 6:
                        obj.agentVersion = reader.string();
                        break;
                    case 1:
                        obj.publicKey = reader.bytes();
                        break;
                    case 2:
                        obj.listenAddrs.push(reader.bytes());
                        break;
                    case 4:
                        obj.observedAddr = reader.bytes();
                        break;
                    case 3:
                        obj.protocols.push(reader.string());
                        break;
                    case 8:
                        obj.signedPeerRecord = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Identify.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Identify.codec());
    };
    Identify.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Identify.codec());
    };
})(Identify || (Identify = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ifKPW":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * The service exported by this module attempts to configure NAT hole punching
 * via UPnP.
 *
 * This will make your node publicly accessible from the internet.
 *
 * For this to work there are some prerequisites:
 *
 * 1. Your router must have UPnP support enabled
 * 2. Your libp2p node must be listening on a non-loopback IPv4 address
 * 3. You must not be [double-NATed](https://kb.netgear.com/30186/What-is-double-NAT-and-why-is-it-bad) by your ISP
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { tcp } from '@libp2p/tcp'
 * import { uPnPNAT } from '@libp2p/upnp-nat'
 *
 * const node = await createLibp2p({
 *   addresses: [
 *     listen: [
 *       '/ip4/0.0.0.0/tcp/0'
 *     ]
 *   ],
 *   transports: [
 *     tcp()
 *   ],
 *   services: {
 *     upnpNAT: uPnPNAT()
 *   }
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uPnPNAT", ()=>uPnPNAT);
var _upnpNatJs = require("./upnp-nat.js");
function uPnPNAT(init = {}) {
    return (components)=>{
        return new (0, _upnpNatJs.UPnPNAT)(components, init);
    };
}

},{"./upnp-nat.js":"7RkwC","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7RkwC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UPnPNAT", ()=>UPnPNAT);
var _natPortMapper = require("@achingbrain/nat-port-mapper");
var _interface = require("@libp2p/interface");
var _isLoopback = require("@libp2p/utils/multiaddr/is-loopback");
var _privateIp = require("@libp2p/utils/private-ip");
var _multiaddr = require("@multiformats/multiaddr");
var _wherearewe = require("wherearewe");
const DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
class UPnPNAT {
    components;
    externalAddress;
    localAddress;
    description;
    ttl;
    keepAlive;
    gateway;
    started;
    client;
    log;
    constructor(components, init){
        this.components = components;
        this.log = components.logger.forComponent("libp2p:upnp-nat");
        this.started = false;
        this.externalAddress = init.externalAddress;
        this.localAddress = init.localAddress;
        this.description = init.description ?? `${components.nodeInfo.name}@${components.nodeInfo.version} ${this.components.peerId.toString()}`;
        this.ttl = init.ttl ?? DEFAULT_TTL;
        this.keepAlive = init.keepAlive ?? true;
        this.gateway = init.gateway;
        if (this.ttl < DEFAULT_TTL) throw new (0, _interface.CodeError)(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`, (0, _interface.ERR_INVALID_PARAMETERS));
    }
    isStarted() {
        return this.started;
    }
    start() {
    // #TODO: is there a way to remove this? Seems like a hack
    }
    /**
     * Attempt to use uPnP to configure port mapping using the current gateway.
     *
     * Run after start to ensure the transport manager has all addresses configured.
     */ afterStart() {
        if ((0, _wherearewe.isBrowser) || this.started) return;
        this.started = true;
        // done async to not slow down startup
        this.mapIpAddresses().catch((err)=>{
            // hole punching errors are non-fatal
            this.log.error(err);
        });
    }
    async mapIpAddresses() {
        const addrs = this.components.transportManager.getAddrs();
        for (const addr of addrs){
            // try to open uPnP ports for each thin waist address
            const { family, host, port, transport } = addr.toOptions();
            if (!addr.isThinWaistAddress() || transport !== "tcp") continue;
            if ((0, _isLoopback.isLoopback)(addr)) continue;
            if (family !== 4) continue;
            const client = this._getClient();
            const publicIp = this.externalAddress ?? await client.externalIp();
            const isPrivate = (0, _privateIp.isPrivateIp)(publicIp);
            if (isPrivate === true) throw new (0, _interface.CodeError)(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`, "ERR_DOUBLE_NAT");
            if (isPrivate == null) throw new (0, _interface.CodeError)(`${publicIp} is not an IP address`, (0, _interface.ERR_INVALID_PARAMETERS));
            const publicPort = highPort();
            this.log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
            await client.map({
                publicPort,
                localPort: port,
                localAddress: this.localAddress,
                protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
            });
            this.components.addressManager.addObservedAddr((0, _multiaddr.fromNodeAddress)({
                family: 4,
                address: publicIp,
                port: publicPort
            }, transport));
        }
    }
    _getClient() {
        if (this.client != null) return this.client;
        this.client = (0, _natPortMapper.upnpNat)({
            description: this.description,
            ttl: this.ttl,
            keepAlive: this.keepAlive,
            gateway: this.gateway
        });
        return this.client;
    }
    /**
     * Stops the NAT manager
     */ async stop() {
        if ((0, _wherearewe.isBrowser) || this.client == null) return;
        try {
            await this.client.close();
            this.client = undefined;
        } catch (err) {
            this.log.error(err);
        }
    }
}

},{"@achingbrain/nat-port-mapper":"2Y9Cw","@libp2p/interface":"b14bx","@libp2p/utils/multiaddr/is-loopback":"7GUaQ","@libp2p/utils/private-ip":"3LaSy","@multiformats/multiaddr":"7Qpz2","wherearewe":"5237b","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2Y9Cw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NatAPI", ()=>NatAPI);
parcelHelpers.export(exports, "upnpNat", ()=>upnpNat);
parcelHelpers.export(exports, "pmpNat", ()=>pmpNat);
var _os = require("os");
var _osDefault = parcelHelpers.interopDefault(_os);
var _logger = require("@libp2p/logger");
var _defaultGateway = require("default-gateway");
var _indexJs = require("./discovery/index.js");
var _indexJs1 = require("./pmp/index.js");
var _indexJs2 = require("./upnp/index.js");
const log = (0, _logger.logger)("nat-port-mapper");
class NatAPI {
    openPorts;
    ttl;
    description;
    gateway;
    keepAlive;
    keepAliveInterval;
    destroyed;
    client;
    updateIntervals;
    constructor(opts = {}, client){
        // TTL is 2 hours (min 20 min)
        this.ttl = opts.ttl != null ? Math.max(opts.ttl, 1200) : 7200;
        this.description = opts.description ?? "NatAPI";
        this.gateway = opts.gateway;
        this.keepAlive = opts.keepAlive ?? true;
        this.client = client;
        this.updateIntervals = new Map();
        // Refresh the mapping 10 minutes before the end of its lifetime
        this.keepAliveInterval = (this.ttl - 600) * 1000;
        this.destroyed = false;
        this.openPorts = [];
    }
    async map(options) {
        if (this.destroyed) throw new Error("client is destroyed");
        // Validate input
        const opts = this.validateInput(options);
        // UDP or TCP
        await this.client.map(opts);
        this.openPorts.push(opts);
        if (this.keepAlive) this.updateIntervals.set(`${opts.publicPort}:${opts.localPort}-${opts.protocol}`, setInterval(()=>{
            this.client.map(opts).catch((err)=>{
                log("Error refreshing port mapping %d:%d for protocol %s mapped on router", opts.publicPort, opts.localPort, opts.protocol, err);
            });
        }, this.keepAliveInterval));
        log("Port %d:%d for protocol %s mapped on router", opts.publicPort, opts.localPort, opts.protocol);
    }
    async unmap(options) {
        if (this.destroyed) throw new Error("client is destroyed");
        // Validate input
        const opts = this.validateInput(options);
        // UDP or TCP
        await this.client.unmap(opts);
        this.openPorts = this.openPorts.filter((openPort)=>{
            return openPort.publicPort !== opts.publicPort && openPort.protocol !== opts.protocol;
        });
        const key = `${opts.publicPort}:${opts.localPort}-${opts.protocol}`;
        clearInterval(this.updateIntervals.get(key));
        this.updateIntervals.delete(key);
        log("Port %d:%d for protocol %s unmapped on router", opts.publicPort, opts.localPort, opts.protocol);
    }
    async close() {
        if (this.destroyed) throw new Error("client already closed");
        if (this.client != null) {
            log("Close UPnP client");
            await this.client.close();
        }
        // stop all updates
        for (const interval of this.updateIntervals.values())clearInterval(interval);
        this.updateIntervals.clear();
        // Unmap all ports
        await Promise.all(this.openPorts.map(async (opts)=>this.unmap(opts)));
    }
    validateInput(options = {}) {
        if (options.localPort == null) throw new Error("invalid parameters");
        const output = {
            localPort: options.localPort,
            localAddress: options.localAddress ?? findLocalAddress(),
            publicPort: options.publicPort ?? options.localPort,
            protocol: options.protocol ?? "TCP",
            description: options.description ?? this.description,
            ttl: options.ttl ?? this.ttl,
            gateway: options.gateway ?? this.gateway
        };
        return output;
    }
    async externalIp() {
        return this.client.externalIp();
    }
}
function findLocalAddress() {
    const interfaces = (0, _osDefault.default).networkInterfaces();
    for (const infos of Object.values(interfaces)){
        if (infos == null) continue;
        for (const info of infos){
            if (info.internal) continue;
            if (info.family === "IPv6") continue;
            log("Found local address", info.address);
            return info.address;
        }
    }
    throw new Error("Please pass a `localAddress` to the map function");
}
function upnpNat(options = {}) {
    const client = (0, _indexJs2.UPNPClient).createClient((0, _indexJs.discoverGateway)(options));
    return new NatAPI(options, client);
}
async function pmpNat(options = {}) {
    const client = (0, _indexJs1.PMPClient).createClient((0, _indexJs.discoverGateway)({
        ...options,
        gateway: (await (0, _defaultGateway.gateway4async)()).gateway
    }));
    return new NatAPI(options, client);
}

},{"os":"6yyXu","@libp2p/logger":"aeh5U","default-gateway":"jnmdB","./discovery/index.js":"1DyUm","./pmp/index.js":"CnTks","./upnp/index.js":"fLVvs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6yyXu":[function(require,module,exports) {
exports.endianness = function() {
    return "LE";
};
exports.hostname = function() {
    if (typeof location !== "undefined") return location.hostname;
    else return "";
};
exports.loadavg = function() {
    return [];
};
exports.uptime = function() {
    return 0;
};
exports.freemem = function() {
    return Number.MAX_VALUE;
};
exports.totalmem = function() {
    return Number.MAX_VALUE;
};
exports.cpus = function() {
    return [];
};
exports.type = function() {
    return "Browser";
};
exports.release = function() {
    if (typeof navigator !== "undefined") return navigator.appVersion;
    return "";
};
exports.networkInterfaces = exports.getNetworkInterfaces = function() {
    return {};
};
exports.arch = function() {
    return "javascript";
};
exports.platform = function() {
    return "browser";
};
exports.tmpdir = exports.tmpDir = function() {
    return "/tmp";
};
exports.EOL = "\n";
exports.homedir = function() {
    return "/";
};

},{}],"jnmdB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gateway4async", ()=>gateway4async);
parcelHelpers.export(exports, "gateway6async", ()=>gateway6async);
parcelHelpers.export(exports, "gateway4sync", ()=>gateway4sync);
parcelHelpers.export(exports, "gateway6sync", ()=>gateway6sync);
var _nodeNet = require("net");
var _execa = require("execa");
var _nodeOs = require("os");
const plat = (0, _nodeOs.platform)();
const dests = new Set([
    "default",
    "0.0.0.0",
    "0.0.0.0/0",
    "::",
    "::/0"
]);
let promise, sync;
if (plat === "linux") {
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const results = /default( via .+?)?( dev .+?)( |$)/.exec(line) || [];
            const gateway = (results[1] || "").substring(5);
            const iface = (results[2] || "").substring(5);
            if (gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
            else if (iface && !gateway) {
                const interfaces = (0, _nodeOs.networkInterfaces)();
                const addresses = interfaces[iface];
                for (const addr of addresses || []){
                    if (Number(family.substring(3)) === family && (0, _nodeNet.isIP)(addr.address)) return {
                        gateway: addr.address,
                        version: family,
                        int: iface ?? null
                    };
                }
            }
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("ip", [
            `-${family}`,
            "r"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("ip", [
            `-${family}`,
            "r"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "darwin") {
    // The IPv4 gateway is in column 3 in Darwin 19 (macOS 10.15 Catalina) and higher,
    // previously it was in column 5
    const v4IfaceColumn = parseInt((0, _nodeOs.release)()) >= 19 ? 3 : 5;
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const results = line.split(/ +/) || [];
            const target = results[0];
            const gateway = results[1];
            const iface = results[family === 4 ? v4IfaceColumn : 3];
            if (dests.has(target) && gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "win32") {
    const gwArgs = "path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table".split(" ");
    const ifArgs = (index)=>`path Win32_NetworkAdapter where Index=${index} get NetConnectionID,MACAddress /format:table`.split(" ");
    const spawnOpts = {
        windowsHide: true
    };
    // Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric
    //
    // DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric
    // {"1.2.3.4", "2001:db8::1"}   {0, 256}           12     25
    // {"2.3.4.5"}                  {25}               12     55
    function parseGwTable(gwTable, family) {
        let [bestGw, bestMetric, bestId] = [
            null,
            null,
            null
        ];
        for (let line of (gwTable || "").trim().split(/\r?\n/).splice(1)){
            line = line.trim();
            const [_, gwArr, gwCostsArr, id, ipMetric] = /({.+?}) +({.+?}) +([0-9]+) +([0-9]+)/.exec(line) || [];
            if (!gwArr) continue;
            const gateways = (gwArr.match(/"(.+?)"/g) || []).map((match)=>match.substring(1, match.length - 1));
            const gatewayCosts = gwCostsArr.match(/[0-9]+/g) || [];
            for (const [index, gateway] of Object.entries(gateways)){
                if (!gateway || (0, _nodeNet.isIP)(gateway) !== family) continue;
                const metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);
                if (!bestGw || metric < bestMetric) [bestGw, bestMetric, bestId] = [
                    gateway,
                    metric,
                    id
                ];
            }
        }
        if (bestGw) return [
            bestGw,
            bestId
        ];
    }
    function parseIfTable(ifTable) {
        const line = (ifTable || "").trim().split("\n")[1];
        let [mac, name] = line.trim().split(/\s+/);
        mac = mac.toLowerCase();
        // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues
        // https://github.com/silverwind/default-gateway/issues/14
        for (const [osname, addrs] of Object.entries((0, _nodeOs.networkInterfaces)()))for (const addr of addrs){
            if (addr?.mac?.toLowerCase() === mac) return osname;
        }
        return name;
    }
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("wmic", gwArgs, spawnOpts);
        const [gateway, id] = parseGwTable(stdout, family) || [];
        if (!gateway) throw new Error("Unable to determine default gateway");
        let name;
        if (id) {
            const { stdout } = await (0, _execa.execa)("wmic", ifArgs(id), spawnOpts);
            name = parseIfTable(stdout);
        }
        return {
            gateway,
            version: family,
            int: name ?? null
        };
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("wmic", gwArgs, spawnOpts);
        const [gateway, id] = parseGwTable(stdout, family) || [];
        if (!gateway) throw new Error("Unable to determine default gateway");
        let name;
        if (id) {
            const { stdout } = (0, _execa.execaSync)("wmic", ifArgs(id), spawnOpts);
            name = parseIfTable(stdout);
        }
        return {
            gateway,
            version: family,
            int: name ?? null
        };
    };
} else if (plat === "android") {
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const [_, gateway, iface] = /default via (.+?) dev (.+?)( |$)/.exec(line) || [];
            if (gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("ip", [
            `-${family}`,
            "r"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("ip", [
            `-${family}`,
            "r"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "freebsd") {
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const [target, gateway, _, iface] = line.split(/ +/) || [];
            if (dests.has(target) && gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "aix" && (0, _nodeOs.type)() === "OS400") {
    const db2util = "/QOpenSys/pkgs/bin/db2util";
    const sql = "select NEXT_HOP, LOCAL_BINDING_INTERFACE from QSYS2.NETSTAT_ROUTE_INFO where ROUTE_TYPE='DFTROUTE' and NEXT_HOP!='*DIRECT' and CONNECTION_TYPE=?";
    const parse = (stdout, family)=>{
        try {
            const resultObj = JSON.parse(stdout);
            const gateway = resultObj.records[0].NEXT_HOP;
            const iface = resultObj.records[0].LOCAL_BINDING_INTERFACE;
            return {
                gateway,
                version: family,
                iface
            };
        } catch  {}
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)(db2util, [
            sql,
            "-p",
            `IPV${family}`,
            "-o",
            "json"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)(db2util, [
            sql,
            "-p",
            `IPV${family}`,
            "-o",
            "json"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "openbsd") {
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const results = line.split(/ +/) || [];
            const target = results[0];
            const gateway = results[1];
            const iface = results[7];
            if (dests.has(target) && gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
} else if (plat === "sunos" || plat === "aix" && (0, _nodeOs.type)() !== "OS400") {
    const parse = (stdout, family)=>{
        for (const line of (stdout || "").trim().split("\n")){
            const results = line.split(/ +/) || [];
            const target = results[0];
            const gateway = results[1];
            const iface = results[5];
            if (dests.has(target) && gateway && (0, _nodeNet.isIP)(gateway)) return {
                gateway,
                version: family,
                int: iface ?? null
            };
        }
        throw new Error("Unable to determine default gateway");
    };
    promise = async (family)=>{
        const { stdout } = await (0, _execa.execa)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
    sync = (family)=>{
        const { stdout } = (0, _execa.execaSync)("netstat", [
            "-rn",
            "-f",
            family === 4 ? "inet" : "inet6"
        ]);
        return parse(stdout, family);
    };
} else {
    promise = (_)=>{
        throw new Error("Unsupported Platform");
    };
    sync = (_)=>{
        throw new Error("Unsupported Platform");
    };
}
const gateway4async = ()=>promise(4);
const gateway6async = ()=>promise(6);
const gateway4sync = ()=>sync(4);
const gateway6sync = ()=>sync(6);
exports.default = {
    gateway4async,
    gateway6async,
    gateway4sync,
    gateway6sync
};

},{"node:net":"bXKEI","execa":"3lRjJ","node:os":"6yyXu","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bXKEI":[function(require,module,exports) {
"use strict";

},{}],"3lRjJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "execa", ()=>execa);
parcelHelpers.export(exports, "execaSync", ()=>execaSync);
parcelHelpers.export(exports, "$", ()=>$);
parcelHelpers.export(exports, "execaCommand", ()=>execaCommand);
parcelHelpers.export(exports, "execaCommandSync", ()=>execaCommandSync);
parcelHelpers.export(exports, "execaNode", ()=>execaNode);
var _nodeBuffer = require("buffer");
var _nodePath = require("path");
var _nodePathDefault = parcelHelpers.interopDefault(_nodePath);
var _nodeChildProcess = require("child_process");
var _nodeChildProcessDefault = parcelHelpers.interopDefault(_nodeChildProcess);
var _nodeProcess = require("process");
var _nodeProcessDefault = parcelHelpers.interopDefault(_nodeProcess);
var _crossSpawn = require("cross-spawn");
var _crossSpawnDefault = parcelHelpers.interopDefault(_crossSpawn);
var _stripFinalNewline = require("strip-final-newline");
var _stripFinalNewlineDefault = parcelHelpers.interopDefault(_stripFinalNewline);
var _npmRunPath = require("npm-run-path");
var _onetime = require("onetime");
var _onetimeDefault = parcelHelpers.interopDefault(_onetime);
var _errorJs = require("./lib/error.js");
var _stdioJs = require("./lib/stdio.js");
var _killJs = require("./lib/kill.js");
var _pipeJs = require("./lib/pipe.js");
var _streamJs = require("./lib/stream.js");
var _promiseJs = require("./lib/promise.js");
var _commandJs = require("./lib/command.js");
var _verboseJs = require("./lib/verbose.js");
const DEFAULT_MAX_BUFFER = 100000000;
const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath })=>{
    const env = extendEnv ? {
        ...(0, _nodeProcessDefault.default).env,
        ...envOption
    } : envOption;
    if (preferLocal) return (0, _npmRunPath.npmRunPathEnv)({
        env,
        cwd: localDir,
        execPath
    });
    return env;
};
const handleArguments = (file, args, options = {})=>{
    const parsed = (0, _crossSpawnDefault.default)._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || (0, _nodeProcessDefault.default).cwd(),
        execPath: (0, _nodeProcessDefault.default).execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        verbose: (0, _verboseJs.verboseDefault),
        ...options
    };
    options.env = getEnv(options);
    options.stdio = (0, _stdioJs.normalizeStdio)(options);
    if ((0, _nodeProcessDefault.default).platform === "win32" && (0, _nodePathDefault.default).basename(file, ".exe") === "cmd") // #116
    args.unshift("/q");
    return {
        file,
        args,
        options,
        parsed
    };
};
const handleOutput = (options, value, error)=>{
    if (typeof value !== "string" && !(0, _nodeBuffer.Buffer).isBuffer(value)) // When `execaSync()` errors, we normalize it to '' to mimic `execa()`
    return error === undefined ? undefined : "";
    if (options.stripFinalNewline) return (0, _stripFinalNewlineDefault.default)(value);
    return value;
};
function execa(file, args, options) {
    const parsed = handleArguments(file, args, options);
    const command = (0, _commandJs.joinCommand)(file, args);
    const escapedCommand = (0, _commandJs.getEscapedCommand)(file, args);
    (0, _verboseJs.logCommand)(escapedCommand, parsed.options);
    (0, _killJs.validateTimeout)(parsed.options);
    let spawned;
    try {
        spawned = (0, _nodeChildProcessDefault.default).spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
        // Ensure the returned error is always both a promise and a child process
        const dummySpawned = new (0, _nodeChildProcessDefault.default).ChildProcess();
        const errorPromise = Promise.reject((0, _errorJs.makeError)({
            error,
            stdout: "",
            stderr: "",
            all: "",
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        }));
        (0, _promiseJs.mergePromise)(dummySpawned, errorPromise);
        return dummySpawned;
    }
    const spawnedPromise = (0, _promiseJs.getSpawnedPromise)(spawned);
    const timedPromise = (0, _killJs.setupTimeout)(spawned, parsed.options, spawnedPromise);
    const processDone = (0, _killJs.setExitHandler)(spawned, parsed.options, timedPromise);
    const context = {
        isCanceled: false
    };
    spawned.kill = (0, _killJs.spawnedKill).bind(null, spawned.kill.bind(spawned));
    spawned.cancel = (0, _killJs.spawnedCancel).bind(null, spawned, context);
    const handlePromise = async ()=>{
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await (0, _streamJs.getSpawnedResult)(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
            const returnedError = (0, _errorJs.makeError)({
                error,
                exitCode,
                signal,
                stdout,
                stderr,
                all,
                command,
                escapedCommand,
                parsed,
                timedOut,
                isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
                killed: spawned.killed
            });
            if (!parsed.options.reject) return returnedError;
            throw returnedError;
        }
        return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    };
    const handlePromiseOnce = (0, _onetimeDefault.default)(handlePromise);
    (0, _streamJs.handleInput)(spawned, parsed.options);
    spawned.all = (0, _streamJs.makeAllStream)(spawned, parsed.options);
    (0, _pipeJs.addPipeMethods)(spawned);
    (0, _promiseJs.mergePromise)(spawned, handlePromiseOnce);
    return spawned;
}
function execaSync(file, args, options) {
    const parsed = handleArguments(file, args, options);
    const command = (0, _commandJs.joinCommand)(file, args);
    const escapedCommand = (0, _commandJs.getEscapedCommand)(file, args);
    (0, _verboseJs.logCommand)(escapedCommand, parsed.options);
    const input = (0, _streamJs.handleInputSync)(parsed.options);
    let result;
    try {
        result = (0, _nodeChildProcessDefault.default).spawnSync(parsed.file, parsed.args, {
            ...parsed.options,
            input
        });
    } catch (error) {
        throw (0, _errorJs.makeError)({
            error,
            stdout: "",
            stderr: "",
            all: "",
            command,
            escapedCommand,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
        const error = (0, _errorJs.makeError)({
            stdout,
            stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command,
            escapedCommand,
            parsed,
            timedOut: result.error && result.error.code === "ETIMEDOUT",
            isCanceled: false,
            killed: result.signal !== null
        });
        if (!parsed.options.reject) return error;
        throw error;
    }
    return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
    };
}
const normalizeScriptStdin = ({ input, inputFile, stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
        stdin: "inherit"
    } : {};
const normalizeScriptOptions = (options = {})=>({
        preferLocal: true,
        ...normalizeScriptStdin(options),
        ...options
    });
function create$(options) {
    function $(templatesOrOptions, ...expressions) {
        if (!Array.isArray(templatesOrOptions)) return create$({
            ...options,
            ...templatesOrOptions
        });
        const [file, ...args] = (0, _commandJs.parseTemplates)(templatesOrOptions, expressions);
        return execa(file, args, normalizeScriptOptions(options));
    }
    $.sync = (templates, ...expressions)=>{
        if (!Array.isArray(templates)) throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
        const [file, ...args] = (0, _commandJs.parseTemplates)(templates, expressions);
        return execaSync(file, args, normalizeScriptOptions(options));
    };
    return $;
}
const $ = create$();
function execaCommand(command, options) {
    const [file, ...args] = (0, _commandJs.parseCommand)(command);
    return execa(file, args, options);
}
function execaCommandSync(command, options) {
    const [file, ...args] = (0, _commandJs.parseCommand)(command);
    return execaSync(file, args, options);
}
function execaNode(scriptPath, args, options = {}) {
    if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
    }
    const stdio = (0, _stdioJs.normalizeStdioNode)(options);
    const defaultExecArgv = (0, _nodeProcessDefault.default).execArgv.filter((arg)=>!arg.startsWith("--inspect"));
    const { nodePath = (0, _nodeProcessDefault.default).execPath, nodeOptions = defaultExecArgv } = options;
    return execa(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
    ], {
        ...options,
        stdin: undefined,
        stdout: undefined,
        stderr: undefined,
        stdio,
        shell: false
    });
}

},{"node:buffer":"fCgem","node:path":"loE3o","node:child_process":"bXKEI","node:process":"d5jf4","cross-spawn":"7QweW","strip-final-newline":"7aEh8","npm-run-path":"cGL1T","onetime":"kXATo","./lib/error.js":"laSjc","./lib/stdio.js":"16xp4","./lib/kill.js":"fmvRP","./lib/pipe.js":"9okfB","./lib/stream.js":"23os0","./lib/promise.js":"hRdCh","./lib/command.js":"eoK9g","./lib/verbose.js":"gdbvL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"loE3o":[function(require,module,exports) {
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("c0743715070b1b8a");
"use strict";
function assertPath(path) {
    if (typeof path !== "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += "/..";
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return "/" + resolvedPath;
            else return "/";
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return ".";
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += "/" + arg;
            }
        }
        if (joined === undefined) return ".";
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return "";
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return "";
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return _format("/", pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
posix.posix = posix;
module.exports = posix;

},{"c0743715070b1b8a":"d5jf4"}],"7QweW":[function(require,module,exports) {
"use strict";
const cp = require("31ad5c79ab61c096");
const parse = require("a5986a7059085e40");
const enoent = require("73537512670a0bf7");
function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
}
function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);
    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
}
module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;
module.exports._parse = parse;
module.exports._enoent = enoent;

},{"31ad5c79ab61c096":"bXKEI","a5986a7059085e40":"k2SE7","73537512670a0bf7":"fuRZi"}],"k2SE7":[function(require,module,exports) {
var process = require("c0bc8ffd12945a61");
"use strict";
const path = require("59fad3d4cdae670a");
const resolveCommand = require("4e091bdeed3b50f4");
const escape = require("b1ce2cfceb7828ab");
const readShebang = require("c8a7dc662fcd132c");
const isWin = process.platform === "win32";
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
    }
    return parsed.file;
}
function parseNonShell(parsed) {
    if (!isWin) return parsed;
    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);
    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);
    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);
        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [
            parsed.command
        ].concat(parsed.args).join(" ");
        parsed.args = [
            "/d",
            "/s",
            "/c",
            `"${shellCommand}"`
        ];
        parsed.command = "cmd.exe";
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }
    return parsed;
}
function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }
    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original
    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args
        }
    };
    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}
module.exports = parse;

},{"c0bc8ffd12945a61":"d5jf4","59fad3d4cdae670a":"loE3o","4e091bdeed3b50f4":"8Ii1n","b1ce2cfceb7828ab":"igWRg","c8a7dc662fcd132c":"gVCM9"}],"8Ii1n":[function(require,module,exports) {
var process = require("20dcc3bd2d524439");
"use strict";
const path = require("74ae99eafea58388");
const which = require("8c59959915a1f9fb");
const getPathKey = require("185517ce26521ce8");
function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) try {
        process.chdir(parsed.options.cwd);
    } catch (err) {
    /* Empty */ }
    let resolved;
    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({
                env
            })],
            pathExt: withoutPathExt ? path.delimiter : undefined
        });
    } catch (e) {
    /* Empty */ } finally{
        if (shouldSwitchCwd) process.chdir(cwd);
    }
    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    return resolved;
}
function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
module.exports = resolveCommand;

},{"20dcc3bd2d524439":"d5jf4","74ae99eafea58388":"loE3o","8c59959915a1f9fb":"jFNQV","185517ce26521ce8":"jTNI7"}],"jFNQV":[function(require,module,exports) {
var process = require("b2add3a889792897");
const isWindows = process.platform === "win32" || false || false;
const path = require("ec51d11ae3349c");
const COLON = isWindows ? ";" : ":";
const isexe = require("6465f743566232fa");
const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: "ENOENT"
    });
const getPathInfo = (cmd, opt)=>{
    const colon = opt.colon || COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ""
    ] : [
        // windows always checks the cwd first
        ...isWindows ? [
            process.cwd()
        ] : [],
        ...(opt.path || undefined || /* istanbul ignore next: very unusual */ "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || undefined || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [
        ""
    ];
    if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
    }
    return {
        pathEnv,
        pathExt,
        pathExtExe
    };
};
const which = (cmd, opt, cb)=>{
    if (typeof opt === "function") {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i)=>new Promise((resolve, reject)=>{
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
            if (ii === pathExt.length) return resolve(step(i + 1));
            const ext = pathExt[ii];
            isexe(p + ext, {
                pathExt: pathExtExe
            }, (er, is)=>{
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
};
const whichSync = (cmd, opt)=>{
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for(let i = 0; i < pathEnv.length; i++){
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(let j = 0; j < pathExt.length; j++){
            const cur = p + pathExt[j];
            try {
                const is = isexe.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
};
module.exports = which;
which.sync = whichSync;

},{"b2add3a889792897":"d5jf4","ec51d11ae3349c":"loE3o","6465f743566232fa":"7a2U7"}],"7a2U7":[function(require,module,exports) {
var process = require("d84b4066126664c3");
var global = arguments[3];
var fs = require("8151d50fc29c100b");
var core;
if (process.platform === "win32" || global.TESTING_WINDOWS) core = require("5cf66a438869cea4");
else core = require("80f029e97e561d5c");
module.exports = isexe;
isexe.sync = sync;
function isexe(path, options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== "function") throw new TypeError("callback not provided");
        return new Promise(function(resolve, reject) {
            isexe(path, options || {}, function(er, is) {
                if (er) reject(er);
                else resolve(is);
            });
        });
    }
    core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") return false;
        else throw er;
    }
}

},{"d84b4066126664c3":"d5jf4","8151d50fc29c100b":"bXKEI","5cf66a438869cea4":"6lL1q","80f029e97e561d5c":"lrxKV"}],"6lL1q":[function(require,module,exports) {
module.exports = isexe;
isexe.sync = sync;
var fs = require("adce791ee53d6b02");
function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : undefined;
    if (!pathext) return true;
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) return true;
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) return true;
    }
    return false;
}
function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) return false;
    return checkPathExt(path, options);
}
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
}

},{"adce791ee53d6b02":"bXKEI"}],"lrxKV":[function(require,module,exports) {
var process = require("91a1ad95fb6d6891");
module.exports = isexe;
isexe.sync = sync;
var fs = require("e6d05a04a31a6055");
function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
    });
}
function sync(path, options) {
    return checkStat(fs.statSync(path), options);
}
function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
}
function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}

},{"91a1ad95fb6d6891":"d5jf4","e6d05a04a31a6055":"bXKEI"}],"jTNI7":[function(require,module,exports) {
var process = require("b3f1dd2bb3d44520");
"use strict";
const pathKey = (options = {})=>{
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") return "PATH";
    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
};
module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports.default = pathKey;

},{"b3f1dd2bb3d44520":"d5jf4"}],"igWRg":[function(require,module,exports) {
"use strict";
// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;
    // Algorithm below is based on https://qntm.org/cmd
    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, "$1$1");
    // All other backslashes occur literally
    // Quote the whole thing:
    arg = `"${arg}"`;
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, "^$1");
    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
}
module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;

},{}],"gVCM9":[function(require,module,exports) {
var Buffer = require("4ee5854d82eac988").Buffer;
"use strict";
const fs = require("363618b11edcbcdd");
const shebangCommand = require("7d4bbaad1b18bc3e");
function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) {}
    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}
module.exports = readShebang;

},{"4ee5854d82eac988":"fCgem","363618b11edcbcdd":"bXKEI","7d4bbaad1b18bc3e":"9CV1y"}],"9CV1y":[function(require,module,exports) {
"use strict";
const shebangRegex = require("dc6039739d2827c0");
module.exports = (string = "")=>{
    const match = string.match(shebangRegex);
    if (!match) return null;
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") return argument;
    return argument ? `${binary} ${argument}` : binary;
};

},{"dc6039739d2827c0":"21pAH"}],"21pAH":[function(require,module,exports) {
"use strict";
module.exports = /^#!(.*)/;

},{}],"fuRZi":[function(require,module,exports) {
var process = require("76153c4ae5ab1eb0");
"use strict";
const isWin = process.platform === "win32";
function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
    });
}
function hookChildProcess(cp, parsed) {
    if (!isWin) return;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === "exit") {
            const err = verifyENOENT(arg1, parsed, "spawn");
            if (err) return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}
function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawn");
    return null;
}
function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, "spawnSync");
    return null;
}
module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
};

},{"76153c4ae5ab1eb0":"d5jf4"}],"7aEh8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>stripFinalNewline);
function stripFinalNewline(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) input = input.slice(0, -1);
    if (input[input.length - 1] === CR) input = input.slice(0, -1);
    return input;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cGL1T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "npmRunPath", ()=>npmRunPath);
parcelHelpers.export(exports, "npmRunPathEnv", ()=>npmRunPathEnv);
var _nodeProcess = require("process");
var _nodeProcessDefault = parcelHelpers.interopDefault(_nodeProcess);
var _nodePath = require("path");
var _nodePathDefault = parcelHelpers.interopDefault(_nodePath);
var _nodeUrl = require("url");
var _pathKey = require("path-key");
var _pathKeyDefault = parcelHelpers.interopDefault(_pathKey);
const npmRunPath = ({ cwd = (0, _nodeProcessDefault.default).cwd(), path: pathOption = (0, _nodeProcessDefault.default).env[(0, _pathKeyDefault.default)()], preferLocal = true, execPath = (0, _nodeProcessDefault.default).execPath, addExecPath = true } = {})=>{
    const cwdString = cwd instanceof URL ? (0, _nodeUrl.fileURLToPath)(cwd) : cwd;
    const cwdPath = (0, _nodePathDefault.default).resolve(cwdString);
    const result = [];
    if (preferLocal) applyPreferLocal(result, cwdPath);
    if (addExecPath) applyExecPath(result, execPath, cwdPath);
    return [
        ...result,
        pathOption
    ].join((0, _nodePathDefault.default).delimiter);
};
const applyPreferLocal = (result, cwdPath)=>{
    let previous;
    while(previous !== cwdPath){
        result.push((0, _nodePathDefault.default).join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = (0, _nodePathDefault.default).resolve(cwdPath, "..");
    }
};
// Ensure the running `node` binary is used
const applyExecPath = (result, execPath, cwdPath)=>{
    const execPathString = execPath instanceof URL ? (0, _nodeUrl.fileURLToPath)(execPath) : execPath;
    result.push((0, _nodePathDefault.default).resolve(cwdPath, execPathString, ".."));
};
const npmRunPathEnv = ({ env = (0, _nodeProcessDefault.default).env, ...options } = {})=>{
    env = {
        ...env
    };
    const pathName = (0, _pathKeyDefault.default)({
        env
    });
    options.path = env[pathName];
    env[pathName] = npmRunPath(options);
    return env;
};

},{"node:process":"d5jf4","node:path":"loE3o","node:url":"7qjc7","path-key":"034jg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7qjc7":[function(require,module,exports) {
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ "use strict";
var punycode = require("6aa635927f16f681");
function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */ var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */ delims = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    "\n",
    "	"
], // RFC 2396: characters not allowed for various reasons.
unwise = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
].concat(delims), // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = [
    "'"
].concat(unwise), /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */ nonHostChars = [
    "%",
    "/",
    "?",
    ";",
    "#"
].concat(autoEscape), hostEndingChars = [
    "/",
    "?",
    "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    javascript: true,
    "javascript:": true
}, // protocols that never have a hostname.
hostlessProtocol = {
    javascript: true,
    "javascript:": true
}, // protocols that always contain a // bit.
slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
}, querystring = require("6724c84b9b69726b");
function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && typeof url === "object" && url instanceof Url) return url;
    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (typeof url !== "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */ var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */ rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) this.query = querystring.parse(this.search.substr(1));
                else this.query = this.search.substr(1);
            } else if (parseQueryString) {
                this.search = "";
                this.query = {};
            }
            return this;
        }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }
    /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */ if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */ /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */ // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for(var i = 0; i < hostEndingChars.length; i++){
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */ var auth, atSign;
        if (hostEnd === -1) // atSign can be anywhere.
        atSign = rest.lastIndexOf("@");
        else /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */ atSign = rest.lastIndexOf("@", hostEnd);
        /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */ if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }
        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for(var i = 0; i < nonHostChars.length; i++){
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        // pull out port.
        this.parseHost();
        /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */ this.hostname = this.hostname || "";
        /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */ var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for(var i = 0, l = hostparts.length; i < l; i++){
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                    var newpart = "";
                    for(var j = 0, k = part.length; j < k; j++)if (part.charCodeAt(j) > 127) /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */ newpart += "x";
                    else newpart += part[j];
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) rest = "/" + notHost.join(".") + rest;
                        this.hostname = validParts.join(".");
                        break;
                    }
                }
            }
        }
        if (this.hostname.length > hostnameMaxLen) this.hostname = "";
        else // hostnames are always lower case.
        this.hostname = this.hostname.toLowerCase();
        if (!ipv6Hostname) /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */ this.hostname = punycode.toASCII(this.hostname);
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */ if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") rest = "/" + rest;
        }
    }
    /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */ if (!unsafeProtocol[lowerProto]) /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */ for(var i = 0, l = autoEscape.length; i < l; i++){
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1) continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) esc = escape(ae);
        rest = rest.split(ae).join(esc);
    }
    // chop off from the tail first.
    var hash = rest.indexOf("#");
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) this.query = querystring.parse(this.query);
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = "";
        this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) this.pathname = "/";
    // to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
    }
    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
    /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */ if (typeof obj === "string") obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
}
Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) host = auth + this.host;
    else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) host += ":" + this.port;
    }
    if (this.query && typeof this.query === "object" && Object.keys(this.query).length) query = querystring.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: false
    });
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") protocol += ":";
    /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */ if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
    } else if (!host) host = "";
    if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
    if (search && search.charAt(0) !== "?") search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
    if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }
    var result = new Url();
    var tkeys = Object.keys(this);
    for(var tk = 0; tk < tkeys.length; tk++){
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }
    /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */ result.hash = relative.hash;
    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === "") {
        result.href = result.format();
        return result;
    }
    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for(var rk = 0; rk < rkeys.length; rk++){
            var rkey = rkeys[rk];
            if (rkey !== "protocol") result[rkey] = relative[rkey];
        }
        // urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.pathname = "/";
            result.path = result.pathname;
        }
        result.href = result.format();
        return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
        /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */ if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for(var v = 0; v < keys.length; v++){
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while(relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else result.pathname = relative.pathname;
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */ if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
    // fall through to the dot-handling below.
    } else if (relPath.length) {
        /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */ if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (relative.search != null) {
        /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */ if (psychotic) {
            result.host = srcPath.shift();
            result.hostname = result.host;
            /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */ var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.hostname = authInHost.shift();
                result.host = result.hostname;
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        // to support http.request
        if (result.pathname !== null || result.search !== null) result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        result.href = result.format();
        return result;
    }
    if (!srcPath.length) {
        /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */ result.pathname = null;
        // to support http.request
        if (result.search) result.path = "/" + result.search;
        else result.path = null;
        result.href = result.format();
        return result;
    }
    /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */ var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */ var up = 0;
    for(var i = srcPath.length; i >= 0; i--){
        last = srcPath[i];
        if (last === ".") srcPath.splice(i, 1);
        else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) for(; up--; up)srcPath.unshift("..");
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) srcPath.unshift("");
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") srcPath.push("");
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    // put the host back
    if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */ var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
        }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) srcPath.unshift("");
    if (srcPath.length > 0) result.pathname = srcPath.join("/");
    else {
        result.pathname = null;
        result.path = null;
    }
    // to support request.http
    if (result.pathname !== null || result.search !== null) result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};
Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ":") this.port = port.substr(1);
        host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
};
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

},{"6aa635927f16f681":"4SwIZ","6724c84b9b69726b":"kW4GH"}],"4SwIZ":[function(require,module,exports) {
var global = arguments[3];
(function(root) {
    /** Detect free variables */ var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) root = freeGlobal;
    /**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */ var punycode, /** Highest positive signed 32-bit float value */ maxInt = 2147483647, /** Bootstring parameters */ base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", /** Regular expressions */ regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, /** Error messages */ errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
    }, /** Convenience shortcuts */ baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, /** Temporary variable */ key;
    /*--------------------------------------------------------------------------*/ /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */ function error(type) {
        throw new RangeError(errors[type]);
    }
    /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */ function map(array, fn) {
        var length = array.length;
        var result = [];
        while(length--)result[length] = fn(array[length]);
        return result;
    }
    /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */ function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + "@";
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
    }
    /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */ function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while(counter < length){
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else output.push(value);
        }
        return output;
    }
    /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */ function ucs2encode(array) {
        return map(array, function(value) {
            var output = "";
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join("");
    }
    /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */ function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) return codePoint - 22;
        if (codePoint - 65 < 26) return codePoint - 65;
        if (codePoint - 97 < 26) return codePoint - 97;
        return base;
    }
    /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */ function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */ function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */ function decode(input) {
        // Don't use UCS-2
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, /** Cached calculation results */ baseMinusT;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) basic = 0;
        for(j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) error("not-basic");
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(index = basic > 0 ? basic + 1 : 0; index < inputLength;){
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for(oldi = i, w = 1, k = base;; k += base){
                if (index >= inputLength) error("invalid-input");
                digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) error("overflow");
                i += digit * w;
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) break;
                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) error("overflow");
                w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) error("overflow");
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);
        }
        return ucs2encode(output);
    }
    /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */ function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], /** `inputLength` will hold the number of code points in `input`. */ inputLength, /** Cached calculation results */ handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;
        // Handle the basic code points
        for(j = 0; j < inputLength; ++j){
            currentValue = input[j];
            if (currentValue < 0x80) output.push(stringFromCharCode(currentValue));
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) output.push(delimiter);
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for(m = maxInt, j = 0; j < inputLength; ++j){
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) m = currentValue;
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error("overflow");
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for(j = 0; j < inputLength; ++j){
                currentValue = input[j];
                if (currentValue < n && ++delta > maxInt) error("overflow");
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for(q = delta, k = base;; k += base){
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) break;
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join("");
    }
    /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */ function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    }
    /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */ function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
    }
    /*--------------------------------------------------------------------------*/ /** Define the public API */ punycode = {
        /**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */ "version": "1.4.1",
        /**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */ "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
    };
    /** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) define("punycode", function() {
        return punycode;
    });
    else if (freeExports && freeModule) {
        if (module.exports == freeExports) // in Node.js, io.js, or RingoJS v0.8.0+
        freeModule.exports = punycode;
        else // in Narwhal or RingoJS v0.7.0-
        for(key in punycode)punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    } else // in Rhino or a web browser
    root.punycode = punycode;
})(this);

},{}],"kW4GH":[function(require,module,exports) {
"use strict";
var stringify = require("a472ccaa2f2351e9");
var parse = require("7ffa4249597bf32b");
var formats = require("454df9476704f887");
module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"a472ccaa2f2351e9":"aJuQi","7ffa4249597bf32b":"fSZqi","454df9476704f887":"d7Ogf"}],"aJuQi":[function(require,module,exports) {
"use strict";
var getSideChannel = require("6246bbb805756d41");
var utils = require("44263cc7b702ebf");
var formats = require("929f8531a94a537c");
var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
        valueOrArray
    ]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats["default"];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag){
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
            if (pos === step) throw new RangeError("Cyclic object value");
            else findFlag = true; // Break while
        }
        if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
    }
    if (typeof filter === "function") obj = filter(prefix, obj);
    else if (obj instanceof Date) obj = serializeDate(obj);
    else if (generateArrayPrefix === "comma" && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
        if (value instanceof Date) return serializeDate(value);
        return value;
    });
    if (obj === null) {
        if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
            return [
                formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))
            ];
        }
        return [
            formatter(prefix) + "=" + formatter(String(obj))
        ];
    }
    var values = [];
    if (typeof obj === "undefined") return values;
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
        objKeys = [
            {
                value: obj.length > 0 ? obj.join(",") || null : void 0
            }
        ];
    } else if (isArray(filter)) objKeys = filter;
    else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
    for(var j = 0; j < objKeys.length; ++j){
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) continue;
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) return defaults;
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var format = formats["default"];
    if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
        format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) filter = opts.filter;
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) return "";
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) arrayFormat = opts.arrayFormat;
    else if (opts && "indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
    else arrayFormat = "indices";
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
    if (!objKeys) objKeys = Object.keys(obj);
    if (options.sort) objKeys.sort(options.sort);
    var sideChannel = getSideChannel();
    for(var i = 0; i < objKeys.length; ++i){
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) continue;
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
        prefix += "utf8=%26%2310003%3B&";
        else // encodeURIComponent('✓')
        prefix += "utf8=%E2%9C%93&";
    }
    return joined.length > 0 ? prefix + joined : "";
};

},{"6246bbb805756d41":"1zs9d","44263cc7b702ebf":"chmkc","929f8531a94a537c":"d7Ogf"}],"1zs9d":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("7911ec51a2dc9f3e");
var callBound = require("125062ab9035288f");
var inspect = require("9f4f5a92d8c6543");
var $TypeError = require("1d3f7a3f029b095e");
var $WeakMap = GetIntrinsic("%WeakMap%", true);
var $Map = GetIntrinsic("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/ var listGetNode = function(list, key) {
    for(var prev = list, curr; (curr = prev.next) !== null; prev = curr)if (curr.key === key) {
        prev.next = curr.next;
        curr.next = list.next;
        list.next = curr; // eslint-disable-line no-param-reassign
        return curr;
    }
};
var listGet = function(objects, key) {
    var node = listGetNode(objects, key);
    return node && node.value;
};
var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) node.value = value;
    else // Prepend the new node to the beginning of the list
    objects.next = {
        key: key,
        next: objects.next,
        value: value
    };
};
var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
};
module.exports = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
        assert: function(key) {
            if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
        },
        get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if ($wm) return $weakMapGet($wm, key);
            } else if ($Map) {
                if ($m) return $mapGet($m, key);
            } else {
                if ($o) return listGet($o, key);
            }
        },
        has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if ($wm) return $weakMapHas($wm, key);
            } else if ($Map) {
                if ($m) return $mapHas($m, key);
            } else {
                if ($o) return listHas($o, key);
            }
            return false;
        },
        set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if (!$wm) $wm = new $WeakMap();
                $weakMapSet($wm, key, value);
            } else if ($Map) {
                if (!$m) $m = new $Map();
                $mapSet($m, key, value);
            } else {
                if (!$o) // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                $o = {
                    key: {},
                    next: null
                };
                listSet($o, key, value);
            }
        }
    };
    return channel;
};

},{"7911ec51a2dc9f3e":"dZb05","125062ab9035288f":"5yYiF","9f4f5a92d8c6543":"kS3SE","1d3f7a3f029b095e":"6oWLR"}],"dZb05":[function(require,module,exports) {
"use strict";
var undefined1;
var $Error = require("ff34c740859aa28e");
var $EvalError = require("349515b7ea9b6cef");
var $RangeError = require("9da01653b2dd9abf");
var $ReferenceError = require("68586abd6b0136da");
var $SyntaxError = require("662263fdbc077fc8");
var $TypeError = require("abdfc34e5f6bb86");
var $URIError = require("daca1f932429e03e");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) try {
    $gOPD({}, "");
} catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
}
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = require("1f00f712d594ccf")();
var hasProto = require("23730654306aa64c")();
var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
    return x.__proto__;
} // eslint-disable-line no-proto
 : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    "%AsyncFromSyncIteratorPrototype%": undefined,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    "%JSON%": typeof JSON === "object" ? JSON : undefined,
    "%Map%": typeof Map === "undefined" ? undefined : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
    "%Symbol%": hasSymbols ? Symbol : undefined,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet
};
if (getProto) try {
    null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
}
var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
    else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
    else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
    else if (name === "%AsyncGenerator%") {
        var fn = doEval("%AsyncGeneratorFunction%");
        if (fn) value = fn.prototype;
    } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval("%AsyncGenerator%");
        if (gen && getProto) value = getProto(gen.prototype);
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
};
var bind = require("7c5e688e48cd07b0");
var hasOwn = require("af36d49b4b8c6c7c");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) value = doEval(intrinsicName);
        if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError('"allowMissing" argument must be a boolean');
    if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
        if (part === "constructor" || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

},{"ff34c740859aa28e":"eDsor","349515b7ea9b6cef":"hIiFU","9da01653b2dd9abf":"11MNe","68586abd6b0136da":"2YV8d","662263fdbc077fc8":"8jeeH","abdfc34e5f6bb86":"6oWLR","daca1f932429e03e":"a04Um","1f00f712d594ccf":"3dK91","23730654306aa64c":"6eZiF","7c5e688e48cd07b0":"6J4ob","af36d49b4b8c6c7c":"9Wb6f"}],"eDsor":[function(require,module,exports) {
"use strict";
/** @type {import('.')} */ module.exports = Error;

},{}],"hIiFU":[function(require,module,exports) {
"use strict";
/** @type {import('./eval')} */ module.exports = EvalError;

},{}],"11MNe":[function(require,module,exports) {
"use strict";
/** @type {import('./range')} */ module.exports = RangeError;

},{}],"2YV8d":[function(require,module,exports) {
"use strict";
/** @type {import('./ref')} */ module.exports = ReferenceError;

},{}],"8jeeH":[function(require,module,exports) {
"use strict";
/** @type {import('./syntax')} */ module.exports = SyntaxError;

},{}],"6oWLR":[function(require,module,exports) {
"use strict";
/** @type {import('./type')} */ module.exports = TypeError;

},{}],"a04Um":[function(require,module,exports) {
"use strict";
/** @type {import('./uri')} */ module.exports = URIError;

},{}],"3dK91":[function(require,module,exports) {
"use strict";
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = require("3fb25678c62d2fce");
module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") return false;
    if (typeof Symbol !== "function") return false;
    if (typeof origSymbol("foo") !== "symbol") return false;
    if (typeof Symbol("bar") !== "symbol") return false;
    return hasSymbolSham();
};

},{"3fb25678c62d2fce":"euYk7"}],"euYk7":[function(require,module,exports) {
"use strict";
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
    if (typeof Symbol.iterator === "symbol") return true;
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") return false;
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"6eZiF":[function(require,module,exports) {
"use strict";
var test = {
    __proto__: null,
    foo: {}
};
var $Object = Object;
/** @type {import('.')} */ module.exports = function hasProto() {
    // @ts-expect-error: TS errors on an inherited property for some reason
    return ({
        __proto__: test
    }).foo === test.foo && !(test instanceof $Object);
};

},{}],"6J4ob":[function(require,module,exports) {
"use strict";
var implementation = require("12e173b4dbaee960");
module.exports = Function.prototype.bind || implementation;

},{"12e173b4dbaee960":"jwaxQ"}],"jwaxQ":[function(require,module,exports) {
"use strict";
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1)arr[i] = a[i];
    for(var j = 0; j < b.length; j += 1)arr[j + a.length] = b[j];
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1)arr[j] = arrLike[i];
    return arr;
};
var joiny = function(arr, joiner) {
    var str = "";
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) str += joiner;
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) return result;
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs[i] = "$" + i;
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

},{}],"9Wb6f":[function(require,module,exports) {
"use strict";
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require("126cb75e62f8e17b");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);

},{"126cb75e62f8e17b":"6J4ob"}],"5yYiF":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("8b08ecb81cf4de17");
var callBind = require("266fc50410cfc4a");
var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBind(intrinsic);
    return intrinsic;
};

},{"8b08ecb81cf4de17":"dZb05","266fc50410cfc4a":"bfo8D"}],"bfo8D":[function(require,module,exports) {
"use strict";
var bind = require("4f9d84d5de4909bc");
var GetIntrinsic = require("68d2ad3775278f43");
var setFunctionLength = require("f4b53071c102d4e");
var $TypeError = require("761613670c43be80");
var $apply = GetIntrinsic("%Function.prototype.apply%");
var $call = GetIntrinsic("%Function.prototype.call%");
var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
var $defineProperty = require("3426ee59b177cf96");
var $max = GetIntrinsic("%Math.max%");
module.exports = function callBind(originalFunction) {
    if (typeof originalFunction !== "function") throw new $TypeError("a function is required");
    var func = $reflectApply(bind, $call, arguments);
    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
};
var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) $defineProperty(module.exports, "apply", {
    value: applyBind
});
else module.exports.apply = applyBind;

},{"4f9d84d5de4909bc":"6J4ob","68d2ad3775278f43":"dZb05","f4b53071c102d4e":"9IKoX","761613670c43be80":"6oWLR","3426ee59b177cf96":"5SmXK"}],"9IKoX":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("8b1c9107ef1524f2");
var define = require("37dd1486f0f556ef");
var hasDescriptors = require("6a9d2b46085df706")();
var gOPD = require("2d412b0f532d1834");
var $TypeError = require("4352c534d27fe477");
var $floor = GetIntrinsic("%Math.floor%");
/** @typedef {(...args: unknown[]) => unknown} Func */ /** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */ module.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== "function") throw new $TypeError("`fn` is not a function");
    if (typeof length !== "number" || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) throw new $TypeError("`length` must be a positive 32-bit integer");
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) functionLengthIsConfigurable = false;
        if (desc && !desc.writable) functionLengthIsWritable = false;
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) define(/** @type {Parameters<define>[0]} */ fn, "length", length, true, true);
        else define(/** @type {Parameters<define>[0]} */ fn, "length", length);
    }
    return fn;
};

},{"8b1c9107ef1524f2":"dZb05","37dd1486f0f556ef":"6cEff","6a9d2b46085df706":"esBLZ","2d412b0f532d1834":"eOTQB","4352c534d27fe477":"6oWLR"}],"6cEff":[function(require,module,exports) {
"use strict";
var $defineProperty = require("f17fd23367965521");
var $SyntaxError = require("50f12088ee0f6bb");
var $TypeError = require("45c79de2b2f9c949");
var gopd = require("3f9bd39335781ec7");
/** @type {import('.')} */ module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new $TypeError("`obj` must be an object or a function`");
    if (typeof property !== "string" && typeof property !== "symbol") throw new $TypeError("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") throw new $TypeError("`loose`, if provided, must be a boolean");
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value: value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
    else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
    else throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
};

},{"f17fd23367965521":"5SmXK","50f12088ee0f6bb":"8jeeH","45c79de2b2f9c949":"6oWLR","3f9bd39335781ec7":"eOTQB"}],"5SmXK":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("8e0b8e4026aaf38a");
/** @type {import('.')} */ var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
if ($defineProperty) try {
    $defineProperty({}, "a", {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
}
module.exports = $defineProperty;

},{"8e0b8e4026aaf38a":"dZb05"}],"eOTQB":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("693e651525841e04");
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) try {
    $gOPD([], "length");
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"693e651525841e04":"dZb05"}],"esBLZ":[function(require,module,exports) {
"use strict";
var $defineProperty = require("1c3b0ce871129f60");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) return null;
    try {
        return $defineProperty([], "length", {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;

},{"1c3b0ce871129f60":"5SmXK"}],"kS3SE":[function(require,module,exports) {
var global = arguments[3];
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
 ? function(O) {
    return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) return str;
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
    }
    return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require("faefcb1694f2ad90");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") return "undefined";
    if (obj === null) return "null";
    if (typeof obj === "boolean") return obj ? "true" : "false";
    if (typeof obj === "string") return inspectString(obj, opts);
    if (typeof obj === "number") {
        if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") depth = 0;
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray(obj) ? "[Array]" : "[Object]";
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") seen = [];
    else if (indexOf(seen, obj) >= 0) return "[Circular]";
    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for(var i = 0; i < attrs.length; i++)s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        s += ">";
        if (obj.childNodes && obj.childNodes.length) s += "...";
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) return "[]";
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
        return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        if (parts.length === 0) return "[" + String(obj) + "]";
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, {
            depth: maxDepth - depth
        });
        else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
    if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
    if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
    if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
    if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
    if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
    if (isString(obj)) return markBoxed(inspect(String(obj)));
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */ if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
    if (obj === global) return "{ [object globalThis] }";
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) return tag + "{}";
        if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
        return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s + quoteChar;
}
function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
}
function isArray(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
    if (typeof obj === "symbol") return true;
    if (!obj || typeof obj !== "object" || !symToString) return false;
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}
function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
};
function has(obj, key) {
    return hasOwn.call(obj, key);
}
function toStr(obj) {
    return objectToString.call(obj);
}
function nameOf(f) {
    if (f.name) return f.name;
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) return m[1];
    return null;
}
function indexOf(xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}
function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") return false;
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") return false;
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") return false;
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}
function isSet(x) {
    if (!setSize || !x || typeof x !== "object") return false;
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") return false;
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isElement(x) {
    if (!x || typeof x !== "object") return false;
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[n];
    if (x) return "\\" + x;
    return "\\x" + (n < 0x10 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
    return "Object(" + str + ")";
}
function weakCollectionOf(type) {
    return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
    for(var i = 0; i < xs.length; i++){
        if (indexOf(xs[i], "\n") >= 0) return false;
    }
    return true;
}
function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") baseIndent = "	";
    else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
    else return null;
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}
function indentedJoin(xs, indent) {
    if (xs.length === 0) return "";
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for(var i = 0; i < obj.length; i++)xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for(var k = 0; k < syms.length; k++)symMap["$" + syms[k]] = syms[k];
    }
    for(var key in obj){
        if (!has(obj, key)) continue;
         // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) continue;
         // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue; // eslint-disable-line no-restricted-syntax, no-continue
        else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        else xs.push(key + ": " + inspect(obj[key], obj));
    }
    if (typeof gOPS === "function") {
        for(var j = 0; j < syms.length; j++)if (isEnumerable.call(obj, syms[j])) xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
    }
    return xs;
}

},{"faefcb1694f2ad90":"bXKEI"}],"chmkc":[function(require,module,exports) {
"use strict";
var formats = require("7adf3674f81a2c87");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var hexTable = function() {
    var array = [];
    for(var i = 0; i < 256; ++i)array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    return array;
}();
var compactQueue = function compactQueue(queue) {
    while(queue.length > 1){
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
            var compacted = [];
            for(var j = 0; j < obj.length; ++j)if (typeof obj[j] !== "undefined") compacted.push(obj[j]);
            item.obj[item.prop] = compacted;
        }
    }
};
var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for(var i = 0; i < source.length; ++i)if (typeof source[i] !== "undefined") obj[i] = source[i];
    return obj;
};
var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */ if (!source) return target;
    if (typeof source !== "object") {
        if (isArray(target)) target.push(source);
        else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
        } else return [
            target,
            source
        ];
        return target;
    }
    if (!target || typeof target !== "object") return [
        target
    ].concat(source);
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i] = merge(targetItem, item, options);
                else target.push(item);
            } else target[i] = item;
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
        else acc[key] = value;
        return acc;
    }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
var decode = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") // unescape never throws, no try...catch needed:
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) return str;
    var string = str;
    if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
    else if (typeof str !== "string") string = String(str);
    if (charset === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
    var out = "";
    for(var i = 0; i < string.length; ++i){
        var c = string.charCodeAt(i);
        if (c === 0x2D // -
         || c === 0x2E // .
         || c === 0x5F // _
         || c === 0x7E // ~
         || c >= 0x30 && c <= 0x39 // 0-9
         || c >= 0x41 && c <= 0x5A // a-z
         || c >= 0x61 && c <= 0x7A // A-Z
         || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }
        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }
        if (c < 0x800) {
            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
            continue;
        }
        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
            continue;
        }
        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
        /* eslint operator-linebreak: [2, "before"] */ out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }
    return out;
};
var compact = function compact(value) {
    var queue = [
        {
            obj: {
                o: value
            },
            prop: "o"
        }
    ];
    var refs = [];
    for(var i = 0; i < queue.length; ++i){
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; ++j){
            var key = keys[j];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value;
};
var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== "object") return false;
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine(a, b) {
    return [].concat(a, b);
};
var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for(var i = 0; i < val.length; i += 1)mapped.push(fn(val[i]));
        return mapped;
    }
    return fn(val);
};
module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

},{"7adf3674f81a2c87":"d7Ogf"}],"d7Ogf":[function(require,module,exports) {
"use strict";
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
};
module.exports = {
    "default": Format.RFC3986,
    formatters: {
        RFC1738: function(value) {
            return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};

},{}],"fSZqi":[function(require,module,exports) {
"use strict";
var utils = require("e76649c95dd0e736");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};
var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
    return val;
};
// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = "utf8=%26%2310003%3B"; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = "utf8=%E2%9C%93"; // encodeURIComponent('✓')
var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
        __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
        for(i = 0; i < parts.length; ++i)if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) charset = "utf-8";
            else if (parts[i] === isoSentinel) charset = "iso-8859-1";
            skipIndex = i;
            i = parts.length; // The eslint settings do not allow break;
        }
    }
    for(i = 0; i < parts.length; ++i){
        if (i === skipIndex) continue;
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, "value");
            });
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") val = interpretNumericEntities(val);
        if (part.indexOf("[]=") > -1) val = isArray(val) ? [
            val
        ] : val;
        if (has.call(obj, key)) obj[key] = utils.combine(obj[key], val);
        else obj[key] = val;
    }
    return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for(var i = chain.length - 1; i >= 0; --i){
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) obj = [].concat(leaf);
        else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") obj = {
                0: leaf
            };
            else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== "__proto__") obj[cleanRoot] = leaf;
        }
        leaf = obj;
    }
    return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) return;
    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    // The regex chunks
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    // Get the parent
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    // Stash the parent if it exists
    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) return;
        }
        keys.push(parent);
    }
    // Loop through children appending to the array until we hit depth
    var i = 0;
    while(options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth){
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) return;
        }
        keys.push(segment[1]);
    }
    // If there's a remainder, just add whatever is left
    if (segment) keys.push("[" + key.slice(segment.index) + "]");
    return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) return defaults;
    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? Object.create(null) : {};
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    // Iterate over the keys and setup the new object
    var keys = Object.keys(tempObj);
    for(var i = 0; i < keys.length; ++i){
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) return obj;
    return utils.compact(obj);
};

},{"e76649c95dd0e736":"chmkc"}],"034jg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pathKey);
var process = require("fad004802411709b");
function pathKey(options = {}) {
    const { env = process.env, platform = process.platform } = options;
    if (platform !== "win32") return "PATH";
    return Object.keys(env).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
}

},{"fad004802411709b":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kXATo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mimicFn = require("mimic-fn");
var _mimicFnDefault = parcelHelpers.interopDefault(_mimicFn);
const calledFunctions = new WeakMap();
const onetime = (function_, options = {})=>{
    if (typeof function_ !== "function") throw new TypeError("Expected a function");
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime = function(...arguments_) {
        calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
        } else if (options.throw === true) throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
    };
    (0, _mimicFnDefault.default)(onetime, function_);
    calledFunctions.set(onetime, callCount);
    return onetime;
};
onetime.callCount = (function_)=>{
    if (!calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return calledFunctions.get(function_);
};
exports.default = onetime;

},{"mimic-fn":"5gC2j","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5gC2j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mimicFunction);
const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
    // `Function#prototype` is non-writable and non-configurable so can never be modified.
    if (property === "length" || property === "prototype") return;
    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
    if (property === "arguments" || property === "caller") return;
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) return;
    Object.defineProperty(to, property, fromDescriptor);
};
// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from)=>{
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) return;
    Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const changeToString = (to, from, name)=>{
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from.toString());
    // Ensure `to.toString.toString` is non-enumerable and has the same `same`
    Object.defineProperty(newToString, "name", toStringName);
    Object.defineProperty(to, "toString", {
        ...toStringDescriptor,
        value: newToString
    });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from))copyProperty(to, from, property, ignoreNonConfigurable);
    changePrototype(to, from);
    changeToString(to, from, name);
    return to;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"laSjc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeError", ()=>makeError);
var _nodeProcess = require("process");
var _nodeProcessDefault = parcelHelpers.interopDefault(_nodeProcess);
var _humanSignals = require("human-signals");
const getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })=>{
    if (timedOut) return `timed out after ${timeout} milliseconds`;
    if (isCanceled) return "was canceled";
    if (errorCode !== undefined) return `failed with ${errorCode}`;
    if (signal !== undefined) return `was killed with ${signal} (${signalDescription})`;
    if (exitCode !== undefined) return `failed with exit code ${exitCode}`;
    return "failed";
};
const makeError = ({ stdout, stderr, all, error, signal, exitCode, command, escapedCommand, timedOut, isCanceled, killed, parsed: { options: { timeout, cwd = (0, _nodeProcessDefault.default).cwd() } } })=>{
    // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
    // We normalize them to `undefined`
    exitCode = exitCode === null ? undefined : exitCode;
    signal = signal === null ? undefined : signal;
    const signalDescription = signal === undefined ? undefined : (0, _humanSignals.signalsByName)[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({
        timedOut,
        timeout,
        errorCode,
        signal,
        signalDescription,
        exitCode,
        isCanceled
    });
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [
        shortMessage,
        stderr,
        stdout
    ].filter(Boolean).join("\n");
    if (isError) {
        error.originalMessage = error.message;
        error.message = message;
    } else error = new Error(message);
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    error.cwd = cwd;
    if (all !== undefined) error.all = all;
    if ("bufferedData" in error) delete error.bufferedData;
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
};

},{"node:process":"d5jf4","human-signals":"79Exv","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"79Exv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signalsByName", ()=>signalsByName);
parcelHelpers.export(exports, "signalsByNumber", ()=>signalsByNumber);
var _nodeOs = require("os");
var _realtimeJs = require("./realtime.js");
var _signalsJs = require("./signals.js");
const getSignalsByName = ()=>{
    const signals = (0, _signalsJs.getSignals)();
    return Object.fromEntries(signals.map(getSignalByName));
};
const getSignalByName = ({ name, number, description, supported, action, forced, standard })=>[
        name,
        {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        }
    ];
const signalsByName = getSignalsByName();
const getSignalsByNumber = ()=>{
    const signals = (0, _signalsJs.getSignals)();
    const length = (0, _realtimeJs.SIGRTMAX) + 1;
    const signalsA = Array.from({
        length
    }, (value, number)=>getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
};
const getSignalByNumber = (number, signals)=>{
    const signal = findSignalByNumber(number, signals);
    if (signal === undefined) return {};
    const { name, description, supported, action, forced, standard } = signal;
    return {
        [number]: {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        }
    };
};
const findSignalByNumber = (number, signals)=>{
    const signal = signals.find(({ name })=>(0, _nodeOs.constants).signals[name] === number);
    if (signal !== undefined) return signal;
    return signals.find((signalA)=>signalA.number === number);
};
const signalsByNumber = getSignalsByNumber();

},{"node:os":"6yyXu","./realtime.js":"4N7A5","./signals.js":"8K0zX","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4N7A5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRealtimeSignals", ()=>getRealtimeSignals);
parcelHelpers.export(exports, "SIGRTMAX", ()=>SIGRTMAX);
const getRealtimeSignals = ()=>{
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({
        length
    }, getRealtimeSignal);
};
const getRealtimeSignal = (value, index)=>({
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
    });
const SIGRTMIN = 34;
const SIGRTMAX = 64;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8K0zX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSignals", ()=>getSignals);
var _nodeOs = require("os");
var _coreJs = require("./core.js");
var _realtimeJs = require("./realtime.js");
const getSignals = ()=>{
    const realtimeSignals = (0, _realtimeJs.getRealtimeSignals)();
    const signals = [
        ...(0, _coreJs.SIGNALS),
        ...realtimeSignals
    ].map(normalizeSignal);
    return signals;
};
const normalizeSignal = ({ name, number: defaultNumber, description, action, forced = false, standard })=>{
    const { signals: { [name]: constantSignal } } = (0, _nodeOs.constants);
    const supported = constantSignal !== undefined;
    const number = supported ? constantSignal : defaultNumber;
    return {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
    };
};

},{"node:os":"6yyXu","./core.js":"kCti1","./realtime.js":"4N7A5","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kCti1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SIGNALS", ()=>SIGNALS);
const SIGNALS = [
    {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
    },
    {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
    },
    {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
    },
    {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
    },
    {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
    },
    {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
    },
    {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
    },
    {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
    },
    {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
    },
    {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
    },
    {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
    },
    {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
    },
    {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
    },
    {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
    },
    {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
    },
    {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
    },
    {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
    },
    {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
    },
    {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
    },
    {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
    },
    {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
    },
    {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
    },
    {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
    },
    {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
    },
    {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
    },
    {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
    },
    {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
    },
    {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
    },
    {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
    },
    {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
    },
    {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"16xp4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalizeStdio", ()=>normalizeStdio);
parcelHelpers.export(exports, "normalizeStdioNode", ()=>normalizeStdioNode);
const aliases = [
    "stdin",
    "stdout",
    "stderr"
];
const hasAlias = (options)=>aliases.some((alias)=>options[alias] !== undefined);
const normalizeStdio = (options)=>{
    if (!options) return;
    const { stdio } = options;
    if (stdio === undefined) return aliases.map((alias)=>options[alias]);
    if (hasAlias(options)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias)=>`\`${alias}\``).join(", ")}`);
    if (typeof stdio === "string") return stdio;
    if (!Array.isArray(stdio)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({
        length
    }, (value, index)=>stdio[index]);
};
const normalizeStdioNode = (options)=>{
    const stdio = normalizeStdio(options);
    if (stdio === "ipc") return "ipc";
    if (stdio === undefined || typeof stdio === "string") return [
        stdio,
        stdio,
        stdio,
        "ipc"
    ];
    if (stdio.includes("ipc")) return stdio;
    return [
        ...stdio,
        "ipc"
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fmvRP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "spawnedKill", ()=>spawnedKill);
parcelHelpers.export(exports, "spawnedCancel", ()=>spawnedCancel);
parcelHelpers.export(exports, "setupTimeout", ()=>setupTimeout);
parcelHelpers.export(exports, "validateTimeout", ()=>validateTimeout);
parcelHelpers.export(exports, "setExitHandler", ()=>setExitHandler);
var _nodeOs = require("os");
var _nodeOsDefault = parcelHelpers.interopDefault(_nodeOs);
var _signalExit = require("signal-exit");
var _signalExitDefault = parcelHelpers.interopDefault(_signalExit);
const DEFAULT_FORCE_KILL_TIMEOUT = 5000;
const spawnedKill = (kill, signal = "SIGTERM", options = {})=>{
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
};
const setKillTimeout = (kill, signal, options, killResult)=>{
    if (!shouldForceKill(signal, options, killResult)) return;
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(()=>{
        kill("SIGKILL");
    }, timeout);
    // Guarded because there's no `.unref()` when `execa` is used in the renderer
    // process in Electron. This cannot be tested since we don't run tests in
    // Electron.
    // istanbul ignore else
    if (t.unref) t.unref();
};
const shouldForceKill = (signal, { forceKillAfterTimeout }, killResult)=>isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
const isSigterm = (signal)=>signal === (0, _nodeOsDefault.default).constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
const getForceKillAfterTimeout = ({ forceKillAfterTimeout = true })=>{
    if (forceKillAfterTimeout === true) return DEFAULT_FORCE_KILL_TIMEOUT;
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    return forceKillAfterTimeout;
};
const spawnedCancel = (spawned, context)=>{
    const killResult = spawned.kill();
    if (killResult) context.isCanceled = true;
};
const timeoutKill = (spawned, signal, reject)=>{
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {
        timedOut: true,
        signal
    }));
};
const setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise)=>{
    if (timeout === 0 || timeout === undefined) return spawnedPromise;
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject)=>{
        timeoutId = setTimeout(()=>{
            timeoutKill(spawned, killSignal, reject);
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(()=>{
        clearTimeout(timeoutId);
    });
    return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
    ]);
};
const validateTimeout = ({ timeout })=>{
    if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
};
const setExitHandler = async (spawned, { cleanup, detached }, timedPromise)=>{
    if (!cleanup || detached) return timedPromise;
    const removeExitHandler = (0, _signalExitDefault.default)(()=>{
        spawned.kill();
    });
    return timedPromise.finally(()=>{
        removeExitHandler();
    });
};

},{"node:os":"6yyXu","signal-exit":"j8Ldj","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"j8Ldj":[function(require,module,exports) {
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var global = arguments[3];
var process = global.process;
const processOk = function(process) {
    return process && typeof process === "object" && typeof process.removeListener === "function" && typeof process.emit === "function" && typeof process.reallyExit === "function" && typeof process.listeners === "function" && typeof process.kill === "function" && typeof process.pid === "number" && typeof process.on === "function";
};
// some kind of non-node environment, just no-op
/* istanbul ignore if */ if (!processOk(process)) module.exports = function() {
    return function() {};
};
else {
    var assert = require("bbc110a60ddcb999");
    var signals = require("76f7b4ff2ec7e415");
    var isWin = /^win/i.test(process.platform);
    var EE = require("f3fef57218fabfd1");
    /* istanbul ignore if */ if (typeof EE !== "function") EE = EE.EventEmitter;
    var emitter;
    if (process.__signal_exit_emitter__) emitter = process.__signal_exit_emitter__;
    else {
        emitter = process.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
    }
    // Because this emitter is a global, we have to check to see if a
    // previous version of this library failed to enable infinite listeners.
    // I know what you're about to say.  But literally everything about
    // signal-exit is a compromise with evil.  Get used to it.
    if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
    }
    module.exports = function(cb, opts) {
        /* istanbul ignore if */ if (!processOk(global.process)) return function() {};
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) load();
        var ev = "exit";
        if (opts && opts.alwaysLast) ev = "afterexit";
        var remove = function() {
            emitter.removeListener(ev, cb);
            if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) unload();
        };
        emitter.on(ev, cb);
        return remove;
    };
    var unload = function unload() {
        if (!loaded || !processOk(global.process)) return;
        loaded = false;
        signals.forEach(function(sig) {
            try {
                process.removeListener(sig, sigListeners[sig]);
            } catch (er) {}
        });
        process.emit = originalProcessEmit;
        process.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
    };
    module.exports.unload = unload;
    var emit = function emit(event, code, signal) {
        /* istanbul ignore if */ if (emitter.emitted[event]) return;
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
    };
    // { <signal>: <listener fn>, ... }
    var sigListeners = {};
    signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
            /* istanbul ignore if */ if (!processOk(global.process)) return;
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = process.listeners(sig);
            if (listeners.length === emitter.count) {
                unload();
                emit("exit", null, sig);
                /* istanbul ignore next */ emit("afterexit", null, sig);
                /* istanbul ignore next */ if (isWin && sig === "SIGHUP") // "SIGHUP" throws an `ENOSYS` error on Windows,
                // so use a supported signal instead
                sig = "SIGINT";
                /* istanbul ignore next */ process.kill(process.pid, sig);
            }
        };
    });
    module.exports.signals = function() {
        return signals;
    };
    var loaded = false;
    var load = function load() {
        if (loaded || !processOk(global.process)) return;
        loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        emitter.count += 1;
        signals = signals.filter(function(sig) {
            try {
                process.on(sig, sigListeners[sig]);
                return true;
            } catch (er) {
                return false;
            }
        });
        process.emit = processEmit;
        process.reallyExit = processReallyExit;
    };
    module.exports.load = load;
    var originalProcessReallyExit = process.reallyExit;
    var processReallyExit = function processReallyExit(code) {
        /* istanbul ignore if */ if (!processOk(global.process)) return;
        process.exitCode = code || /* istanbul ignore next */ 0;
        emit("exit", process.exitCode, null);
        /* istanbul ignore next */ emit("afterexit", process.exitCode, null);
        /* istanbul ignore next */ originalProcessReallyExit.call(process, process.exitCode);
    };
    var originalProcessEmit = process.emit;
    var processEmit = function processEmit(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
            /* istanbul ignore else */ if (arg !== undefined) process.exitCode = arg;
            var ret = originalProcessEmit.apply(this, arguments);
            /* istanbul ignore next */ emit("exit", process.exitCode, null);
            /* istanbul ignore next */ emit("afterexit", process.exitCode, null);
            /* istanbul ignore next */ return ret;
        } else return originalProcessEmit.apply(this, arguments);
    };
}

},{"bbc110a60ddcb999":"f3tT4","76f7b4ff2ec7e415":"bNVWy","f3fef57218fabfd1":"1VQLm"}],"f3tT4":[function(require,module,exports) {
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("17530e9a8e9dd8de");
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
var _require = require("67930e3bebc18ea9"), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = require("11bdd262fb706a54");
var _require2 = require("d61a3396666721b6"), inspect = _require2.inspect;
var _require$types = require("d61a3396666721b6").types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
var objectAssign = require("fe81af847d362e93")();
var objectIs = require("4ad4507c8e372c71")();
var RegExpPrototypeTest = require("11f208d8f2e10b17")("RegExp.prototype.test");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
    var comparison = require("131e25d2408617a4");
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
}
// Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "",
    "",
    "\\u000b",
    "\\f",
    "",
    "\\u000e",
    "\\u000f",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001a",
    "\\u001b",
    "\\u001c",
    "\\u001d",
    "\\u001e",
    "\\u001f"
];
var escapeFn = function escapeFn(str) {
    return meta[str.charCodeAt(0)];
};
var warned = false;
// The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {};
// All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function innerFail(obj) {
    if (obj.message instanceof Error) throw obj.message;
    throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) internalMessage = "Failed";
    else if (argsLen === 1) {
        message = actual;
        actual = undefined;
    } else {
        if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2) operator = "!=";
    }
    if (message instanceof Error) throw message;
    var errArgs = {
        actual: actual,
        expected: expected,
        operator: operator === undefined ? "fail" : operator,
        stackStartFn: stackStartFn || fail
    };
    if (message !== undefined) errArgs.message = message;
    var err = new AssertionError(errArgs);
    if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
    }
    throw err;
}
assert.fail = fail;
// The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
    if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) throw message;
        var err = new AssertionError({
            actual: value,
            expected: true,
            message: message,
            operator: "==",
            stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
    }
}
// Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    innerOk.apply(void 0, [
        ok,
        args.length
    ].concat(args));
}
assert.ok = ok;
// The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    // eslint-disable-next-line eqeqeq
    if (actual != expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "==",
        stackStartFn: equal
    });
};
// The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    // eslint-disable-next-line eqeqeq
    if (actual == expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "!=",
        stackStartFn: notEqual
    });
};
// The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "deepEqual",
        stackStartFn: deepEqual
    });
};
// The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
    });
};
/* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
    });
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
    });
}
assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (!objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "strictEqual",
        stackStartFn: strictEqual
    });
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
    });
};
var Comparison = /*#__PURE__*/ _createClass(function Comparison(obj, keys, actual) {
    var _this = this;
    _classCallCheck(this, Comparison);
    keys.forEach(function(key) {
        if (key in obj) {
            if (actual !== undefined && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) _this[key] = actual[key];
            else _this[key] = obj[key];
        }
    });
});
function compareExceptionKey(actual, expected, key, message, keys, fn) {
    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
            // Create placeholder objects to create a nice output.
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
                actual: a,
                expected: b,
                operator: "deepStrictEqual",
                stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
        }
        innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: fn.name,
            stackStartFn: fn
        });
    }
}
function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== "function") {
        if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
        // assert.doesNotThrow does not accept objects.
        if (arguments.length === 2) throw new ERR_INVALID_ARG_TYPE("expected", [
            "Function",
            "RegExp"
        ], expected);
        // Handle primitives properly.
        if (_typeof(actual) !== "object" || actual === null) {
            var err = new AssertionError({
                actual: actual,
                expected: expected,
                message: msg,
                operator: "deepStrictEqual",
                stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
        }
        var keys = Object.keys(expected);
        // Special handle errors to make sure the name and the message are compared
        // as well.
        if (expected instanceof Error) keys.push("name", "message");
        else if (keys.length === 0) throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        if (isDeepEqual === undefined) lazyLoadComparison();
        keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) return;
            compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
    }
    // Guard instanceof against arrow functions as they don't have a prototype.
    if (expected.prototype !== undefined && actual instanceof expected) return true;
    if (Error.isPrototypeOf(expected)) return false;
    return expected.call({}, actual) === true;
}
function getActual(fn) {
    if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    try {
        fn();
    } catch (e) {
        return e;
    }
    return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
    // Accept native ES6 promises and promises that are implemented in a similar
    // way. Do not accept thenables that use a function as `obj` and that have no
    // `catch` handler.
    // TODO: thenables are checked up until they have the correct methods,
    // but according to documentation, the `then` method should receive
    // the `fulfill` and `reject` arguments as well or it may be never resolved.
    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
}
function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
            // Return a rejected promise if `promiseFn` throws synchronously.
            resultPromise = promiseFn();
            // Fail in case no promise is returned.
            if (!checkIsPromise(resultPromise)) throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        } else if (checkIsPromise(promiseFn)) resultPromise = promiseFn;
        else throw new ERR_INVALID_ARG_TYPE("promiseFn", [
            "Function",
            "Promise"
        ], promiseFn);
        return Promise.resolve().then(function() {
            return resultPromise;
        }).then(function() {
            return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
            return e;
        });
    });
}
function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === "string") {
        if (arguments.length === 4) throw new ERR_INVALID_ARG_TYPE("error", [
            "Object",
            "Error",
            "Function",
            "RegExp"
        ], error);
        if (_typeof(actual) === "object" && actual !== null) {
            if (actual.message === error) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        } else if (actual === error) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        message = error;
        error = undefined;
    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") throw new ERR_INVALID_ARG_TYPE("error", [
        "Object",
        "Error",
        "Function",
        "RegExp"
    ], error);
    if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) details += " (".concat(error.name, ")");
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
            actual: undefined,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn: stackStartFn
        });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) throw actual;
}
function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL) return;
    if (typeof error === "string") {
        message = error;
        error = undefined;
    }
    if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
            actual: actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn: stackStartFn
        });
    }
    throw actual;
}
assert.throws = function throws(promiseFn) {
    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
    expectsError.apply(void 0, [
        throws,
        getActual(promiseFn)
    ].concat(args));
};
assert.rejects = function rejects(promiseFn) {
    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)args[_key3 - 1] = arguments[_key3];
    return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [
            rejects,
            result
        ].concat(args));
    });
};
assert.doesNotThrow = function doesNotThrow(fn) {
    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)args[_key4 - 1] = arguments[_key4];
    expectsNoError.apply(void 0, [
        doesNotThrow,
        getActual(fn)
    ].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)args[_key5 - 1] = arguments[_key5];
    return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [
            doesNotReject,
            result
        ].concat(args));
    });
};
assert.ifError = function ifError(err) {
    if (err !== null && err !== undefined) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) message += err.constructor.name;
            else message += err.message;
        } else message += inspect(err);
        var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message: message,
            stackStartFn: ifError
        });
        // Make sure we actually have a stack trace!
        var origStack = err.stack;
        if (typeof origStack === "string") {
            // This will remove any duplicated frames from the error frames taken
            // from within `ifError` and add the original error frames to the newly
            // created ones.
            var tmp2 = origStack.split("\n");
            tmp2.shift();
            // Filter all frames existing in err.stack.
            var tmp1 = newErr.stack.split("\n");
            for(var i = 0; i < tmp2.length; i++){
                // Find the first occurrence of the frame.
                var pos = tmp1.indexOf(tmp2[i]);
                if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos);
                    break;
                }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
    }
};
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
function internalMatch(string, regexp, message, fn, fnName) {
    if (!isRegExp(regexp)) throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    var match = fnName === "match";
    if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
        if (message instanceof Error) throw message;
        var generatedMessage = !message;
        // 'The input was expected to not match the regular expression ' +
        message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
        var err = new AssertionError({
            actual: string,
            expected: regexp,
            message: message,
            operator: fnName,
            stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
    }
}
assert.match = function match(string, regexp, message) {
    internalMatch(string, regexp, message, match, "match");
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
    internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
};
// Expose a strict only variant of assert
function strict() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];
    innerOk.apply(void 0, [
        strict,
        args.length
    ].concat(args));
}
assert.strict = objectAssign(strict, assert, {
    equal: assert.strictEqual,
    deepEqual: assert.deepStrictEqual,
    notEqual: assert.notStrictEqual,
    notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

},{"17530e9a8e9dd8de":"d5jf4","67930e3bebc18ea9":"cwQVR","11bdd262fb706a54":"lQlQt","d61a3396666721b6":"cxohQ","fe81af847d362e93":"ajEZo","4ad4507c8e372c71":"ezjA5","11f208d8f2e10b17":"5yYiF","131e25d2408617a4":"d5TM9"}],"cwQVR":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
/* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ "use strict";
// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
var codes = {};
// Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inherits(NodeError, _Base);
        var _super = _createSuper(NodeError);
        function NodeError(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError);
            _this = _super.call(this, getMessage(arg1, arg2, arg3));
            _this.code = code;
            return _this;
        }
        return _createClass(NodeError);
    }(Base);
    codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    if (assert === undefined) assert = require("f73a3052b95b9ed");
    assert(typeof name === "string", "'name' must be a string");
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    // TODO(BridgeAR): Improve the output by showing `null` and similar.
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
}, TypeError);
createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
    if (util === undefined) util = require("1fd472100fa8826f");
    var inspected = util.inspect(value);
    if (inspected.length > 128) inspected = "".concat(inspected.slice(0, 128), "...");
    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
    var type;
    if (value && value.constructor && value.constructor.name) type = "instance of ".concat(value.constructor.name);
    else type = "type ".concat(_typeof(value));
    return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
}, TypeError);
createErrorType("ERR_MISSING_ARGS", function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    if (assert === undefined) assert = require("f73a3052b95b9ed");
    assert(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a) {
        return '"'.concat(a, '"');
    });
    switch(len){
        case 1:
            msg += "".concat(args[0], " argument");
            break;
        case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
        default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
    }
    return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

},{"f73a3052b95b9ed":"f3tT4","1fd472100fa8826f":"cxohQ"}],"cxohQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("bc23a3ea4a141c0b");
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
        return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === "%%") return "%";
        if (i >= len) return x;
        switch(x){
            case "%s":
                return String(args[i++]);
            case "%d":
                return Number(args[i++]);
            case "%j":
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return "[Circular]";
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i])if (isNull(x) || !isObject(x)) str += " " + x;
    else str += " " + inspect(x);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof process === "undefined") return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) throw new Error(msg);
            else if (process.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
var debugEnv;
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error("%s %d: %s", set, pid, msg);
            };
        } else debugs[set] = function() {};
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    exports._extend(ctx, opts);
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    "bold": [
        1,
        22
    ],
    "italic": [
        3,
        23
    ],
    "underline": [
        4,
        24
    ],
    "inverse": [
        7,
        27
    ],
    "white": [
        37,
        39
    ],
    "grey": [
        90,
        39
    ],
    "black": [
        30,
        39
    ],
    "blue": [
        34,
        39
    ],
    "cyan": [
        36,
        39
    ],
    "green": [
        32,
        39
    ],
    "magenta": [
        35,
        39
    ],
    "red": [
        31,
        39
    ],
    "yellow": [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return "\x1b[" + inspect.colors[style][0] + "m" + str + "\x1b[" + inspect.colors[style][1] + "m";
    else return str;
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
        if (isError(value)) return formatError(value);
    }
    var base = "", array = false, braces = [
        "{",
        "}"
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            "[",
            "]"
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) base = " " + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if (isDate(value)) base = " " + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if (isError(value)) base = " " + formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        else return ctx.stylize("[Object]", "special");
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
    }
    if (isNumber(value)) return ctx.stylize("" + value, "number");
    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize("null", "null");
}
function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push("");
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
        else str = ctx.stylize("[Getter]", "special");
    } else if (desc.set) str = ctx.stylize("[Setter]", "special");
    if (!hasOwnProperty(visibleKeys, key)) name = "[" + key + "]";
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf("\n") > -1) {
                if (array) str = str.split("\n").map(function(line) {
                    return "  " + line;
                }).join("\n").slice(2);
                else str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                }).join("\n");
            }
        } else str = ctx.stylize("[Circular]", "special");
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
        }
    }
    return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require("6a1c15bae847a134");
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === "boolean";
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === "number";
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === "string";
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === "symbol";
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === "function";
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require("a42137cd7fc8700d");
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(":");
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(" ");
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = require("a792e8e3e2aa1973");
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;

},{"bc23a3ea4a141c0b":"d5jf4","6a1c15bae847a134":"bnQvf","a42137cd7fc8700d":"inNNy","a792e8e3e2aa1973":"bRL3M"}],"bnQvf":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";
var isArgumentsObject = require("6b5f9ae3e436d527");
var isGeneratorFunction = require("285c2b8081bf4b68");
var whichTypedArray = require("e95b88ccd80e1671");
var isTypedArray = require("7db151546a22c2a8");
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== "undefined";
var SymbolSupported = typeof Symbol !== "undefined";
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === "Uint8Array";
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === "Uint8ClampedArray";
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === "Uint16Array";
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === "Uint32Array";
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === "Int8Array";
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === "Int16Array";
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === "Int32Array";
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === "Float32Array";
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === "Float64Array";
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === "BigInt64Array";
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === "BigUint64Array";
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
}
isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === "undefined") return false;
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
}
isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === "undefined") return false;
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
}
isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === "undefined") return false;
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
}
isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
}
isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") return false;
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
}
isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === "undefined") return false;
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === "undefined") return false;
    if (typeof isSharedArrayBufferToString.working === "undefined") isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    "isProxy",
    "isExternal",
    "isModuleNamespaceObject"
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + " is not supported in userland");
        }
    });
});

},{"6b5f9ae3e436d527":"czr4n","285c2b8081bf4b68":"2XUdn","e95b88ccd80e1671":"lVUO7","7db151546a22c2a8":"1ihkG"}],"czr4n":[function(require,module,exports) {
"use strict";
var hasToStringTag = require("e2b01ce809f132fb")();
var callBound = require("649cbf9949986a39");
var $toString = callBound("Object.prototype.toString");
var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) return false;
    return $toString(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) return true;
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"e2b01ce809f132fb":"9LdQ9","649cbf9949986a39":"5yYiF"}],"9LdQ9":[function(require,module,exports) {
"use strict";
var hasSymbols = require("2ef89576d4959bff");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};

},{"2ef89576d4959bff":"euYk7"}],"2XUdn":[function(require,module,exports) {
"use strict";
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require("b42ab74c25dbb155")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
    if (!hasToStringTag) return false;
    try {
        return Function("return function*() {}")();
    } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== "function") return false;
    if (isFnRegex.test(fnToStr.call(fn))) return true;
    if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
    }
    if (!getProto) return false;
    if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
};

},{"b42ab74c25dbb155":"9LdQ9"}],"lVUO7":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var forEach = require("2941d48f36957e3c");
var availableTypedArrays = require("beaf5502a5823cce");
var callBind = require("e5d203a1b4c809f9");
var callBound = require("83f633f9b335db8f");
var gOPD = require("ce6b45c571ba4e3e");
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = require("9e7ef6c88184c56")();
var g = typeof globalThis === "undefined" ? global : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound("String.prototype.slice");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
var $indexOf = callBound("Array.prototype.indexOf", true) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */ function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
/** @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array} TypedArray */ /** @typedef {'Int8Array' | 'Uint8Array' | 'Uint8ClampedArray' | 'Int16Array' | 'Uint16Array' | 'Int32Array' | 'Uint32Array' | 'Float32Array' | 'Float64Array' | 'BigInt64Array' | 'BigUint64Array'} TypedArrayName */ /** @type {{ [k in `\$${TypedArrayName}`]?: (receiver: TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call } & { __proto__: null }} */ var cache = {
    __proto__: null
};
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        // @ts-expect-error TS won't narrow inside a closure
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            // @ts-expect-error TS won't narrow inside a closure
            descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        // @ts-expect-error TODO: fix
        cache["$" + typedArray] = callBind(descriptor.get);
    }
});
else forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) // @ts-expect-error TODO: fix
    cache["$" + typedArray] = callBind(fn);
});
/** @type {import('.')} */ var tryTypedArrays = function tryAllTypedArrays(value) {
    /** @type {ReturnType<tryAllTypedArrays>} */ var found = false;
    forEach(// eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */ /** @type {any} */ cache, /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */ function(getter, typedArray) {
        if (!found) try {
            // @ts-expect-error TODO: fix
            if ("$" + getter(value) === typedArray) found = $slice(typedArray, 1);
        } catch (e) {}
    });
    return found;
};
/** @type {import('.')} */ var trySlices = function tryAllSlices(value) {
    /** @type {ReturnType<tryAllSlices>} */ var found = false;
    forEach(// eslint-disable-next-line no-extra-parens
    /** @type {any} */ cache, /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */ function(getter, name) {
        if (!found) try {
            // @ts-expect-error TODO: fix
            getter(value);
            found = $slice(name, 1);
        } catch (e) {}
    });
    return found;
};
/** @type {import('.')} */ module.exports = function whichTypedArray(value) {
    if (!value || typeof value !== "object") return false;
    if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) return tag;
        if (tag !== "Object") return false;
        // node < 0.6 hits here on real Typed Arrays
        return trySlices(value);
    }
    if (!gOPD) return null;
     // unknown engine
    return tryTypedArrays(value);
};

},{"2941d48f36957e3c":"1Sol9","beaf5502a5823cce":"kfela","e5d203a1b4c809f9":"bfo8D","83f633f9b335db8f":"5yYiF","ce6b45c571ba4e3e":"eOTQB","9e7ef6c88184c56":"9LdQ9"}],"1Sol9":[function(require,module,exports) {
"use strict";
var isCallable = require("e50ebc24bbb25feb");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++)if (hasOwnProperty.call(array, i)) {
        if (receiver == null) iterator(array[i], i, array);
        else iterator.call(receiver, array[i], i, array);
    }
};
var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++)// no such thing as a sparse string.
    if (receiver == null) iterator(string.charAt(i), i, string);
    else iterator.call(receiver, string.charAt(i), i, string);
};
var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object)if (hasOwnProperty.call(object, k)) {
        if (receiver == null) iterator(object[k], k, object);
        else iterator.call(receiver, object[k], k, object);
    }
};
var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
    var receiver;
    if (arguments.length >= 3) receiver = thisArg;
    if (toStr.call(list) === "[object Array]") forEachArray(list, iterator, receiver);
    else if (typeof list === "string") forEachString(list, iterator, receiver);
    else forEachObject(list, iterator, receiver);
};
module.exports = forEach;

},{"e50ebc24bbb25feb":"9ocyk"}],"9ocyk":[function(require,module,exports) {
"use strict";
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") try {
    badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
            throw isCallableMarker;
        }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function() {
        throw 42;
    }, null, badArrayLike);
} catch (_) {
    if (_ !== isCallableMarker) reflectApply = null;
}
else reflectApply = null;
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) return false;
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]"; // IE 11
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === "object") {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) isDDA = function isDocumentDotAll(value) {
        /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
             || str === objectClass // IE 6-8
            ) && value("") == null; // eslint-disable-line eqeqeq
        } catch (e) {}
        return false;
    };
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) return false;
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    if (hasToStringTag) return tryFunctionObject(value);
    if (isES6ClassFn(value)) return false;
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) return false;
    return tryFunctionObject(value);
};

},{}],"kfela":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var possibleNames = require("3021d1584ad62785");
var g = typeof globalThis === "undefined" ? global : globalThis;
/** @type {import('.')} */ module.exports = function availableTypedArrays() {
    var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
    for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === "function") // @ts-expect-error
    out[out.length] = possibleNames[i];
    return out;
};

},{"3021d1584ad62785":"2CagV"}],"2CagV":[function(require,module,exports) {
"use strict";
/** @type {import('.')} */ module.exports = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
];

},{}],"1ihkG":[function(require,module,exports) {
"use strict";
var whichTypedArray = require("ccf73e5f240c2b8");
/** @type {import('.')} */ module.exports = function isTypedArray(value) {
    return !!whichTypedArray(value);
};

},{"ccf73e5f240c2b8":"lVUO7"}],"inNNy":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};

},{}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"lQlQt":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
var process = require("228da2c254a5e871");
"use strict";
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) _construct = Reflect.construct.bind();
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
var _require = require("9984e91d63ed614c"), inspect = _require.inspect;
var _require2 = require("1670766d7c5cef96"), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return "";
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while(count){
        str += str;
        count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
}
var blue = "";
var green = "";
var red = "";
var white = "";
var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
};
// Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
    var keys = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys.forEach(function(key) {
        target[key] = source[key];
    });
    Object.defineProperty(target, "message", {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    // The util.inspect default values could be changed. This makes sure the
    // error messages contain the necessary information nevertheless.
    return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i = 0;
    var indicator = "";
    // In case both values are objects explicitly mark them as not reference equal
    // for the `strictEqual` operator.
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) operator = "strictEqualObject";
    // If "actual" and "expected" fit on a single line and they are not strictly
    // equal, check further special handling.
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        // If the character length of "actual" and "expected" together is less than
        // kMaxShortLength and if neither is an object and at least one of them is
        // not `zero`, use the strict equal comparison to visualize the output.
        if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) // -0 === +0
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        } else if (operator !== "strictEqualObject") {
            // If the stderr is a tty and the input length is lower than the current
            // columns per line, add a mismatch indicator below the output. If it is
            // not a tty, use a default value of 80 characters.
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
                while(actualLines[0][i] === expectedLines[0][i])i++;
                // Ignore the first characters.
                if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = "\n  ".concat(repeat(" ", i), "^");
                    i = 0;
                }
            }
        }
    }
    // Remove all ending lines that match (this optimizes the output for
    // readability by reducing the number of total changed lines).
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while(a === b){
        if (i++ < 2) end = "\n  ".concat(a).concat(end);
        else other = a;
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length);
    // Strict equal with identical objects that are not identical by reference.
    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
    if (maxLines === 0) {
        // We have to get the result again. The lines were all removed before.
        var _actualLines = actualInspected.split("\n");
        // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while(_actualLines.length > 27)_actualLines.pop();
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
    }
    if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for(i = 0; i < maxLines; i++){
        // Only extra expected lines exist
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(expectedLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(expectedLines[i - 1]);
                printedLines++;
            }
            // Mark the current line as the last diverging one.
            lastPos = i;
            // Add the expected line to the cache.
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
        // Only extra actual lines exist
        } else if (expectedLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(actualLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
            }
            // Mark the current line as the last diverging one.
            lastPos = i;
            // Add the actual line to the result.
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
        // Lines diverge
        } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            // If the lines diverge, specifically check for lines that only diverge by
            // a trailing comma. In that case it is actually identical and we should
            // mark it as such.
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
            // If the expected line has a trailing comma but is otherwise identical,
            // add a comma at the end of the actual line. Otherwise the output could
            // look weird as in:
            //
            //   [
            //     1         // No comma at the end!
            // +   2
            //   ]
            //
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ",";
            }
            if (divergingLines) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                    if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                    } else if (cur > 3) {
                        res += "\n  ".concat(actualLines[i - 2]);
                        printedLines++;
                    }
                    res += "\n  ".concat(actualLines[i - 1]);
                    printedLines++;
                }
                // Mark the current line as the last diverging one.
                lastPos = i;
                // Add the actual line to the result and cache the expected diverging
                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                printedLines += 2;
            // Lines are identical
            } else {
                // Add all cached information to the result before adding other things
                // and reset the cache.
                res += other;
                other = "";
                // If the last diverging line is exactly one line above or if it is the
                // very first line, add the line to the result.
                if (cur === 1 || i === 0) {
                    res += "\n  ".concat(actualLine);
                    printedLines++;
                }
            }
        }
        // Inspected object to big (Show ~20 rows max)
        if (printedLines > 20 && i < maxLines - 2) return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/ function(_Error, _inspect$custom) {
    _inherits(AssertionError, _Error);
    var _super = _createSuper(AssertionError);
    function AssertionError(options) {
        var _this;
        _classCallCheck(this, AssertionError);
        if (_typeof(options) !== "object" || options === null) throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) _this = _super.call(this, String(message));
        else {
            if (process.stderr && process.stderr.isTTY) {
                // Reset on each call to make sure we handle dynamically set environment
                // variables correct.
                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                    blue = "\x1b[34m";
                    green = "\x1b[32m";
                    white = "\x1b[39m";
                    red = "\x1b[31m";
                } else {
                    blue = "";
                    green = "";
                    white = "";
                    red = "";
                }
            }
            // Prevent the error stack from being visible by duplicating the error
            // in a very close way to the original in case both sides are actually
            // instances of Error.
            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") _this = _super.call(this, createErrDiff(actual, expected, operator));
            else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                // In case the objects are equal but the operator requires unequal, show
                // the first object and say A equals B
                var base = kReadableOperator[operator];
                var res = inspectValue(actual).split("\n");
                // In case "actual" is an object, it should not be reference equal.
                if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) base = kReadableOperator.notStrictEqualObject;
                // Only remove lines in case it makes sense to collapse those.
                // TODO: Accept env to always show the full error.
                if (res.length > 30) {
                    res[26] = "".concat(blue, "...").concat(white);
                    while(res.length > 27)res.pop();
                }
                // Only print a single input.
                if (res.length === 1) _this = _super.call(this, "".concat(base, " ").concat(res[0]));
                else _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
            } else {
                var _res = inspectValue(actual);
                var other = "";
                var knownOperators = kReadableOperator[operator];
                if (operator === "notDeepEqual" || operator === "notEqual") {
                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                    if (_res.length > 1024) _res = "".concat(_res.slice(0, 1021), "...");
                } else {
                    other = "".concat(inspectValue(expected));
                    if (_res.length > 512) _res = "".concat(_res.slice(0, 509), "...");
                    if (other.length > 512) other = "".concat(other.slice(0, 509), "...");
                    if (operator === "deepEqual" || operator === "equal") _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                    else other = " ".concat(operator, " ").concat(other);
                }
                _this = _super.call(this, "".concat(_res).concat(other));
            }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) // eslint-disable-next-line no-restricted-syntax
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        // Create error message including the error code in the name.
        _this.stack;
        // Reset the name.
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError, [
        {
            key: "toString",
            value: function toString() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
            }
        },
        {
            key: _inspect$custom,
            value: function value(recurseTimes, ctx) {
                // This limits the `actual` and `expected` property default inspection to
                // the minimum depth. Otherwise those values would be too verbose compared
                // to the actual error message which contains a combined view of these two
                // input values.
                return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
                    customInspect: false,
                    depth: 0
                }));
            }
        }
    ]);
    return AssertionError;
}(/*#__PURE__*/ _wrapNativeSuper(Error), inspect.custom);
module.exports = AssertionError;

},{"228da2c254a5e871":"d5jf4","9984e91d63ed614c":"cxohQ","1670766d7c5cef96":"cwQVR"}],"ajEZo":[function(require,module,exports) {
"use strict";
var implementation = require("b7e83063a8ec29e5");
var lacksProperEnumerationOrder = function() {
    if (!Object.assign) return false;
    /*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */ var str = "abcdefghijklmnopqrst";
    var letters = str.split("");
    var map = {};
    for(var i = 0; i < letters.length; ++i)map[letters[i]] = letters[i];
    var obj = Object.assign({}, map);
    var actual = "";
    for(var k in obj)actual += k;
    return str !== actual;
};
var assignHasPendingExceptions = function() {
    if (!Object.assign || !Object.preventExtensions) return false;
    /*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */ var thrower = Object.preventExtensions({
        1: 2
    });
    try {
        Object.assign(thrower, "xy");
    } catch (e) {
        return thrower[1] === "y";
    }
    return false;
};
module.exports = function getPolyfill() {
    if (!Object.assign) return implementation;
    if (lacksProperEnumerationOrder()) return implementation;
    if (assignHasPendingExceptions()) return implementation;
    return Object.assign;
};

},{"b7e83063a8ec29e5":"jttW1"}],"jttW1":[function(require,module,exports) {
"use strict";
// modified from https://github.com/es-shims/es6-shim
var objectKeys = require("334c0bea01e613e6");
var hasSymbols = require("1964e25feb5e87a1")();
var callBound = require("6fb85b5b56dcab21");
var toObject = Object;
var $push = callBound("Array.prototype.push");
var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
    if (target == null) throw new TypeError("target must be an object");
    var to = toObject(target); // step 1
    if (arguments.length === 1) return to; // step 2
    for(var s = 1; s < arguments.length; ++s){
        var from = toObject(arguments[s]); // step 3.a.i
        // step 3.a.ii:
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
            var syms = getSymbols(from);
            for(var j = 0; j < syms.length; ++j){
                var key = syms[j];
                if ($propIsEnumerable(from, key)) $push(keys, key);
            }
        }
        // step 3.a.iii:
        for(var i = 0; i < keys.length; ++i){
            var nextKey = keys[i];
            if ($propIsEnumerable(from, nextKey)) {
                var propValue = from[nextKey]; // step 3.a.iii.2.a
                to[nextKey] = propValue; // step 3.a.iii.2.b
            }
        }
    }
    return to; // step 4
};

},{"334c0bea01e613e6":"eNyf4","1964e25feb5e87a1":"euYk7","6fb85b5b56dcab21":"5yYiF"}],"eNyf4":[function(require,module,exports) {
"use strict";
var slice = Array.prototype.slice;
var isArgs = require("93e8460f624c96f4");
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
} : require("344bb0d7b2568e03");
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) Object.keys = function keys(object) {
            if (isArgs(object)) return originalKeys(slice.call(object));
            return originalKeys(object);
        };
    } else Object.keys = keysShim;
    return Object.keys || keysShim;
};
module.exports = keysShim;

},{"93e8460f624c96f4":"1HhOq","344bb0d7b2568e03":"aV01q"}],"1HhOq":[function(require,module,exports) {
"use strict";
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    return isArgs;
};

},{}],"aV01q":[function(require,module,exports) {
"use strict";
var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = require("b0d8c8b84be91ffd"); // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
    var dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = function() {
        /* global window */ if (typeof window === "undefined") return false;
        for(var k in window)try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") try {
                equalsConstructorPrototype(window[k]);
            } catch (e) {
                return true;
            }
        } catch (e) {
            return true;
        }
        return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */ if (typeof window === "undefined" || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };
    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) throw new TypeError("Object.keys called on a non-object");
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
        if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
        else {
            for(var name in object)if (!(skipProto && name === "prototype") && has.call(object, name)) theKeys.push(String(name));
        }
        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
        }
        return theKeys;
    };
}
module.exports = keysShim;

},{"b0d8c8b84be91ffd":"1HhOq"}],"ezjA5":[function(require,module,exports) {
"use strict";
var implementation = require("ff80ab827617d6fd");
module.exports = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation;
};

},{"ff80ab827617d6fd":"WLxcH"}],"WLxcH":[function(require,module,exports) {
"use strict";
var numberIsNaN = function(value) {
    return value !== value;
};
module.exports = function is(a, b) {
    if (a === 0 && b === 0) return 1 / a === 1 / b;
    if (a === b) return true;
    if (numberIsNaN(a) && numberIsNaN(b)) return true;
    return false;
};

},{}],"d5TM9":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
    var array = [];
    set.forEach(function(value) {
        return array.push(value);
    });
    return array;
};
var arrayFromMap = function arrayFromMap(map) {
    var array = [];
    map.forEach(function(value, key) {
        return array.push([
            key,
            value
        ]);
    });
    return array;
};
var objectIs = Object.is ? Object.is : require("3addb16fbdd05c1c");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : require("a27e57a3fd2e2e23");
function uncurryThis(f) {
    return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = require("4940125679601087").types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
    if (key.length === 0 || key.length > 10) return true;
    for(var i = 0; i < key.length; i++){
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
    }
    // The maximum size for an array is 2 ** 32 -1.
    return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
}
// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;
// Check if they have the same source and flags
function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    for(var offset = 0; offset < a.byteLength; offset++){
        if (a[offset] !== b[offset]) return false;
    }
    return true;
}
function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    if (isStringObject(val1)) return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    if (isBooleanObject(val1)) return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    if (isBigIntObject(val1)) return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}
// Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.
function innerDeepEqual(val1, val2, strict, memos) {
    // All identical values are equivalent, as determined by ===.
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
    }
    // Check more closely if val1 and val2 are equal.
    if (strict) {
        if (_typeof(val1) !== "object") return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) return false;
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) return false;
    } else {
        if (val1 === null || _typeof(val1) !== "object") {
            if (val2 === null || _typeof(val2) !== "object") // eslint-disable-next-line eqeqeq
            return val1 == val2;
            return false;
        }
        if (val2 === null || _typeof(val2) !== "object") return false;
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) return false;
    if (Array.isArray(val1)) {
        // Check for sparse arrays and general fast path
        if (val1.length !== val2.length) return false;
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    }
    // [browserify] This triggers on certain types in IE (Map/Set) so we don't
    // wan't to early return out of the rest of the checks. However we can check
    // if the second value is one of these values and the first isn't.
    if (val1Tag === "[object Object]") {
        // return keyCheck(val1, val2, strict, memos, kNoIterator);
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) return false;
    }
    if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) return false;
    } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) return false;
    } else if (isNativeError(val1) || val1 instanceof Error) {
        // Do not compare the stack as it might differ even though the error itself
        // is otherwise identical.
        if (val1.message !== val2.message || val1.name !== val2.name) return false;
    } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) return false;
        } else if (!areSimilarTypedArrays(val1, val2)) return false;
        // Buffer.compare returns true, so val1.length === val2.length. If they both
        // only contain numeric keys, we don't need to exam further than checking
        // the symbols.
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) return false;
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) return false;
    return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
    return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
    });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    // For all remaining Object pairs, including Array, objects and Maps,
    // equivalence is determined by having:
    // a) The same number of owned enumerable properties
    // b) The same set of keys/indexes (although not necessarily the same order)
    // c) Equivalent values for every corresponding key/index
    // d) For Sets and Maps, equal contents
    // Note: this accounts for both named and indexed properties on Arrays.
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        // The pair must have the same number of owned properties.
        if (aKeys.length !== bKeys.length) return false;
    }
    // Cheap key test
    var i = 0;
    for(; i < aKeys.length; i++){
        if (!hasOwnProperty(val2, aKeys[i])) return false;
    }
    if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            var count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                var key = symbolKeysA[i];
                if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) return false;
                    aKeys.push(key);
                    count++;
                } else if (propertyIsEnumerable(val2, key)) return false;
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) return false;
        } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) return false;
        }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) return true;
    // Use memos to handle cycles.
    if (memos === undefined) memos = {
        val1: new Map(),
        val2: new Map(),
        position: 0
    };
    else {
        // We prevent up to two map.has(x) calls by directly retrieving the value
        // and checking for undefined. The map can only contain numbers, so it is
        // safe to check for undefined only.
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) return val2MemoA === val2MemoB;
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
    // Go looking.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
            // Remove the matching element to make sure we do not check that again.
            set.delete(val2);
            return true;
        }
    }
    return false;
}
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
    switch(_typeof(prim)){
        case "undefined":
            return null;
        case "object":
            // Only pass in null as object!
            return undefined;
        case "symbol":
            return false;
        case "string":
            prim = +prim;
        // Loose equal entries exist only if the string is possible to convert to
        // a regular number and not NaN.
        // Fall through
        case "number":
            if (numberIsNaN(prim)) return false;
    }
    return true;
}
function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    var curB = b.get(altValue);
    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) return false;
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
    // This is a lazily initiated Set of entries which have to be compared
    // pairwise.
    var set = null;
    var aValues = arrayFromSet(a);
    for(var i = 0; i < aValues.length; i++){
        var val = aValues[i];
        // Note: Checking for the objects first improves the performance for object
        // heavy sets but it is a minor slow down for primitives. As they are fast
        // to check this improves the worst case scenario instead.
        if (_typeof(val) === "object" && val !== null) {
            if (set === null) set = new Set();
            // If the specified value doesn't exist in the second set its an not null
            // object (or non strict only: a not matching primitive) we'll need to go
            // hunting for something thats deep-(strict-)equal to it. To make this
            // O(n log n) complexity we have to copy these values in a new set first.
            set.add(val);
        } else if (!b.has(val)) {
            if (strict) return false;
            // Fast path to detect missing string, symbol, undefined and null values.
            if (!setMightHaveLoosePrim(a, b, val)) return false;
            if (set === null) set = new Set();
            set.add(val);
        }
    }
    if (set !== null) {
        var bValues = arrayFromSet(b);
        for(var _i = 0; _i < bValues.length; _i++){
            var _val = bValues[_i];
            // We have to check if a primitive value is already
            // matching and only if it's not, go hunting for it.
            if (_typeof(_val) === "object" && _val !== null) {
                if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    // To be able to handle cases like:
    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
    // ... we need to consider *all* matching keys, not just the first we find.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for(var i = 0; i < aEntries.length; i++){
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
            if (set === null) set = new Set();
            set.add(key);
        } else {
            // By directly retrieving the value we prevent another b.has(key) check in
            // almost all possible cases.
            var item2 = b.get(key);
            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                if (strict) return false;
                // Fast path to detect missing string, symbol, undefined and null
                // keys.
                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                if (set === null) set = new Set();
                set.add(key);
            }
        }
    }
    if (set !== null) {
        var bEntries = arrayFromMap(b);
        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(_key) === "object" && _key !== null) {
                if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
    // Sets and maps don't have their entries accessible via normal object
    // properties.
    var i = 0;
    if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsArray) for(; i < a.length; i++){
        if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) return false;
        } else if (hasOwnProperty(b, i)) return false;
        else {
            // Array is sparse.
            var keysA = Object.keys(a);
            for(; i < keysA.length; i++){
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) return false;
            }
            if (keysA.length !== Object.keys(b).length) return false;
            return true;
        }
    }
    // The pair must have equivalent values for every corresponding key.
    // Possibly expensive deep test:
    for(i = 0; i < keys.length; i++){
        var _key2 = keys[i];
        if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) return false;
    }
    return true;
}
function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
    isDeepEqual: isDeepEqual,
    isDeepStrictEqual: isDeepStrictEqual
};

},{"3addb16fbdd05c1c":"k2tpA","a27e57a3fd2e2e23":"hY4fH","4940125679601087":"cxohQ"}],"k2tpA":[function(require,module,exports) {
"use strict";
var define = require("7a0bb7df335a6af");
var callBind = require("794ce1103c4a65ba");
var implementation = require("f52a71fcf365d3bd");
var getPolyfill = require("59addbaef079e040");
var shim = require("c0e8b0f7342ba484");
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"7a0bb7df335a6af":"6eq5U","794ce1103c4a65ba":"bfo8D","f52a71fcf365d3bd":"WLxcH","59addbaef079e040":"ezjA5","c0e8b0f7342ba484":"9p2yJ"}],"6eq5U":[function(require,module,exports) {
"use strict";
var keys = require("7ff177585d1618f0");
var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = require("84ca194f5a28ce70");
var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
};
var supportsDescriptors = require("c52d62086511583f")();
var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
        if (predicate === true) {
            if (object[name] === value) return;
        } else if (!isFunction(predicate) || !predicate()) return;
    }
    if (supportsDescriptors) defineDataProperty(object, name, value, true);
    else defineDataProperty(object, name, value);
};
var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) props = concat.call(props, Object.getOwnPropertySymbols(map));
    for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

},{"7ff177585d1618f0":"eNyf4","84ca194f5a28ce70":"6cEff","c52d62086511583f":"esBLZ"}],"9p2yJ":[function(require,module,exports) {
"use strict";
var getPolyfill = require("f188d636391a5061");
var define = require("155865cffc557cd");
module.exports = function shimObjectIs() {
    var polyfill = getPolyfill();
    define(Object, {
        is: polyfill
    }, {
        is: function testObjectIs() {
            return Object.is !== polyfill;
        }
    });
    return polyfill;
};

},{"f188d636391a5061":"ezjA5","155865cffc557cd":"6eq5U"}],"hY4fH":[function(require,module,exports) {
"use strict";
var callBind = require("8bc778ead6edc2b");
var define = require("1e9a111647ec40d6");
var implementation = require("db9e8266e38a0a1c");
var getPolyfill = require("37ae20d268339d21");
var shim = require("9fe13ad91d3d9c68");
var polyfill = callBind(getPolyfill(), Number);
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"8bc778ead6edc2b":"bfo8D","1e9a111647ec40d6":"6eq5U","db9e8266e38a0a1c":"lxsrq","37ae20d268339d21":"h00Nr","9fe13ad91d3d9c68":"cr2es"}],"lxsrq":[function(require,module,exports) {
"use strict";
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function isNaN(value) {
    return value !== value;
};

},{}],"h00Nr":[function(require,module,exports) {
"use strict";
var implementation = require("e25466f067cfd8fc");
module.exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) return Number.isNaN;
    return implementation;
};

},{"e25466f067cfd8fc":"lxsrq"}],"cr2es":[function(require,module,exports) {
"use strict";
var define = require("6e613ddb8bace1c6");
var getPolyfill = require("f2ce5ac0488eb372");
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function shimNumberIsNaN() {
    var polyfill = getPolyfill();
    define(Number, {
        isNaN: polyfill
    }, {
        isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
        }
    });
    return polyfill;
};

},{"6e613ddb8bace1c6":"6eq5U","f2ce5ac0488eb372":"h00Nr"}],"bNVWy":[function(require,module,exports) {
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
var process = require("145b97b75bbb08f6");
module.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
];
if (process.platform !== "win32") module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");

},{"145b97b75bbb08f6":"d5jf4"}],"1VQLm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"9okfB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addPipeMethods", ()=>addPipeMethods);
var _nodeFs = require("fs");
var _nodeChildProcess = require("child_process");
var _isStream = require("is-stream");
const isExecaChildProcess = (target)=>target instanceof (0, _nodeChildProcess.ChildProcess) && typeof target.then === "function";
const pipeToTarget = (spawned, streamName, target)=>{
    if (typeof target === "string") {
        spawned[streamName].pipe((0, _nodeFs.createWriteStream)(target));
        return spawned;
    }
    if ((0, _isStream.isWritableStream)(target)) {
        spawned[streamName].pipe(target);
        return spawned;
    }
    if (!isExecaChildProcess(target)) throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
    if (!(0, _isStream.isWritableStream)(target.stdin)) throw new TypeError("The target child process's stdin must be available.");
    spawned[streamName].pipe(target.stdin);
    return target;
};
const addPipeMethods = (spawned)=>{
    if (spawned.stdout !== null) spawned.pipeStdout = pipeToTarget.bind(undefined, spawned, "stdout");
    if (spawned.stderr !== null) spawned.pipeStderr = pipeToTarget.bind(undefined, spawned, "stderr");
    if (spawned.all !== undefined) spawned.pipeAll = pipeToTarget.bind(undefined, spawned, "all");
};

},{"node:fs":"bXKEI","node:child_process":"bXKEI","is-stream":"dpmgS","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dpmgS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isStream", ()=>isStream);
parcelHelpers.export(exports, "isWritableStream", ()=>isWritableStream);
parcelHelpers.export(exports, "isReadableStream", ()=>isReadableStream);
parcelHelpers.export(exports, "isDuplexStream", ()=>isDuplexStream);
parcelHelpers.export(exports, "isTransformStream", ()=>isTransformStream);
function isStream(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
    return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
    return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
    return isWritableStream(stream) && isReadableStream(stream);
}
function isTransformStream(stream) {
    return isDuplexStream(stream) && typeof stream._transform === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"23os0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "handleInputSync", ()=>handleInputSync);
parcelHelpers.export(exports, "handleInput", ()=>handleInput);
parcelHelpers.export(exports, "makeAllStream", ()=>makeAllStream);
parcelHelpers.export(exports, "getSpawnedResult", ()=>getSpawnedResult);
var _nodeFs = require("fs");
var _isStream = require("is-stream");
var _getStream = require("get-stream");
var _getStreamDefault = parcelHelpers.interopDefault(_getStream);
var _mergeStream = require("merge-stream");
var _mergeStreamDefault = parcelHelpers.interopDefault(_mergeStream);
const validateInputOptions = (input)=>{
    if (input !== undefined) throw new TypeError("The `input` and `inputFile` options cannot be both set.");
};
const getInputSync = ({ input, inputFile })=>{
    if (typeof inputFile !== "string") return input;
    validateInputOptions(input);
    return (0, _nodeFs.readFileSync)(inputFile);
};
const handleInputSync = (options)=>{
    const input = getInputSync(options);
    if ((0, _isStream.isStream)(input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
    return input;
};
const getInput = ({ input, inputFile })=>{
    if (typeof inputFile !== "string") return input;
    validateInputOptions(input);
    return (0, _nodeFs.createReadStream)(inputFile);
};
const handleInput = (spawned, options)=>{
    const input = getInput(options);
    if (input === undefined) return;
    if ((0, _isStream.isStream)(input)) input.pipe(spawned.stdin);
    else spawned.stdin.end(input);
};
const makeAllStream = (spawned, { all })=>{
    if (!all || !spawned.stdout && !spawned.stderr) return;
    const mixed = (0, _mergeStreamDefault.default)();
    if (spawned.stdout) mixed.add(spawned.stdout);
    if (spawned.stderr) mixed.add(spawned.stderr);
    return mixed;
};
// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const getBufferedData = async (stream, streamPromise)=>{
    // When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
    if (!stream || streamPromise === undefined) return;
    stream.destroy();
    try {
        return await streamPromise;
    } catch (error) {
        return error.bufferedData;
    }
};
const getStreamPromise = (stream, { encoding, buffer, maxBuffer })=>{
    if (!stream || !buffer) return;
    if (encoding) return (0, _getStreamDefault.default)(stream, {
        encoding,
        maxBuffer
    });
    return (0, _getStreamDefault.default).buffer(stream, {
        maxBuffer
    });
};
const getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone)=>{
    const stdoutPromise = getStreamPromise(stdout, {
        encoding,
        buffer,
        maxBuffer
    });
    const stderrPromise = getStreamPromise(stderr, {
        encoding,
        buffer,
        maxBuffer
    });
    const allPromise = getStreamPromise(all, {
        encoding,
        buffer,
        maxBuffer: maxBuffer * 2
    });
    try {
        return await Promise.all([
            processDone,
            stdoutPromise,
            stderrPromise,
            allPromise
        ]);
    } catch (error) {
        return Promise.all([
            {
                error,
                signal: error.signal,
                timedOut: error.timedOut
            },
            getBufferedData(stdout, stdoutPromise),
            getBufferedData(stderr, stderrPromise),
            getBufferedData(all, allPromise)
        ]);
    }
};

},{"node:fs":"bXKEI","is-stream":"dpmgS","get-stream":"5VQsa","merge-stream":"49ZvG","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5VQsa":[function(require,module,exports) {
"use strict";
const { constants: BufferConstants } = require("b678607c84e570b0");
const stream = require("794c80517bf93410");
const { promisify } = require("545ca3362edf2020");
const bufferStream = require("3f06fd998d239c50");
const streamPipelinePromisified = promisify(stream.pipeline);
class MaxBufferError extends Error {
    constructor(){
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
    }
}
async function getStream(inputStream, options) {
    if (!inputStream) throw new Error("Expected a stream");
    options = {
        maxBuffer: Infinity,
        ...options
    };
    const { maxBuffer } = options;
    const stream = bufferStream(options);
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) error.bufferedData = stream.getBufferedValue();
            reject(error);
        };
        (async ()=>{
            try {
                await streamPipelinePromisified(inputStream, stream);
                resolve();
            } catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on("data", ()=>{
            if (stream.getBufferedLength() > maxBuffer) rejectPromise(new MaxBufferError());
        });
    });
    return stream.getBufferedValue();
}
module.exports = getStream;
module.exports.buffer = (stream, options)=>getStream(stream, {
        ...options,
        encoding: "buffer"
    });
module.exports.array = (stream, options)=>getStream(stream, {
        ...options,
        array: true
    });
module.exports.MaxBufferError = MaxBufferError;

},{"b678607c84e570b0":"fCgem","794c80517bf93410":"j77ns","545ca3362edf2020":"cxohQ","3f06fd998d239c50":"lEnYf"}],"j77ns":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require("96b62835346f84f0").EventEmitter;
var inherits = require("4a6ee9586f51c38d");
inherits(Stream, EE);
Stream.Readable = require("e6206e1f4d20abc7");
Stream.Writable = require("a3f1405f37e1dfb1");
Stream.Duplex = require("6691a72c5fc222fd");
Stream.Transform = require("43a905ce7ec6ac9e");
Stream.PassThrough = require("dd715550d7783885");
Stream.finished = require("d90a3520974ec96e");
Stream.pipeline = require("eb2779cfd287c5c9");
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on("drain", ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"96b62835346f84f0":"1VQLm","4a6ee9586f51c38d":"bRL3M","e6206e1f4d20abc7":"6NdbQ","a3f1405f37e1dfb1":"gTkcq","6691a72c5fc222fd":"kKNA3","43a905ce7ec6ac9e":"ba8Mr","dd715550d7783885":"2xP98","d90a3520974ec96e":"aOMy2","eb2779cfd287c5c9":"fyp4t"}],"6NdbQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var global = arguments[3];
var process = require("896ff8d56553f7a");
"use strict";
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require("16782d660ac22e0c").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("9a34f23fa53f83f7");
/*</replacement>*/ var Buffer = require("fb95ecaa88342eae").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require("a4a723b7297c7152");
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
else debug = function debug() {};
/*</replacement>*/ var BufferList = require("7a14cc1689b8c63e");
var destroyImpl = require("efa8155386cc4283");
var _require = require("994c984d08c7bbf2"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("8de60461b822641b").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require("19affa8ce41f090d")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++)stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require("830c56f840811f05");
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
    if (from === undefined) from = require("7451b8c4bf72370");
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"896ff8d56553f7a":"d5jf4","16782d660ac22e0c":"1VQLm","9a34f23fa53f83f7":"60BLS","fb95ecaa88342eae":"fCgem","a4a723b7297c7152":"bXKEI","7a14cc1689b8c63e":"hf3P2","efa8155386cc4283":"YI8DF","994c984d08c7bbf2":"61BRN","8de60461b822641b":"aJlwj","19affa8ce41f090d":"bRL3M","f1c95f846e94e4eb":"kKNA3","6392acd10886f115":"3vmkr","830c56f840811f05":"k019Y","7451b8c4bf72370":"ak0YH"}],"60BLS":[function(require,module,exports) {
module.exports = require("ed88fc9aa73f911").EventEmitter;

},{"ed88fc9aa73f911":"1VQLm"}],"hf3P2":[function(require,module,exports) {
"use strict";
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = require("59f5d0111b7fa075"), Buffer = _require.Buffer;
var _require2 = require("eef6a677577349b8"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

},{"59f5d0111b7fa075":"fCgem","eef6a677577349b8":"bXKEI"}],"YI8DF":[function(require,module,exports) {
var process = require("4284522496af5dfb");
"use strict";
// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"4284522496af5dfb":"d5jf4"}],"61BRN":[function(require,module,exports) {
"use strict";
var ERR_INVALID_OPT_VALUE = require("4e508d569e2117ef").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"4e508d569e2117ef":"aJlwj"}],"aJlwj":[function(require,module,exports) {
"use strict";
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.codes = codes;

},{}],"kKNA3":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
var process = require("2ab1115635c50a9f");
"use strict";
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require("68a7582259cd5865");
var Writable = require("93d042f8bb80078e");
require("aa7b11ba5bf4defc")(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys = objectKeys(Writable.prototype);
for(var v = 0; v < keys.length; v++){
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"2ab1115635c50a9f":"d5jf4","68a7582259cd5865":"6NdbQ","93d042f8bb80078e":"gTkcq","aa7b11ba5bf4defc":"bRL3M"}],"gTkcq":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
var global = arguments[3];
var process = require("f05a2a5a09d4d8b0");
"use strict";
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require("dc51171b07b54af1")
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("44a3cc22ec64fcd3");
/*</replacement>*/ var Buffer = require("de8f7fb7ccda8086").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require("acf48fb5d9dc6204");
var _require = require("9d146cd974da0f53"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("3c574b8881abcf86").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require("10dad555ffe77dde")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"f05a2a5a09d4d8b0":"d5jf4","dc51171b07b54af1":"j92NQ","44a3cc22ec64fcd3":"60BLS","de8f7fb7ccda8086":"fCgem","acf48fb5d9dc6204":"YI8DF","9d146cd974da0f53":"61BRN","3c574b8881abcf86":"aJlwj","10dad555ffe77dde":"bRL3M","c5e7171d6f58d3c0":"kKNA3"}],"j92NQ":[function(require,module,exports) {
/**
 * Module exports.
 */ var global = arguments[3];
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config("noDeprecation")) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config("throwDeprecation")) throw new Error(msg);
            else if (config("traceDeprecation")) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
}

},{}],"3vmkr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
/*<replacement>*/ var Buffer = require("2a29807c689a070a").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "\uFFFD";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "\uFFFD";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\uFFFD";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

},{"2a29807c689a070a":"eW7r9"}],"eW7r9":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"fCgem"}],"k019Y":[function(require,module,exports) {
var process = require("96b869862a96261a");
"use strict";
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = require("745a3cd8f6469ed5");
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"96b869862a96261a":"d5jf4","745a3cd8f6469ed5":"aOMy2"}],"aOMy2":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var ERR_STREAM_PREMATURE_CLOSE = require("d35458f585bdd360").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;

},{"d35458f585bdd360":"aJlwj"}],"ak0YH":[function(require,module,exports) {
module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
};

},{}],"ba8Mr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = Transform;
var _require$codes = require("baab47252aa06434").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require("db11ebf938e536ed");
require("82049677fa603d40")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"baab47252aa06434":"aJlwj","db11ebf938e536ed":"kKNA3","82049677fa603d40":"bRL3M"}],"2xP98":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = PassThrough;
var Transform = require("7ab21291895ec3d2");
require("f24ec1883eef5e9b")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"7ab21291895ec3d2":"ba8Mr","f24ec1883eef5e9b":"bRL3M"}],"fyp4t":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require("6ba21bd580ac7d57").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = require("dd7fd89dd81b8674");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"6ba21bd580ac7d57":"aJlwj","dd7fd89dd81b8674":"aOMy2"}],"lEnYf":[function(require,module,exports) {
var Buffer = require("34b9b9c9e201b40f").Buffer;
"use strict";
const { PassThrough: PassThroughStream } = require("fc8e941a79feb917");
module.exports = (options)=>{
    options = {
        ...options
    };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) objectMode = !(encoding || isBuffer);
    else encoding = encoding || "utf8";
    if (isBuffer) encoding = null;
    const stream = new PassThroughStream({
        objectMode
    });
    if (encoding) stream.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk)=>{
        chunks.push(chunk);
        if (objectMode) length = chunks.length;
        else length += chunk.length;
    });
    stream.getBufferedValue = ()=>{
        if (array) return chunks;
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = ()=>length;
    return stream;
};

},{"34b9b9c9e201b40f":"fCgem","fc8e941a79feb917":"j77ns"}],"49ZvG":[function(require,module,exports) {
"use strict";
const { PassThrough } = require("31888be9d1b329aa");
module.exports = function() {
    var sources = [];
    var output = new PassThrough({
        objectMode: true
    });
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
        if (Array.isArray(source)) {
            source.forEach(add);
            return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, {
            end: false
        });
        return this;
    }
    function isEmpty() {
        return sources.length == 0;
    }
    function remove(source) {
        sources = sources.filter(function(it) {
            return it !== source;
        });
        if (!sources.length && output.readable) output.end();
    }
};

},{"31888be9d1b329aa":"j77ns"}],"hRdCh":[function(require,module,exports) {
// eslint-disable-next-line unicorn/prefer-top-level-await
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergePromise", ()=>mergePromise);
parcelHelpers.export(exports, "getSpawnedPromise", ()=>getSpawnedPromise);
const nativePromisePrototype = (async ()=>{})().constructor.prototype;
const descriptors = [
    "then",
    "catch",
    "finally"
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
const mergePromise = (spawned, promise)=>{
    for (const [property, descriptor] of descriptors){
        // Starting the main `promise` is deferred to avoid consuming streams
        const value = typeof promise === "function" ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {
            ...descriptor,
            value
        });
    }
};
const getSpawnedPromise = (spawned)=>new Promise((resolve, reject)=>{
        spawned.on("exit", (exitCode, signal)=>{
            resolve({
                exitCode,
                signal
            });
        });
        spawned.on("error", (error)=>{
            reject(error);
        });
        if (spawned.stdin) spawned.stdin.on("error", (error)=>{
            reject(error);
        });
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eoK9g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "joinCommand", ()=>joinCommand);
parcelHelpers.export(exports, "getEscapedCommand", ()=>getEscapedCommand);
parcelHelpers.export(exports, "parseCommand", ()=>parseCommand);
parcelHelpers.export(exports, "parseTemplates", ()=>parseTemplates);
var _nodeBuffer = require("buffer");
var _nodeChildProcess = require("child_process");
const normalizeArgs = (file, args = [])=>{
    if (!Array.isArray(args)) return [
        file
    ];
    return [
        file,
        ...args
    ];
};
const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const DOUBLE_QUOTES_REGEXP = /"/g;
const escapeArg = (arg)=>{
    if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) return arg;
    return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
};
const joinCommand = (file, args)=>normalizeArgs(file, args).join(" ");
const getEscapedCommand = (file, args)=>normalizeArgs(file, args).map((arg)=>escapeArg(arg)).join(" ");
const SPACES_REGEXP = / +/g;
const parseCommand = (command)=>{
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) // Merge previous token with current one
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        else tokens.push(token);
    }
    return tokens;
};
const parseExpression = (expression)=>{
    const typeOfExpression = typeof expression;
    if (typeOfExpression === "string") return expression;
    if (typeOfExpression === "number") return String(expression);
    if (typeOfExpression === "object" && expression !== null && !(expression instanceof (0, _nodeChildProcess.ChildProcess)) && "stdout" in expression) {
        const typeOfStdout = typeof expression.stdout;
        if (typeOfStdout === "string") return expression.stdout;
        if ((0, _nodeBuffer.Buffer).isBuffer(expression.stdout)) return expression.stdout.toString();
        throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
    }
    throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const concatTokens = (tokens, nextTokens, isNew)=>isNew || tokens.length === 0 || nextTokens.length === 0 ? [
        ...tokens,
        ...nextTokens
    ] : [
        ...tokens.slice(0, -1),
        `${tokens[tokens.length - 1]}${nextTokens[0]}`,
        ...nextTokens.slice(1)
    ];
const parseTemplate = ({ templates, expressions, tokens, index, template })=>{
    const templateString = template ?? templates.raw[index];
    const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
    const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(" "));
    if (index === expressions.length) return newTokens;
    const expression = expressions[index];
    const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>parseExpression(expression)) : [
        parseExpression(expression)
    ];
    return concatTokens(newTokens, expressionTokens, templateString.endsWith(" "));
};
const parseTemplates = (templates, expressions)=>{
    let tokens = [];
    for (const [index, template] of templates.entries())tokens = parseTemplate({
        templates,
        expressions,
        tokens,
        index,
        template
    });
    return tokens;
};

},{"node:buffer":"fCgem","node:child_process":"bXKEI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gdbvL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "verboseDefault", ()=>verboseDefault);
parcelHelpers.export(exports, "logCommand", ()=>logCommand);
var _nodeUtil = require("util");
var _nodeProcess = require("process");
var _nodeProcessDefault = parcelHelpers.interopDefault(_nodeProcess);
const verboseDefault = (0, _nodeUtil.debuglog)("execa").enabled;
const padField = (field, padding)=>String(field).padStart(padding, "0");
const getTimestamp = ()=>{
    const date = new Date();
    return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
};
const logCommand = (escapedCommand, { verbose })=>{
    if (!verbose) return;
    (0, _nodeProcessDefault.default).stderr.write(`[${getTimestamp()}] ${escapedCommand}\n`);
};

},{"node:util":"cxohQ","node:process":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1DyUm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "discoverGateway", ()=>discoverGateway);
var _ssdp = require("@achingbrain/ssdp");
var _ssdpDefault = parcelHelpers.interopDefault(_ssdp);
var _logger = require("@libp2p/logger");
var _itFirst = require("it-first");
var _itFirstDefault = parcelHelpers.interopDefault(_itFirst);
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
const log = (0, _logger.logger)("nat-port-mapper:discovery");
const ST = "urn:schemas-upnp-org:device:InternetGatewayDevice:1";
const ONE_MINUTE = 60000;
const ONE_HOUR = ONE_MINUTE * 60;
function discoverGateway(options = {}) {
    const timeout = options.timeout ?? ONE_HOUR;
    const discoveryTimeout = options.discoveryTimeout ?? ONE_MINUTE;
    let service;
    let expires;
    return ()=>{
        let discovery;
        let clear;
        const discover = {
            gateway: async ()=>{
                if (service != null && !(expires < Date.now())) return service;
                if (options.gateway != null) {
                    log("Using overridden gateway address %s", options.gateway);
                    if (!options.gateway.startsWith("http")) options.gateway = `http://${options.gateway}`;
                    expires = Date.now() + timeout;
                    service = {
                        location: new URL(options.gateway),
                        details: {
                            device: {
                                serviceList: {
                                    service: []
                                },
                                deviceList: {
                                    device: []
                                }
                            }
                        },
                        expires,
                        serviceType: ST,
                        uniqueServiceName: "unknown"
                    };
                } else {
                    if (discovery == null) {
                        discovery = await (0, _ssdpDefault.default)({
                            start: false
                        });
                        discovery.on("error", (err)=>{
                            log.error("ssdp error", err);
                        });
                        await discovery.start();
                    }
                    log("Discovering gateway");
                    const clearable = (0, _pTimeoutDefault.default)((0, _itFirstDefault.default)(discovery.discover(ST)), {
                        milliseconds: discoveryTimeout
                    });
                    clear = clearable.clear;
                    const result = await clearable;
                    if (result == null) throw new Error("Could not discover gateway");
                    log("Discovered gateway %s", result.location);
                    service = result;
                    expires = Date.now() + timeout;
                }
                return service;
            },
            cancel: async ()=>{
                if (discovery != null) await discovery.stop();
                if (clear != null) clear();
            }
        };
        return discover;
    };
}

},{"@achingbrain/ssdp":"fscmf","@libp2p/logger":"aeh5U","it-first":"11pUD","p-timeout":"2j2Zi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fscmf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>async function(options = {}) {
        const ssdp = new SSDPImpl(options);
        if (options.start !== false) await ssdp.start();
        return ssdp;
    });
var _events = require("events");
var _eventIterator = require("event-iterator");
var _indexJs = require("./advertise/index.js");
var _advertsJs = require("./adverts.js");
var _notifyJs = require("./commands/notify.js");
var _searchJs = require("./commands/search.js");
var _createSocketsJs = require("./create-sockets.js");
var _defaultSsdpOptionsJs = require("./default-ssdp-options.js");
var _indexJs1 = require("./discover/index.js");
var _searchResponseJs = require("./discover/search-response.js");
var _parseSsdpMessageJs = require("./parse-ssdp-message.js");
var _sendSsdpMessageJs = require("./send-ssdp-message.js");
class SSDPImpl extends (0, _events.EventEmitter) {
    udn;
    signature;
    sockets;
    options;
    abortController;
    constructor(options){
        super();
        this.options = (0, _defaultSsdpOptionsJs.defaultSsdpOptions)(options);
        this.udn = this.options.udn;
        this.signature = this.options.signature;
        this.sockets = [];
        this.abortController = new AbortController();
    }
    async start() {
        // set up UDP sockets listening for SSDP broadcasts
        this.sockets = await (0, _createSocketsJs.createSockets)(this, this.abortController.signal);
        // set up protocol listeners
        this.on("transport:incoming-message", (0, _parseSsdpMessageJs.parseSsdpMessage).bind(null, this));
        this.on("ssdp:send-message", (0, _sendSsdpMessageJs.sendSsdpMessage).bind(null, this));
        this.on("ssdp:m-search", (0, _searchJs.search).bind(null, this));
        this.on("ssdp:notify", (0, _notifyJs.notify).bind(null, this));
        this.on("ssdp:search-response", (0, _searchResponseJs.searchResponse).bind(null, this));
    }
    async stop() {
        await (0, _advertsJs.adverts).stopAll();
        await Promise.all(this.sockets.map(async (socket)=>{
            await new Promise((resolve)=>{
                socket.on("close", ()=>{
                    resolve();
                });
                socket.close();
                socket.closed = true;
            });
        }));
        this.abortController.abort();
    }
    async advertise(advert) {
        return (0, _indexJs.advertise)(this, advert);
    }
    async *discover(serviceType) {
        const iterator = new (0, _eventIterator.EventIterator)(({ push })=>{
            const listener = (service)=>{
                if (serviceType != null && service.serviceType !== serviceType) return;
                push(service);
            };
            this.addListener("service:discover", listener);
            return ()=>{
                this.removeListener("service:discover", listener);
            };
        });
        (0, _indexJs1.discover)(this, serviceType);
        yield* iterator;
    }
}

},{"events":"1VQLm","event-iterator":"fULWt","./advertise/index.js":"aag3U","./adverts.js":"dLY1T","./commands/notify.js":"dTg93","./commands/search.js":"24uxn","./create-sockets.js":"fJDyh","./default-ssdp-options.js":"8MZWH","./discover/index.js":"jqVYe","./discover/search-response.js":"86Dqm","./parse-ssdp-message.js":"e8LTb","./send-ssdp-message.js":"kGTyT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fULWt":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const event_iterator_1 = require("45071f5384d6531d");
exports.EventIterator = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({ push })=>{
        this.addEventListener(event, push, options);
        return ()=>this.removeEventListener(event, push, options);
    }, evOptions);
}
exports.subscribe = subscribe;
exports.default = event_iterator_1.EventIterator;

},{"45071f5384d6531d":"iIzBm"}],"iIzBm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
class EventQueue {
    constructor(){
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
    }
    push(value) {
        if (this.isStopped) return;
        const resolution = {
            value,
            done: false
        };
        if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder) placeholder.resolve(resolution);
        } else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
                this.isPaused = true;
                if (this.eventHandlers.highWater) this.eventHandlers.highWater();
                else if (console) console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
        }
    }
    stop() {
        if (this.isStopped) return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue)placeholder.resolve({
            value: undefined,
            done: true
        });
        this.pullQueue.length = 0;
    }
    fail(error) {
        if (this.isStopped) return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue)placeholder.reject(error);
            this.pullQueue.length = 0;
        } else {
            const rejection = Promise.reject(error);
            /* Attach error handler to avoid leaking an unhandled promise rejection. */ rejection.catch(()=>{});
            this.pushQueue.push(rejection);
        }
    }
    remove() {
        Promise.resolve().then(()=>{
            if (this.removeCallback) this.removeCallback();
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: (value)=>{
                const result = this.pushQueue.shift();
                if (result) {
                    if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                        this.isPaused = false;
                        if (this.eventHandlers.lowWater) this.eventHandlers.lowWater();
                    }
                    return result;
                } else if (this.isStopped) return Promise.resolve({
                    value: undefined,
                    done: true
                });
                else return new Promise((resolve, reject)=>{
                    this.pullQueue.push({
                        resolve,
                        reject
                    });
                });
            },
            return: ()=>{
                this.isStopped = true;
                this.pushQueue.length = 0;
                this.remove();
                return Promise.resolve({
                    value: undefined,
                    done: true
                });
            }
        };
    }
}
class EventIterator {
    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}){
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
            push: (value)=>queue.push(value),
            stop: ()=>queue.stop(),
            fail: (error)=>queue.fail(error),
            on: (event, fn)=>{
                queue.eventHandlers[event] = fn;
            }
        }) || (()=>{});
        this[Symbol.asyncIterator] = ()=>queue[Symbol.asyncIterator]();
        Object.freeze(this);
    }
}
exports.EventIterator = EventIterator;
exports.default = EventIterator;

},{}],"aag3U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "advertise", ()=>advertise);
var _advertsJs = require("../adverts.js");
var _notifyJs = require("../commands/notify.js");
var _broadcastAdvertJs = require("./broadcast-advert.js");
var _createLocationJs = require("./create-location.js");
var _parseOptionsJs = require("./parse-options.js");
async function advertise(ssdp, options) {
    const advert = (0, _parseOptionsJs.parseAdvertOptions)(ssdp, options);
    const shutDownServers = await (0, _createLocationJs.createLocation)(ssdp, advert);
    let timeout;
    const broadcast = ()=>{
        (0, _broadcastAdvertJs.broadcastAdvert)(ssdp, advert, (0, _notifyJs.ALIVE));
        timeout = setTimeout(broadcast, advert.interval);
    };
    // send ssdp:byebye then ssdp:alive
    // see: https://msdn.microsoft.com/en-us/library/cc247331.aspx
    (0, _broadcastAdvertJs.broadcastAdvert)(ssdp, advert, (0, _notifyJs.BYEBYE));
    broadcast();
    const ad = {
        service: advert,
        stop: async ()=>{
            clearTimeout(timeout);
            // tell the network we are going away
            (0, _broadcastAdvertJs.broadcastAdvert)(ssdp, advert, (0, _notifyJs.BYEBYE));
            await shutDownServers();
            // remove advert from list
            (0, _advertsJs.adverts).remove(ad);
        }
    };
    (0, _advertsJs.adverts).add(ad);
    return ad;
}

},{"../adverts.js":"dLY1T","../commands/notify.js":"dTg93","./broadcast-advert.js":"br8tl","./create-location.js":"bJzwd","./parse-options.js":"66mRS","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dLY1T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "adverts", ()=>adverts);
class Adverts {
    adverts;
    constructor(){
        this.adverts = [];
    }
    add(advert) {
        this.adverts.push(advert);
    }
    remove(advert) {
        this.adverts = this.adverts.filter((ad)=>ad !== advert);
    }
    clear() {
        this.adverts = [];
    }
    forEach(fn) {
        this.adverts.forEach((ad)=>{
            fn(ad.service);
        });
    }
    async stopAll() {
        await Promise.all(this.adverts.map(async (ad)=>ad.stop()));
    }
}
const adverts = new Adverts();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dTg93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ALIVE", ()=>ALIVE);
parcelHelpers.export(exports, "BYEBYE", ()=>BYEBYE);
parcelHelpers.export(exports, "notify", ()=>notify);
var _cacheJs = require("../cache.js");
var _resolveServiceJs = require("./resolve-service.js");
const ALIVE = "ssdp:alive";
const BYEBYE = "ssdp:byebye";
function notify(ssdp, message) {
    if (message.LOCATION == null || message.USN == null || message.NT == null || message.NTS == null) return;
    if (message.NTS === BYEBYE) {
        (0, _cacheJs.cache).deleteService(message.NT, message.USN);
        ssdp.emit("service:remove", message.USN);
        return;
    }
    (0, _resolveServiceJs.resolveService)(ssdp, message.USN, message.NT, message.LOCATION, message.ttl()).catch((err)=>{
        ssdp.emit("error", err);
    });
}

},{"../cache.js":"eGE8X","./resolve-service.js":"ep6Kz","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eGE8X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cache", ()=>cache);
class Cache {
    // service type => unique service name => service
    services;
    constructor(){
        this.services = new Map();
    }
    hasService(serviceType, uniqueServiceName) {
        const instances = this.services.get(serviceType);
        if (instances == null) return false;
        return instances.has(uniqueServiceName);
    }
    getService(serviceType, uniqueServiceName) {
        const instances = this.services.get(serviceType);
        if (instances == null) return;
        const service = instances.get(uniqueServiceName);
        if (service == null) return;
        return service;
    }
    deleteService(serviceType, uniqueServiceName) {
        const instances = this.services.get(serviceType);
        if (instances == null) return;
        instances.delete(uniqueServiceName);
        if (instances.size === 0) this.services.delete(serviceType);
    }
    cacheService(service) {
        const instances = this.services.get(service.serviceType) ?? new Map();
        instances.set(service.uniqueServiceName, service);
        this.services.set(service.serviceType, instances);
    }
    clear() {
        this.services = new Map();
    }
}
const cache = new Cache();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ep6Kz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveService", ()=>resolveService);
var _cacheJs = require("../cache.js");
var _resolveLocationJs = require("./resolve-location.js");
async function resolveService(ssdp, usn, st, location, ttl) {
    // all arguments are required
    if (ssdp == null || usn == null || st == null || location == null || ttl == null) return;
    let newService = false;
    let service = (0, _cacheJs.cache).getService(st, usn);
    if (service == null) {
        newService = true;
        service = {
            location: new URL(location),
            details: {
                pending: true
            },
            expires: 0,
            serviceType: st,
            uniqueServiceName: usn
        };
        (0, _cacheJs.cache).cacheService(service);
    }
    if (!newService) {
        if (service.details.pending === true) // not yet loaded the advert details
        return;
    }
    let oldDetails = null;
    if (!newService) oldDetails = JSON.stringify(service.details);
    try {
        service.details = await (0, _resolveLocationJs.resolveLocation)(location);
        service.expires = Date.now() + ttl;
        (0, _cacheJs.cache).cacheService(service);
        if (oldDetails === JSON.stringify(service.details)) // details have not changed, ignore the notify
        return;
        if (newService) ssdp.emit("service:discover", service);
        else ssdp.emit("service:update", service);
    } catch (err) {
        // remove it so we can try again later
        (0, _cacheJs.cache).deleteService(st, usn);
        ssdp.emit("error", err);
    }
}

},{"../cache.js":"eGE8X","./resolve-location.js":"9YP0a","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"9YP0a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveLocation", ()=>resolveLocation);
var _xml2Js = require("xml2js");
var _fetchJs = require("../fetch.js");
async function resolveLocation(location) {
    if (location.substring(0, 4) !== "http") location = `http://${location}`;
    const text = await (0, _fetchJs.fetch)(location, {
        method: "GET",
        headers: {
            accept: "application/xml"
        }
    });
    const result = await (0, _xml2Js.parseStringPromise)(text, {
        normalize: true,
        explicitArray: false,
        explicitRoot: true
    });
    if (result == null) return {};
    return result.root ?? result;
}

},{"xml2js":"7fkbn","../fetch.js":"iv0pL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7fkbn":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = require("7ea326df427f014c");
    builder = require("115692d66e5bd90b");
    parser = require("259cca7c8022cb30");
    processors = require("4d88504c3e73ae8e");
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(this);

},{"7ea326df427f014c":"lc6iE","115692d66e5bd90b":"fsQXE","259cca7c8022cb30":"9b9bV","4d88504c3e73ae8e":"ifmcs"}],"lc6iE":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: "@@",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ""
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: "$$",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: "root",
            xmldec: {
                "version": "1.0",
                "encoding": "UTF-8",
                "standalone": true
            },
            doctype: null,
            renderOpts: {
                "pretty": true,
                "indent": "  ",
                "newline": "\n"
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: "",
            cdata: false
        }
    };
}).call(this);

},{}],"fsQXE":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = require("ad623f14adf9b5ff");
    defaults = require("1257d11f8d203f5b").defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
    };
    exports.Builder = function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else rootName = this.options.rootName;
            render = function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== "object") {
                        if (_this.options.cdata && requiresCDATA(obj)) element.raw(wrapCDATA(obj));
                        else element.txt(obj);
                    } else if (Array.isArray(obj)) for(index in obj){
                        if (!hasProp.call(obj, index)) continue;
                        child = obj[index];
                        for(key in child){
                            entry = child[key];
                            element = render(element.ele(key), entry).up();
                        }
                    }
                    else for(key in obj){
                        if (!hasProp.call(obj, key)) continue;
                        child = obj[key];
                        if (key === attrkey) {
                            if (typeof child === "object") for(attr in child){
                                value = child[attr];
                                element = element.att(attr, value);
                            }
                        } else if (key === charkey) {
                            if (_this.options.cdata && requiresCDATA(child)) element = element.raw(wrapCDATA(child));
                            else element = element.txt(child);
                        } else if (Array.isArray(child)) for(index in child){
                            if (!hasProp.call(child, index)) continue;
                            entry = child[index];
                            if (typeof entry === "string") {
                                if (_this.options.cdata && requiresCDATA(entry)) element = element.ele(key).raw(wrapCDATA(entry)).up();
                                else element = element.ele(key, entry).up();
                            } else element = render(element.ele(key), entry).up();
                        }
                        else if (typeof child === "object") element = render(element.ele(key), child).up();
                        else if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) element = element.ele(key).raw(wrapCDATA(child)).up();
                        else {
                            if (child == null) child = "";
                            element = element.ele(key, child.toString()).up();
                        }
                    }
                    return element;
                };
            }(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    }();
}).call(this);

},{"ad623f14adf9b5ff":"78LsS","1257d11f8d203f5b":"lc6iE"}],"78LsS":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
    ref = require("2647794ec6919cf8"), assign = ref.assign, isFunction = ref.isFunction;
    XMLDOMImplementation = require("204f3257bd042cb8");
    XMLDocument = require("1984b650bfe70c70");
    XMLDocumentCB = require("9dbd1ebdb6a95fc3");
    XMLStringWriter = require("69100afb0dfc47f2");
    XMLStreamWriter = require("fd0f26d6534ce99d");
    NodeType = require("fcf823ff2587a9f2");
    WriterState = require("bba57db33f4cadd6");
    module.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) throw new Error("Root element needs a name.");
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
            doc.declaration(options);
            if (options.pubID != null || options.sysID != null) doc.dtd(options);
        }
        return root;
    };
    module.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
            ref1 = [
                options,
                onData
            ], onData = ref1[0], onEnd = ref1[1];
            options = {};
        }
        if (onData) return new XMLDocumentCB(options, onData, onEnd);
        else return new XMLDocument(options);
    };
    module.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
    };
    module.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
    };
    module.exports.implementation = new XMLDOMImplementation();
    module.exports.nodeType = NodeType;
    module.exports.writerState = WriterState;
}).call(this);

},{"2647794ec6919cf8":"ftYTw","204f3257bd042cb8":"bGKIh","1984b650bfe70c70":"kMBGe","9dbd1ebdb6a95fc3":"bE5zE","69100afb0dfc47f2":"4Wk49","fd0f26d6534ce99d":"jE03a","fcf823ff2587a9f2":"iNzZB","bba57db33f4cadd6":"8DB9D"}],"ftYTw":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) Object.assign.apply(null, arguments);
        else for(i = 0, len = sources.length; i < len; i++){
            source = sources[i];
            if (source != null) for(key in source){
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
            }
        }
        return target;
    };
    isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
    };
    isArray = function(val) {
        if (isFunction(Array.isArray)) return Array.isArray(val);
        else return Object.prototype.toString.call(val) === "[object Array]";
    };
    isEmpty = function(val) {
        var key;
        if (isArray(val)) return !val.length;
        else {
            for(key in val){
                if (!hasProp.call(val, key)) continue;
                return false;
            }
            return true;
        }
    };
    isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
        if (isFunction(obj.valueOf)) return obj.valueOf();
        else return obj;
    };
    module.exports.assign = assign;
    module.exports.isFunction = isFunction;
    module.exports.isObject = isObject;
    module.exports.isArray = isArray;
    module.exports.isEmpty = isEmpty;
    module.exports.isPlainObject = isPlainObject;
    module.exports.getValue = getValue;
}).call(this);

},{}],"bGKIh":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMImplementation;
    module.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation() {}
        XMLDOMImplementation.prototype.hasFeature = function(feature, version) {
            return true;
        };
        XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation;
    }();
}).call(this);

},{}],"kMBGe":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject = require("13a5a3baabce41d8").isPlainObject;
    XMLDOMImplementation = require("b6961c96ff36d753");
    XMLDOMConfiguration = require("1f23d28cae8a60a5");
    XMLNode = require("cd39268a029bdce2");
    NodeType = require("ee7140c760116731");
    XMLStringifier = require("f050dc0a62284d96");
    XMLStringWriter = require("1c368e88d7130ef6");
    module.exports = XMLDocument = function(superClass) {
        extend(XMLDocument, superClass);
        function XMLDocument(options) {
            XMLDocument.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) options.writer = new XMLStringWriter();
            this.options = options;
            this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument.prototype, "implementation", {
            value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument.prototype, "doctype", {
            get: function() {
                var child, i, len, ref;
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.DocType) return child;
                }
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "documentElement", {
            get: function() {
                return this.rootObject || null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "inputEncoding", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", {
            get: function() {
                return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "xmlEncoding", {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].encoding;
                else return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "xmlStandalone", {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].standalone === "yes";
                else return false;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "xmlVersion", {
            get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) return this.children[0].version;
                else return "1.0";
            }
        });
        Object.defineProperty(XMLDocument.prototype, "URL", {
            get: function() {
                return this.documentURI;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "origin", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "compatMode", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "characterSet", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDocument.prototype, "contentType", {
            get: function() {
                return null;
            }
        });
        XMLDocument.prototype.end = function(writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) writer = this.options.writer;
            else if (isPlainObject(writer)) {
                writerOptions = writer;
                writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument;
    }(XMLNode);
}).call(this);

},{"13a5a3baabce41d8":"ftYTw","b6961c96ff36d753":"bGKIh","1f23d28cae8a60a5":"dnVHJ","cd39268a029bdce2":"kfik1","ee7140c760116731":"iNzZB","f050dc0a62284d96":"acXVD","1c368e88d7130ef6":"4Wk49"}],"dnVHJ":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require("c72a8151611a34e9");
    XMLDOMStringList = require("6710741fe0d16dae");
    module.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration() {
            var clonedSelf;
            this.defaultParams = {
                "canonical-form": false,
                "cdata-sections": false,
                "comments": false,
                "datatype-normalization": false,
                "element-content-whitespace": true,
                "entities": true,
                "error-handler": new XMLDOMErrorHandler(),
                "infoset": true,
                "validate-if-schema": false,
                "namespaces": true,
                "namespace-declarations": true,
                "normalize-characters": false,
                "schema-location": "",
                "schema-type": "",
                "split-cdata-sections": true,
                "validate": false,
                "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", {
            get: function() {
                return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
        });
        XMLDOMConfiguration.prototype.getParameter = function(name) {
            if (this.params.hasOwnProperty(name)) return this.params[name];
            else return null;
        };
        XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
            return true;
        };
        XMLDOMConfiguration.prototype.setParameter = function(name, value) {
            if (value != null) return this.params[name] = value;
            else return delete this.params[name];
        };
        return XMLDOMConfiguration;
    }();
}).call(this);

},{"c72a8151611a34e9":"jNEDm","6710741fe0d16dae":"03onb"}],"jNEDm":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMErrorHandler;
    module.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler() {}
        XMLDOMErrorHandler.prototype.handleError = function(error) {
            throw new Error(error);
        };
        return XMLDOMErrorHandler;
    }();
}).call(this);

},{}],"03onb":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLDOMStringList;
    module.exports = XMLDOMStringList = function() {
        function XMLDOMStringList(arr) {
            this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList.prototype, "length", {
            get: function() {
                return this.arr.length;
            }
        });
        XMLDOMStringList.prototype.item = function(index) {
            return this.arr[index] || null;
        };
        XMLDOMStringList.prototype.contains = function(str) {
            return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList;
    }();
}).call(this);

},{}],"kfik1":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    ref1 = require("704f24b4c9ed0254"), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module.exports = XMLNode = function() {
        function XMLNode(parent1) {
            this.parent = parent1;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
                XMLElement = require("bb9f43b93220ad7a");
                XMLCData = require("4c7d896cb6b56d63");
                XMLComment = require("91ed1f62eb89b645");
                XMLDeclaration = require("f449ccd8348c817c");
                XMLDocType = require("8ee4082395714d35");
                XMLRaw = require("f9c5b1d6679a33d5");
                XMLText = require("65d90f77c6196668");
                XMLProcessingInstruction = require("8e2e2e7d9c99b0f1");
                XMLDummy = require("f80ef020b5f168cc");
                NodeType = require("7c33a03644563158");
                XMLNodeList = require("ff2b0673a3f10f56");
                XMLNamedNodeMap = require("dbaafd3117e37a72");
                DocumentPosition = require("6214827e72f53399");
            }
        }
        Object.defineProperty(XMLNode.prototype, "nodeName", {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLNode.prototype, "nodeType", {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLNode.prototype, "nodeValue", {
            get: function() {
                return this.value;
            }
        });
        Object.defineProperty(XMLNode.prototype, "parentNode", {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLNode.prototype, "childNodes", {
            get: function() {
                if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new XMLNodeList(this.children);
                return this.childNodeList;
            }
        });
        Object.defineProperty(XMLNode.prototype, "firstChild", {
            get: function() {
                return this.children[0] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, "lastChild", {
            get: function() {
                return this.children[this.children.length - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, "previousSibling", {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i - 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, "nextSibling", {
            get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i + 1] || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, "ownerDocument", {
            get: function() {
                return this.document() || null;
            }
        });
        Object.defineProperty(XMLNode.prototype, "textContent", {
            get: function() {
                var child, j, len, ref2, str;
                if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                    str = "";
                    ref2 = this.children;
                    for(j = 0, len = ref2.length; j < len; j++){
                        child = ref2[j];
                        if (child.textContent) str += child.textContent;
                    }
                    return str;
                } else return null;
            },
            set: function(value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLNode.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
                this.options = parent.options;
                this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                results.push(child.setParent(this));
            }
            return results;
        };
        XMLNode.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) ref2 = [
                {},
                null
            ], attributes = ref2[0], text = ref2[1];
            if (attributes == null) attributes = {};
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref3 = [
                attributes,
                text
            ], text = ref3[0], attributes = ref3[1];
            if (name != null) name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                item = name[j];
                lastChild = this.element(item);
            }
            else if (isFunction(name)) lastChild = this.element(name.apply());
            else if (isObject(name)) for(key in name){
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) val = val.apply();
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) lastChild = this.dummy();
                else if (isObject(val) && isEmpty(val)) lastChild = this.element(key);
                else if (!this.options.keepNullNodes && val == null) lastChild = this.dummy();
                else if (!this.options.separateArrayItems && Array.isArray(val)) for(k = 0, len1 = val.length; k < len1; k++){
                    item = val[k];
                    childNode = {};
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                }
                else if (isObject(val)) {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.element(val);
                    else {
                        lastChild = this.element(key);
                        lastChild.element(val);
                    }
                } else lastChild = this.element(key, val);
            }
            else if (!this.options.keepNullNodes && text === null) lastChild = this.dummy();
            else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) lastChild = this.text(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) lastChild = this.cdata(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) lastChild = this.comment(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) lastChild = this.raw(text);
                else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                else lastChild = this.node(name, attributes, text);
            }
            if (lastChild == null) throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            return lastChild;
        };
        XMLNode.prototype.insertBefore = function(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
                newChild = name;
                refChild = attributes;
                newChild.setParent(this);
                if (refChild) {
                    i = children.indexOf(refChild);
                    removed = children.splice(i);
                    children.push(newChild);
                    Array.prototype.push.apply(children, removed);
                } else children.push(newChild);
                return newChild;
            } else {
                if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                child = this.parent.element(name, attributes, text);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
            }
        };
        XMLNode.prototype.insertAfter = function(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
        };
        XMLNode.prototype.remove = function() {
            var i, ref2;
            if (this.isRoot) throw new Error("Cannot remove the root element. " + this.debugInfo());
            i = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [
                i,
                i - i + 1
            ].concat(ref2 = [])), ref2;
            return this.parent;
        };
        XMLNode.prototype.node = function(name, attributes, text) {
            var child, ref2;
            if (name != null) name = getValue(name);
            attributes || (attributes = {});
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref2 = [
                attributes,
                text
            ], text = ref2[0], attributes = ref2[1];
            child = new XMLElement(this, name, attributes);
            if (text != null) child.text(text);
            this.children.push(child);
            return child;
        };
        XMLNode.prototype.text = function(value) {
            var child;
            if (isObject(value)) this.element(value);
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.cdata = function(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.comment = function(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.commentBefore = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.commentAfter = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.raw = function(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
        };
        XMLNode.prototype.dummy = function() {
            var child;
            child = new XMLDummy(this);
            return child;
        };
        XMLNode.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(j = 0, len = target.length; j < len; j++){
                insTarget = target[j];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
            }
            return this;
        };
        XMLNode.prototype.instructionBefore = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.instructionAfter = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
        };
        XMLNode.prototype.declaration = function(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) doc.children.unshift(xmldec);
            else if (doc.children[0].type === NodeType.Declaration) doc.children[0] = xmldec;
            else doc.children.unshift(xmldec);
            return doc.root() || doc;
        };
        XMLNode.prototype.dtd = function(pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref2 = doc.children;
            for(i = j = 0, len = ref2.length; j < len; i = ++j){
                child = ref2[i];
                if (child.type === NodeType.DocType) {
                    doc.children[i] = doctype;
                    return doctype;
                }
            }
            ref3 = doc.children;
            for(i = k = 0, len1 = ref3.length; k < len1; i = ++k){
                child = ref3[i];
                if (child.isRoot) {
                    doc.children.splice(i, 0, doctype);
                    return doctype;
                }
            }
            doc.children.push(doctype);
            return doctype;
        };
        XMLNode.prototype.up = function() {
            if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            return this.parent;
        };
        XMLNode.prototype.root = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node.rootObject;
                else if (node.isRoot) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.document = function() {
            var node;
            node = this;
            while(node){
                if (node.type === NodeType.Document) return node;
                else node = node.parent;
            }
        };
        XMLNode.prototype.end = function(options) {
            return this.document().end(options);
        };
        XMLNode.prototype.prev = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) throw new Error("Already at the first node. " + this.debugInfo());
            return this.parent.children[i - 1];
        };
        XMLNode.prototype.next = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) throw new Error("Already at the last node. " + this.debugInfo());
            return this.parent.children[i + 1];
        };
        XMLNode.prototype.importDocument = function(doc) {
            var clonedRoot;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
        };
        XMLNode.prototype.debugInfo = function(name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) return "";
            else if (name == null) return "parent: <" + this.parent.name + ">";
            else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) return "node: <" + name + ">";
            else return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        };
        XMLNode.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.doc = function() {
            return this.document();
        };
        XMLNode.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLNode.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLNode.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLNode.prototype.t = function(value) {
            return this.text(value);
        };
        XMLNode.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLNode.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLNode.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLNode.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLNode.prototype.u = function() {
            return this.up();
        };
        XMLNode.prototype.importXMLBuilder = function(doc) {
            return this.importDocument(doc);
        };
        XMLNode.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.hasChildNodes = function() {
            return this.children.length !== 0;
        };
        XMLNode.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isSupported = function(feature, version) {
            return true;
        };
        XMLNode.prototype.hasAttributes = function() {
            return this.attribs.length !== 0;
        };
        XMLNode.prototype.compareDocumentPosition = function(other) {
            var ref, res;
            ref = this;
            if (ref === other) return 0;
            else if (this.document() !== other.document()) {
                res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                if (Math.random() < 0.5) res |= DocumentPosition.Preceding;
                else res |= DocumentPosition.Following;
                return res;
            } else if (ref.isAncestor(other)) return DocumentPosition.Contains | DocumentPosition.Preceding;
            else if (ref.isDescendant(other)) return DocumentPosition.Contains | DocumentPosition.Following;
            else if (ref.isPreceding(other)) return DocumentPosition.Preceding;
            else return DocumentPosition.Following;
        };
        XMLNode.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.isEqualNode = function(node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) return false;
            if (node.children.length !== this.children.length) return false;
            for(i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j){
                if (!this.children[i].isEqualNode(node.children[i])) return false;
            }
            return true;
        };
        XMLNode.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode.prototype.contains = function(other) {
            if (!other) return false;
            return other === this || this.isDescendant(other);
        };
        XMLNode.prototype.isDescendant = function(node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (node === child) return true;
                isDescendantChild = child.isDescendant(node);
                if (isDescendantChild) return true;
            }
            return false;
        };
        XMLNode.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
        };
        XMLNode.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos < thisPos;
        };
        XMLNode.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) return false;
            else return nodePos > thisPos;
        };
        XMLNode.prototype.treePosition = function(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
                pos++;
                if (!found && childNode === node) return found = true;
            });
            if (found) return pos;
            else return -1;
        };
        XMLNode.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for(j = 0, len = ref2.length; j < len; j++){
                child = ref2[j];
                if (res = func(child)) return res;
                else {
                    res = this.foreachTreeNode(child, func);
                    if (res) return res;
                }
            }
        };
        return XMLNode;
    }();
}).call(this);

},{"704f24b4c9ed0254":"ftYTw","bb9f43b93220ad7a":"c5gEs","4c7d896cb6b56d63":"iw4Bz","91ed1f62eb89b645":"d9Olx","f449ccd8348c817c":"7KOl1","8ee4082395714d35":"aPjL5","f9c5b1d6679a33d5":"Dh6Jk","65d90f77c6196668":"cFPm0","8e2e2e7d9c99b0f1":"47tYo","f80ef020b5f168cc":"5b4ux","7c33a03644563158":"iNzZB","ff2b0673a3f10f56":"8bc8r","dbaafd3117e37a72":"5PONq","6214827e72f53399":"2bb5a"}],"c5gEs":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    ref = require("760e1e681b3efb5e"), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
    XMLNode = require("b30d72617b2d0e");
    NodeType = require("b548af19154e188f");
    XMLAttribute = require("91ce844474972b76");
    XMLNamedNodeMap = require("1a2db5acef6e9ab2");
    module.exports = XMLElement = function(superClass) {
        extend(XMLElement, superClass);
        function XMLElement(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing element name. " + this.debugInfo());
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) this.attribute(attributes);
            if (parent.type === NodeType.Document) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
                if (parent.children) {
                    ref1 = parent.children;
                    for(j = 0, len = ref1.length; j < len; j++){
                        child = ref1[j];
                        if (child.type === NodeType.DocType) {
                            child.name = this.name;
                            break;
                        }
                    }
                }
            }
        }
        Object.defineProperty(XMLElement.prototype, "tagName", {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, "namespaceURI", {
            get: function() {
                return "";
            }
        });
        Object.defineProperty(XMLElement.prototype, "prefix", {
            get: function() {
                return "";
            }
        });
        Object.defineProperty(XMLElement.prototype, "localName", {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLElement.prototype, "id", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, "className", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, "classList", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLElement.prototype, "attributes", {
            get: function() {
                if (!this.attributeMap || !this.attributeMap.nodes) this.attributeMap = new XMLNamedNodeMap(this.attribs);
                return this.attributeMap;
            }
        });
        XMLElement.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) clonedSelf.documentObject = null;
            clonedSelf.attribs = {};
            ref1 = this.attribs;
            for(attName in ref1){
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
        };
        XMLElement.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLElement.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo());
            name = getValue(name);
            if (Array.isArray(name)) for(j = 0, len = name.length; j < len; j++){
                attName = name[j];
                delete this.attribs[attName];
            }
            else delete this.attribs[name];
            return this;
        };
        XMLElement.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement.prototype.att = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.a = function(name, value) {
            return this.attribute(name, value);
        };
        XMLElement.prototype.getAttribute = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].value;
            else return null;
        };
        XMLElement.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNode = function(name) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name];
            else return null;
        };
        XMLElement.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
        };
        XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttribute = function(name, isId) {
            if (this.attribs.hasOwnProperty(name)) return this.attribs[name].isId;
            else return isId;
        };
        XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement.prototype.isEqualNode = function(node) {
            var i, j, ref1;
            if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.attribs.length !== this.attribs.length) return false;
            for(i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j){
                if (!this.attribs[i].isEqualNode(node.attribs[i])) return false;
            }
            return true;
        };
        return XMLElement;
    }(XMLNode);
}).call(this);

},{"760e1e681b3efb5e":"ftYTw","b30d72617b2d0e":"kfik1","b548af19154e188f":"iNzZB","91ce844474972b76":"cvUns","1a2db5acef6e9ab2":"5PONq"}],"iNzZB":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
    };
}).call(this);

},{}],"cvUns":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require("2ac94b791509906a");
    XMLNode = require("4460ed8c305de0cc");
    module.exports = XMLAttribute = function() {
        function XMLAttribute(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
            }
            if (name == null) throw new Error("Missing attribute name. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute.prototype, "nodeType", {
            get: function() {
                return this.type;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "ownerElement", {
            get: function() {
                return this.parent;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "textContent", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "namespaceURI", {
            get: function() {
                return "";
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "prefix", {
            get: function() {
                return "";
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "localName", {
            get: function() {
                return this.name;
            }
        });
        Object.defineProperty(XMLAttribute.prototype, "specified", {
            get: function() {
                return true;
            }
        });
        XMLAttribute.prototype.clone = function() {
            return Object.create(this);
        };
        XMLAttribute.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute.prototype.debugInfo = function(name) {
            name = name || this.name;
            if (name == null) return "parent: <" + this.parent.name + ">";
            else return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        };
        XMLAttribute.prototype.isEqualNode = function(node) {
            if (node.namespaceURI !== this.namespaceURI) return false;
            if (node.prefix !== this.prefix) return false;
            if (node.localName !== this.localName) return false;
            if (node.value !== this.value) return false;
            return true;
        };
        return XMLAttribute;
    }();
}).call(this);

},{"2ac94b791509906a":"iNzZB","4460ed8c305de0cc":"kfik1"}],"5PONq":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNamedNodeMap;
    module.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap.prototype, "length", {
            get: function() {
                return Object.keys(this.nodes).length || 0;
            }
        });
        XMLNamedNodeMap.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNamedNodeMap.prototype.getNamedItem = function(name) {
            return this.nodes[name];
        };
        XMLNamedNodeMap.prototype.setNamedItem = function(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
        };
        XMLNamedNodeMap.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap;
    }();
}).call(this);

},{}],"iw4Bz":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("1d10efe8d12710ca");
    XMLCharacterData = require("da41985d18d84bf2");
    module.exports = XMLCData = function(superClass) {
        extend(XMLCData, superClass);
        function XMLCData(parent, text) {
            XMLCData.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing CDATA text. " + this.debugInfo());
            this.name = "#cdata-section";
            this.type = NodeType.CData;
            this.value = this.stringify.cdata(text);
        }
        XMLCData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCData.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData;
    }(XMLCharacterData);
}).call(this);

},{"1d10efe8d12710ca":"iNzZB","da41985d18d84bf2":"an1GL"}],"an1GL":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLCharacterData, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require("d99443ca7fe2d67d");
    module.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData, superClass);
        function XMLCharacterData(parent) {
            XMLCharacterData.__super__.constructor.call(this, parent);
            this.value = "";
        }
        Object.defineProperty(XMLCharacterData.prototype, "data", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, "length", {
            get: function() {
                return this.value.length;
            }
        });
        Object.defineProperty(XMLCharacterData.prototype, "textContent", {
            get: function() {
                return this.value;
            },
            set: function(value) {
                return this.value = value || "";
            }
        });
        XMLCharacterData.prototype.clone = function() {
            return Object.create(this);
        };
        XMLCharacterData.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData.prototype.isEqualNode = function(node) {
            if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.data !== this.data) return false;
            return true;
        };
        return XMLCharacterData;
    }(XMLNode);
}).call(this);

},{"d99443ca7fe2d67d":"kfik1"}],"d9Olx":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("b0dbe926c1622528");
    XMLCharacterData = require("d18aaaf3ab58e603");
    module.exports = XMLComment = function(superClass) {
        extend(XMLComment, superClass);
        function XMLComment(parent, text) {
            XMLComment.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing comment text. " + this.debugInfo());
            this.name = "#comment";
            this.type = NodeType.Comment;
            this.value = this.stringify.comment(text);
        }
        XMLComment.prototype.clone = function() {
            return Object.create(this);
        };
        XMLComment.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment;
    }(XMLCharacterData);
}).call(this);

},{"b0dbe926c1622528":"iNzZB","d18aaaf3ab58e603":"an1GL"}],"7KOl1":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require("cf2a3ddbe00c2bec").isObject;
    XMLNode = require("b70b0f72196be228");
    NodeType = require("7910f9e4e0ec2b8c");
    module.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration, superClass);
        function XMLDeclaration(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration.__super__.constructor.call(this, parent);
            if (isObject(version)) ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
            if (!version) version = "1.0";
            this.type = NodeType.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) this.encoding = this.stringify.xmlEncoding(encoding);
            if (standalone != null) this.standalone = this.stringify.xmlStandalone(standalone);
        }
        XMLDeclaration.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration;
    }(XMLNode);
}).call(this);

},{"cf2a3ddbe00c2bec":"ftYTw","b70b0f72196be228":"kfik1","7910f9e4e0ec2b8c":"iNzZB"}],"aPjL5":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require("2d96570e9ce5a61a").isObject;
    XMLNode = require("10eff02d526f1f13");
    NodeType = require("9167240c545a1251");
    XMLDTDAttList = require("364c364aa3224d14");
    XMLDTDEntity = require("f24de147ed1d6fb5");
    XMLDTDElement = require("a588b70eba73aefb");
    XMLDTDNotation = require("6f9e9e9353c73e81");
    XMLNamedNodeMap = require("dbb2e06d6fd270ad");
    module.exports = XMLDocType = function(superClass) {
        extend(XMLDocType, superClass);
        function XMLDocType(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            XMLDocType.__super__.constructor.call(this, parent);
            this.type = NodeType.DocType;
            if (parent.children) {
                ref = parent.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.Element) {
                        this.name = child.name;
                        break;
                    }
                }
            }
            this.documentObject = parent;
            if (isObject(pubID)) ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
            if (sysID == null) ref2 = [
                pubID,
                sysID
            ], sysID = ref2[0], pubID = ref2[1];
            if (pubID != null) this.pubID = this.stringify.dtdPubID(pubID);
            if (sysID != null) this.sysID = this.stringify.dtdSysID(sysID);
        }
        Object.defineProperty(XMLDocType.prototype, "entities", {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {};
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.EntityDeclaration && !child.pe) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, "notations", {
            get: function() {
                var child, i, len, nodes, ref;
                nodes = {};
                ref = this.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    if (child.type === NodeType.NotationDeclaration) nodes[child.name] = child;
                }
                return new XMLNamedNodeMap(nodes);
            }
        });
        Object.defineProperty(XMLDocType.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDocType.prototype, "internalSubset", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        XMLDocType.prototype.element = function(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.entity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.pEntity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.notation = function(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
        };
        XMLDocType.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType.prototype.ele = function(name, value) {
            return this.element(name, value);
        };
        XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocType.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocType.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        XMLDocType.prototype.up = function() {
            return this.root() || this.documentObject;
        };
        XMLDocType.prototype.isEqualNode = function(node) {
            if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.name !== this.name) return false;
            if (node.publicId !== this.publicId) return false;
            if (node.systemId !== this.systemId) return false;
            return true;
        };
        return XMLDocType;
    }(XMLNode);
}).call(this);

},{"2d96570e9ce5a61a":"ftYTw","10eff02d526f1f13":"kfik1","9167240c545a1251":"iNzZB","364c364aa3224d14":"eBGGV","f24de147ed1d6fb5":"iAklG","a588b70eba73aefb":"1ix9Z","6f9e9e9353c73e81":"3I1Jt","dbb2e06d6fd270ad":"5PONq"}],"eBGGV":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require("e63acd90dbde9d27");
    NodeType = require("e38e2d5ce2a0a55");
    module.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList, superClass);
        function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList.__super__.constructor.call(this, parent);
            if (elementName == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (attributeName == null) throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            if (!attributeType) throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            if (!defaultValueType) throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            if (defaultValueType.indexOf("#") !== 0) defaultValueType = "#" + defaultValueType;
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList;
    }(XMLNode);
}).call(this);

},{"e63acd90dbde9d27":"kfik1","e38e2d5ce2a0a55":"iNzZB"}],"iAklG":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require("6b00c2638d6cff6e").isObject;
    XMLNode = require("5619e8138a9444ca");
    NodeType = require("2e642c53b1846a5e");
    module.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity, superClass);
        function XMLDTDEntity(parent, pe, name, value) {
            XMLDTDEntity.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            if (value == null) throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
                this.value = this.stringify.dtdEntityValue(value);
                this.internal = true;
            } else {
                if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                this.internal = false;
                if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
                if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
                if (value.nData != null) this.nData = this.stringify.dtdNData(value.nData);
                if (this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
        }
        Object.defineProperty(XMLDTDEntity.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, "notationName", {
            get: function() {
                return this.nData || null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", {
            get: function() {
                return null;
            }
        });
        Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", {
            get: function() {
                return null;
            }
        });
        XMLDTDEntity.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity;
    }(XMLNode);
}).call(this);

},{"6b00c2638d6cff6e":"ftYTw","5619e8138a9444ca":"kfik1","2e642c53b1846a5e":"iNzZB"}],"1ix9Z":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require("58f833e8788221ff");
    NodeType = require("bd936b22ecaf9e3e");
    module.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement, superClass);
        function XMLDTDElement(parent, name, value) {
            XMLDTDElement.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD element name. " + this.debugInfo());
            if (!value) value = "(#PCDATA)";
            if (Array.isArray(value)) value = "(" + value.join(",") + ")";
            this.name = this.stringify.name(name);
            this.type = NodeType.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement;
    }(XMLNode);
}).call(this);

},{"58f833e8788221ff":"kfik1","bd936b22ecaf9e3e":"iNzZB"}],"3I1Jt":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require("30e258c5f358ba86");
    NodeType = require("3458890a6746c52e");
    module.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation, superClass);
        function XMLDTDNotation(parent, name, value) {
            XMLDTDNotation.__super__.constructor.call(this, parent);
            if (name == null) throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) this.pubID = this.stringify.dtdPubID(value.pubID);
            if (value.sysID != null) this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        Object.defineProperty(XMLDTDNotation.prototype, "publicId", {
            get: function() {
                return this.pubID;
            }
        });
        Object.defineProperty(XMLDTDNotation.prototype, "systemId", {
            get: function() {
                return this.sysID;
            }
        });
        XMLDTDNotation.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation;
    }(XMLNode);
}).call(this);

},{"30e258c5f358ba86":"kfik1","3458890a6746c52e":"iNzZB"}],"Dh6Jk":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("dcd9ea319a520167");
    XMLNode = require("47e90ce7f40a2f89");
    module.exports = XMLRaw = function(superClass) {
        extend(XMLRaw, superClass);
        function XMLRaw(parent, text) {
            XMLRaw.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing raw text. " + this.debugInfo());
            this.type = NodeType.Raw;
            this.value = this.stringify.raw(text);
        }
        XMLRaw.prototype.clone = function() {
            return Object.create(this);
        };
        XMLRaw.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw;
    }(XMLNode);
}).call(this);

},{"dcd9ea319a520167":"iNzZB","47e90ce7f40a2f89":"kfik1"}],"cFPm0":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("e16b55d7b9ae6110");
    XMLCharacterData = require("6951a1495b9b2aef");
    module.exports = XMLText = function(superClass) {
        extend(XMLText, superClass);
        function XMLText(parent, text) {
            XMLText.__super__.constructor.call(this, parent);
            if (text == null) throw new Error("Missing element text. " + this.debugInfo());
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", {
            get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
        });
        Object.defineProperty(XMLText.prototype, "wholeText", {
            get: function() {
                var next, prev, str;
                str = "";
                prev = this.previousSibling;
                while(prev){
                    str = prev.data + str;
                    prev = prev.previousSibling;
                }
                str += this.data;
                next = this.nextSibling;
                while(next){
                    str = str + next.data;
                    next = next.nextSibling;
                }
                return str;
            }
        });
        XMLText.prototype.clone = function() {
            return Object.create(this);
        };
        XMLText.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText;
    }(XMLCharacterData);
}).call(this);

},{"e16b55d7b9ae6110":"iNzZB","6951a1495b9b2aef":"an1GL"}],"47tYo":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("dc0d646c907512fa");
    XMLCharacterData = require("3417ec217a826ec8");
    module.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction, superClass);
        function XMLProcessingInstruction(parent, target, value) {
            XMLProcessingInstruction.__super__.constructor.call(this, parent);
            if (target == null) throw new Error("Missing instruction target. " + this.debugInfo());
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) this.value = this.stringify.insValue(value);
        }
        XMLProcessingInstruction.prototype.clone = function() {
            return Object.create(this);
        };
        XMLProcessingInstruction.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction.prototype.isEqualNode = function(node) {
            if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) return false;
            if (node.target !== this.target) return false;
            return true;
        };
        return XMLProcessingInstruction;
    }(XMLCharacterData);
}).call(this);

},{"dc0d646c907512fa":"iNzZB","3417ec217a826ec8":"an1GL"}],"5b4ux":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require("a213921cd91c2245");
    NodeType = require("47cd197d16eee265");
    module.exports = XMLDummy = function(superClass) {
        extend(XMLDummy, superClass);
        function XMLDummy(parent) {
            XMLDummy.__super__.constructor.call(this, parent);
            this.type = NodeType.Dummy;
        }
        XMLDummy.prototype.clone = function() {
            return Object.create(this);
        };
        XMLDummy.prototype.toString = function(options) {
            return "";
        };
        return XMLDummy;
    }(XMLNode);
}).call(this);

},{"a213921cd91c2245":"kfik1","47cd197d16eee265":"iNzZB"}],"8bc8r":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLNodeList;
    module.exports = XMLNodeList = function() {
        function XMLNodeList(nodes) {
            this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList.prototype, "length", {
            get: function() {
                return this.nodes.length || 0;
            }
        });
        XMLNodeList.prototype.clone = function() {
            return this.nodes = null;
        };
        XMLNodeList.prototype.item = function(index) {
            return this.nodes[index] || null;
        };
        return XMLNodeList;
    }();
}).call(this);

},{}],"2bb5a":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
    };
}).call(this);

},{}],"acXVD":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringifier, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, hasProp = {}.hasOwnProperty;
    module.exports = XMLStringifier = function() {
        function XMLStringifier(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {});
            this.options = options;
            if (!this.options.version) this.options.version = "1.0";
            ref = options.stringify || {};
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this[key] = value;
            }
        }
        XMLStringifier.prototype.name = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalName("" + val || "");
        };
        XMLStringifier.prototype.text = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier.prototype.cdata = function(val) {
            if (this.options.noValidation) return val;
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.comment = function(val) {
            if (this.options.noValidation) return val;
            val = "" + val || "";
            if (val.match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.raw = function(val) {
            if (this.options.noValidation) return val;
            return "" + val || "";
        };
        XMLStringifier.prototype.attValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier.prototype.insTarget = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.insValue = function(val) {
            if (this.options.noValidation) return val;
            val = "" + val || "";
            if (val.match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) return val;
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
            return val;
        };
        XMLStringifier.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) return val;
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
            return this.assertLegalChar(val);
        };
        XMLStringifier.prototype.xmlStandalone = function(val) {
            if (this.options.noValidation) return val;
            if (val) return "yes";
            else return "no";
        };
        XMLStringifier.prototype.dtdPubID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdSysID = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdElementValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdAttType = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdAttDefault = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdEntityValue = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.dtdNData = function(val) {
            if (this.options.noValidation) return val;
            return this.assertLegalChar("" + val || "");
        };
        XMLStringifier.prototype.convertAttKey = "@";
        XMLStringifier.prototype.convertPIKey = "?";
        XMLStringifier.prototype.convertTextKey = "#text";
        XMLStringifier.prototype.convertCDataKey = "#cdata";
        XMLStringifier.prototype.convertCommentKey = "#comment";
        XMLStringifier.prototype.convertRawKey = "#raw";
        XMLStringifier.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) return str;
            regex = "";
            if (this.options.version === "1.0") {
                regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            } else if (this.options.version === "1.1") {
                regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
            return str;
        };
        XMLStringifier.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) return str;
            this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) throw new Error("Invalid character in name");
            return str;
        };
        XMLStringifier.prototype.textEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier.prototype.attEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) return str;
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier;
    }();
}).call(this);

},{}],"4Wk49":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    XMLWriterBase = require("9d52dc0ac6724da0");
    module.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter, superClass);
        function XMLStringWriter(options) {
            XMLStringWriter.__super__.constructor.call(this, options);
        }
        XMLStringWriter.prototype.document = function(doc, options) {
            var child, i, len, r, ref;
            options = this.filterOptions(options);
            r = "";
            ref = doc.children;
            for(i = 0, len = ref.length; i < len; i++){
                child = ref[i];
                r += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r.slice(-options.newline.length) === options.newline) r = r.slice(0, -options.newline.length);
            return r;
        };
        return XMLStringWriter;
    }(XMLWriterBase);
}).call(this);

},{"9d52dc0ac6724da0":"jI9f2"}],"jI9f2":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
    assign = require("75817c14e3dd56ca").assign;
    NodeType = require("d6d53251a09a6ee1");
    XMLDeclaration = require("9730194a8c0c4783");
    XMLDocType = require("ede7c141272b1dd5");
    XMLCData = require("a57838031903ea3f");
    XMLComment = require("f7ead1ad3653d490");
    XMLElement = require("dcc173f9e43bfc0a");
    XMLRaw = require("349c9f4a67644a6d");
    XMLText = require("6db0cc37b41855c3");
    XMLProcessingInstruction = require("167c0e9fd7f100e6");
    XMLDummy = require("15cae005a9a3ed5a");
    XMLDTDAttList = require("ce8d6b343d31d749");
    XMLDTDElement = require("2cddea69d2f73295");
    XMLDTDEntity = require("5bcc55fbd5532354");
    XMLDTDNotation = require("8beeee48423bc83");
    WriterState = require("dd94c2394fe6b644");
    module.exports = XMLWriterBase = function() {
        function XMLWriterBase(options) {
            var key, ref, value;
            options || (options = {});
            this.options = options;
            ref = options.writer || {};
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this["_" + key] = this[key];
                this[key] = value;
            }
        }
        XMLWriterBase.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {});
            options = assign({}, this.options, options);
            filteredOptions = {
                writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
            filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
            if (filteredOptions.spaceBeforeSlash === true) filteredOptions.spaceBeforeSlash = " ";
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {};
            filteredOptions.state = WriterState.None;
            return filteredOptions;
        };
        XMLWriterBase.prototype.indent = function(node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) return "";
            else if (options.pretty) {
                indentLevel = (level || 0) + options.offset + 1;
                if (indentLevel > 0) return new Array(indentLevel).join(options.indent);
            }
            return "";
        };
        XMLWriterBase.prototype.endline = function(node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) return "";
            else return options.newline;
        };
        XMLWriterBase.prototype.attribute = function(att, options, level) {
            var r;
            this.openAttribute(att, options, level);
            r = " " + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r;
        };
        XMLWriterBase.prototype.cdata = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<![CDATA[";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += "]]>" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.comment = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!-- ";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += " -->" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.declaration = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?xml";
            options.state = WriterState.InsideTag;
            r += ' version="' + node.version + '"';
            if (node.encoding != null) r += ' encoding="' + node.encoding + '"';
            if (node.standalone != null) r += ' standalone="' + node.standalone + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.docType = function(node, options, level) {
            var child, i, len, r, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            r += "<!DOCTYPE " + node.root().name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            if (node.children.length > 0) {
                r += " [";
                r += this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(i = 0, len = ref.length; i < len; i++){
                    child = ref[i];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += "]";
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r = "";
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r += this.indent(node, options, level) + "<" + node.name;
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                r += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
            })) {
                if (options.allowEmpty) {
                    r += ">";
                    options.state = WriterState.CloseTag;
                    r += "</" + node.name + ">" + this.endline(node, options, level);
                } else {
                    options.state = WriterState.CloseTag;
                    r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                r += ">";
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                r += this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
                if (options.dontPrettyTextNodes) {
                    ref1 = node.children;
                    for(i = 0, len = ref1.length; i < len; i++){
                        child = ref1[i];
                        if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                            options.suppressPrettyCount++;
                            prettySuppressed = true;
                            break;
                        }
                    }
                }
                r += ">" + this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref2 = node.children;
                for(j = 0, len1 = ref2.length; j < len1; j++){
                    child = ref2[j];
                    r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += this.indent(node, options, level) + "</" + node.name + ">";
                if (prettySuppressed) options.suppressPrettyCount--;
                r += this.endline(node, options, level);
                options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
            switch(node.type){
                case NodeType.CData:
                    return this.cdata(node, options, level);
                case NodeType.Comment:
                    return this.comment(node, options, level);
                case NodeType.Element:
                    return this.element(node, options, level);
                case NodeType.Raw:
                    return this.raw(node, options, level);
                case NodeType.Text:
                    return this.text(node, options, level);
                case NodeType.ProcessingInstruction:
                    return this.processingInstruction(node, options, level);
                case NodeType.Dummy:
                    return "";
                case NodeType.Declaration:
                    return this.declaration(node, options, level);
                case NodeType.DocType:
                    return this.docType(node, options, level);
                case NodeType.AttributeDeclaration:
                    return this.dtdAttList(node, options, level);
                case NodeType.ElementDeclaration:
                    return this.dtdElement(node, options, level);
                case NodeType.EntityDeclaration:
                    return this.dtdEntity(node, options, level);
                case NodeType.NotationDeclaration:
                    return this.dtdNotation(node, options, level);
                default:
                    throw new Error("Unknown XML node type: " + node.constructor.name);
            }
        };
        XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?";
            options.state = WriterState.InsideTag;
            r += node.target;
            if (node.value) r += " " + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.raw = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.text = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ATTLIST";
            options.state = WriterState.InsideTag;
            r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
            if (node.defaultValueType !== "#DEFAULT") r += " " + node.defaultValueType;
            if (node.defaultValue) r += ' "' + node.defaultValue + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdElement = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ELEMENT";
            options.state = WriterState.InsideTag;
            r += " " + node.name + " " + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ENTITY";
            options.state = WriterState.InsideTag;
            if (node.pe) r += " %";
            r += " " + node.name;
            if (node.value) r += ' "' + node.value + '"';
            else {
                if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
                if (node.nData) r += " NDATA " + node.nData;
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!NOTATION";
            options.state = WriterState.InsideTag;
            r += " " + node.name;
            if (node.pubID && node.sysID) r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            else if (node.pubID) r += ' PUBLIC "' + node.pubID + '"';
            else if (node.sysID) r += ' SYSTEM "' + node.sysID + '"';
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
        };
        XMLWriterBase.prototype.openNode = function(node, options, level) {};
        XMLWriterBase.prototype.closeNode = function(node, options, level) {};
        XMLWriterBase.prototype.openAttribute = function(att, options, level) {};
        XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};
        return XMLWriterBase;
    }();
}).call(this);

},{"75817c14e3dd56ca":"ftYTw","d6d53251a09a6ee1":"iNzZB","9730194a8c0c4783":"7KOl1","ede7c141272b1dd5":"aPjL5","a57838031903ea3f":"iw4Bz","f7ead1ad3653d490":"d9Olx","dcc173f9e43bfc0a":"c5gEs","349c9f4a67644a6d":"Dh6Jk","6db0cc37b41855c3":"cFPm0","167c0e9fd7f100e6":"47tYo","15cae005a9a3ed5a":"5b4ux","ce8d6b343d31d749":"eBGGV","2cddea69d2f73295":"1ix9Z","5bcc55fbd5532354":"iAklG","8beeee48423bc83":"3I1Jt","dd94c2394fe6b644":"8DB9D"}],"8DB9D":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
    };
}).call(this);

},{}],"bE5zE":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
    ref = require("4a0b6b137d547786"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
    NodeType = require("97c418eb43415d1");
    XMLDocument = require("bbdde255e9b44c2a");
    XMLElement = require("7caa93eaeb2c96a7");
    XMLCData = require("e6175a20b2232a77");
    XMLComment = require("b035b3e1bd26442f");
    XMLRaw = require("526deec19abea5fe");
    XMLText = require("55ab1233b224d930");
    XMLProcessingInstruction = require("d22472ac05d87f1c");
    XMLDeclaration = require("39cdad257f5d6100");
    XMLDocType = require("9cbc536e76baf6e7");
    XMLDTDAttList = require("f30e4e8b2fd7fcd0");
    XMLDTDEntity = require("191528b53de83946");
    XMLDTDElement = require("1817e86507e2f1b4");
    XMLDTDNotation = require("26d62c2b781ea9d6");
    XMLAttribute = require("8e92d10ad0cfdf87");
    XMLStringifier = require("d654416cbe0a799d");
    XMLStringWriter = require("bb156ac07b50c66a");
    WriterState = require("ba39b9e659007a91");
    module.exports = XMLDocumentCB = function() {
        function XMLDocumentCB(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType.Document;
            options || (options = {});
            writerOptions = {};
            if (!options.writer) options.writer = new XMLStringWriter();
            else if (isPlainObject(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function() {};
            this.onEndCallback = onEnd || function() {};
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {};
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
        }
        XMLDocumentCB.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch(node.type){
                case NodeType.CData:
                    this.cdata(node.value);
                    break;
                case NodeType.Comment:
                    this.comment(node.value);
                    break;
                case NodeType.Element:
                    attributes = {};
                    ref1 = node.attribs;
                    for(attName in ref1){
                        if (!hasProp.call(ref1, attName)) continue;
                        att = ref1[attName];
                        attributes[attName] = att.value;
                    }
                    this.node(node.name, attributes);
                    break;
                case NodeType.Dummy:
                    this.dummy();
                    break;
                case NodeType.Raw:
                    this.raw(node.value);
                    break;
                case NodeType.Text:
                    this.text(node.value);
                    break;
                case NodeType.ProcessingInstruction:
                    this.instruction(node.target, node.value);
                    break;
                default:
                    throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for(i = 0, len = ref2.length; i < len; i++){
                child = ref2[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) this.up();
            }
            return this;
        };
        XMLDocumentCB.prototype.dummy = function() {
            return this;
        };
        XMLDocumentCB.prototype.node = function(name, attributes, text) {
            var ref1;
            if (name == null) throw new Error("Missing node name.");
            if (this.root && this.currentLevel === -1) throw new Error("Document can only have one root node. " + this.debugInfo(name));
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) attributes = {};
            attributes = getValue(attributes);
            if (!isObject(attributes)) ref1 = [
                attributes,
                text
            ], text = ref1[0], attributes = ref1[1];
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) this.text(text);
            return this;
        };
        XMLDocumentCB.prototype.element = function(name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType.DocType) this.dtdElement.apply(this, arguments);
            else if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root = new XMLDocument(this.options).element("TEMP_ROOT");
                root.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root.children;
                for(i = 0, len = ref1.length; i < len; i++){
                    child = ref1[i];
                    this.createChildNode(child);
                    if (child.type === NodeType.Element) this.up();
                }
            } else this.node(name, attributes, text);
            return this;
        };
        XMLDocumentCB.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            if (name != null) name = getValue(name);
            if (isObject(name)) for(attName in name){
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                if (this.options.keepNullAttributes && value == null) this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                else if (value != null) this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
            return this;
        };
        XMLDocumentCB.prototype.text = function(value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.cdata = function(value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.comment = function(value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.raw = function(value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.instruction = function(target, value) {
            var i, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) target = getValue(target);
            if (value != null) value = getValue(value);
            if (Array.isArray(target)) for(i = 0, len = target.length; i < len; i++){
                insTarget = target[i];
                this.instruction(insTarget);
            }
            else if (isObject(target)) for(insTarget in target){
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
            }
            else {
                if (isFunction(value)) value = value.apply();
                node = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            }
            return this;
        };
        XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) throw new Error("declaration() must be the first node.");
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
            this.openCurrent();
            if (root == null) throw new Error("Missing root node name.");
            if (this.root) throw new Error("dtd() must come before the root node.");
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
        };
        XMLDocumentCB.prototype.dtdElement = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.entity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.pEntity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.notation = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
        };
        XMLDocumentCB.prototype.up = function() {
            if (this.currentLevel < 0) throw new Error("The document node has no parent.");
            if (this.currentNode) {
                if (this.currentNode.children) this.closeNode(this.currentNode);
                else this.openNode(this.currentNode);
                this.currentNode = null;
            } else this.closeNode(this.openTags[this.currentLevel]);
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
        };
        XMLDocumentCB.prototype.end = function() {
            while(this.currentLevel >= 0)this.up();
            return this.onEnd();
        };
        XMLDocumentCB.prototype.openCurrent = function() {
            if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
            }
        };
        XMLDocumentCB.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
                if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) this.root = node;
                chunk = "";
                if (node.type === NodeType.Element) {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
                    ref1 = node.attribs;
                    for(name in ref1){
                        if (!hasProp.call(ref1, name)) continue;
                        att = ref1[name];
                        chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                    }
                    chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
                    this.writerOptions.state = WriterState.InsideTag;
                } else {
                    this.writerOptions.state = WriterState.OpenTag;
                    chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
                    if (node.pubID && node.sysID) chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                    else if (node.sysID) chunk += ' SYSTEM "' + node.sysID + '"';
                    if (node.children) {
                        chunk += " [";
                        this.writerOptions.state = WriterState.InsideTag;
                    } else {
                        this.writerOptions.state = WriterState.CloseTag;
                        chunk += ">";
                    }
                    chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                }
                this.onData(chunk, this.currentLevel);
                return node.isOpen = true;
            }
        };
        XMLDocumentCB.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) {
                chunk = "";
                this.writerOptions.state = WriterState.CloseTag;
                if (node.type === NodeType.Element) chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
                else chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.None;
                this.onData(chunk, this.currentLevel);
                return node.isClosed = true;
            }
        };
        XMLDocumentCB.prototype.onData = function(chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB.prototype.onEnd = function() {
            this.documentCompleted = true;
            return this.onEndCallback();
        };
        XMLDocumentCB.prototype.debugInfo = function(name) {
            if (name == null) return "";
            else return "node: <" + name + ">";
        };
        XMLDocumentCB.prototype.ele = function() {
            return this.element.apply(this, arguments);
        };
        XMLDocumentCB.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.txt = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.dat = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.com = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.ins = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
        };
        XMLDocumentCB.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
        };
        XMLDocumentCB.prototype.t = function(value) {
            return this.text(value);
        };
        XMLDocumentCB.prototype.d = function(value) {
            return this.cdata(value);
        };
        XMLDocumentCB.prototype.c = function(value) {
            return this.comment(value);
        };
        XMLDocumentCB.prototype.r = function(value) {
            return this.raw(value);
        };
        XMLDocumentCB.prototype.i = function(target, value) {
            return this.instruction(target, value);
        };
        XMLDocumentCB.prototype.att = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.a = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) return this.attList.apply(this, arguments);
            else return this.attribute.apply(this, arguments);
        };
        XMLDocumentCB.prototype.ent = function(name, value) {
            return this.entity(name, value);
        };
        XMLDocumentCB.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
        };
        XMLDocumentCB.prototype.not = function(name, value) {
            return this.notation(name, value);
        };
        return XMLDocumentCB;
    }();
}).call(this);

},{"4a0b6b137d547786":"ftYTw","97c418eb43415d1":"iNzZB","bbdde255e9b44c2a":"kMBGe","7caa93eaeb2c96a7":"c5gEs","e6175a20b2232a77":"iw4Bz","b035b3e1bd26442f":"d9Olx","526deec19abea5fe":"Dh6Jk","55ab1233b224d930":"cFPm0","d22472ac05d87f1c":"47tYo","39cdad257f5d6100":"7KOl1","9cbc536e76baf6e7":"aPjL5","f30e4e8b2fd7fcd0":"eBGGV","191528b53de83946":"iAklG","1817e86507e2f1b4":"1ix9Z","26d62c2b781ea9d6":"3I1Jt","8e92d10ad0cfdf87":"cvUns","d654416cbe0a799d":"acXVD","bb156ac07b50c66a":"4Wk49","ba39b9e659007a91":"8DB9D"}],"jE03a":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require("2724c4fa3231a13e");
    XMLWriterBase = require("b06c90945fd90755");
    WriterState = require("f344b6746962647f");
    module.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter, superClass);
        function XMLStreamWriter(stream, options) {
            this.stream = stream;
            XMLStreamWriter.__super__.constructor.call(this, options);
        }
        XMLStreamWriter.prototype.endline = function(node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) return "";
            else return XMLStreamWriter.__super__.endline.call(this, node, options, level);
        };
        XMLStreamWriter.prototype.document = function(doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            ref = doc.children;
            for(i = j = 0, len = ref.length; j < len; i = ++j){
                child = ref[i];
                child.isLastRootNode = i === doc.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc.children;
            results = [];
            for(k = 0, len1 = ref1.length; k < len1; k++){
                child = ref1[k];
                results.push(this.writeChildNode(child, options, 0));
            }
            return results;
        };
        XMLStreamWriter.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write("<!DOCTYPE " + node.root().name);
            if (node.pubID && node.sysID) this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            else if (node.sysID) this.stream.write(' SYSTEM "' + node.sysID + '"');
            if (node.children.length > 0) {
                this.stream.write(" [");
                this.stream.write(this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref = node.children;
                for(j = 0, len = ref.length; j < len; j++){
                    child = ref[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write("]");
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + ">");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + "<" + node.name);
            ref = node.attribs;
            for(name in ref){
                if (!hasProp.call(ref, name)) continue;
                att = ref[name];
                this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
            })) {
                if (options.allowEmpty) {
                    this.stream.write(">");
                    options.state = WriterState.CloseTag;
                    this.stream.write("</" + node.name + ">");
                } else {
                    options.state = WriterState.CloseTag;
                    this.stream.write(options.spaceBeforeSlash + "/>");
                }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                this.stream.write(">");
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node.name + ">");
            } else {
                this.stream.write(">" + this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref1 = node.children;
                for(j = 0, len = ref1.length; j < len; j++){
                    child = ref1[j];
                    this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
        };
        XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter;
    }(XMLWriterBase);
}).call(this);

},{"2724c4fa3231a13e":"iNzZB","b06c90945fd90755":"jI9f2","f344b6746962647f":"8DB9D"}],"9b9bV":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent)if (hasProp.call(parent, key)) child[key] = parent[key];
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    sax = require("13410777db2f54ad");
    events = require("d9a5d36551474a58");
    bom = require("8551b3c8f0063f8b");
    processors = require("7ac38f981f246dd7");
    setImmediate = require("524970f650843682").setImmediate;
    defaults = require("657f91eda6e269d2").defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    defineProperty = function(obj, key, value) {
        var descriptor;
        descriptor = Object.create(null);
        descriptor.value = value;
        descriptor.writable = true;
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return Object.defineProperty(obj, key, descriptor);
    };
    exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) return new exports.Parser(opts);
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) this.options.xmlnskey = this.options.attrkey + "ns";
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) this.options.tagNameProcessors = [];
                this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = "";
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) return defineProperty(obj, key, newValue);
                else return defineProperty(obj, key, [
                    newValue
                ]);
            } else {
                if (!(obj[key] instanceof Array)) defineProperty(obj, key, [
                    obj[key]
                ]);
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            }(this);
            this.saxParser.onend = function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {};
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) obj[attrkey] = {};
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) _this.assignOrPush(obj, processedKey, newValue);
                            else defineProperty(obj[attrkey], processedKey, newValue);
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) obj[_this.options.xmlnskey] = {
                        uri: node.uri,
                        local: node.local
                    };
                    return stack.push(obj);
                };
            }(this);
            this.saxParser.onclosetag = function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) delete obj["#name"];
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) obj[charkey] = obj[charkey].trim();
                        if (_this.options.normalize) obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                    }
                    if (isEmpty(obj)) {
                        if (typeof _this.options.emptyTag === "function") obj = _this.options.emptyTag();
                        else obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                    }
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {};
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) node[_this.options.childkey] = obj;
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {};
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                defineProperty(objClone, key, obj[key]);
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) obj = obj[charkey];
                        }
                    }
                    if (stack.length > 0) return _this.assignOrPush(s, nodeName, obj);
                    else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {};
                            defineProperty(obj, nodeName, old);
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            ontext = function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                "#name": "__text__"
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            }(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) return s.cdata = true;
                };
            }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === "") {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit("error", err);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) throw err;
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) return reject(err);
                        else return resolve(value);
                    });
                };
            }(this));
        };
        return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === "function") cb = b;
            if (typeof a === "object") options = a;
        } else {
            if (typeof a === "function") cb = a;
            options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === "object") options = a;
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(this);

},{"13410777db2f54ad":"bY4if","d9a5d36551474a58":"1VQLm","8551b3c8f0063f8b":"9OO6G","7ac38f981f246dd7":"ifmcs","524970f650843682":"l8XYx","657f91eda6e269d2":"lc6iE"}],"bY4if":[function(require,module,exports) {
var Buffer = require("e8399c94bace2e95").Buffer;
(function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 65536;
    var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
    ];
    sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, "onready");
    }
    if (!Object.create) Object.create = function(o) {
        function F() {}
        F.prototype = o;
        var newf = new F();
        return newf;
    };
    if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
        return a;
    };
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) // Text/cdata nodes can get big, and since they're buffered,
            // we can get here under normal conditions.
            // Avoid issues by emitting the text node now,
            // so at least it won't get any bigger.
            switch(buffers[i]){
                case "textNode":
                    closeText(parser);
                    break;
                case "cdata":
                    emitNode(parser, "oncdata", parser.cdata);
                    parser.cdata = "";
                    break;
                case "script":
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                    break;
                default:
                    error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++)parser[buffers[i]] = "";
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
        }
        if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = require("55cad32d9fc3850b").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    if (!Stream) Stream = function() {};
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit("end");
        };
        this._parser.onerror = function(er) {
            me.emit("error", er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
                get: function() {
                    return me._parser["on" + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser["on" + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require("f36f08810ace8da5").StringDecoder;
                this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [
                arguments[0]
            ] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
        };
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
        return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++ // <script> ... <
    };
    sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
    };
    sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s in sax.STATE)sax.STATE[sax.STATE[s]] = s;
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, "Unexpected end");
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
        if (parser.strict) error(parser, message);
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? [
            "",
            name
        ] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
                // namespace binding attribute. push the binding into scope
                if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
                else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
                else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, "onopennamespace", {
                    prefix: p,
                    uri: tag.ns[p]
                });
            });
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== "xmlns" && !uri) {
                    strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S.SCRIPT;
            else parser.state = S.TEXT;
            parser.tag = null;
            parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== "script") {
                parser.script += "</" + parser.tagName + ">";
                parser.tagName = "";
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) // fail the first time in strict mode
            strictFail(parser, "Unexpected close tag");
            else break;
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while(s-- > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for(var i in tag.ns)x[i] = tag.ns[i];
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) // remove namespace bindings introduced by tag
            Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", {
                    prefix: p,
                    uri: n
                });
            });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error(parser, "Cannot write after close. Assign an onready handler.");
        if (chunk === null) return end(parser);
        if (typeof chunk === "object") chunk = chunk.toString();
        var i = 0;
        var c = "";
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) break;
            if (parser.trackPosition) {
                parser.position++;
                if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                } else parser.column++;
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === "\uFEFF") continue;
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== "<" && c !== "&"){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === "\n") {
                                    parser.line++;
                                    parser.column = 0;
                                } else parser.column++;
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
                        if (c === "&") parser.state = S.TEXT_ENTITY;
                        else parser.textNode += c;
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === "<") parser.state = S.SCRIPT_ENDING;
                    else parser.script += c;
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === "/") parser.state = S.CLOSE_TAG;
                    else {
                        parser.script += "<" + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === "!") {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = "";
                    } else if (isWhitespace(c)) ;
                    else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === "/") {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = "";
                    } else if (c === "?") {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = "";
                    } else {
                        strictFail(parser, "Unencoded <");
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(" ") + c;
                        }
                        parser.textNode += "<" + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, "onopencdata");
                        parser.state = S.CDATA;
                        parser.sgmlDecl = "";
                        parser.cdata = "";
                    } else if (parser.sgmlDecl + c === "--") {
                        parser.state = S.COMMENT;
                        parser.comment = "";
                        parser.sgmlDecl = "";
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
                        parser.doctype = "";
                        parser.sgmlDecl = "";
                    } else if (c === ">") {
                        emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                        parser.sgmlDecl = "";
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else parser.sgmlDecl += c;
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = "";
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === ">") {
                        parser.state = S.TEXT;
                        emitNode(parser, "ondoctype", parser.doctype);
                        parser.doctype = true // just remember that we saw it.
                        ;
                    } else {
                        parser.doctype += c;
                        if (c === "[") parser.state = S.DOCTYPE_DTD;
                        else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = "";
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === "]") parser.state = S.DOCTYPE;
                    else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = "";
                    }
                    continue;
                case S.COMMENT:
                    if (c === "-") parser.state = S.COMMENT_ENDING;
                    else parser.comment += c;
                    continue;
                case S.COMMENT_ENDING:
                    if (c === "-") {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) emitNode(parser, "oncomment", parser.comment);
                        parser.comment = "";
                    } else {
                        parser.comment += "-" + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== ">") {
                        strictFail(parser, "Malformed comment");
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += "--" + c;
                        parser.state = S.COMMENT;
                    } else parser.state = S.TEXT;
                    continue;
                case S.CDATA:
                    if (c === "]") parser.state = S.CDATA_ENDING;
                    else parser.cdata += c;
                    continue;
                case S.CDATA_ENDING:
                    if (c === "]") parser.state = S.CDATA_ENDING_2;
                    else {
                        parser.cdata += "]" + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === ">") {
                        if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
                        emitNode(parser, "onclosecdata");
                        parser.cdata = "";
                        parser.state = S.TEXT;
                    } else if (c === "]") parser.cdata += "]";
                    else {
                        parser.cdata += "]]" + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === "?") parser.state = S.PROC_INST_ENDING;
                    else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
                    else parser.procInstName += c;
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) continue;
                    else if (c === "?") parser.state = S.PROC_INST_ENDING;
                    else parser.procInstBody += c;
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === ">") {
                        emitNode(parser, "onprocessinginstruction", {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = "";
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += "?" + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) parser.tagName += c;
                    else {
                        newTag(parser);
                        if (c === ">") openTag(parser);
                        else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                        else {
                            if (!isWhitespace(c)) strictFail(parser, "Invalid character in tag name");
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === ">") {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, "Forward-slash in opening tag not followed by >");
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) continue;
                    else if (c === ">") openTag(parser);
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_NAME:
                    if (c === "=") parser.state = S.ATTRIB_VALUE;
                    else if (c === ">") {
                        strictFail(parser, "Attribute without value");
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    else if (isMatch(nameBody, c)) parser.attribName += c;
                    else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === "=") parser.state = S.ATTRIB_VALUE;
                    else if (isWhitespace(c)) continue;
                    else {
                        strictFail(parser, "Attribute without value");
                        parser.tag.attributes[parser.attribName] = "";
                        parser.attribValue = "";
                        emitNode(parser, "onattribute", {
                            name: parser.attribName,
                            value: ""
                        });
                        parser.attribName = "";
                        if (c === ">") openTag(parser);
                        else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, "Invalid attribute name");
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) continue;
                    else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        strictFail(parser, "Unquoted attribute value");
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    parser.q = "";
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) parser.state = S.ATTRIB;
                    else if (c === ">") openTag(parser);
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        strictFail(parser, "No whitespace between attributes");
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    if (c === ">") openTag(parser);
                    else parser.state = S.ATTRIB;
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) continue;
                        else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += "</" + c;
                                parser.state = S.SCRIPT;
                            } else strictFail(parser, "Invalid tagname in closing tag.");
                        } else parser.tagName = c;
                    } else if (c === ">") closeTag(parser);
                    else if (isMatch(nameBody, c)) parser.tagName += c;
                    else if (parser.script) {
                        parser.script += "</" + parser.tagName;
                        parser.tagName = "";
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) strictFail(parser, "Invalid tagname in closing tag");
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) continue;
                    if (c === ">") closeTag(parser);
                    else strictFail(parser, "Invalid characters in closing tag");
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = "textNode";
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = "attribValue";
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = "attribValue";
                            break;
                    }
                    if (c === ";") {
                        if (parser.opt.unparsedEntities) {
                            var parsedEntity = parseEntity(parser);
                            parser.entity = "";
                            parser.state = returnState;
                            parser.write(parsedEntity);
                        } else {
                            parser[buffer] += parseEntity(parser);
                            parser.entity = "";
                            parser.state = returnState;
                        }
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
                    else {
                        strictFail(parser, "Invalid character in entity name");
                        parser[buffer] += "&" + parser.entity + c;
                        parser.entity = "";
                        parser.state = returnState;
                    }
                    continue;
                default:
                    throw new Error(parser, "Unknown state: " + parser.state);
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
            var MAX_SIZE = 0x4000;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) return "";
            var result = "";
            while(++index < length){
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 0x10FFFF || // not a valid Unicode code point
                floor(codePoint) !== codePoint // not an integer
                ) throw RangeError("Invalid code point: " + codePoint);
                if (codePoint <= 0xFFFF) codeUnits.push(codePoint);
                else {
                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 0x10000;
                    highSurrogate = (codePoint >> 10) + 0xD800;
                    lowSurrogate = codePoint % 0x400 + 0xDC00;
                    codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        /* istanbul ignore next */ if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
        });
        else String.fromCodePoint = fromCodePoint;
    })();
})(exports);

},{"e8399c94bace2e95":"fCgem","55cad32d9fc3850b":"j77ns","f36f08810ace8da5":"3vmkr"}],"9OO6G":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") return str.substring(1);
        else return str;
    };
}).call(this);

},{}],"ifmcs":[function(require,module,exports) {
// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) str = str.toLowerCase() === "true";
        return str;
    };
}).call(this);

},{}],"l8XYx":[function(require,module,exports) {
var global = arguments[3];
var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;
// DOM APIs, for completeness
exports.setTimeout = function() {
    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function(timeout) {
    if (timeout) timeout.close();
};
function Timeout(id, clearFn) {
    this._id = id;
    this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
    this._clearFn.call(scope, this._id);
};
// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
};
exports.unenroll = function(item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
};
exports._unrefActive = exports.active = function(item) {
    clearTimeout(item._idleTimeoutId);
    var msecs = item._idleTimeout;
    if (msecs >= 0) item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout) item._onTimeout();
    }, msecs);
};
// setimmediate attaches itself to the global object
require("55080a345f0b7464");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;

},{"55080a345f0b7464":"g4k8b"}],"g4k8b":[function(require,module,exports) {
var process = require("96b87729426a727d");
var global = arguments[3];
(function(global, undefined) {
    "use strict";
    if (global.setImmediate) return;
    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;
    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") callback = new Function("" + callback);
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i + 1];
        // Store and register the task
        var task = {
            callback: callback,
            args: args
        };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }
    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }
    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch(args.length){
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }
    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
        // "too much recursion" error.
        setTimeout(runIfPresent, 0, handle);
        else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally{
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function() {
                runIfPresent(handle);
            });
        };
    }
    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }
    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) runIfPresent(+event.data.slice(messagePrefix.length));
        };
        if (global.addEventListener) global.addEventListener("message", onGlobalMessage, false);
        else global.attachEvent("onmessage", onGlobalMessage);
        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };
        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }
    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }
    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }
    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
    // Don't get fooled by e.g. browserify environments.
    if (({}).toString.call(global.process) === "[object process]") // For Node.js before 0.9
    installNextTickImplementation();
    else if (canUsePostMessage()) // For non-IE10 modern browsers
    installPostMessageImplementation();
    else if (global.MessageChannel) // For web workers, where supported
    installMessageChannelImplementation();
    else if (doc && "onreadystatechange" in doc.createElement("script")) // For IE 6–8
    installReadyStateChangeImplementation();
    else // For older browsers
    installSetTimeoutImplementation();
    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);

},{"96b87729426a727d":"d5jf4"}],"iv0pL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetch", ()=>fetch);
var _http = require("http");
var _httpDefault = parcelHelpers.interopDefault(_http);
var _https = require("https");
var _httpsDefault = parcelHelpers.interopDefault(_https);
function initRequest(url, init) {
    if (url.protocol === "http:") return (0, _httpDefault.default).request(url, {
        method: init.method,
        headers: init.headers
    });
    else if (url.protocol === "https:") return (0, _httpsDefault.default).request(url, {
        method: init.method,
        headers: init.headers,
        rejectUnauthorized: false
    });
    else throw new Error("Invalid protocol " + url.protocol);
}
async function fetch(url, init = {}) {
    return new Promise((resolve, reject)=>{
        const request = initRequest(new URL(url), init);
        if (init.body != null) request.write(init.body);
        request.end();
        request.on("error", (err)=>{
            reject(err);
        });
        request.on("response", (response)=>{
            if (response.headers["content-type"] != null && !response.headers["content-type"].includes("/xml")) {
                reject(new Error(`Bad content type ${response.headers["content-type"]}`));
                return;
            }
            let body = "";
            response.on("data", (chunk)=>{
                body += chunk.toString();
            });
            response.on("end", ()=>{
                resolve(body);
            });
            response.on("error", (err)=>{
                reject(err);
            });
        });
    });
}

},{"http":"5y8Jo","https":"djrPu","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"5y8Jo":[function(require,module,exports) {
var global = arguments[3];
var ClientRequest = require("83d28c734ca853c7");
var response = require("48c6aa21794e4a2c");
var extend = require("cc32961fe07c8fa5");
var statusCodes = require("381164753d333ab6");
var url = require("6039c69b7d2da501");
var http = exports;
http.request = function(opts, cb) {
    if (typeof opts === "string") opts = url.parse(opts);
    else opts = extend(opts);
    // Normally, the page is loaded from http or https, so not specifying a protocol
    // will result in a (valid) protocol-relative url. However, this won't work if
    // the protocol is something else, like 'file:'
    var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path = opts.path || "/";
    // Necessary for IPv6 addresses
    if (host && host.indexOf(":") !== -1) host = "[" + host + "]";
    // This may be a relative url. The browser should always be able to interpret it correctly.
    opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    // Also valid opts.auth, opts.mode
    var req = new ClientRequest(opts);
    if (cb) req.on("response", cb);
    return req;
};
http.get = function get(opts, cb) {
    var req = http.request(opts, cb);
    req.end();
    return req;
};
http.ClientRequest = ClientRequest;
http.IncomingMessage = response.IncomingMessage;
http.Agent = function() {};
http.Agent.defaultMaxSockets = 4;
http.globalAgent = new http.Agent();
http.STATUS_CODES = statusCodes;
http.METHODS = [
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REPORT",
    "SEARCH",
    "SUBSCRIBE",
    "TRACE",
    "UNLOCK",
    "UNSUBSCRIBE"
];

},{"83d28c734ca853c7":"csW06","48c6aa21794e4a2c":"47huq","cc32961fe07c8fa5":"93zjj","381164753d333ab6":"iqSVp","6039c69b7d2da501":"7qjc7"}],"csW06":[function(require,module,exports) {
var Buffer = require("171a808a93d7935a").Buffer;
var global = arguments[3];
var process = require("a9ea3f73cd8e4ec0");
var capability = require("47a5b3351a25523b");
var inherits = require("33d332b21b1041");
var response = require("90881d49dd53d428");
var stream = require("c817ce87e1330fb2");
var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;
function decideMode(preferBinary, useFetch) {
    if (capability.fetch && useFetch) return "fetch";
    else if (capability.mozchunkedarraybuffer) return "moz-chunked-arraybuffer";
    else if (capability.msstream) return "ms-stream";
    else if (capability.arraybuffer && preferBinary) return "arraybuffer";
    else return "text";
}
var ClientRequest = module.exports = function(opts) {
    var self = this;
    stream.Writable.call(self);
    self._opts = opts;
    self._body = [];
    self._headers = {};
    if (opts.auth) self.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
        self.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        // If the use of XHR should be preferred. Not typically needed.
        useFetch = false;
        preferBinary = true;
    } else if (opts.mode === "prefer-streaming") // If streaming is a high priority but binary compatibility and
    // the accuracy of the 'content-type' header aren't
    preferBinary = false;
    else if (opts.mode === "allow-wrong-content-type") // If streaming is more important than preserving the 'content-type' header
    preferBinary = !capability.overrideMimeType;
    else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") // Use binary if text streaming may corrupt data or the content-type header, or for speed
    preferBinary = true;
    else throw new Error("Invalid value for opts.mode");
    self._mode = decideMode(preferBinary, useFetch);
    self._fetchTimer = null;
    self._socketTimeout = null;
    self._socketTimer = null;
    self.on("finish", function() {
        self._onFinish();
    });
};
inherits(ClientRequest, stream.Writable);
ClientRequest.prototype.setHeader = function(name, value) {
    var self = this;
    var lowerName = name.toLowerCase();
    // This check is not necessary, but it prevents warnings from browsers about setting unsafe
    // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
    // http-browserify did it, so I will too.
    if (unsafeHeaders.indexOf(lowerName) !== -1) return;
    self._headers[lowerName] = {
        name: name,
        value: value
    };
};
ClientRequest.prototype.getHeader = function(name) {
    var header = this._headers[name.toLowerCase()];
    if (header) return header.value;
    return null;
};
ClientRequest.prototype.removeHeader = function(name) {
    var self = this;
    delete self._headers[name.toLowerCase()];
};
ClientRequest.prototype._onFinish = function() {
    var self = this;
    if (self._destroyed) return;
    var opts = self._opts;
    if ("timeout" in opts && opts.timeout !== 0) self.setTimeout(opts.timeout);
    var headersObj = self._headers;
    var body = null;
    if (opts.method !== "GET" && opts.method !== "HEAD") body = new Blob(self._body, {
        type: (headersObj["content-type"] || {}).value || ""
    });
    // create flattened list of headers
    var headersList = [];
    Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) value.forEach(function(v) {
            headersList.push([
                name,
                v
            ]);
        });
        else headersList.push([
            name,
            value
        ]);
    });
    if (self._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
            var controller = new AbortController();
            signal = controller.signal;
            self._fetchAbortController = controller;
            if ("requestTimeout" in opts && opts.requestTimeout !== 0) self._fetchTimer = global.setTimeout(function() {
                self.emit("requestTimeout");
                if (self._fetchAbortController) self._fetchAbortController.abort();
            }, opts.requestTimeout);
        }
        global.fetch(self._opts.url, {
            method: self._opts.method,
            headers: headersList,
            body: body || undefined,
            mode: "cors",
            credentials: opts.withCredentials ? "include" : "same-origin",
            signal: signal
        }).then(function(response) {
            self._fetchResponse = response;
            self._resetTimers(false);
            self._connect();
        }, function(reason) {
            self._resetTimers(true);
            if (!self._destroyed) self.emit("error", reason);
        });
    } else {
        var xhr = self._xhr = new global.XMLHttpRequest();
        try {
            xhr.open(self._opts.method, self._opts.url, true);
        } catch (err) {
            process.nextTick(function() {
                self.emit("error", err);
            });
            return;
        }
        // Can't set responseType on really old browsers
        if ("responseType" in xhr) xhr.responseType = self._mode;
        if ("withCredentials" in xhr) xhr.withCredentials = !!opts.withCredentials;
        if (self._mode === "text" && "overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
            xhr.timeout = opts.requestTimeout;
            xhr.ontimeout = function() {
                self.emit("requestTimeout");
            };
        }
        headersList.forEach(function(header) {
            xhr.setRequestHeader(header[0], header[1]);
        });
        self._response = null;
        xhr.onreadystatechange = function() {
            switch(xhr.readyState){
                case rStates.LOADING:
                case rStates.DONE:
                    self._onXHRProgress();
                    break;
            }
        };
        // Necessary for streaming in Firefox, since xhr.response is ONLY defined
        // in onprogress, not in onreadystatechange with xhr.readyState = 3
        if (self._mode === "moz-chunked-arraybuffer") xhr.onprogress = function() {
            self._onXHRProgress();
        };
        xhr.onerror = function() {
            if (self._destroyed) return;
            self._resetTimers(true);
            self.emit("error", new Error("XHR error"));
        };
        try {
            xhr.send(body);
        } catch (err) {
            process.nextTick(function() {
                self.emit("error", err);
            });
            return;
        }
    }
};
/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */ function statusValid(xhr) {
    try {
        var status = xhr.status;
        return status !== null && status !== 0;
    } catch (e) {
        return false;
    }
}
ClientRequest.prototype._onXHRProgress = function() {
    var self = this;
    self._resetTimers(false);
    if (!statusValid(self._xhr) || self._destroyed) return;
    if (!self._response) self._connect();
    self._response._onXHRProgress(self._resetTimers.bind(self));
};
ClientRequest.prototype._connect = function() {
    var self = this;
    if (self._destroyed) return;
    self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self));
    self._response.on("error", function(err) {
        self.emit("error", err);
    });
    self.emit("response", self._response);
};
ClientRequest.prototype._write = function(chunk, encoding, cb) {
    var self = this;
    self._body.push(chunk);
    cb();
};
ClientRequest.prototype._resetTimers = function(done) {
    var self = this;
    global.clearTimeout(self._socketTimer);
    self._socketTimer = null;
    if (done) {
        global.clearTimeout(self._fetchTimer);
        self._fetchTimer = null;
    } else if (self._socketTimeout) self._socketTimer = global.setTimeout(function() {
        self.emit("timeout");
    }, self._socketTimeout);
};
ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
    var self = this;
    self._destroyed = true;
    self._resetTimers(true);
    if (self._response) self._response._destroyed = true;
    if (self._xhr) self._xhr.abort();
    else if (self._fetchAbortController) self._fetchAbortController.abort();
    if (err) self.emit("error", err);
};
ClientRequest.prototype.end = function(data, encoding, cb) {
    var self = this;
    if (typeof data === "function") {
        cb = data;
        data = undefined;
    }
    stream.Writable.prototype.end.call(self, data, encoding, cb);
};
ClientRequest.prototype.setTimeout = function(timeout, cb) {
    var self = this;
    if (cb) self.once("timeout", cb);
    self._socketTimeout = timeout;
    self._resetTimers(false);
};
ClientRequest.prototype.flushHeaders = function() {};
ClientRequest.prototype.setNoDelay = function() {};
ClientRequest.prototype.setSocketKeepAlive = function() {};
// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
];

},{"171a808a93d7935a":"fCgem","a9ea3f73cd8e4ec0":"d5jf4","47a5b3351a25523b":"jih7t","33d332b21b1041":"bRL3M","90881d49dd53d428":"47huq","c817ce87e1330fb2":"jXNWE"}],"jih7t":[function(require,module,exports) {
var global = arguments[3];
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
exports.writableStream = isFunction(global.WritableStream);
exports.abortController = isFunction(global.AbortController);
// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr;
function getXHR() {
    // Cache the xhr value
    if (xhr !== undefined) return xhr;
    if (global.XMLHttpRequest) {
        xhr = new global.XMLHttpRequest();
        // If XDomainRequest is available (ie only, where xhr might not work
        // cross domain), use the page location. Otherwise use example.com
        // Note: this doesn't actually make an http request.
        try {
            xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
            xhr = null;
        }
    } else // Service workers don't have XHR
    xhr = null;
    return xhr;
}
function checkTypeSupport(type) {
    var xhr = getXHR();
    if (!xhr) return false;
    try {
        xhr.responseType = type;
        return xhr.responseType === type;
    } catch (e) {}
    return false;
}
// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");
// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
function isFunction(value) {
    return typeof value === "function";
}
xhr = null // Help gc
;

},{}],"47huq":[function(require,module,exports) {
var process = require("d1269065c33ee7fe");
var Buffer = require("77d4ce6cf763caca").Buffer;
var global = arguments[3];
var capability = require("7dcf7aadbb533bfb");
var inherits = require("57b1383434ef92a1");
var stream = require("fa2873d490014c0a");
var rStates = exports.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};
var IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, resetTimers) {
    var self = this;
    stream.Readable.call(self);
    self._mode = mode;
    self.headers = {};
    self.rawHeaders = [];
    self.trailers = {};
    self.rawTrailers = [];
    // Fake the 'close' event, but only once 'end' fires
    self.on("end", function() {
        // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
        process.nextTick(function() {
            self.emit("close");
        });
    });
    if (mode === "fetch") {
        self._fetchResponse = response;
        self.url = response.url;
        self.statusCode = response.status;
        self.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
            self.headers[key.toLowerCase()] = header;
            self.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
            var writable = new WritableStream({
                write: function(chunk) {
                    resetTimers(false);
                    return new Promise(function(resolve, reject) {
                        if (self._destroyed) reject();
                        else if (self.push(Buffer.from(chunk))) resolve();
                        else self._resumeFetch = resolve;
                    });
                },
                close: function() {
                    resetTimers(true);
                    if (!self._destroyed) self.push(null);
                },
                abort: function(err) {
                    resetTimers(true);
                    if (!self._destroyed) self.emit("error", err);
                }
            });
            try {
                response.body.pipeTo(writable).catch(function(err) {
                    resetTimers(true);
                    if (!self._destroyed) self.emit("error", err);
                });
                return;
            } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
        }
        // fallback for when writableStream or pipeTo aren't available
        var reader = response.body.getReader();
        function read() {
            reader.read().then(function(result) {
                if (self._destroyed) return;
                resetTimers(result.done);
                if (result.done) {
                    self.push(null);
                    return;
                }
                self.push(Buffer.from(result.value));
                read();
            }).catch(function(err) {
                resetTimers(true);
                if (!self._destroyed) self.emit("error", err);
            });
        }
        read();
    } else {
        self._xhr = xhr;
        self._pos = 0;
        self.url = xhr.responseURL;
        self.statusCode = xhr.status;
        self.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
            var matches = header.match(/^([^:]+):\s*(.*)/);
            if (matches) {
                var key = matches[1].toLowerCase();
                if (key === "set-cookie") {
                    if (self.headers[key] === undefined) self.headers[key] = [];
                    self.headers[key].push(matches[2]);
                } else if (self.headers[key] !== undefined) self.headers[key] += ", " + matches[2];
                else self.headers[key] = matches[2];
                self.rawHeaders.push(matches[1], matches[2]);
            }
        });
        self._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
            var mimeType = self.rawHeaders["mime-type"];
            if (mimeType) {
                var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                if (charsetMatch) self._charset = charsetMatch[1].toLowerCase();
            }
            if (!self._charset) self._charset = "utf-8" // best guess
            ;
        }
    }
};
inherits(IncomingMessage, stream.Readable);
IncomingMessage.prototype._read = function() {
    var self = this;
    var resolve = self._resumeFetch;
    if (resolve) {
        self._resumeFetch = null;
        resolve();
    }
};
IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
    var self = this;
    var xhr = self._xhr;
    var response = null;
    switch(self._mode){
        case "text":
            response = xhr.responseText;
            if (response.length > self._pos) {
                var newData = response.substr(self._pos);
                if (self._charset === "x-user-defined") {
                    var buffer = Buffer.alloc(newData.length);
                    for(var i = 0; i < newData.length; i++)buffer[i] = newData.charCodeAt(i) & 0xff;
                    self.push(buffer);
                } else self.push(newData, self._charset);
                self._pos = response.length;
            }
            break;
        case "arraybuffer":
            if (xhr.readyState !== rStates.DONE || !xhr.response) break;
            response = xhr.response;
            self.push(Buffer.from(new Uint8Array(response)));
            break;
        case "moz-chunked-arraybuffer":
            response = xhr.response;
            if (xhr.readyState !== rStates.LOADING || !response) break;
            self.push(Buffer.from(new Uint8Array(response)));
            break;
        case "ms-stream":
            response = xhr.response;
            if (xhr.readyState !== rStates.LOADING) break;
            var reader = new global.MSStreamReader();
            reader.onprogress = function() {
                if (reader.result.byteLength > self._pos) {
                    self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
                    self._pos = reader.result.byteLength;
                }
            };
            reader.onload = function() {
                resetTimers(true);
                self.push(null);
            };
            // reader.onerror = ??? // TODO: this
            reader.readAsArrayBuffer(response);
            break;
    }
    // The ms-stream case handles end separately in reader.onload()
    if (self._xhr.readyState === rStates.DONE && self._mode !== "ms-stream") {
        resetTimers(true);
        self.push(null);
    }
};

},{"d1269065c33ee7fe":"d5jf4","77d4ce6cf763caca":"fCgem","7dcf7aadbb533bfb":"jih7t","57b1383434ef92a1":"bRL3M","fa2873d490014c0a":"jXNWE"}],"jXNWE":[function(require,module,exports) {
exports = module.exports = require("68bb3bdae87803ec");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require("74167f79b688eaf7");
exports.Duplex = require("84600f6783428a47");
exports.Transform = require("23bee5f697448a0");
exports.PassThrough = require("e0ec4b8e438dbbd");
exports.finished = require("6cc0f9af7147cdbc");
exports.pipeline = require("f90db22d01d3c3d1");

},{"68bb3bdae87803ec":"6NdbQ","74167f79b688eaf7":"gTkcq","84600f6783428a47":"kKNA3","23bee5f697448a0":"ba8Mr","e0ec4b8e438dbbd":"2xP98","6cc0f9af7147cdbc":"aOMy2","f90db22d01d3c3d1":"fyp4t"}],"93zjj":[function(require,module,exports) {
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if (hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

},{}],"iqSVp":[function(require,module,exports) {
module.exports = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
};

},{}],"djrPu":[function(require,module,exports) {
var http = require("c0383d0f5be55d6b");
var url = require("23c94c23cc2fc416");
var https = module.exports;
for(var key in http)if (http.hasOwnProperty(key)) https[key] = http[key];
https.request = function(params, cb) {
    params = validateParams(params);
    return http.request.call(this, params, cb);
};
https.get = function(params, cb) {
    params = validateParams(params);
    return http.get.call(this, params, cb);
};
function validateParams(params) {
    if (typeof params === "string") params = url.parse(params);
    if (!params.protocol) params.protocol = "https:";
    if (params.protocol !== "https:") throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
    return params;
}

},{"c0383d0f5be55d6b":"5y8Jo","23c94c23cc2fc416":"7qjc7"}],"br8tl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "broadcastAdvert", ()=>broadcastAdvert);
const broadcastAdvert = (ssdp, advert, notifcationSubType)=>{
    ssdp.emit("ssdp:send-message", "NOTIFY * HTTP/1.1", {
        NT: advert.usn,
        NTS: notifcationSubType,
        USN: `${ssdp.udn}::${advert.usn}`,
        "CACHE-CONTROL": `max-age=${Math.round(advert.ttl / 1000)}`,
        SERVER: ssdp.signature,
        LOCATION: advert.location
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bJzwd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createLocation", ()=>createLocation);
var _http = require("http");
var _httpDefault = parcelHelpers.interopDefault(_http);
var _freeportPromise = require("freeport-promise");
var _detailsHandlerJs = require("./details-handler.js");
var _findAllInterfacesJs = require("./find-all-interfaces.js");
async function createLocation(ssdp, advert) {
    if (advert.location != null) return async ()=>Promise.resolve();
    const servers = [];
    advert.location = {};
    await Promise.all(ssdp.sockets.map(async (socket)=>Promise.all((0, _findAllInterfacesJs.findAllInterfaces)(socket.type === "udp4" && advert.ipv4, socket.type === "udp6" && advert.ipv6).map(async (iface)=>{
            await (0, _freeportPromise.freeport)().then(async (port)=>{
                await new Promise((resolve, reject)=>{
                    let location = "http://";
                    if (socket.type === "udp6") location += `[${iface.address}]`;
                    else location += iface.address;
                    location += `:${port}`;
                    advert.location[socket.type] = location;
                    const server = (0, _httpDefault.default).createServer((req, res)=>{
                        (0, _detailsHandlerJs.detailsHandler)(advert.details, req, res);
                    });
                    const addr = socket.address();
                    server.listen(port, addr.address, ()=>{
                        resolve();
                    });
                    server.on("error", (err)=>{
                        reject(err);
                    });
                    servers.push(server);
                });
            });
        }))));
    return async ()=>{
        await Promise.all(servers.map(async (server)=>new Promise((resolve, reject)=>{
                server.close();
                resolve();
            })));
    };
}

},{"http":"5y8Jo","freeport-promise":"jYTTc","./details-handler.js":"6UykY","./find-all-interfaces.js":"ep5hY","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jYTTc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "freeport", ()=>freeport);
var _net = require("net");
async function freeport() {
    return await new Promise((resolve, reject)=>{
        const server = (0, _net.createServer)();
        let port = 0;
        server.once("listening", ()=>{
            const address = server.address();
            if (address == null) return reject(new Error("Server was not listening"));
            if (typeof address === "string") return reject(new Error("Server was Unix Socket"));
            port = address.port;
            server.close();
        });
        server.once("close", ()=>{
            resolve(port);
        });
        server.once("error", reject);
        server.listen(0, "127.0.0.1");
    });
}

},{"net":"bXKEI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6UykY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "detailsHandler", ()=>detailsHandler);
function detailsHandler(createDetails, request, response) {
    createDetails().then((details)=>{
        response.writeHead(200, {
            "Content-Type": "text/xml"
        });
        response.end(details);
    }).catch((error)=>{
        response.writeHead(500);
        response.end(error);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ep5hY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findAllInterfaces", ()=>findAllInterfaces);
var _os = require("os");
var _osDefault = parcelHelpers.interopDefault(_os);
function findAllInterfaces(includeIPv4, includeIPv6) {
    const output = [];
    const networkInterfaces = (0, _osDefault.default).networkInterfaces();
    Object.values(networkInterfaces).forEach((info)=>{
        if (info == null) return;
        info.forEach((iface)=>{
            if (iface.internal) return;
            if (iface.family === "IPv4" && includeIPv4) output.push(iface);
            if (iface.family === "IPv6" && includeIPv6) output.push(iface);
        });
    });
    return output;
}

},{"os":"6yyXu","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"66mRS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseAdvertOptions", ()=>parseAdvertOptions);
var _mergeOptions = require("merge-options");
var _mergeOptionsDefault = parcelHelpers.interopDefault(_mergeOptions);
var _xml2Js = require("xml2js");
var _xml2JsDefault = parcelHelpers.interopDefault(_xml2Js);
function parseAdvertOptions(ssdp, options) {
    if (options == null) throw new Error("Empty advert passed");
    if (options.usn == null) throw new Error("Advert should have a usn property");
    const opts = (0, _mergeOptionsDefault.default)(options, {
        usn: options.usn,
        interval: 10000,
        ttl: 1800000,
        ipv4: true,
        ipv6: true,
        location: null,
        details: {
            $: {
                xmlns: "urn:schemas-upnp-org:device-1-0"
            },
            specVersion: {
                major: 1,
                minor: 1
            },
            URLBase: "http://example.com",
            device: {
                deviceType: options.usn,
                friendlyName: "A friendly device name",
                manufacturer: "Manufactuer name",
                manufacturerURL: "http://example.com",
                modelDescription: "A description of the device",
                modelName: "A model name",
                modelNumber: "A vendor specific model number",
                modelURL: "http://example.com",
                serialNumber: "A device specific serial number",
                UDN: ssdp.udn,
                presentationURL: "index.html"
            }
        }
    });
    const details = opts.details;
    opts.details = async ()=>{
        return new Promise((resolve, reject)=>{
            try {
                const builder = new (0, _xml2JsDefault.default).Builder();
                resolve(builder.buildObject(details));
            } catch (error) {
                reject(error);
            }
        });
    };
    return opts;
}

},{"merge-options":"l45Gy","xml2js":"7fkbn","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"24uxn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "search", ()=>search);
var _advertsJs = require("../adverts.js");
function search(ssdp, message, remote) {
    if (message.ST == null) return;
    (0, _advertsJs.adverts).forEach((advert)=>{
        if (message.ST === "ssdp:all" || advert.usn.toLowerCase() === message.ST.toLowerCase()) ssdp.emit("ssdp:send-message", "HTTP/1.1 200 OK", {
            ST: message.ST === "ssdp:all" ? advert.usn : message.ST,
            USN: `${ssdp.udn}::${advert.usn}`,
            LOCATION: advert.location,
            "CACHE-CONTROL": `max-age=${Math.round(advert.ttl / 1000)}`,
            DATE: new Date().toUTCString(),
            SERVER: ssdp.signature,
            EXT: ""
        }, remote);
    });
}

},{"../adverts.js":"dLY1T","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fJDyh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSockets", ()=>createSockets);
var _dgram = require("dgram");
async function createSockets(ssdp, signal) {
    return Promise.all(ssdp.options.sockets.map(async (options)=>{
        return new Promise((resolve, reject)=>{
            const socket = (0, _dgram.createSocket)({
                type: options.type,
                reuseAddr: true,
                signal
            }, (buf, info)=>{
                ssdp.emit("transport:incoming-message", buf, info);
            });
            socket.bind(options.bind.port, options.bind.address);
            // @ts-expect-error .options is not a property of Socket
            socket.options = options;
            socket.on("error", (err)=>{
                ssdp.emit("error", err);
            });
            socket.on("listening", ()=>{
                try {
                    socket.addMembership(options.broadcast.address, socket.address().address);
                    socket.setBroadcast(true);
                    socket.setMulticastTTL(options.maxHops);
                    resolve(socket);
                } catch (error) {
                    error.message = `Adding membership ${options.broadcast.address} failed - ${error.message}`; // eslint-disable-line @typescript-eslint/restrict-template-expressions
                    reject(error);
                }
            });
        });
    }));
}

},{"dgram":"bXKEI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8MZWH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultSsdpOptions", ()=>defaultSsdpOptions);
var _crypto = require("crypto"); // remove when having crypto global
var _module = require("module");
var _mergeOptions = require("merge-options");
var _mergeOptionsDefault = parcelHelpers.interopDefault(_mergeOptions);
var _defaultSocketOptionsJs = require("./default-socket-options.js");
var process = require("5769d906b9833e88");
const req = (0, _module.createRequire)("file:///node_modules/@achingbrain/ssdp/dist/src/default-ssdp-options.js");
const { name, version } = req("../../package.json");
const DEFAULT_SSDP_SIGNATURE = `node.js/${process.version.substring(1)} UPnP/1.1 ${name}/${version}`;
function defaultSsdpOptions(options) {
    return (0, _mergeOptionsDefault.default)(options ?? {}, {
        usn: `uuid:${(0, _crypto.webcrypto).randomUUID()}`,
        signature: DEFAULT_SSDP_SIGNATURE,
        sockets: [
            {}
        ].map((0, _defaultSocketOptionsJs.defaultSocketOptions)),
        retry: {
            times: 5,
            interval: 5000
        }
    });
}

},{"5769d906b9833e88":"d5jf4","crypto":"hagNj","module":"bXKEI","merge-options":"l45Gy","./default-socket-options.js":"jxSHd","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"hagNj":[function(require,module,exports) {
"use strict";
exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require("9f84b01a6f751e2b");
exports.createHash = exports.Hash = require("6215218888164bf3");
exports.createHmac = exports.Hmac = require("41dc42cb22bbf5f8");
var algos = require("acce2639fd57a8ee");
var algoKeys = Object.keys(algos);
var hashes = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
].concat(algoKeys);
exports.getHashes = function() {
    return hashes;
};
var p = require("b26231bc996405c3");
exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;
var aes = require("cd296f7efacbf3dd");
exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;
var dh = require("f35f6f689077fd07");
exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;
var sign = require("e955328ff9b7dd32");
exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;
exports.createECDH = require("84e3bfaa4f6c843e");
var publicEncrypt = require("eeb59405cf029b93");
exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt;
// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })
var rf = require("327f527258516f60");
exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;
exports.createCredentials = function() {
    throw new Error([
        "sorry, createCredentials is not implemented yet",
        "we accept pull requests",
        "https://github.com/crypto-browserify/crypto-browserify"
    ].join("\n"));
};
exports.constants = {
    "DH_CHECK_P_NOT_SAFE_PRIME": 2,
    "DH_CHECK_P_NOT_PRIME": 1,
    "DH_UNABLE_TO_CHECK_GENERATOR": 4,
    "DH_NOT_SUITABLE_GENERATOR": 8,
    "NPN_ENABLED": 1,
    "ALPN_ENABLED": 1,
    "RSA_PKCS1_PADDING": 1,
    "RSA_SSLV23_PADDING": 2,
    "RSA_NO_PADDING": 3,
    "RSA_PKCS1_OAEP_PADDING": 4,
    "RSA_X931_PADDING": 5,
    "RSA_PKCS1_PSS_PADDING": 6,
    "POINT_CONVERSION_COMPRESSED": 2,
    "POINT_CONVERSION_UNCOMPRESSED": 4,
    "POINT_CONVERSION_HYBRID": 6
};

},{"9f84b01a6f751e2b":"8hjhE","6215218888164bf3":"2WyL8","41dc42cb22bbf5f8":"k1utz","acce2639fd57a8ee":"busIB","b26231bc996405c3":"g38Hg","cd296f7efacbf3dd":"d4idn","f35f6f689077fd07":"hwD3y","e955328ff9b7dd32":"jbRNy","84e3bfaa4f6c843e":"9Rcg1","eeb59405cf029b93":"h9Rdh","327f527258516f60":"k3tsT"}],"8hjhE":[function(require,module,exports) {
var global = arguments[3];
var process = require("9f5c61be6bd9c67a");
"use strict";
// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536;
// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295;
function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer = require("caff9346743c214e").Buffer;
var crypto = global.crypto || global.msCrypto;
if (crypto && crypto.getRandomValues) module.exports = randomBytes;
else module.exports = oldBrowser;
function randomBytes(size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer.allocUnsafe(size);
    if (size > 0) {
        if (size > MAX_BYTES) // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for(var generated = 0; generated < size; generated += MAX_BYTES)// buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        else crypto.getRandomValues(bytes);
    }
    if (typeof cb === "function") return process.nextTick(function() {
        cb(null, bytes);
    });
    return bytes;
}

},{"9f5c61be6bd9c67a":"d5jf4","caff9346743c214e":"eW7r9"}],"2WyL8":[function(require,module,exports) {
"use strict";
var inherits = require("45ce174cec337471");
var MD5 = require("4170b0039f3b4aab");
var RIPEMD160 = require("efcc6ede1fda4d98");
var sha = require("65b1a51ddac82548");
var Base = require("ac5a46c0f3b4d769");
function Hash(hash) {
    Base.call(this, "digest");
    this._hash = hash;
}
inherits(Hash, Base);
Hash.prototype._update = function(data) {
    this._hash.update(data);
};
Hash.prototype._final = function() {
    return this._hash.digest();
};
module.exports = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
    return new Hash(sha(alg));
};

},{"45ce174cec337471":"bRL3M","4170b0039f3b4aab":"45VeE","efcc6ede1fda4d98":"bFDDq","65b1a51ddac82548":"jkn7m","ac5a46c0f3b4d769":"g5fTz"}],"45VeE":[function(require,module,exports) {
"use strict";
var inherits = require("634114d48656c754");
var HashBase = require("4b170874b4cb8d4e");
var Buffer = require("72d4e45c6a42a2da").Buffer;
var ARRAY16 = new Array(16);
function MD5() {
    HashBase.call(this, 64);
    // state
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
}
inherits(MD5, HashBase);
MD5.prototype._update = function() {
    var M = ARRAY16;
    for(var i = 0; i < 16; ++i)M[i] = this._block.readInt32LE(i * 4);
    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
    d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
    c = fnF(c, d, a, b, M[2], 0x242070db, 17);
    b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
    a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
    d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
    c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
    b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
    a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
    d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
    c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
    b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
    a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
    d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
    c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
    b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
    a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
    d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
    c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
    b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
    a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
    d = fnG(d, a, b, c, M[10], 0x02441453, 9);
    c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
    b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
    a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
    d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
    c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
    b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
    a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
    d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
    c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
    b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
    a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
    d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
    c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
    b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
    a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
    d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
    c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
    b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
    a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
    d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
    c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
    b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
    a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
    d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
    c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
    b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
    a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
    d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
    c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
    b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
    a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
    d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
    c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
    b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
    a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
    d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
    c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
    b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
    a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
    d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
    c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
    b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
};
MD5.prototype._digest = function() {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;
    if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    // produce result
    var buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
};
function rotl(x, n) {
    return x << n | x >>> 32 - n;
}
function fnF(a, b, c, d, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}
function fnG(a, b, c, d, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}
function fnH(a, b, c, d, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}
function fnI(a, b, c, d, m, k, s) {
    return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}
module.exports = MD5;

},{"634114d48656c754":"bRL3M","4b170874b4cb8d4e":"51qBP","72d4e45c6a42a2da":"eW7r9"}],"51qBP":[function(require,module,exports) {
"use strict";
var Buffer = require("27eaec8a721206a5").Buffer;
var Transform = require("c5aab47d8f1d340a").Transform;
var inherits = require("91e9fa68d440541e");
function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer.isBuffer(val) && typeof val !== "string") throw new TypeError(prefix + " must be a string or a buffer");
}
function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [
        0,
        0,
        0,
        0
    ];
    this._finalized = false;
}
inherits(HashBase, Transform);
HashBase.prototype._transform = function(chunk, encoding, callback) {
    var error = null;
    try {
        this.update(chunk, encoding);
    } catch (err) {
        error = err;
    }
    callback(error);
};
HashBase.prototype._flush = function(callback) {
    var error = null;
    try {
        this.push(this.digest());
    } catch (err) {
        error = err;
    }
    callback(error);
};
HashBase.prototype.update = function(data, encoding) {
    throwIfNotStringOrBuffer(data, "Data");
    if (this._finalized) throw new Error("Digest already called");
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
    // consume data
    var block = this._block;
    var offset = 0;
    while(this._blockOffset + data.length - offset >= this._blockSize){
        for(var i = this._blockOffset; i < this._blockSize;)block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
    }
    while(offset < data.length)block[this._blockOffset++] = data[offset++];
    // update length
    for(var j = 0, carry = data.length * 8; carry > 0; ++j){
        this._length[j] += carry;
        carry = this._length[j] / 0x0100000000 | 0;
        if (carry > 0) this._length[j] -= 0x0100000000 * carry;
    }
    return this;
};
HashBase.prototype._update = function() {
    throw new Error("_update is not implemented");
};
HashBase.prototype.digest = function(encoding) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = true;
    var digest = this._digest();
    if (encoding !== undefined) digest = digest.toString(encoding);
    // reset state
    this._block.fill(0);
    this._blockOffset = 0;
    for(var i = 0; i < 4; ++i)this._length[i] = 0;
    return digest;
};
HashBase.prototype._digest = function() {
    throw new Error("_digest is not implemented");
};
module.exports = HashBase;

},{"27eaec8a721206a5":"eW7r9","c5aab47d8f1d340a":"jXNWE","91e9fa68d440541e":"bRL3M"}],"bFDDq":[function(require,module,exports) {
"use strict";
var Buffer = require("c813c8075bcf823e").Buffer;
var inherits = require("84928993e7c3934b");
var HashBase = require("4b3519823770a56d");
var ARRAY16 = new Array(16);
var zl = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var zr = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var sl = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sr = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];
var hl = [
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
];
var hr = [
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
];
function RIPEMD160() {
    HashBase.call(this, 64);
    // state
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
}
inherits(RIPEMD160, HashBase);
RIPEMD160.prototype._update = function() {
    var words = ARRAY16;
    for(var j = 0; j < 16; ++j)words[j] = this._block.readInt32LE(j * 4);
    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0;
    // computation
    for(var i = 0; i < 80; i += 1){
        var tl;
        var tr;
        if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
    }
    // update state
    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
};
RIPEMD160.prototype._digest = function() {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;
    if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    // produce result
    var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
};
function rotl(x, n) {
    return x << n | x >>> 32 - n;
}
function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}
function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}
function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}
function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}
function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}
module.exports = RIPEMD160;

},{"c813c8075bcf823e":"fCgem","84928993e7c3934b":"bRL3M","4b3519823770a56d":"51qBP"}],"jkn7m":[function(require,module,exports) {
var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm();
};
exports.sha = require("54c9313943368ce2");
exports.sha1 = require("6e6f42e0b6fe29ef");
exports.sha224 = require("cefe70c6f9f68940");
exports.sha256 = require("3b4e2aa73bc3fef5");
exports.sha384 = require("be7da8b8e5a0fd78");
exports.sha512 = require("25610a4ba83316a4");

},{"54c9313943368ce2":"6PecA","6e6f42e0b6fe29ef":"iCEYJ","cefe70c6f9f68940":"7e0O2","3b4e2aa73bc3fef5":"kVAym","be7da8b8e5a0fd78":"bWRvM","25610a4ba83316a4":"aZK4H"}],"6PecA":[function(require,module,exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */ var inherits = require("55404b425acd1c6f");
var Hash = require("457bc9c7737d761f");
var Buffer = require("44759e57eb2992a").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    -1894007588,
    -899497514
];
var W = new Array(80);
function Sha() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha, Hash);
Sha.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha;

},{"55404b425acd1c6f":"bRL3M","457bc9c7737d761f":"7wpAR","44759e57eb2992a":"eW7r9"}],"7wpAR":[function(require,module,exports) {
var Buffer = require("fe67468afd3c1b91").Buffer;
// prototype class for hash functions
function Hash(blockSize, finalSize) {
    this._block = Buffer.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
}
Hash.prototype.update = function(data, enc) {
    if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer.from(data, enc);
    }
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for(var offset = 0; offset < length;){
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for(var i = 0; i < remainder; i++)block[assigned + i] = data[offset + i];
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) this._update(block);
    }
    this._len += length;
    return this;
};
Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80;
    // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
    }
    var bits = this._len * 8;
    // uint32
    if (bits <= 0xffffffff) this._block.writeUInt32BE(bits, this._blockSize - 4);
    else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash = this._hash();
    return enc ? hash.toString(enc) : hash;
};
Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
};
module.exports = Hash;

},{"fe67468afd3c1b91":"eW7r9"}],"iCEYJ":[function(require,module,exports) {
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ var inherits = require("bf0dcaa2121c06d3");
var Hash = require("788f05b1f9753762");
var Buffer = require("ee7c2a3e649d259f").Buffer;
var K = [
    0x5a827999,
    0x6ed9eba1,
    -1894007588,
    -899497514
];
var W = new Array(80);
function Sha1() {
    this.init();
    this._w = W;
    Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function() {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
};
function rotl1(num) {
    return num << 1 | num >>> 31;
}
function rotl5(num) {
    return num << 5 | num >>> 27;
}
function rotl30(num) {
    return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
Sha1.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 80; ++i)W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    for(var j = 0; j < 80; ++j){
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
};
Sha1.prototype._hash = function() {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
};
module.exports = Sha1;

},{"bf0dcaa2121c06d3":"bRL3M","788f05b1f9753762":"7wpAR","ee7c2a3e649d259f":"eW7r9"}],"7e0O2":[function(require,module,exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = require("1759318dd61b32af");
var Sha256 = require("5a24a8ff4dc414f6");
var Hash = require("377596dd27739a66");
var Buffer = require("381289f917f16a20").Buffer;
var W = new Array(64);
function Sha224() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha224, Sha256);
Sha224.prototype.init = function() {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
};
Sha224.prototype._hash = function() {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
};
module.exports = Sha224;

},{"1759318dd61b32af":"bRL3M","5a24a8ff4dc414f6":"kVAym","377596dd27739a66":"7wpAR","381289f917f16a20":"eW7r9"}],"kVAym":[function(require,module,exports) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */ var inherits = require("682a6716eeab42dd");
var Hash = require("f062bd789841a9ce");
var Buffer = require("1d47643a8adb8c1b").Buffer;
var K = [
    0x428A2F98,
    0x71374491,
    0xB5C0FBCF,
    0xE9B5DBA5,
    0x3956C25B,
    0x59F111F1,
    0x923F82A4,
    0xAB1C5ED5,
    0xD807AA98,
    0x12835B01,
    0x243185BE,
    0x550C7DC3,
    0x72BE5D74,
    0x80DEB1FE,
    0x9BDC06A7,
    0xC19BF174,
    0xE49B69C1,
    0xEFBE4786,
    0x0FC19DC6,
    0x240CA1CC,
    0x2DE92C6F,
    0x4A7484AA,
    0x5CB0A9DC,
    0x76F988DA,
    0x983E5152,
    0xA831C66D,
    0xB00327C8,
    0xBF597FC7,
    0xC6E00BF3,
    0xD5A79147,
    0x06CA6351,
    0x14292967,
    0x27B70A85,
    0x2E1B2138,
    0x4D2C6DFC,
    0x53380D13,
    0x650A7354,
    0x766A0ABB,
    0x81C2C92E,
    0x92722C85,
    0xA2BFE8A1,
    0xA81A664B,
    0xC24B8B70,
    0xC76C51A3,
    0xD192E819,
    0xD6990624,
    0xF40E3585,
    0x106AA070,
    0x19A4C116,
    0x1E376C08,
    0x2748774C,
    0x34B0BCB5,
    0x391C0CB3,
    0x4ED8AA4A,
    0x5B9CCA4F,
    0x682E6FF3,
    0x748F82EE,
    0x78A5636F,
    0x84C87814,
    0x8CC70208,
    0x90BEFFFA,
    0xA4506CEB,
    0xBEF9A3F7,
    0xC67178F2
];
var W = new Array(64);
function Sha256() {
    this.init();
    this._w = W // new Array(64)
    ;
    Hash.call(this, 64, 56);
}
inherits(Sha256, Hash);
Sha256.prototype.init = function() {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
};
function ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256.prototype._update = function(M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for(var i = 0; i < 16; ++i)W[i] = M.readInt32BE(i * 4);
    for(; i < 64; ++i)W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    for(var j = 0; j < 64; ++j){
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
};
Sha256.prototype._hash = function() {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
};
module.exports = Sha256;

},{"682a6716eeab42dd":"bRL3M","f062bd789841a9ce":"7wpAR","1d47643a8adb8c1b":"eW7r9"}],"bWRvM":[function(require,module,exports) {
var inherits = require("2a5cbb73fedd61b");
var SHA512 = require("fdb4d0946b31cdb5");
var Hash = require("50aa04d4bd2df0e1");
var Buffer = require("3d3bcc84ec383b74").Buffer;
var W = new Array(160);
function Sha384() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function() {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
};
Sha384.prototype._hash = function() {
    var H = Buffer.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
};
module.exports = Sha384;

},{"2a5cbb73fedd61b":"bRL3M","fdb4d0946b31cdb5":"aZK4H","50aa04d4bd2df0e1":"7wpAR","3d3bcc84ec383b74":"eW7r9"}],"aZK4H":[function(require,module,exports) {
var inherits = require("8d87c82d5ce5743");
var Hash = require("27d0146c4419ba93");
var Buffer = require("602d9c7256ca6bf7").Buffer;
var K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
var W = new Array(160);
function Sha512() {
    this.init();
    this._w = W;
    Hash.call(this, 128, 112);
}
inherits(Sha512, Hash);
Sha512.prototype.init = function() {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
};
function Ch(x, y, z) {
    return z ^ x & (y ^ z);
}
function maj(x, y, z) {
    return x & y | z & (x | y);
}
function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M) {
    var W = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for(var i = 0; i < 32; i += 2){
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
    }
    for(; i < 160; i += 2){
        var xh = W[i - 30];
        var xl = W[i - 30 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W[i - 4];
        xl = W[i - 4 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 14];
        var Wi7l = W[i - 14 + 1];
        var Wi16h = W[i - 32];
        var Wi16l = W[i - 32 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W[i] = Wih;
        W[i + 1] = Wil;
    }
    for(var j = 0; j < 160; j += 2){
        Wih = W[j];
        Wil = W[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        // t2 = sigma0 + maj
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function() {
    var H = Buffer.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
};
module.exports = Sha512;

},{"8d87c82d5ce5743":"bRL3M","27d0146c4419ba93":"7wpAR","602d9c7256ca6bf7":"eW7r9"}],"g5fTz":[function(require,module,exports) {
var Buffer = require("631f7eb12d35b579").Buffer;
var Transform = require("5b378a2a05398c5").Transform;
var StringDecoder = require("d42da7de127e1c4b").StringDecoder;
var inherits = require("7a0f2f27fe0a389b");
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) this[hashMode] = this._finalOrDigest;
    else this.final = this._finalOrDigest;
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
inherits(CipherBase, Transform);
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") data = Buffer.from(data, inputEnc);
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) outData = this._toString(outData, outputEnc);
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) this._update(data);
        else this.push(this._update(data));
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) outData = this._toString(outData, outputEnc, true);
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) out += this._decoder.end();
    return out;
};
module.exports = CipherBase;

},{"631f7eb12d35b579":"eW7r9","5b378a2a05398c5":"j77ns","d42da7de127e1c4b":"3vmkr","7a0f2f27fe0a389b":"bRL3M"}],"k1utz":[function(require,module,exports) {
"use strict";
var inherits = require("6a73c7c8ca6b61fa");
var Legacy = require("e1b443c27c833bc0");
var Base = require("7571755cc57fd60e");
var Buffer = require("b8ba1339feab1938").Buffer;
var md5 = require("c00fb3fd28cadeb2");
var RIPEMD160 = require("b7f8eae556813ec1");
var sha = require("40c5a912778271f7");
var ZEROS = Buffer.alloc(128);
function Hmac(alg, key) {
    Base.call(this, "digest");
    if (typeof key === "string") key = Buffer.from(key);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key;
    if (key.length > blocksize) {
        var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        key = hash.update(key).digest();
    } else if (key.length < blocksize) key = Buffer.concat([
        key,
        ZEROS
    ], blocksize);
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);
    for(var i = 0; i < blocksize; i++){
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
    }
    this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
    this._hash.update(ipad);
}
inherits(Hmac, Base);
Hmac.prototype._update = function(data) {
    this._hash.update(data);
};
Hmac.prototype._final = function() {
    var h = this._hash.digest();
    var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
    return hash.update(this._opad).update(h).digest();
};
module.exports = function createHmac(alg, key) {
    alg = alg.toLowerCase();
    if (alg === "rmd160" || alg === "ripemd160") return new Hmac("rmd160", key);
    if (alg === "md5") return new Legacy(md5, key);
    return new Hmac(alg, key);
};

},{"6a73c7c8ca6b61fa":"bRL3M","e1b443c27c833bc0":"kO6k7","7571755cc57fd60e":"g5fTz","b8ba1339feab1938":"eW7r9","c00fb3fd28cadeb2":"h5gRT","b7f8eae556813ec1":"bFDDq","40c5a912778271f7":"jkn7m"}],"kO6k7":[function(require,module,exports) {
"use strict";
var inherits = require("2baf2864ece10f11");
var Buffer = require("c7fb5e22d675c53c").Buffer;
var Base = require("8fdec7d6b96329ea");
var ZEROS = Buffer.alloc(128);
var blocksize = 64;
function Hmac(alg, key) {
    Base.call(this, "digest");
    if (typeof key === "string") key = Buffer.from(key);
    this._alg = alg;
    this._key = key;
    if (key.length > blocksize) key = alg(key);
    else if (key.length < blocksize) key = Buffer.concat([
        key,
        ZEROS
    ], blocksize);
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);
    for(var i = 0; i < blocksize; i++){
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
    }
    this._hash = [
        ipad
    ];
}
inherits(Hmac, Base);
Hmac.prototype._update = function(data) {
    this._hash.push(data);
};
Hmac.prototype._final = function() {
    var h = this._alg(Buffer.concat(this._hash));
    return this._alg(Buffer.concat([
        this._opad,
        h
    ]));
};
module.exports = Hmac;

},{"2baf2864ece10f11":"bRL3M","c7fb5e22d675c53c":"eW7r9","8fdec7d6b96329ea":"g5fTz"}],"h5gRT":[function(require,module,exports) {
var MD5 = require("f07cc93582c49804");
module.exports = function(buffer) {
    return new MD5().update(buffer).digest();
};

},{"f07cc93582c49804":"45VeE"}],"busIB":[function(require,module,exports) {
"use strict";
module.exports = require("b6a65ebe2480cb5a");

},{"b6a65ebe2480cb5a":"kWFdV"}],"kWFdV":[function(require,module,exports) {
module.exports = JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}');

},{}],"g38Hg":[function(require,module,exports) {
exports.pbkdf2 = require("50310b85983e4f32");
exports.pbkdf2Sync = require("5f7b0df9c2ef196d");

},{"50310b85983e4f32":"aqdig","5f7b0df9c2ef196d":"lh9gw"}],"aqdig":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("a1f6b66eddae53e0").Buffer;
var checkParameters = require("a915fb954a5b62ac");
var defaultEncoding = require("76b8747fb257c65c");
var sync = require("f6f43e3eaadd9ae9");
var toBuffer = require("d12cab846fc3f945");
var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
};
var checks = [];
function checkNative(algo) {
    if (global.process && !global.process.browser) return Promise.resolve(false);
    if (!subtle || !subtle.importKey || !subtle.deriveBits) return Promise.resolve(false);
    if (checks[algo] !== undefined) return checks[algo];
    ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
        return true;
    }).catch(function() {
        return false;
    });
    checks[algo] = prom;
    return prom;
}
var nextTick;
function getNextTick() {
    if (nextTick) return nextTick;
    if (global.process && global.process.nextTick) nextTick = global.process.nextTick;
    else if (global.queueMicrotask) nextTick = global.queueMicrotask;
    else if (global.setImmediate) nextTick = global.setImmediate;
    else nextTick = global.setTimeout;
    return nextTick;
}
function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey("raw", password, {
        name: "PBKDF2"
    }, false, [
        "deriveBits"
    ]).then(function(key) {
        return subtle.deriveBits({
            name: "PBKDF2",
            salt: salt,
            iterations: iterations,
            hash: {
                name: algo
            }
        }, key, length << 3);
    }).then(function(res) {
        return Buffer.from(res);
    });
}
function resolvePromise(promise, callback) {
    promise.then(function(out) {
        getNextTick()(function() {
            callback(null, out);
        });
    }, function(e) {
        getNextTick()(function() {
            callback(e);
        });
    });
}
module.exports = function(password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === "function") {
        callback = digest;
        digest = undefined;
    }
    digest = digest || "sha1";
    var algo = toBrowser[digest.toLowerCase()];
    if (!algo || typeof global.Promise !== "function") {
        getNextTick()(function() {
            var out;
            try {
                out = sync(password, salt, iterations, keylen, digest);
            } catch (e) {
                return callback(e);
            }
            callback(null, out);
        });
        return;
    }
    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    if (typeof callback !== "function") throw new Error("No callback provided to pbkdf2");
    resolvePromise(checkNative(algo).then(function(resp) {
        if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
        return sync(password, salt, iterations, keylen, digest);
    }), callback);
};

},{"a1f6b66eddae53e0":"eW7r9","a915fb954a5b62ac":"jg75G","76b8747fb257c65c":"T9r9Q","f6f43e3eaadd9ae9":"lh9gw","d12cab846fc3f945":"kaFyH"}],"jg75G":[function(require,module,exports) {
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
;
module.exports = function(iterations, keylen) {
    if (typeof iterations !== "number") throw new TypeError("Iterations not a number");
    if (iterations < 0) throw new TypeError("Bad iterations");
    if (typeof keylen !== "number") throw new TypeError("Key length not a number");
    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) throw new TypeError("Bad key length");
};

},{}],"T9r9Q":[function(require,module,exports) {
var global = arguments[3];
var process = require("6b9fe6b7a0bbf941");
var defaultEncoding;
/* istanbul ignore next */ if (global.process && global.process.browser) defaultEncoding = "utf-8";
else if (global.process && global.process.version) {
    var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
    defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
} else defaultEncoding = "utf-8";
module.exports = defaultEncoding;

},{"6b9fe6b7a0bbf941":"d5jf4"}],"lh9gw":[function(require,module,exports) {
var md5 = require("1e04e1c2d51cd13d");
var RIPEMD160 = require("42015ac33af139f8");
var sha = require("a7eb8e83614997ca");
var Buffer = require("290c92d9373f664d").Buffer;
var checkParameters = require("1b04775c4713da3d");
var defaultEncoding = require("b290a762e8475e9f");
var toBuffer = require("82c0eccfe5526b2c");
var ZEROS = Buffer.alloc(128);
var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function Hmac(alg, key, saltLen) {
    var hash = getDigest(alg);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key.length > blocksize) key = hash(key);
    else if (key.length < blocksize) key = Buffer.concat([
        key,
        ZEROS
    ], blocksize);
    var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
    for(var i = 0; i < blocksize; i++){
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
    }
    var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.hash = hash;
    this.size = sizes[alg];
}
Hmac.prototype.run = function(data, ipad) {
    data.copy(ipad, this.blocksize);
    var h = this.hash(ipad);
    h.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
};
function getDigest(alg) {
    function shaFunc(data) {
        return sha(alg).update(data).digest();
    }
    function rmd160Func(data) {
        return new RIPEMD160().update(data).digest();
    }
    if (alg === "rmd160" || alg === "ripemd160") return rmd160Func;
    if (alg === "md5") return md5;
    return shaFunc;
}
function pbkdf2(password, salt, iterations, keylen, digest) {
    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    digest = digest || "sha1";
    var hmac = new Hmac(digest, password, salt.length);
    var DK = Buffer.allocUnsafe(keylen);
    var block1 = Buffer.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = sizes[digest];
    var l = Math.ceil(keylen / hLen);
    for(var i = 1; i <= l; i++){
        block1.writeUInt32BE(i, salt.length);
        var T = hmac.run(block1, hmac.ipad1);
        var U = T;
        for(var j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(var k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
module.exports = pbkdf2;

},{"1e04e1c2d51cd13d":"h5gRT","42015ac33af139f8":"bFDDq","a7eb8e83614997ca":"jkn7m","290c92d9373f664d":"eW7r9","1b04775c4713da3d":"jg75G","b290a762e8475e9f":"T9r9Q","82c0eccfe5526b2c":"kaFyH"}],"kaFyH":[function(require,module,exports) {
var Buffer = require("cc6579c2e1506b6d").Buffer;
module.exports = function(thing, encoding, name) {
    if (Buffer.isBuffer(thing)) return thing;
    else if (typeof thing === "string") return Buffer.from(thing, encoding);
    else if (ArrayBuffer.isView(thing)) return Buffer.from(thing.buffer);
    else throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
};

},{"cc6579c2e1506b6d":"eW7r9"}],"d4idn":[function(require,module,exports) {
var DES = require("9fddd06e02c9f65f");
var aes = require("c080e0e074a10616");
var aesModes = require("deca4106fa6cf801");
var desModes = require("7141e0762da15af0");
var ebtk = require("ca278cb2f2d32ea3");
function createCipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
    } else throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
}
function createDecipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
        keyLen = aesModes[suite].key;
        ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
        keyLen = desModes[suite].key * 8;
        ivLen = desModes[suite].iv;
    } else throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
}
function createCipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
        key: key,
        iv: iv,
        mode: suite
    });
    throw new TypeError("invalid suite type");
}
function createDecipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
        key: key,
        iv: iv,
        mode: suite,
        decrypt: true
    });
    throw new TypeError("invalid suite type");
}
function getCiphers() {
    return Object.keys(desModes).concat(aes.getCiphers());
}
exports.createCipher = exports.Cipher = createCipher;
exports.createCipheriv = exports.Cipheriv = createCipheriv;
exports.createDecipher = exports.Decipher = createDecipher;
exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"9fddd06e02c9f65f":"d7hSK","c080e0e074a10616":"hnlHj","deca4106fa6cf801":"jyQSU","7141e0762da15af0":"iO8co","ca278cb2f2d32ea3":"1rd4d"}],"d7hSK":[function(require,module,exports) {
var CipherBase = require("4df025afd5a20f9f");
var des = require("8ea0942e2f125a3");
var inherits = require("8a7d640fedcdd788");
var Buffer = require("c9c674d2a2a092c4").Buffer;
var modes = {
    "des-ede3-cbc": des.CBC.instantiate(des.EDE),
    "des-ede3": des.EDE,
    "des-ede-cbc": des.CBC.instantiate(des.EDE),
    "des-ede": des.EDE,
    "des-cbc": des.CBC.instantiate(des.DES),
    "des-ecb": des.DES
};
modes.des = modes["des-cbc"];
modes.des3 = modes["des-ede3-cbc"];
module.exports = DES;
inherits(DES, CipherBase);
function DES(opts) {
    CipherBase.call(this);
    var modeName = opts.mode.toLowerCase();
    var mode = modes[modeName];
    var type;
    if (opts.decrypt) type = "decrypt";
    else type = "encrypt";
    var key = opts.key;
    if (!Buffer.isBuffer(key)) key = Buffer.from(key);
    if (modeName === "des-ede" || modeName === "des-ede-cbc") key = Buffer.concat([
        key,
        key.slice(0, 8)
    ]);
    var iv = opts.iv;
    if (!Buffer.isBuffer(iv)) iv = Buffer.from(iv);
    this._des = mode.create({
        key: key,
        iv: iv,
        type: type
    });
}
DES.prototype._update = function(data) {
    return Buffer.from(this._des.update(data));
};
DES.prototype._final = function() {
    return Buffer.from(this._des.final());
};

},{"4df025afd5a20f9f":"g5fTz","8ea0942e2f125a3":"jn95T","8a7d640fedcdd788":"bRL3M","c9c674d2a2a092c4":"eW7r9"}],"jn95T":[function(require,module,exports) {
"use strict";
exports.utils = require("c56851640eb0e265");
exports.Cipher = require("22f0b7ac3b9c9316");
exports.DES = require("d0445787359f92a0");
exports.CBC = require("203ada8fdbbff440");
exports.EDE = require("736756ddbc573f7");

},{"c56851640eb0e265":"aeccw","22f0b7ac3b9c9316":"jz3In","d0445787359f92a0":"gDFTo","203ada8fdbbff440":"lPo0P","736756ddbc573f7":"avp7S"}],"aeccw":[function(require,module,exports) {
"use strict";
exports.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
    return res >>> 0;
};
exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = value >>> 16 & 0xff;
    bytes[2 + off] = value >>> 8 & 0xff;
    bytes[3 + off] = value & 0xff;
};
exports.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for(var i = 6; i >= 0; i -= 2){
        for(var j = 0; j <= 24; j += 8){
            outL <<= 1;
            outL |= inR >>> j + i & 1;
        }
        for(var j = 0; j <= 24; j += 8){
            outL <<= 1;
            outL |= inL >>> j + i & 1;
        }
    }
    for(var i = 6; i >= 0; i -= 2){
        for(var j = 1; j <= 25; j += 8){
            outR <<= 1;
            outR |= inR >>> j + i & 1;
        }
        for(var j = 1; j <= 25; j += 8){
            outR <<= 1;
            outR |= inL >>> j + i & 1;
        }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
};
exports.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for(var i = 0; i < 4; i++)for(var j = 24; j >= 0; j -= 8){
        outL <<= 1;
        outL |= inR >>> j + i & 1;
        outL <<= 1;
        outL |= inL >>> j + i & 1;
    }
    for(var i = 4; i < 8; i++)for(var j = 24; j >= 0; j -= 8){
        outR <<= 1;
        outR |= inR >>> j + i & 1;
        outR <<= 1;
        outR |= inL >>> j + i & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
};
exports.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    // 7, 15, 23, 31, 39, 47, 55, 63
    // 6, 14, 22, 30, 39, 47, 55, 63
    // 5, 13, 21, 29, 39, 47, 55, 63
    // 4, 12, 20, 28
    for(var i = 7; i >= 5; i--){
        for(var j = 0; j <= 24; j += 8){
            outL <<= 1;
            outL |= inR >> j + i & 1;
        }
        for(var j = 0; j <= 24; j += 8){
            outL <<= 1;
            outL |= inL >> j + i & 1;
        }
    }
    for(var j = 0; j <= 24; j += 8){
        outL <<= 1;
        outL |= inR >> j + i & 1;
    }
    // 1, 9, 17, 25, 33, 41, 49, 57
    // 2, 10, 18, 26, 34, 42, 50, 58
    // 3, 11, 19, 27, 35, 43, 51, 59
    // 36, 44, 52, 60
    for(var i = 1; i <= 3; i++){
        for(var j = 0; j <= 24; j += 8){
            outR <<= 1;
            outR |= inR >> j + i & 1;
        }
        for(var j = 0; j <= 24; j += 8){
            outR <<= 1;
            outR |= inL >> j + i & 1;
        }
    }
    for(var j = 0; j <= 24; j += 8){
        outR <<= 1;
        outR |= inL >> j + i & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
};
exports.r28shl = function r28shl(num, shift) {
    return num << shift & 0xfffffff | num >>> 28 - shift;
};
var pc2table = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
];
exports.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len = pc2table.length >>> 1;
    for(var i = 0; i < len; i++){
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 0x1;
    }
    for(var i = len; i < pc2table.length; i++){
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 0x1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
};
exports.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r & 1) << 5 | r >>> 27;
    for(var i = 23; i >= 15; i -= 4){
        outL <<= 6;
        outL |= r >>> i & 0x3f;
    }
    for(var i = 11; i >= 3; i -= 4){
        outR |= r >>> i & 0x3f;
        outR <<= 6;
    }
    outR |= (r & 0x1f) << 1 | r >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
};
var sTable = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
];
exports.substitute = function substitute(inL, inR) {
    var out = 0;
    for(var i = 0; i < 4; i++){
        var b = inL >>> 18 - i * 6 & 0x3f;
        var sb = sTable[i * 0x40 + b];
        out <<= 4;
        out |= sb;
    }
    for(var i = 0; i < 4; i++){
        var b = inR >>> 18 - i * 6 & 0x3f;
        var sb = sTable[256 + i * 0x40 + b];
        out <<= 4;
        out |= sb;
    }
    return out >>> 0;
};
var permuteTable = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
];
exports.permute = function permute(num) {
    var out = 0;
    for(var i = 0; i < permuteTable.length; i++){
        out <<= 1;
        out |= num >>> permuteTable[i] & 0x1;
    }
    return out >>> 0;
};
exports.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);
    while(str.length < size)str = "0" + str;
    var out = [];
    for(var i = 0; i < size; i += group)out.push(str.slice(i, i + group));
    return out.join(" ");
};

},{}],"jz3In":[function(require,module,exports) {
"use strict";
var assert = require("85cfb697294fd1d8");
function Cipher(options) {
    this.options = options;
    this.type = this.options.type;
    this.blockSize = 8;
    this._init();
    this.buffer = new Array(this.blockSize);
    this.bufferOff = 0;
    this.padding = options.padding !== false;
}
module.exports = Cipher;
Cipher.prototype._init = function _init() {
// Might be overrided
};
Cipher.prototype.update = function update(data) {
    if (data.length === 0) return [];
    if (this.type === "decrypt") return this._updateDecrypt(data);
    else return this._updateEncrypt(data);
};
Cipher.prototype._buffer = function _buffer(data, off) {
    // Append data to buffer
    var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
    for(var i = 0; i < min; i++)this.buffer[this.bufferOff + i] = data[off + i];
    this.bufferOff += min;
    // Shift next
    return min;
};
Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
    this._update(this.buffer, 0, out, off);
    this.bufferOff = 0;
    return this.blockSize;
};
Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = (this.bufferOff + data.length) / this.blockSize | 0;
    var out = new Array(count * this.blockSize);
    if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
    }
    // Write blocks
    var max = data.length - (data.length - inputOff) % this.blockSize;
    for(; inputOff < max; inputOff += this.blockSize){
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
    }
    // Queue rest
    for(; inputOff < data.length; inputOff++, this.bufferOff++)this.buffer[this.bufferOff] = data[inputOff];
    return out;
};
Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
    var out = new Array(count * this.blockSize);
    // TODO(indutny): optimize it, this is far from optimal
    for(; count > 0; count--){
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
    }
    // Buffer rest of the input
    inputOff += this._buffer(data, inputOff);
    return out;
};
Cipher.prototype.final = function final(buffer) {
    var first;
    if (buffer) first = this.update(buffer);
    var last;
    if (this.type === "encrypt") last = this._finalEncrypt();
    else last = this._finalDecrypt();
    if (first) return first.concat(last);
    else return last;
};
Cipher.prototype._pad = function _pad(buffer, off) {
    if (off === 0) return false;
    while(off < buffer.length)buffer[off++] = 0;
    return true;
};
Cipher.prototype._finalEncrypt = function _finalEncrypt() {
    if (!this._pad(this.buffer, this.bufferOff)) return [];
    var out = new Array(this.blockSize);
    this._update(this.buffer, 0, out, 0);
    return out;
};
Cipher.prototype._unpad = function _unpad(buffer) {
    return buffer;
};
Cipher.prototype._finalDecrypt = function _finalDecrypt() {
    assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var out = new Array(this.blockSize);
    this._flushBuffer(out, 0);
    return this._unpad(out);
};

},{"85cfb697294fd1d8":"8OvWh"}],"8OvWh":[function(require,module,exports) {
module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};

},{}],"gDFTo":[function(require,module,exports) {
"use strict";
var assert = require("2e43e10aa2de50ed");
var inherits = require("551480b8aa09d318");
var utils = require("b6dc5b7926f5a82f");
var Cipher = require("38547d2f1967e2cd");
function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
}
function DES(options) {
    Cipher.call(this, options);
    var state = new DESState();
    this._desState = state;
    this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;
DES.create = function create(options) {
    return new DES(options);
};
var shiftTable = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
];
DES.prototype.deriveKeys = function deriveKeys(state, key) {
    state.keys = new Array(32);
    assert.equal(key.length, this.blockSize, "Invalid key length");
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];
    for(var i = 0; i < state.keys.length; i += 2){
        var shift = shiftTable[i >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i);
    }
};
DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(inp, inOff);
    var r = utils.readUInt32BE(inp, inOff + 4);
    // Initial Permutation
    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if (this.type === "encrypt") this._encrypt(state, l, r, state.tmp, 0);
    else this._decrypt(state, l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
};
DES.prototype._pad = function _pad(buffer, off) {
    if (this.padding === false) return false;
    var value = buffer.length - off;
    for(var i = off; i < buffer.length; i++)buffer[i] = value;
    return true;
};
DES.prototype._unpad = function _unpad(buffer) {
    if (this.padding === false) return buffer;
    var pad = buffer[buffer.length - 1];
    for(var i = buffer.length - pad; i < buffer.length; i++)assert.equal(buffer[i], pad);
    return buffer.slice(0, buffer.length - pad);
};
DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart;
    // Apply f() x16 times
    for(var i = 0; i < state.keys.length; i += 2){
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        // f(r, k)
        utils.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = r;
        r = (l ^ f) >>> 0;
        l = t;
    }
    // Reverse Initial Permutation
    utils.rip(r, l, out, off);
};
DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart;
    // Apply f() x16 times
    for(var i = state.keys.length - 2; i >= 0; i -= 2){
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        // f(r, k)
        utils.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = l;
        l = (r ^ f) >>> 0;
        r = t;
    }
    // Reverse Initial Permutation
    utils.rip(l, r, out, off);
};

},{"2e43e10aa2de50ed":"8OvWh","551480b8aa09d318":"bRL3M","b6dc5b7926f5a82f":"aeccw","38547d2f1967e2cd":"jz3In"}],"lPo0P":[function(require,module,exports) {
"use strict";
var assert = require("63ac301527fc117b");
var inherits = require("7d48f4d3d39d3b86");
var proto = {};
function CBCState(iv) {
    assert.equal(iv.length, 8, "Invalid IV length");
    this.iv = new Array(8);
    for(var i = 0; i < this.iv.length; i++)this.iv[i] = iv[i];
}
function instantiate(Base) {
    function CBC(options) {
        Base.call(this, options);
        this._cbcInit();
    }
    inherits(CBC, Base);
    var keys = Object.keys(proto);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        CBC.prototype[key] = proto[key];
    }
    CBC.create = function create(options) {
        return new CBC(options);
    };
    return CBC;
}
exports.instantiate = instantiate;
proto._cbcInit = function _cbcInit() {
    var state = new CBCState(this.options.iv);
    this._cbcState = state;
};
proto._update = function _update(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state.iv;
    if (this.type === "encrypt") {
        for(var i = 0; i < this.blockSize; i++)iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for(var i = 0; i < this.blockSize; i++)iv[i] = out[outOff + i];
    } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for(var i = 0; i < this.blockSize; i++)out[outOff + i] ^= iv[i];
        for(var i = 0; i < this.blockSize; i++)iv[i] = inp[inOff + i];
    }
};

},{"63ac301527fc117b":"8OvWh","7d48f4d3d39d3b86":"bRL3M"}],"avp7S":[function(require,module,exports) {
"use strict";
var assert = require("d5bfc55b5aa12c8d");
var inherits = require("39ce41101e752862");
var Cipher = require("ba2db61b5607fad4");
var DES = require("f13080dd5389ba87");
function EDEState(type, key) {
    assert.equal(key.length, 24, "Invalid key length");
    var k1 = key.slice(0, 8);
    var k2 = key.slice(8, 16);
    var k3 = key.slice(16, 24);
    if (type === "encrypt") this.ciphers = [
        DES.create({
            type: "encrypt",
            key: k1
        }),
        DES.create({
            type: "decrypt",
            key: k2
        }),
        DES.create({
            type: "encrypt",
            key: k3
        })
    ];
    else this.ciphers = [
        DES.create({
            type: "decrypt",
            key: k3
        }),
        DES.create({
            type: "encrypt",
            key: k2
        }),
        DES.create({
            type: "decrypt",
            key: k1
        })
    ];
}
function EDE(options) {
    Cipher.call(this, options);
    var state = new EDEState(this.type, this.options.key);
    this._edeState = state;
}
inherits(EDE, Cipher);
module.exports = EDE;
EDE.create = function create(options) {
    return new EDE(options);
};
EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._edeState;
    state.ciphers[0]._update(inp, inOff, out, outOff);
    state.ciphers[1]._update(out, outOff, out, outOff);
    state.ciphers[2]._update(out, outOff, out, outOff);
};
EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"d5bfc55b5aa12c8d":"8OvWh","39ce41101e752862":"bRL3M","ba2db61b5607fad4":"jz3In","f13080dd5389ba87":"gDFTo"}],"hnlHj":[function(require,module,exports) {
var ciphers = require("852cf53431a1f811");
var deciphers = require("cf65999dbb4c5e15");
var modes = require("deceb76ffb34f58f");
function getCiphers() {
    return Object.keys(modes);
}
exports.createCipher = exports.Cipher = ciphers.createCipher;
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
exports.createDecipher = exports.Decipher = deciphers.createDecipher;
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"852cf53431a1f811":"7DBsd","cf65999dbb4c5e15":"cixt2","deceb76ffb34f58f":"1XQMU"}],"7DBsd":[function(require,module,exports) {
var MODES = require("634015cf40a677fe");
var AuthCipher = require("ca7c032525082be8");
var Buffer = require("2bd35013f47d4062").Buffer;
var StreamCipher = require("2b03aae3a1335af6");
var Transform = require("138a78277ccfd16f");
var aes = require("cc8a1e2b2934f08f");
var ebtk = require("b149eab8b94068d4");
var inherits = require("ebc328fc178264d2");
function Cipher(mode, key, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._cipher = new aes.AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
inherits(Cipher, Transform);
Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
var PADDING = Buffer.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i = -1;
    while(++i < len)padBuff.writeUInt8(len, i);
    return Buffer.concat([
        this.cache,
        padBuff
    ]);
};
function createCipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (config.type === "stream") return new StreamCipher(config.module, password, iv);
    else if (config.type === "auth") return new AuthCipher(config.module, password, iv);
    return new Cipher(config.module, password, iv);
}
function createCipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createCipheriv(suite, keys.key, keys.iv);
}
exports.createCipheriv = createCipheriv;
exports.createCipher = createCipher;

},{"634015cf40a677fe":"jyQSU","ca7c032525082be8":"kn9wf","2bd35013f47d4062":"eW7r9","2b03aae3a1335af6":"4ZMNU","138a78277ccfd16f":"g5fTz","cc8a1e2b2934f08f":"4VzKF","b149eab8b94068d4":"1rd4d","ebc328fc178264d2":"bRL3M"}],"jyQSU":[function(require,module,exports) {
var modeModules = {
    ECB: require("c49ddaf3154fac1e"),
    CBC: require("7c781e2d9206f623"),
    CFB: require("12dfbd130b5827a1"),
    CFB8: require("ae02434166690767"),
    CFB1: require("15ddc45cf76ec123"),
    OFB: require("62e3e290f0879f98"),
    CTR: require("1e6578fa70b860a7"),
    GCM: require("1e6578fa70b860a7")
};
var modes = require("b313067770c9aed2");
for(var key in modes)modes[key].module = modeModules[modes[key].mode];
module.exports = modes;

},{"c49ddaf3154fac1e":"f4tme","7c781e2d9206f623":"8JcO4","12dfbd130b5827a1":"dVMRE","ae02434166690767":"jk3Qm","15ddc45cf76ec123":"4BsKj","62e3e290f0879f98":"9DT3x","1e6578fa70b860a7":"fLj86","b313067770c9aed2":"1XQMU"}],"f4tme":[function(require,module,exports) {
exports.encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
};
exports.decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
};

},{}],"8JcO4":[function(require,module,exports) {
var xor = require("587e692127ea2c31");
exports.encrypt = function(self, block) {
    var data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
};
exports.decrypt = function(self, block) {
    var pad = self._prev;
    self._prev = block;
    var out = self._cipher.decryptBlock(block);
    return xor(out, pad);
};

},{"587e692127ea2c31":"eYhY5"}],"eYhY5":[function(require,module,exports) {
var Buffer = require("ccae1b11eb3a9ec8").Buffer;
module.exports = function xor(a, b) {
    var length = Math.min(a.length, b.length);
    var buffer = new Buffer(length);
    for(var i = 0; i < length; ++i)buffer[i] = a[i] ^ b[i];
    return buffer;
};

},{"ccae1b11eb3a9ec8":"fCgem"}],"dVMRE":[function(require,module,exports) {
var Buffer = require("7747ec7a535c746a").Buffer;
var xor = require("fe4415d84c8f2a05");
function encryptStart(self, data, decrypt) {
    var len = data.length;
    var out = xor(data, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer.concat([
        self._prev,
        decrypt ? data : out
    ]);
    return out;
}
exports.encrypt = function(self, data, decrypt) {
    var out = Buffer.allocUnsafe(0);
    var len;
    while(data.length){
        if (self._cache.length === 0) {
            self._cache = self._cipher.encryptBlock(self._prev);
            self._prev = Buffer.allocUnsafe(0);
        }
        if (self._cache.length <= data.length) {
            len = self._cache.length;
            out = Buffer.concat([
                out,
                encryptStart(self, data.slice(0, len), decrypt)
            ]);
            data = data.slice(len);
        } else {
            out = Buffer.concat([
                out,
                encryptStart(self, data, decrypt)
            ]);
            break;
        }
    }
    return out;
};

},{"7747ec7a535c746a":"eW7r9","fe4415d84c8f2a05":"eYhY5"}],"jk3Qm":[function(require,module,exports) {
var Buffer = require("36c8b61b54eac90b").Buffer;
function encryptByte(self, byteParam, decrypt) {
    var pad = self._cipher.encryptBlock(self._prev);
    var out = pad[0] ^ byteParam;
    self._prev = Buffer.concat([
        self._prev.slice(1),
        Buffer.from([
            decrypt ? byteParam : out
        ])
    ]);
    return out;
}
exports.encrypt = function(self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;
    while(++i < len)out[i] = encryptByte(self, chunk[i], decrypt);
    return out;
};

},{"36c8b61b54eac90b":"eW7r9"}],"4BsKj":[function(require,module,exports) {
var Buffer = require("5eb46e1eefd15734").Buffer;
function encryptByte(self, byteParam, decrypt) {
    var pad;
    var i = -1;
    var len = 8;
    var out = 0;
    var bit, value;
    while(++i < len){
        pad = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }
    return out;
}
function shiftIn(buffer, value) {
    var len = buffer.length;
    var i = -1;
    var out = Buffer.allocUnsafe(buffer.length);
    buffer = Buffer.concat([
        buffer,
        Buffer.from([
            value
        ])
    ]);
    while(++i < len)out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    return out;
}
exports.encrypt = function(self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;
    while(++i < len)out[i] = encryptByte(self, chunk[i], decrypt);
    return out;
};

},{"5eb46e1eefd15734":"eW7r9"}],"9DT3x":[function(require,module,exports) {
var Buffer = require("b3ff65e516d49ef1").Buffer;
var xor = require("7f0c2ff10cf58835");
function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
}
exports.encrypt = function(self, chunk) {
    while(self._cache.length < chunk.length)self._cache = Buffer.concat([
        self._cache,
        getBlock(self)
    ]);
    var pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};

},{"b3ff65e516d49ef1":"fCgem","7f0c2ff10cf58835":"eYhY5"}],"fLj86":[function(require,module,exports) {
var xor = require("9e40d7dfdb715c7");
var Buffer = require("53cb1eb6f102a1c9").Buffer;
var incr32 = require("57780b841d591d93");
function getBlock(self) {
    var out = self._cipher.encryptBlockRaw(self._prev);
    incr32(self._prev);
    return out;
}
var blockSize = 16;
exports.encrypt = function(self, chunk) {
    var chunkNum = Math.ceil(chunk.length / blockSize);
    var start = self._cache.length;
    self._cache = Buffer.concat([
        self._cache,
        Buffer.allocUnsafe(chunkNum * blockSize)
    ]);
    for(var i = 0; i < chunkNum; i++){
        var out = getBlock(self);
        var offset = start + i * blockSize;
        self._cache.writeUInt32BE(out[0], offset + 0);
        self._cache.writeUInt32BE(out[1], offset + 4);
        self._cache.writeUInt32BE(out[2], offset + 8);
        self._cache.writeUInt32BE(out[3], offset + 12);
    }
    var pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};

},{"9e40d7dfdb715c7":"eYhY5","53cb1eb6f102a1c9":"eW7r9","57780b841d591d93":"bZlDZ"}],"bZlDZ":[function(require,module,exports) {
function incr32(iv) {
    var len = iv.length;
    var item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) iv.writeUInt8(0, len);
        else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
module.exports = incr32;

},{}],"1XQMU":[function(require,module,exports) {
module.exports = JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}');

},{}],"kn9wf":[function(require,module,exports) {
var aes = require("b0edcf3ce18ae4ef");
var Buffer = require("2c8f7ba691c38788").Buffer;
var Transform = require("1432783a1879aa01");
var inherits = require("60e0d0bfceaaf739");
var GHASH = require("f76de0f4100ad13f");
var xor = require("a9c82903acf3978e");
var incr32 = require("4e429278132497a7");
function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);
    for(var i = 0; i < len; ++i)out += a[i] ^ b[i];
    return out;
}
function calcIv(self, iv, ck) {
    if (iv.length === 12) {
        self._finID = Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer.alloc(toPad, 0));
    }
    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 0, 8);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer.from(self._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this);
    var h = Buffer.alloc(4, 0);
    this._cipher = new aes.AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
}
inherits(StreamCipher, Transform);
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) this._ghash.update(chunk);
    else this._ghash.update(out);
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = tag;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(buf);
    this._alen += buf.length;
};
module.exports = StreamCipher;

},{"b0edcf3ce18ae4ef":"4VzKF","2c8f7ba691c38788":"eW7r9","1432783a1879aa01":"g5fTz","60e0d0bfceaaf739":"bRL3M","f76de0f4100ad13f":"lmx0M","a9c82903acf3978e":"eYhY5","4e429278132497a7":"bZlDZ"}],"4VzKF":[function(require,module,exports) {
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/
var Buffer = require("9c4f04f75f375be").Buffer;
function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i = 0; i < len; i++)out[i] = buf.readUInt32BE(i * 4);
    return out;
}
function scrubVec(v) {
    for(var i = 0; i < v.length; v++)v[i] = 0;
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
// AES constants
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    // Compute double table
    var d = new Array(256);
    for(var j = 0; j < 256; j++)if (j < 128) d[j] = j << 1;
    else d[j] = j << 1 ^ 0x11b;
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    // Walk GF(2^8)
    var x = 0;
    var xi = 0;
    for(var i = 0; i < 256; ++i){
        // Compute sbox
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        // Compute sub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) x = xi = 1;
        else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 16;
AES.keySize = 32;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k = 0; k < keySize; k++)keySchedule[k] = keyWords[k];
    for(k = keySize; k < ksRows; k++){
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        keySchedule[k] = keySchedule[k - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) invKeySchedule[ik] = tt;
        else invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    // swap
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
module.exports.AES = AES;

},{"9c4f04f75f375be":"eW7r9"}],"lmx0M":[function(require,module,exports) {
var Buffer = require("815beeecbe039d1a").Buffer;
var ZEROES = Buffer.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
    ];
}
function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer.alloc(16, 0);
    this.cache = Buffer.allocUnsafe(0);
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function(block) {
    var i = -1;
    while(++i < block.length)this.state[i] ^= block[i];
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i = -1;
    while(++i < 128){
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
            // Z_i+1 = Z_i ^ V_i
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        // Store the value of LSB(V_i)
        lsbVi = (Vi[3] & 1) !== 0;
        // V_i+1 = V_i >> 1
        for(j = 3; j > 0; j--)Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        Vi[0] = Vi[0] >>> 1;
        // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
        if (lsbVi) Vi[0] = Vi[0] ^ -520093696;
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) this.ghash(Buffer.concat([
        this.cache,
        ZEROES
    ], 16));
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
module.exports = GHASH;

},{"815beeecbe039d1a":"eW7r9"}],"4ZMNU":[function(require,module,exports) {
var aes = require("499d62308d7dac40");
var Buffer = require("bc4a1f7113303d58").Buffer;
var Transform = require("e701745abb80bc49");
var inherits = require("3765f10ec3d7a831");
function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this);
    this._cipher = new aes.AES(key);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
}
inherits(StreamCipher, Transform);
StreamCipher.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher.prototype._final = function() {
    this._cipher.scrub();
};
module.exports = StreamCipher;

},{"499d62308d7dac40":"4VzKF","bc4a1f7113303d58":"eW7r9","e701745abb80bc49":"g5fTz","3765f10ec3d7a831":"bRL3M"}],"1rd4d":[function(require,module,exports) {
var Buffer = require("adb33291e0f9c65a").Buffer;
var MD5 = require("15f984dc9e3797d9");
/* eslint-disable camelcase */ function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");
    if (salt) {
        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
        if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
    }
    var keyLen = keyBits / 8;
    var key = Buffer.alloc(keyLen);
    var iv = Buffer.alloc(ivLen || 0);
    var tmp = Buffer.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        var hash = new MD5();
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        var used = 0;
        if (keyLen > 0) {
            var keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen;
            var length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key: key,
        iv: iv
    };
}
module.exports = EVP_BytesToKey;

},{"adb33291e0f9c65a":"eW7r9","15f984dc9e3797d9":"45VeE"}],"cixt2":[function(require,module,exports) {
var AuthCipher = require("2f5914bdcee0aab2");
var Buffer = require("2eedc5cbfd1eafeb").Buffer;
var MODES = require("2b861a45e2a2d1fe");
var StreamCipher = require("54b6d333d74ae9c8");
var Transform = require("4b438dd1327af64e");
var aes = require("928aea47daff81dc");
var ebtk = require("25542df8da1646fe");
var inherits = require("153b885d89d2089e");
function Decipher(mode, key, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._last = void 0;
    this._cipher = new aes.AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
inherits(Decipher, Transform);
Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) return unpad(this._mode.decrypt(this, chunk));
    else if (chunk) throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else if (this.cache.length >= 16) {
        out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) throw new Error("unable to decrypt data");
    var i = -1;
    while(++i < padded){
        if (last[i + (16 - padded)] !== padded) throw new Error("unable to decrypt data");
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (config.type === "stream") return new StreamCipher(config.module, password, iv, true);
    else if (config.type === "auth") return new AuthCipher(config.module, password, iv, true);
    return new Decipher(config.module, password, iv);
}
function createDecipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createDecipheriv(suite, keys.key, keys.iv);
}
exports.createDecipher = createDecipher;
exports.createDecipheriv = createDecipheriv;

},{"2f5914bdcee0aab2":"kn9wf","2eedc5cbfd1eafeb":"eW7r9","2b861a45e2a2d1fe":"jyQSU","54b6d333d74ae9c8":"4ZMNU","4b438dd1327af64e":"g5fTz","928aea47daff81dc":"4VzKF","25542df8da1646fe":"1rd4d","153b885d89d2089e":"bRL3M"}],"iO8co":[function(require,module,exports) {
exports["des-ecb"] = {
    key: 8,
    iv: 0
};
exports["des-cbc"] = exports.des = {
    key: 8,
    iv: 8
};
exports["des-ede3-cbc"] = exports.des3 = {
    key: 24,
    iv: 8
};
exports["des-ede3"] = {
    key: 24,
    iv: 0
};
exports["des-ede-cbc"] = {
    key: 16,
    iv: 8
};
exports["des-ede"] = {
    key: 16,
    iv: 0
};

},{}],"hwD3y":[function(require,module,exports) {
var Buffer = require("55a084ce1a29baa3").Buffer;
var generatePrime = require("5ed99cf028c947ad");
var primes = require("8da23ed5d7edf952");
var DH = require("981b8db942febaf3");
function getDiffieHellman(mod) {
    var prime = new Buffer(primes[mod].prime, "hex");
    var gen = new Buffer(primes[mod].gen, "hex");
    return new DH(prime, gen);
}
var ENCODINGS = {
    "binary": true,
    "hex": true,
    "base64": true
};
function createDiffieHellman(prime, enc, generator, genc) {
    if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) return createDiffieHellman(prime, "binary", enc, generator);
    enc = enc || "binary";
    genc = genc || "binary";
    generator = generator || new Buffer([
        2
    ]);
    if (!Buffer.isBuffer(generator)) generator = new Buffer(generator, genc);
    if (typeof prime === "number") return new DH(generatePrime(prime, generator), generator, true);
    if (!Buffer.isBuffer(prime)) prime = new Buffer(prime, enc);
    return new DH(prime, generator, true);
}
exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

},{"55a084ce1a29baa3":"fCgem","5ed99cf028c947ad":"ZMXAL","8da23ed5d7edf952":"ch1XV","981b8db942febaf3":"f8kfc"}],"ZMXAL":[function(require,module,exports) {
var randomBytes = require("e11b752ebf414e01");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require("6139735ee181267b");
var TWENTYFOUR = new BN(24);
var MillerRabin = require("7b3f73f9ab7b2b6a");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;
function _getPrimes() {
    if (primes !== null) return primes;
    var limit = 0x100000;
    var res = [];
    res[0] = 2;
    for(var i = 1, k = 3; k < limit; k += 2){
        var sqrt = Math.ceil(Math.sqrt(k));
        for(var j = 0; j < i && res[j] <= sqrt; j++)if (k % res[j] === 0) break;
        if (i !== j && res[j] <= sqrt) continue;
        res[i++] = k;
    }
    primes = res;
    return res;
}
function simpleSieve(p) {
    var primes = _getPrimes();
    for(var i = 0; i < primes.length; i++)if (p.modn(primes[i]) === 0) {
        if (p.cmpn(primes[i]) === 0) return true;
        else return false;
    }
    return true;
}
function fermatTest(p) {
    var red = BN.mont(p);
    return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}
function findPrime(bits, gen) {
    if (bits < 16) {
        // this is what openssl does
        if (gen === 2 || gen === 5) return new BN([
            0x8c,
            0x7b
        ]);
        else return new BN([
            0x8c,
            0x27
        ]);
    }
    gen = new BN(gen);
    var num, n2;
    while(true){
        num = new BN(randomBytes(Math.ceil(bits / 8)));
        while(num.bitLength() > bits)num.ishrn(1);
        if (num.isEven()) num.iadd(ONE);
        if (!num.testn(1)) num.iadd(TWO);
        if (!gen.cmp(TWO)) while(num.mod(TWENTYFOUR).cmp(ELEVEN))num.iadd(FOUR);
        else if (!gen.cmp(FIVE)) while(num.mod(TEN).cmp(THREE))num.iadd(FOUR);
        n2 = num.shrn(1);
        if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) return num;
    }
}

},{"e11b752ebf414e01":"8hjhE","6139735ee181267b":"VopIn","7b3f73f9ab7b2b6a":"i79Nu"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // 'A' - 'F'
        if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else return c - 48 & 0xf;
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this.strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is BN v4 instance
        r.strip();
        else // r is BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"bXKEI"}],"i79Nu":[function(require,module,exports) {
var bn = require("31d279a7646d17e9");
var brorand = require("1ed277e13aa258c6");
function MillerRabin(rand) {
    this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;
MillerRabin.create = function create(rand) {
    return new MillerRabin(rand);
};
MillerRabin.prototype._randbelow = function _randbelow(n) {
    var len = n.bitLength();
    var min_bytes = Math.ceil(len / 8);
    // Generage random bytes until a number less than n is found.
    // This ensures that 0..n-1 have an equal probability of being selected.
    do var a = new bn(this.rand.generate(min_bytes));
    while (a.cmp(n) >= 0);
    return a;
};
MillerRabin.prototype._randrange = function _randrange(start, stop) {
    // Generate a random number greater than or equal to start and less than stop.
    var size = stop.sub(start);
    return start.add(this._randbelow(size));
};
MillerRabin.prototype.test = function test(n, k, cb) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k) k = Math.max(1, len / 48 | 0);
    // Find d and s, (n - 1) = (2 ^ s) * d;
    var n1 = n.subn(1);
    for(var s = 0; !n1.testn(s); s++);
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    var prime = true;
    for(; k > 0; k--){
        var a = this._randrange(new bn(2), n1);
        if (cb) cb(a);
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
        for(var i = 1; i < s; i++){
            x = x.redSqr();
            if (x.cmp(rone) === 0) return false;
            if (x.cmp(rn1) === 0) break;
        }
        if (i === s) return false;
    }
    return prime;
};
MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k) k = Math.max(1, len / 48 | 0);
    // Find d and s, (n - 1) = (2 ^ s) * d;
    var n1 = n.subn(1);
    for(var s = 0; !n1.testn(s); s++);
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    for(; k > 0; k--){
        var a = this._randrange(new bn(2), n1);
        var g = n.gcd(a);
        if (g.cmpn(1) !== 0) return g;
        var x = a.toRed(red).redPow(d);
        if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
        for(var i = 1; i < s; i++){
            x = x.redSqr();
            if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
            if (x.cmp(rn1) === 0) break;
        }
        if (i === s) {
            x = x.redSqr();
            return x.fromRed().subn(1).gcd(n);
        }
    }
    return false;
};

},{"31d279a7646d17e9":"VopIn","1ed277e13aa258c6":"8FGdh"}],"8FGdh":[function(require,module,exports) {
var r;
module.exports = function rand(len) {
    if (!r) r = new Rand(null);
    return r.generate(len);
};
function Rand(rand) {
    this.rand = rand;
}
module.exports.Rand = Rand;
Rand.prototype.generate = function generate(len) {
    return this._rand(len);
};
// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes) return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for(var i = 0; i < res.length; i++)res[i] = this.rand.getByte();
    return res;
};
if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) // Modern browsers
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
    };
    else if (self.msCrypto && self.msCrypto.getRandomValues) // IE
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
    };
    else if (typeof window === "object") // Old junk
    Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
    };
} else // Node.js or Web worker with no crypto support
try {
    var crypto = require("e8ad0674730919a8");
    if (typeof crypto.randomBytes !== "function") throw new Error("Not supported");
    Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
    };
} catch (e) {}

},{"e8ad0674730919a8":"bXKEI"}],"ch1XV":[function(require,module,exports) {
module.exports = JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}');

},{}],"f8kfc":[function(require,module,exports) {
var Buffer = require("18c258c24cda4205").Buffer;
var BN = require("6cfaed55db270425");
var MillerRabin = require("8bc0d9823ee74460");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require("dd39d03f4b3404fc");
var randomBytes = require("e2757e55299a3ebc");
module.exports = DH;
function setPublicKey(pub, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub)) pub = new Buffer(pub, enc);
    this._pub = new BN(pub);
    return this;
}
function setPrivateKey(priv, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv)) priv = new Buffer(priv, enc);
    this._priv = new BN(priv);
    return this;
}
var primeCache = {};
function checkPrime(prime, generator) {
    var gen = generator.toString("hex");
    var hex = [
        gen,
        prime.toString(16)
    ].join("_");
    if (hex in primeCache) return primeCache[hex];
    var error = 0;
    if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        //not a prime so +1
        error += 1;
        if (gen === "02" || gen === "05") // we'd be able to check the generator
        // it would fail so +8
        error += 8;
        else //we wouldn't be able to test the generator
        // so +4
        error += 4;
        primeCache[hex] = error;
        return error;
    }
    if (!millerRabin.test(prime.shrn(1))) //not a safe prime
    error += 2;
    var rem;
    switch(gen){
        case "02":
            if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) // unsuidable generator
            error += 8;
            break;
        case "05":
            rem = prime.mod(TEN);
            if (rem.cmp(THREE) && rem.cmp(SEVEN)) // prime mod 10 needs to equal 3 or 7
            error += 8;
            break;
        default:
            error += 4;
    }
    primeCache[hex] = error;
    return error;
}
function DH(prime, generator, malleable) {
    this.setGenerator(generator);
    this.__prime = new BN(prime);
    this._prime = BN.mont(this.__prime);
    this._primeLen = prime.length;
    this._pub = undefined;
    this._priv = undefined;
    this._primeCode = undefined;
    if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
    } else this._primeCode = 8;
}
Object.defineProperty(DH.prototype, "verifyError", {
    enumerable: true,
    get: function() {
        if (typeof this._primeCode !== "number") this._primeCode = checkPrime(this.__prime, this.__gen);
        return this._primeCode;
    }
});
DH.prototype.generateKeys = function() {
    if (!this._priv) this._priv = new BN(randomBytes(this._primeLen));
    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
    return this.getPublicKey();
};
DH.prototype.computeSecret = function(other) {
    other = new BN(other);
    other = other.toRed(this._prime);
    var secret = other.redPow(this._priv).fromRed();
    var out = new Buffer(secret.toArray());
    var prime = this.getPrime();
    if (out.length < prime.length) {
        var front = new Buffer(prime.length - out.length);
        front.fill(0);
        out = Buffer.concat([
            front,
            out
        ]);
    }
    return out;
};
DH.prototype.getPublicKey = function getPublicKey(enc) {
    return formatReturnValue(this._pub, enc);
};
DH.prototype.getPrivateKey = function getPrivateKey(enc) {
    return formatReturnValue(this._priv, enc);
};
DH.prototype.getPrime = function(enc) {
    return formatReturnValue(this.__prime, enc);
};
DH.prototype.getGenerator = function(enc) {
    return formatReturnValue(this._gen, enc);
};
DH.prototype.setGenerator = function(gen, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(gen)) gen = new Buffer(gen, enc);
    this.__gen = gen;
    this._gen = new BN(gen);
    return this;
};
function formatReturnValue(bn, enc) {
    var buf = new Buffer(bn.toArray());
    if (!enc) return buf;
    else return buf.toString(enc);
}

},{"18c258c24cda4205":"fCgem","6cfaed55db270425":"VopIn","8bc0d9823ee74460":"i79Nu","dd39d03f4b3404fc":"ZMXAL","e2757e55299a3ebc":"8hjhE"}],"jbRNy":[function(require,module,exports) {
"use strict";
var Buffer = require("9c72b70d69889676").Buffer;
var createHash = require("efe64c48bedfa38e");
var stream = require("6a5343e9b2081ca8");
var inherits = require("f95e32eac8325984");
var sign = require("6e9f6edb752a2c10");
var verify = require("c2f6e4379d1db430");
var algorithms = require("2d93707c75adaee");
Object.keys(algorithms).forEach(function(key) {
    algorithms[key].id = Buffer.from(algorithms[key].id, "hex");
    algorithms[key.toLowerCase()] = algorithms[key];
});
function Sign(algorithm) {
    stream.Writable.call(this);
    var data = algorithms[algorithm];
    if (!data) throw new Error("Unknown message digest");
    this._hashType = data.hash;
    this._hash = createHash(data.hash);
    this._tag = data.id;
    this._signType = data.sign;
}
inherits(Sign, stream.Writable);
Sign.prototype._write = function _write(data, _, done) {
    this._hash.update(data);
    done();
};
Sign.prototype.update = function update(data, enc) {
    this._hash.update(typeof data === "string" ? Buffer.from(data, enc) : data);
    return this;
};
Sign.prototype.sign = function signMethod(key, enc) {
    this.end();
    var hash = this._hash.digest();
    var sig = sign(hash, key, this._hashType, this._signType, this._tag);
    return enc ? sig.toString(enc) : sig;
};
function Verify(algorithm) {
    stream.Writable.call(this);
    var data = algorithms[algorithm];
    if (!data) throw new Error("Unknown message digest");
    this._hash = createHash(data.hash);
    this._tag = data.id;
    this._signType = data.sign;
}
inherits(Verify, stream.Writable);
Verify.prototype._write = function _write(data, _, done) {
    this._hash.update(data);
    done();
};
Verify.prototype.update = function update(data, enc) {
    this._hash.update(typeof data === "string" ? Buffer.from(data, enc) : data);
    return this;
};
Verify.prototype.verify = function verifyMethod(key, sig, enc) {
    var sigBuffer = typeof sig === "string" ? Buffer.from(sig, enc) : sig;
    this.end();
    var hash = this._hash.digest();
    return verify(sigBuffer, hash, key, this._signType, this._tag);
};
function createSign(algorithm) {
    return new Sign(algorithm);
}
function createVerify(algorithm) {
    return new Verify(algorithm);
}
module.exports = {
    Sign: createSign,
    Verify: createVerify,
    createSign: createSign,
    createVerify: createVerify
};

},{"9c72b70d69889676":"eW7r9","efe64c48bedfa38e":"2WyL8","6a5343e9b2081ca8":"jXNWE","f95e32eac8325984":"bRL3M","6e9f6edb752a2c10":"lDgyi","c2f6e4379d1db430":"vbFso","2d93707c75adaee":"kWFdV"}],"lDgyi":[function(require,module,exports) {
"use strict";
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require("6ae1d89b9934a98d").Buffer;
var createHmac = require("a8da94153ecfc34b");
var crt = require("51cccb2c4d98daac");
var EC = require("94cc3a287d70a03d").ec;
var BN = require("e83ac2526d8afeba");
var parseKeys = require("892f1603b4523d84");
var curves = require("d22eecc2600c2d97");
var RSA_PKCS1_PADDING = 1;
function sign(hash, key, hashType, signType, tag) {
    var priv = parseKeys(key);
    if (priv.curve) {
        // rsa keys can be interpreted as ecdsa ones in openssl
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa") throw new Error("wrong private key type");
        return ecSign(hash, priv);
    } else if (priv.type === "dsa") {
        if (signType !== "dsa") throw new Error("wrong private key type");
        return dsaSign(hash, priv, hashType);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") throw new Error("wrong private key type");
    if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) throw new Error("illegal or unsupported padding mode");
    hash = Buffer.concat([
        tag,
        hash
    ]);
    var len = priv.modulus.byteLength();
    var pad = [
        0,
        1
    ];
    while(hash.length + pad.length + 1 < len)pad.push(0xff);
    pad.push(0x00);
    var i = -1;
    while(++i < hash.length)pad.push(hash[i]);
    var out = crt(pad, priv);
    return out;
}
function ecSign(hash, priv) {
    var curveId = curves[priv.curve.join(".")];
    if (!curveId) throw new Error("unknown curve " + priv.curve.join("."));
    var curve = new EC(curveId);
    var key = curve.keyFromPrivate(priv.privateKey);
    var out = key.sign(hash);
    return Buffer.from(out.toDER());
}
function dsaSign(hash, priv, algo) {
    var x = priv.params.priv_key;
    var p = priv.params.p;
    var q = priv.params.q;
    var g = priv.params.g;
    var r = new BN(0);
    var k;
    var H = bits2int(hash, q).mod(q);
    var s = false;
    var kv = getKey(x, q, hash, algo);
    while(s === false){
        k = makeKey(q, kv, algo);
        r = makeR(g, k, p, q);
        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
        if (s.cmpn(0) === 0) {
            s = false;
            r = new BN(0);
        }
    }
    return toDER(r, s);
}
function toDER(r, s) {
    r = r.toArray();
    s = s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    var total = r.length + s.length + 4;
    var res = [
        0x30,
        total,
        0x02,
        r.length
    ];
    res = res.concat(r, [
        0x02,
        s.length
    ], s);
    return Buffer.from(res);
}
function getKey(x, q, hash, algo) {
    x = Buffer.from(x.toArray());
    if (x.length < q.byteLength()) {
        var zeros = Buffer.alloc(q.byteLength() - x.length);
        x = Buffer.concat([
            zeros,
            x
        ]);
    }
    var hlen = hash.length;
    var hbits = bits2octets(hash, q);
    var v = Buffer.alloc(hlen);
    v.fill(1);
    var k = Buffer.alloc(hlen);
    k = createHmac(algo, k).update(v).update(Buffer.from([
        0
    ])).update(x).update(hbits).digest();
    v = createHmac(algo, k).update(v).digest();
    k = createHmac(algo, k).update(v).update(Buffer.from([
        1
    ])).update(x).update(hbits).digest();
    v = createHmac(algo, k).update(v).digest();
    return {
        k: k,
        v: v
    };
}
function bits2int(obits, q) {
    var bits = new BN(obits);
    var shift = (obits.length << 3) - q.bitLength();
    if (shift > 0) bits.ishrn(shift);
    return bits;
}
function bits2octets(bits, q) {
    bits = bits2int(bits, q);
    bits = bits.mod(q);
    var out = Buffer.from(bits.toArray());
    if (out.length < q.byteLength()) {
        var zeros = Buffer.alloc(q.byteLength() - out.length);
        out = Buffer.concat([
            zeros,
            out
        ]);
    }
    return out;
}
function makeKey(q, kv, algo) {
    var t;
    var k;
    do {
        t = Buffer.alloc(0);
        while(t.length * 8 < q.bitLength()){
            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            t = Buffer.concat([
                t,
                kv.v
            ]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([
            0
        ])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
    }while (k.cmp(q) !== -1);
    return k;
}
function makeR(g, k, p, q) {
    return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}
module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;

},{"6ae1d89b9934a98d":"eW7r9","a8da94153ecfc34b":"k1utz","51cccb2c4d98daac":"e594P","94cc3a287d70a03d":"1NKsH","e83ac2526d8afeba":"dkoZR","892f1603b4523d84":"4Szbv","d22eecc2600c2d97":"iadQk"}],"e594P":[function(require,module,exports) {
var Buffer = require("a54d4e6dcf549cd6").Buffer;
var BN = require("5d911a7c773081c");
var randomBytes = require("cfe4d67488897360");
function blind(priv) {
    var r = getr(priv);
    var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    var len = priv.modulus.byteLength();
    var r;
    do r = new BN(randomBytes(len));
    while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
    return r;
}
function crt(msg, priv) {
    var blinds = blind(priv);
    var len = priv.modulus.byteLength();
    var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    var c1 = blinded.toRed(BN.mont(priv.prime1));
    var c2 = blinded.toRed(BN.mont(priv.prime2));
    var qinv = priv.coefficient;
    var p = priv.prime1;
    var q = priv.prime2;
    var m1 = c1.redPow(priv.exponent1).fromRed();
    var m2 = c2.redPow(priv.exponent2).fromRed();
    var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
}
crt.getr = getr;
module.exports = crt;

},{"a54d4e6dcf549cd6":"fCgem","5d911a7c773081c":"a7QF4","cfe4d67488897360":"8hjhE"}],"a7QF4":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("79c4f6b461b259c").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, "Invalid character in " + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    } catch (e) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"79c4f6b461b259c":"bXKEI"}],"1NKsH":[function(require,module,exports) {
"use strict";
var elliptic = exports;
elliptic.version = require("e6672bc3ba1c9961").version;
elliptic.utils = require("5bc72f89931ad0f5");
elliptic.rand = require("7f90d752a36f35cf");
elliptic.curve = require("d11da69c91421223");
elliptic.curves = require("6845bad4ed92c3e4");
// Protocols
elliptic.ec = require("b5f2e1f615acc4b");
elliptic.eddsa = require("79ae761761517980");

},{"e6672bc3ba1c9961":"bvED4","5bc72f89931ad0f5":"8sNT5","7f90d752a36f35cf":"8FGdh","d11da69c91421223":"72OoG","6845bad4ed92c3e4":"6yRo9","b5f2e1f615acc4b":"5gDK1","79ae761761517980":"jPbam"}],"bvED4":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"elliptic","version":"6.5.4","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

},{}],"8sNT5":[function(require,module,exports) {
"use strict";
var utils = exports;
var BN = require("f4cbcf6f6eb25ca0");
var minAssert = require("d8ee30463f95a0fd");
var minUtils = require("997429d6bbd82d59");
utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;
// Represent num in a w-NAF form
function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for(var i = 0; i < naf.length; i++){
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
            if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
            else z = mod;
            k.isubn(z);
        } else z = 0;
        naf[i] = z;
        k.iushrn(1);
    }
    return naf;
}
utils.getNAF = getNAF;
// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
    var jsf = [
        [],
        []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
        // First phase
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3) m14 = -1;
        if (m24 === 3) m24 = -1;
        var u1;
        if ((m14 & 1) === 0) u1 = 0;
        else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
            else u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) u2 = 0;
        else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
            else u2 = m24;
        }
        jsf[1].push(u2);
        // Second phase
        if (2 * d1 === u1 + 1) d1 = 1 - d1;
        if (2 * d2 === u2 + 1) d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
    }
    return jsf;
}
utils.getJSF = getJSF;
function cachedProperty(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
}
utils.cachedProperty = cachedProperty;
function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
}
utils.parseBytes = parseBytes;
function intFromLE(bytes) {
    return new BN(bytes, "hex", "le");
}
utils.intFromLE = intFromLE;

},{"f4cbcf6f6eb25ca0":"VopIn","d8ee30463f95a0fd":"8OvWh","997429d6bbd82d59":"6f39G"}],"6f39G":[function(require,module,exports) {
"use strict";
var utils = exports;
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== "string") {
        for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
        return res;
    }
    if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0) msg = "0" + msg;
        for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else for(var i = 0; i < msg.length; i++){
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);
        else res.push(lo);
    }
    return res;
}
utils.toArray = toArray;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
utils.zero2 = zero2;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
utils.toHex = toHex;
utils.encode = function encode(arr, enc) {
    if (enc === "hex") return toHex(arr);
    else return arr;
};

},{}],"72OoG":[function(require,module,exports) {
"use strict";
var curve = exports;
curve.base = require("59d486bd2037506a");
curve.short = require("eb37617ef6927580");
curve.mont = require("be9c662572da2183");
curve.edwards = require("60763dd06fe64e8d");

},{"59d486bd2037506a":"kvY1a","eb37617ef6927580":"e7TRt","be9c662572da2183":"2JhQH","60763dd06fe64e8d":"3idNZ"}],"kvY1a":[function(require,module,exports) {
"use strict";
var BN = require("70865a568c61cc60");
var utils = require("fb5111a3810a8235");
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;
function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    // Useful for many curves
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
module.exports = BaseCurve;
BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine") acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};

},{"70865a568c61cc60":"VopIn","fb5111a3810a8235":"8sNT5"}],"e7TRt":[function(require,module,exports) {
"use strict";
var utils = require("89f794ef417dc31c");
var BN = require("c314b0ac30b69c4a");
var inherits = require("6ac4d7c73f24ab9c");
var Base = require("6e622edb7498c94");
var assert = utils.assert;
function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new BN(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new BN(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
inherits(Point, Base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string") obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine") return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};

},{"89f794ef417dc31c":"8sNT5","c314b0ac30b69c4a":"VopIn","6ac4d7c73f24ab9c":"bRL3M","6e622edb7498c94":"kvY1a"}],"2JhQH":[function(require,module,exports) {
"use strict";
var BN = require("ebdf19f04f3ed250");
var inherits = require("cb5bb4841a749f68");
var Base = require("51280941230b3f98");
var utils = require("ea7949a80be00261");
function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;
MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
};
function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
    } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
}
inherits(Point, Base.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
Point.prototype.precompute = function precompute() {
// No-op
};
Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
Point.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
};
Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
};
Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q
    for(var bits = []; t.cmpn(0) !== 0; t.iushrn(1))bits.push(t.andln(1));
    for(var i = bits.length - 1; i >= 0; i--)if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
    } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
    }
    return b;
};
Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
};
Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
};
Point.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
    return this.x.fromRed();
};

},{"ebdf19f04f3ed250":"VopIn","cb5bb4841a749f68":"bRL3M","51280941230b3f98":"kvY1a","ea7949a80be00261":"8sNT5"}],"3idNZ":[function(require,module,exports) {
"use strict";
var utils = require("7bd66a4710450b08");
var BN = require("ccef46dcf03d45c6");
var inherits = require("19937272cbe23c92");
var Base = require("108c8ead5f54502b");
var assert = utils.assert;
function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();
    else return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;
    else return this.c.redMul(num);
};
// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red) y = y.toRed(this.red);
    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
        if (odd) throw new Error("invalid point");
        else return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true;
    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
};
function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        // Use extended coordinates
        if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
    }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
        // E = a * C
        e = this.curve._mulA(c);
        // F = E + D
        var f = e.redAdd(d);
        if (this.zOne) {
            // X3 = (B - C - D) * (F - 2)
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F^2 - 2 * F
            nz = f.redSqr().redSub(f).redSub(f);
        } else {
            // H = Z1^2
            h = this.z.redSqr();
            // J = F - 2 * H
            j = f.redSub(h).redISub(h);
            // X3 = (B-C-D)*J
            nx = b.redSub(c).redISub(d).redMul(j);
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F * J
            nz = f.redMul(j);
        }
    } else {
        // E = C + D
        e = c.redAdd(d);
        // H = (c * Z1)^2
        h = this.curve._mulC(this.z).redSqr();
        // J = E - 2 * H
        j = e.redSub(h).redSub(h);
        // X3 = c * (B - E) * J
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        // Y3 = c * E * (C - D)
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        // Z3 = E * J
        nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    // Double in extended coordinates
    if (this.curve.extended) return this._extDbl();
    else return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
        // Y3 = A * G * (D - a * C)
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        // Z3 = F * G
        nz = f.redMul(g);
    } else {
        // Y3 = A * G * (D - C)
        ny = a.redMul(g).redMul(d.redSub(c));
        // Z3 = c * F * G
        nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);
    else return this._projAdd(p);
};
Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, true);
};
Point.prototype.normalize = function normalize() {
    if (this.zOne) return this;
    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
};
Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
};
Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"7bd66a4710450b08":"8sNT5","ccef46dcf03d45c6":"VopIn","19937272cbe23c92":"bRL3M","108c8ead5f54502b":"kvY1a"}],"6yRo9":[function(require,module,exports) {
"use strict";
var curves = exports;
var hash = require("1c9db357c0845afa");
var curve = require("47ec78745540f875");
var utils = require("e30b16e4a47a5405");
var assert = utils.assert;
function PresetCurve(options) {
    if (options.type === "short") this.curve = new curve.short(options);
    else if (options.type === "edwards") this.curve = new curve.edwards(options);
    else this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}
curves.PresetCurve = PresetCurve;
function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name, {
                configurable: true,
                enumerable: true,
                value: curve
            });
            return curve;
        }
    });
}
defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: false,
    g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
});
defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: false,
    g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
});
defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: false,
    g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
});
defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: false,
    g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
});
defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: false,
    g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
});
defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "9"
    ]
});
defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
    ]
});
var pre;
try {
    pre = require("9eada5f7049e7dfd");
} catch (e) {
    pre = undefined;
}
defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
        {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }
    ],
    gRed: false,
    g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
    ]
});

},{"1c9db357c0845afa":"gOEGU","47ec78745540f875":"72OoG","e30b16e4a47a5405":"8sNT5","9eada5f7049e7dfd":"lgNSV"}],"gOEGU":[function(require,module,exports) {
var hash = exports;
hash.utils = require("38593959f18bd562");
hash.common = require("31a457752237e8ad");
hash.sha = require("3e37816d2a2fd68d");
hash.ripemd = require("ce5a13b5bd10f171");
hash.hmac = require("c32fbac97a361580");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"38593959f18bd562":"kfzn2","31a457752237e8ad":"ecAfF","3e37816d2a2fd68d":"8nbee","ce5a13b5bd10f171":"9kyRQ","c32fbac97a361580":"5KrrE"}],"kfzn2":[function(require,module,exports) {
"use strict";
var assert = require("6002b0feade022a4");
var inherits = require("d4826c9d0ff1b1f");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === "string") {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = "";
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === "little") w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return "0" + word;
    else if (word.length === 6) return "00" + word;
    else if (word.length === 5) return "000" + word;
    else if (word.length === 4) return "0000" + word;
    else if (word.length === 3) return "00000" + word;
    else if (word.length === 2) return "000000" + word;
    else if (word.length === 1) return "0000000" + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"6002b0feade022a4":"8OvWh","d4826c9d0ff1b1f":"bRL3M"}],"ecAfF":[function(require,module,exports) {
"use strict";
var utils = require("e9291abdfb47ee4f");
var assert = require("ea8841b701712638");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === "big") {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

},{"e9291abdfb47ee4f":"kfzn2","ea8841b701712638":"8OvWh"}],"8nbee":[function(require,module,exports) {
"use strict";
exports.sha1 = require("3835379564860fd7");
exports.sha224 = require("bb9f72f042233648");
exports.sha256 = require("20a3b0fa42e37dfe");
exports.sha384 = require("ad4827efa7d953c2");
exports.sha512 = require("301292595a944c1d");

},{"3835379564860fd7":"fnjyb","bb9f72f042233648":"9x7tY","20a3b0fa42e37dfe":"9bCbT","ad4827efa7d953c2":"lJMiS","301292595a944c1d":"8y482"}],"fnjyb":[function(require,module,exports) {
"use strict";
var utils = require("b75f3c1442bf9100");
var common = require("a29e68029e4c48f8");
var shaCommon = require("1be62f90a237cba5");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"b75f3c1442bf9100":"kfzn2","a29e68029e4c48f8":"ecAfF","1be62f90a237cba5":"gzrNi"}],"gzrNi":[function(require,module,exports) {
"use strict";
var utils = require("f0fb61f828bacd0f");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"f0fb61f828bacd0f":"kfzn2"}],"9x7tY":[function(require,module,exports) {
"use strict";
var utils = require("fe5acd040463c159");
var SHA256 = require("fa3503eda3738d05");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 7), "big");
    else return utils.split32(this.h.slice(0, 7), "big");
};

},{"fe5acd040463c159":"kfzn2","fa3503eda3738d05":"9bCbT"}],"9bCbT":[function(require,module,exports) {
"use strict";
var utils = require("32ad3e510bd41f2a");
var common = require("469ad88ad505772a");
var shaCommon = require("fffa7d1ddf1f0b43");
var assert = require("126369f57b5225ed");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"32ad3e510bd41f2a":"kfzn2","469ad88ad505772a":"ecAfF","fffa7d1ddf1f0b43":"gzrNi","126369f57b5225ed":"8OvWh"}],"lJMiS":[function(require,module,exports) {
"use strict";
var utils = require("a696ee34c45713da");
var SHA512 = require("fff95253fdaa49ea");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 12), "big");
    else return utils.split32(this.h.slice(0, 12), "big");
};

},{"a696ee34c45713da":"kfzn2","fff95253fdaa49ea":"8y482"}],"8y482":[function(require,module,exports) {
"use strict";
var utils = require("7753b1fa702fbb54");
var common = require("81b6970d75627ce1");
var assert = require("f660976cede694e2");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

},{"7753b1fa702fbb54":"kfzn2","81b6970d75627ce1":"ecAfF","f660976cede694e2":"8OvWh"}],"9kyRQ":[function(require,module,exports) {
"use strict";
var utils = require("36495272d446418f");
var common = require("ad8cf0490e28e8d7");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = "little";
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "little");
    else return utils.split32(this.h, "little");
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

},{"36495272d446418f":"kfzn2","ad8cf0490e28e8d7":"ecAfF"}],"5KrrE":[function(require,module,exports) {
"use strict";
var utils = require("596c08b6835a6e2d");
var assert = require("be527907d4f06808");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

},{"596c08b6835a6e2d":"kfzn2","be527907d4f06808":"8OvWh"}],"lgNSV":[function(require,module,exports) {
module.exports = {
    doubles: {
        step: 4,
        points: [
            [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
        ]
    },
    naf: {
        wnd: 7,
        points: [
            [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
        ]
    }
};

},{}],"5gDK1":[function(require,module,exports) {
"use strict";
var BN = require("2e69183faf5285a1");
var HmacDRBG = require("b0cb641292e4911d");
var utils = require("eab3e45147b180ba");
var curves = require("a5ce61d26ce01c4c");
var rand = require("f6342f89ac472937");
var assert = utils.assert;
var KeyPair = require("eb5ba559e423f6e9");
var Signature = require("7c5e2c76c574ce41");
function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === "string") {
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
module.exports = EC;
EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for(;;){
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray("be", bytes);
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new BN(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new Signature({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, "hex");
    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature, i);
        } catch (e) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
};

},{"2e69183faf5285a1":"VopIn","b0cb641292e4911d":"eMMR6","eab3e45147b180ba":"8sNT5","a5ce61d26ce01c4c":"6yRo9","f6342f89ac472937":"8FGdh","eb5ba559e423f6e9":"c4oIH","7c5e2c76c574ce41":"cRuxW"}],"eMMR6":[function(require,module,exports) {
"use strict";
var hash = require("629972fec592198f");
var utils = require("c20531edfb274a2c");
var assert = require("43ff1863ab3fce20");
function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils.toArray(options.pers, options.persEnc || "hex");
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    // Optional encoding
    if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
};

},{"629972fec592198f":"gOEGU","c20531edfb274a2c":"6f39G","43ff1863ab3fce20":"8OvWh"}],"c4oIH":[function(require,module,exports) {
"use strict";
var BN = require("55cc33a33cda153d");
var utils = require("bda8b1ff480a7f3");
var assert = utils.assert;
function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;
    return new KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: "Invalid public key"
    };
    if (!pub.validate()) return {
        result: false,
        reason: "Public key is not a point"
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: "Public key * N != O"
    };
    return {
        result: true,
        reason: null
    };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === "string") {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex") return this.priv.toString(16, 2);
    else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === "mont") assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) assert(pub.validate(), "public point not validated");
    return pub.mul(this.priv).getX();
};
// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
};
KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};

},{"55cc33a33cda153d":"VopIn","bda8b1ff480a7f3":"8sNT5"}],"cRuxW":[function(require,module,exports) {
"use strict";
var BN = require("a7ae8f0fe39990e7");
var utils = require("5df7da4811374387");
var assert = utils.assert;
function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;
function Position() {
    this.place = 0;
}
function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) return false;
    var len = getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = getLength(data, p);
    if (rlen === false) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
};
function constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
};

},{"a7ae8f0fe39990e7":"VopIn","5df7da4811374387":"8sNT5"}],"jPbam":[function(require,module,exports) {
"use strict";
var hash = require("50f9bfa8a484d5d8");
var curves = require("68956d27442d6321");
var utils = require("99ec52641eff141d");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require("2ad2982d76b37f15");
var Signature = require("76c25a1d63d10c1b");
function EDDSA(curve) {
    assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA)) return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
}
module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/ EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
        R: R,
        S: S,
        Rencoded: Rencoded
    });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/ EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for(var i = 0; i < arguments.length; i++)hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature) return sig;
    return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/ EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
};
EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
};

},{"50f9bfa8a484d5d8":"gOEGU","68956d27442d6321":"6yRo9","99ec52641eff141d":"8sNT5","2ad2982d76b37f15":"hOVET","76c25a1d63d10c1b":"a5qj9"}],"hOVET":[function(require,module,exports) {
"use strict";
var utils = require("387ffb9c0bf065ab");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/ function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;
    else this._pubBytes = parseBytes(params.pub);
}
KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(eddsa, {
        pub: pub
    });
};
KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair) return secret;
    return new KeyPair(eddsa, {
        secret: secret
    });
};
KeyPair.prototype.secret = function secret() {
    return this._secret;
};
cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
});
cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
};
KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
};
KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils.encode(this.secret(), enc);
};
KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
};
module.exports = KeyPair;

},{"387ffb9c0bf065ab":"8sNT5"}],"a5qj9":[function(require,module,exports) {
"use strict";
var BN = require("696e2c87f819d166");
var utils = require("51b94bcac1dcb2b2");
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/ function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object") sig = parseBytes(sig);
    if (Array.isArray(sig)) sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
    };
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof BN) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
});
Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
};
Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), "hex").toUpperCase();
};
module.exports = Signature;

},{"696e2c87f819d166":"VopIn","51b94bcac1dcb2b2":"8sNT5"}],"dkoZR":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("63bd24e3f2284d92").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, "Invalid character in " + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    } catch (e) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"63bd24e3f2284d92":"bXKEI"}],"4Szbv":[function(require,module,exports) {
var asn1 = require("a33d2f68b0ffe26d");
var aesid = require("c39bbd52d12adb70");
var fixProc = require("7247fe0465255c67");
var ciphers = require("ea725b5eadc96106");
var compat = require("aa2a622927353f9f");
var Buffer = require("11d61e4bc73f5fdc").Buffer;
module.exports = parseKeys;
function parseKeys(buffer) {
    var password;
    if (typeof buffer === "object" && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
    }
    if (typeof buffer === "string") buffer = Buffer.from(buffer);
    var stripped = fixProc(buffer, password);
    var type = stripped.tag;
    var data = stripped.data;
    var subtype, ndata;
    switch(type){
        case "CERTIFICATE":
            ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        // falls through
        case "PUBLIC KEY":
            if (!ndata) ndata = asn1.PublicKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        // throw new Error('unknown key type ' + type)
        case "ENCRYPTED PRIVATE KEY":
            data = asn1.EncryptedPrivateKey.decode(data, "der");
            data = decrypt(data, password);
        // falls through
        case "PRIVATE KEY":
            ndata = asn1.PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        // throw new Error('unknown key type ' + type)
        case "RSA PUBLIC KEY":
            return asn1.RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
            return asn1.RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: asn1.DSAPrivateKey.decode(data, "der")
            };
        case "EC PRIVATE KEY":
            data = asn1.ECPrivateKey.decode(data, "der");
            return {
                curve: data.parameters.value,
                privateKey: data.privateKey
            };
        default:
            throw new Error("unknown key type " + type);
    }
}
parseKeys.signature = asn1.signature;
function decrypt(data, password) {
    var salt = data.algorithm.decrypt.kde.kdeparams.salt;
    var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    var iv = data.algorithm.decrypt.cipher.iv;
    var cipherText = data.subjectPrivateKey;
    var keylen = parseInt(algo.split("-")[1], 10) / 8;
    var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
    var cipher = ciphers.createDecipheriv(algo, key, iv);
    var out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer.concat(out);
}

},{"a33d2f68b0ffe26d":"l0ugz","c39bbd52d12adb70":"bvb6u","7247fe0465255c67":"bNDUb","ea725b5eadc96106":"hnlHj","aa2a622927353f9f":"g38Hg","11d61e4bc73f5fdc":"eW7r9"}],"l0ugz":[function(require,module,exports) {
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
"use strict";
var asn1 = require("821e6411e0aeb10a");
exports.certificate = require("6bb4fbbd6e2d2384");
var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
exports.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
exports.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
exports.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
exports.DSAPrivateKey = DSAPrivateKey;
exports.DSAparam = asn1.define("DSAparam", function() {
    this.int();
});
var ECPrivateKey = asn1.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
exports.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
exports.signature = asn1.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});

},{"821e6411e0aeb10a":"iV1JX","6bb4fbbd6e2d2384":"Tf0QA"}],"iV1JX":[function(require,module,exports) {
"use strict";
const asn1 = exports;
asn1.bignum = require("b4f67f473458f037");
asn1.define = require("3a96ab8454f69498").define;
asn1.base = require("82a96f1d67e1a13d");
asn1.constants = require("f666a445bd64a777");
asn1.decoders = require("e200f1dc591d286b");
asn1.encoders = require("5ea4ddb7d1e6fcb9");

},{"b4f67f473458f037":"VopIn","3a96ab8454f69498":"2oHUo","82a96f1d67e1a13d":"3q4wA","f666a445bd64a777":"oiTK8","e200f1dc591d286b":"awa6C","5ea4ddb7d1e6fcb9":"2psTt"}],"2oHUo":[function(require,module,exports) {
"use strict";
const encoders = require("f26403796e11865b");
const decoders = require("a00827f0f69fbce");
const inherits = require("64c493c8ea32f1a7");
const api = exports;
api.define = function define(name, body) {
    return new Entity(name, body);
};
function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name = this.name;
    function Generated(entity) {
        this._initNamed(entity, name);
    }
    inherits(Generated, Base);
    Generated.prototype._initNamed = function _initNamed(entity, name) {
        Base.call(this, entity, name);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    // Lazily create decoder
    if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(decoders[enc]);
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    // Lazily create encoder
    if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(encoders[enc]);
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
    return this._getEncoder(enc).encode(data, reporter);
};

},{"f26403796e11865b":"2psTt","a00827f0f69fbce":"awa6C","64c493c8ea32f1a7":"bRL3M"}],"2psTt":[function(require,module,exports) {
"use strict";
const encoders = exports;
encoders.der = require("6153180e09514e51");
encoders.pem = require("babaf0c4b3d9210a");

},{"6153180e09514e51":"b1CZy","babaf0c4b3d9210a":"jRlrF"}],"b1CZy":[function(require,module,exports) {
"use strict";
const inherits = require("94789e1422bf21a1");
const Buffer = require("9dd3df095b47dfb").Buffer;
const Node = require("ee66f238a776dfa1");
// Import DER constants
const der = require("e0096fa50301b4fb");
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    // Construct base tree
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
module.exports = DEREncoder;
DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};
// Tree methods
function DERNode(parent) {
    Node.call(this, "der", parent);
}
inherits(DERNode, Node);
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    // Short form
    if (content.length < 0x80) {
        const header = Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    // Long form
    // Count octets required to store length
    let lenOctets = 1;
    for(let i = content.length; i >= 0x100; i >>= 8)lenOctets++;
    const header = Buffer.alloc(2 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;
    for(let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)header[i] = j & 0xff;
    return this._createEncoderBuffer([
        header,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") return this._createEncoderBuffer([
        str.unused | 0,
        str.data
    ]);
    else if (tag === "bmpstr") {
        const buf = Buffer.alloc(str.length * 2);
        for(let i = 0; i < str.length; i++)buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
        if (!this._isNumstr(str)) return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) return this._createEncoderBuffer(str);
    else if (tag === "objDesc") return this._createEncoderBuffer(str);
    else return this.reporter.error("Encoding of string type: " + tag + " unsupported");
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === "string") {
        if (!values) return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id)) return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s.]+/g);
        for(let i = 0; i < id.length; i++)id[i] |= 0;
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i = 0; i < id.length; i++)id[i] |= 0;
    }
    if (!Array.isArray(id)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
    if (!relative) {
        if (id[1] >= 40) return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    // Count number of octets
    let size = 0;
    for(let i = 0; i < id.length; i++){
        let ident = id[i];
        for(size++; ident >= 0x80; ident >>= 7)size++;
    }
    const objid = Buffer.alloc(size);
    let offset = objid.length - 1;
    for(let i = id.length - 1; i >= 0; i--){
        let ident = id[i];
        objid[offset--] = ident & 0x7f;
        while((ident >>= 7) > 0)objid[offset--] = 0x80 | ident & 0x7f;
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) return "0" + num;
    else return num;
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);
    if (tag === "gentime") str = [
        two(date.getUTCFullYear()),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
    ].join("");
    else if (tag === "utctime") str = [
        two(date.getUTCFullYear() % 100),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
    ].join("");
    else this.reporter.error("Encoding " + tag + " time is not supported yet");
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        num = values[num];
    }
    // Bignum, assume big endian
    if (typeof num !== "number" && !Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) numArray.unshift(0);
        num = Buffer.from(numArray);
    }
    if (Buffer.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) size++;
        const out = Buffer.alloc(size);
        num.copy(out);
        if (num.length === 0) out[0] = 0;
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) return this._createEncoderBuffer(num);
    if (num < 0x100) return this._createEncoderBuffer([
        0,
        num
    ]);
    let size = 1;
    for(let i = num; i >= 0x100; i >>= 8)size++;
    const out = new Array(size);
    for(let i = out.length - 1; i >= 0; i--){
        out[i] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) out.unshift(0);
    return this._createEncoderBuffer(Buffer.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") entity = entity(obj);
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state["default"] === null) return false;
    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
    if (data.length !== state.defaultBuffer.length) return false;
    for(i = 0; i < data.length; i++)if (data[i] !== state.defaultBuffer[i]) return false;
    return true;
};
// Utility methods
function encodeTag(tag, primitive, cls, reporter) {
    let res;
    if (tag === "seqof") tag = "seq";
    else if (tag === "setof") tag = "set";
    if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];
    else if (typeof tag === "number" && (tag | 0) === tag) res = tag;
    else return reporter.error("Unknown tag: " + tag);
    if (res >= 0x1f) return reporter.error("Multi-octet tag encoding unsupported");
    if (!primitive) res |= 0x20;
    res |= der.tagClassByName[cls || "universal"] << 6;
    return res;
}

},{"94789e1422bf21a1":"bRL3M","9dd3df095b47dfb":"aLyFx","ee66f238a776dfa1":"l9Edp","e0096fa50301b4fb":"i6Hqy"}],"aLyFx":[function(require,module,exports) {
/* eslint-disable node/no-deprecated-api */ var process = require("e7af3484edf6bee9");
"use strict";
var buffer = require("9b1fd4bf3515d7a6");
var Buffer = buffer.Buffer;
var safer = {};
var key;
for(key in buffer){
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for(key in Buffer){
    if (!Buffer.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer[key];
}
safer.Buffer.prototype = Buffer.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    return Buffer(value, encodingOrOffset, length);
};
if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    if (size < 0 || size >= 2 * 1073741824) throw new RangeError('The value "' + size + '" is invalid for option "size"');
    var buf = Buffer(size);
    if (!fill || fill.length === 0) buf.fill(0);
    else if (typeof encoding === "string") buf.fill(fill, encoding);
    else buf.fill(fill);
    return buf;
};
if (!safer.kStringMaxLength) try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
} catch (e) {
// we can't determine kStringMaxLength in environments where process.binding
// is unsupported, so let's not set it
}
if (!safer.constants) {
    safer.constants = {
        MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
}
module.exports = safer;

},{"e7af3484edf6bee9":"d5jf4","9b1fd4bf3515d7a6":"fCgem"}],"l9Edp":[function(require,module,exports) {
"use strict";
const Reporter = require("3f60e59b9a23b489").Reporter;
const EncoderBuffer = require("485fe0fa4bfbbbca").EncoderBuffer;
const DecoderBuffer = require("485fe0fa4bfbbbca").DecoderBuffer;
const assert = require("1bf7ce79b1c01d8b");
// Supported tags
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
];
// Public methods list
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
].concat(tags);
// Overrided methods list
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
];
function Node(enc, parent, name) {
    const state = {};
    this._baseState = state;
    state.name = name;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    // State
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state["default"] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    // Should create new instance on each method
    if (!state.parent) {
        state.children = [];
        this._wrap();
    }
}
module.exports = Node;
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
];
Node.prototype.clone = function clone() {
    const state = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    // Filter children
    state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assert.equal(state.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state = this._baseState;
    // Filter children and args
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        // Replace parent to maintain backward link
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) return arg;
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) key |= 0;
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
//
// Overrided methods
//
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
    };
});
//
// Public methods
//
tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert(item);
    const state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state = this._baseState;
    state.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state = this._baseState;
    assert(state["default"] === null);
    state["default"] = val;
    state.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) this._useArgs(args);
    return this;
};
Node.prototype.key = function key(newKey) {
    const state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state = this._baseState;
    state.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state = this._baseState;
    assert(state.use === null);
    state.contains = item;
    return this;
};
//
// Decoding
//
Node.prototype._decode = function decode(input, options) {
    const state = this._baseState;
    // Decode root node
    if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
    let result = state["default"];
    let present = true;
    let prevKey = null;
    if (state.key !== null) prevKey = input.enterKey(state.key);
    // Check if tag is there
    if (state.optional) {
        let tag = null;
        if (state.explicit !== null) tag = state.explicit;
        else if (state.implicit !== null) tag = state.implicit;
        else if (state.tag !== null) tag = state.tag;
        if (tag === null && !state.any) {
            // Trial and Error
            const save = input.save();
            try {
                if (state.choice === null) this._decodeGeneric(state.tag, input, options);
                else this._decodeChoice(input, options);
                present = true;
            } catch (e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present)) return present;
        }
    }
    // Push object on stack
    let prevObj;
    if (state.obj && present) prevObj = input.enterObject();
    if (present) {
        // Unwrap explicit values
        if (state.explicit !== null) {
            const explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit)) return explicit;
            input = explicit;
        }
        const start = input.offset;
        // Unwrap implicit and normal values
        if (state.use === null && state.choice === null) {
            let save;
            if (state.any) save = input.save();
            const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body)) return body;
            if (state.any) result = input.raw(save);
            else input = body;
        }
        if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, "content");
        // Select proper method for tag
        if (state.any) ;
        else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options);
        else result = this._decodeChoice(input, options);
        if (input.isError(result)) return result;
        // Decode children
        if (!state.any && state.choice === null && state.children !== null) state.children.forEach(function decodeChildren(child) {
            // NOTE: We are ignoring errors here, to let parser continue with other
            // parts of encoded data
            child._decode(input, options);
        });
        // Decode contained/encoded by schema, only in bit or octet strings
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
    }
    // Pop object
    if (state.obj && present) result = input.leaveObject(prevObj);
    // Set key
    if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);
    else if (prevKey !== null) input.exitKey(prevKey);
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    const state = this._baseState;
    if (tag === "seq" || tag === "set") return null;
    if (tag === "seqof" || tag === "setof") return this._decodeList(input, tag, state.args[0], options);
    else if (/str$/.test(tag)) return this._decodeStr(input, tag, options);
    else if (tag === "objid" && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options);
    else if (tag === "objid") return this._decodeObjid(input, null, null, options);
    else if (tag === "gentime" || tag === "utctime") return this._decodeTime(input, tag, options);
    else if (tag === "null_") return this._decodeNull(input, options);
    else if (tag === "bool") return this._decodeBool(input, options);
    else if (tag === "objDesc") return this._decodeStr(input, tag, options);
    else if (tag === "int" || tag === "enum") return this._decodeInt(input, state.args && state.args[0], options);
    if (state.use !== null) return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    else return input.error("unknown tag: " + tag);
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state = this._baseState;
    // Create altered use decoder if implicit is set
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) return false;
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) return input.error("Choice not matched");
    return result;
};
//
// Encoding
//
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state["default"] !== null && state["default"] === data) return;
    const result = this._encodeValue(data, reporter, parent);
    if (result === undefined) return;
    if (this._skipDefault(result, reporter, parent)) return;
    return result;
};
Node.prototype._encodeValue = function encode(data, reporter, parent) {
    const state = this._baseState;
    // Decode root node
    if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
    let result = null;
    // Set reporter to share it with a child class
    this.reporter = reporter;
    // Check if data is there
    if (state.optional && data === undefined) {
        if (state["default"] !== null) data = state["default"];
        else return;
    }
    // Encode children first
    let content = null;
    let primitive = false;
    if (state.any) // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
    else if (state.choice) result = this._encodeChoice(data, reporter);
    else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
    } else if (state.children) {
        content = state.children.map(function(child) {
            if (child._baseState.tag === "null_") return child._encode(null, reporter, data);
            if (child._baseState.key === null) return reporter.error("Child should have a key");
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data !== "object") return reporter.error("Child expected, but input is not object");
            const res = child._encode(data[child._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state.tag === "seqof" || state.tag === "setof") {
            // TODO(indutny): this should be thrown on DSL level
            if (!(state.args && state.args.length === 1)) return reporter.error("Too many args for : " + state.tag);
            if (!Array.isArray(data)) return reporter.error("seqof/setof, but data is not Array");
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
                const state = this._baseState;
                return this._getUse(state.args[0], data)._encode(item, reporter);
            }, child));
        } else if (state.use !== null) result = this._getUse(state.use, parent)._encode(data, reporter);
        else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
        }
    }
    // Encode data itself
    if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
            if (state.use === null) reporter.error("Tag could be omitted only for .use()");
        } else if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
    }
    // Wrap in explicit
    if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, "context", result);
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    const state = this._baseState;
    const node = state.choice[data.type];
    if (!node) assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
    return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    const state = this._baseState;
    if (/str$/.test(tag)) return this._encodeStr(data, tag);
    else if (tag === "objid" && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    else if (tag === "objid") return this._encodeObjid(data, null, null);
    else if (tag === "gentime" || tag === "utctime") return this._encodeTime(data, tag);
    else if (tag === "null_") return this._encodeNull();
    else if (tag === "int" || tag === "enum") return this._encodeInt(data, state.args && state.reverseArgs[0]);
    else if (tag === "bool") return this._encodeBool(data);
    else if (tag === "objDesc") return this._encodeStr(data, tag);
    else throw new Error("Unsupported tag: " + tag);
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

},{"3f60e59b9a23b489":"2Vti8","485fe0fa4bfbbbca":"1GNVB","1bf7ce79b1c01d8b":"8OvWh"}],"2Vti8":[function(require,module,exports) {
"use strict";
const inherits = require("cca99c6acf69321b");
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
exports.Reporter = Reporter;
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state = this._reporterState;
    return {
        obj: state.obj,
        pathLen: state.path.length
    };
};
Reporter.prototype.restore = function restore(data) {
    const state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null) state.obj[key] = value;
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state = this._reporterState;
    const prev = state.obj;
    state.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state = this._reporterState;
    const now = state.obj;
    state.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) err = msg;
    else err = new ReporterError(state.path.map(function(elem) {
        return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
    if (!state.options.partial) throw err;
    if (!inherited) state.errors.push(err);
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state = this._reporterState;
    if (!state.options.partial) return result;
    return {
        result: this.isError(result) ? null : result,
        errors: state.errors
    };
};
function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);
    if (!this.stack) try {
        // IE only adds stack when thrown
        throw new Error(this.message);
    } catch (e) {
        this.stack = e.stack;
    }
    return this;
};

},{"cca99c6acf69321b":"bRL3M"}],"1GNVB":[function(require,module,exports) {
"use strict";
const inherits = require("ff35534ecc380ed3");
const Reporter = require("caca6de43dc40469").Reporter;
const Buffer = require("c3dd8e06b6bddac8").Buffer;
function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!Buffer.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base;
    this.offset = 0;
    this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
    if (data instanceof DecoderBuffer) return true;
    // Or accept compatible API
    const isCompatible = typeof data === "object" && Buffer.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    // Return skipped data
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);
    else return this.error(fail || "DecoderBuffer overrun");
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) return this.error(fail || "DecoderBuffer overrun");
    const res = new DecoderBuffer(this.base);
    // Share reporter state
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer.byteLength(value);
    } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else return reporter.error("Unsupported type: " + typeof value);
}
exports.EncoderBuffer = EncoderBuffer;
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
    if (data instanceof EncoderBuffer) return true;
    // Or accept compatible API
    const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) out = Buffer.alloc(this.length);
    if (!offset) offset = 0;
    if (this.length === 0) return out;
    if (Array.isArray(this.value)) this.value.forEach(function(item) {
        item.join(out, offset);
        offset += item.length;
    });
    else {
        if (typeof this.value === "number") out[offset] = this.value;
        else if (typeof this.value === "string") out.write(this.value, offset);
        else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
        offset += this.length;
    }
    return out;
};

},{"ff35534ecc380ed3":"bRL3M","caca6de43dc40469":"2Vti8","c3dd8e06b6bddac8":"aLyFx"}],"i6Hqy":[function(require,module,exports) {
"use strict";
// Helper
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        // Convert key to integer if it is stringified
        if ((key | 0) == key) key = key | 0;
        const value = map[key];
        res[value] = key;
    });
    return res;
}
exports.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
exports.tagClassByName = reverse(exports.tagClass);
exports.tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
exports.tagByName = reverse(exports.tag);

},{}],"jRlrF":[function(require,module,exports) {
"use strict";
const inherits = require("bc3c7930ded74eee");
const DEREncoder = require("cf885a4234262436");
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;
PEMEncoder.prototype.encode = function encode(data, options) {
    const buf = DEREncoder.prototype.encode.call(this, data);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i = 0; i < p.length; i += 64)out.push(p.slice(i, i + 64));
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};

},{"bc3c7930ded74eee":"bRL3M","cf885a4234262436":"b1CZy"}],"awa6C":[function(require,module,exports) {
"use strict";
const decoders = exports;
decoders.der = require("abb46f93da4a6a9");
decoders.pem = require("f1e062afeaaaac02");

},{"abb46f93da4a6a9":"foBr8","f1e062afeaaaac02":"iexo6"}],"foBr8":[function(require,module,exports) {
"use strict";
const inherits = require("7c238308bb002386");
const bignum = require("1928930ea2b8651");
const DecoderBuffer = require("caab1b42d6fb9403").DecoderBuffer;
const Node = require("72cb51ff1d236b42");
// Import DER constants
const der = require("43b3126d1d799ae0");
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    // Construct base tree
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
module.exports = DERDecoder;
DERDecoder.prototype.decode = function decode(data, options) {
    if (!DecoderBuffer.isDecoderBuffer(data)) data = new DecoderBuffer(data, options);
    return this.tree._decode(data, options);
};
// Tree methods
function DERNode(parent) {
    Node.call(this, "der", parent);
}
inherits(DERNode, Node);
DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) return false;
    const state = buffer.save();
    const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) return decodedTag;
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
};
DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) return decodedTag;
    let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    // Failure
    if (buffer.isError(len)) return len;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) return buffer.error('Failed to match tag: "' + tag + '"');
    if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    // Indefinite length... find END tag
    const state = buffer.save();
    const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) return res;
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    for(;;){
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag)) return tag;
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len)) return len;
        let res;
        if (tag.primitive || len !== null) res = buffer.skip(len);
        else res = this._skipUntilEnd(buffer, fail);
        // Failure
        if (buffer.isError(res)) return res;
        if (tag.tagStr === "end") break;
    }
};
DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
    const result = [];
    while(!buffer.isEmpty()){
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd)) return possibleEnd;
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd) break;
        result.push(res);
    }
    return result;
};
DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused)) return unused;
        return {
            unused: unused,
            data: buffer.raw()
        };
    } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1) return buffer.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for(let i = 0; i < raw.length / 2; i++)str += String.fromCharCode(raw.readUInt16BE(i * 2));
        return str;
    } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) return buffer.error("Decoding of string type: numstr unsupported characters");
        return numstr;
    } else if (tag === "octstr") return buffer.raw();
    else if (tag === "objDesc") return buffer.raw();
    else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) return buffer.error("Decoding of string type: printstr unsupported characters");
        return printstr;
    } else if (/str$/.test(tag)) return buffer.raw().toString();
    else return buffer.error("Decoding of string type: " + tag + " unsupported");
};
DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer.isEmpty()){
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 0x80) identifiers.push(ident);
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative) result = identifiers;
    else result = [
        first,
        second
    ].concat(identifiers.slice(1));
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) tmp = values[result.join(".")];
        if (tmp !== undefined) result = tmp;
    }
    return result;
};
DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
    const str = buffer.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min;
    let sec;
    if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) year = 2000 + year;
        else year = 1900 + year;
    } else return buffer.error("Decoding " + tag + " time is not supported yet");
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode.prototype._decodeBool = function decodeBool(buffer) {
    const res = buffer.readUInt8();
    if (buffer.isError(res)) return res;
    else return res !== 0;
};
DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
    // Bigint, return as it is (assume big endian)
    const raw = buffer.raw();
    let res = new bignum(raw);
    if (values) res = values[res.toString(10)] || res;
    return res;
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") entity = entity(obj);
    return entity._getDecoder("der").tree;
};
// Utility methods
function derDecodeTag(buf, fail) {
    let tag = buf.readUInt8(fail);
    if (buf.isError(tag)) return tag;
    const cls = der.tagClass[tag >> 6];
    const primitive = (tag & 0x20) === 0;
    // Multi-octet tag - load
    if ((tag & 0x1f) === 0x1f) {
        let oct = tag;
        tag = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail);
            if (buf.isError(oct)) return oct;
            tag <<= 7;
            tag |= oct & 0x7f;
        }
    } else tag &= 0x1f;
    const tagStr = der.tag[tag];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail) {
    let len = buf.readUInt8(fail);
    if (buf.isError(len)) return len;
    // Indefinite form
    if (!primitive && len === 0x80) return null;
    // Definite form
    if ((len & 0x80) === 0) // Short form
    return len;
    // Long form
    const num = len & 0x7f;
    if (num > 4) return buf.error("length octect is too long");
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j)) return j;
        len |= j;
    }
    return len;
}

},{"7c238308bb002386":"bRL3M","1928930ea2b8651":"VopIn","caab1b42d6fb9403":"1GNVB","72cb51ff1d236b42":"l9Edp","43b3126d1d799ae0":"i6Hqy"}],"iexo6":[function(require,module,exports) {
"use strict";
const inherits = require("c2d50a9d5a6f334a");
const Buffer = require("34248664f237b3bc").Buffer;
const DERDecoder = require("dc9bd6cca8dafd6");
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;
PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i = 0; i < lines.length; i++){
        const match = lines[i].match(re);
        if (match === null) continue;
        if (match[2] !== label) continue;
        if (start === -1) {
            if (match[1] !== "BEGIN") break;
            start = i;
        } else {
            if (match[1] !== "END") break;
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1) throw new Error("PEM section not found for: " + label);
    const base64 = lines.slice(start + 1, end).join("");
    // Remove excessive symbols
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};

},{"c2d50a9d5a6f334a":"bRL3M","34248664f237b3bc":"aLyFx","dc9bd6cca8dafd6":"foBr8"}],"3q4wA":[function(require,module,exports) {
"use strict";
const base = exports;
base.Reporter = require("59a43dc644aa14a1").Reporter;
base.DecoderBuffer = require("bb5e01939a3ed5de").DecoderBuffer;
base.EncoderBuffer = require("bb5e01939a3ed5de").EncoderBuffer;
base.Node = require("97802675bd1acef");

},{"59a43dc644aa14a1":"2Vti8","bb5e01939a3ed5de":"1GNVB","97802675bd1acef":"l9Edp"}],"oiTK8":[function(require,module,exports) {
"use strict";
const constants = exports;
// Helper
constants._reverse = function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        // Convert key to integer if it is stringified
        if ((key | 0) == key) key = key | 0;
        const value = map[key];
        res[value] = key;
    });
    return res;
};
constants.der = require("cd34b6c5ba00554c");

},{"cd34b6c5ba00554c":"i6Hqy"}],"Tf0QA":[function(require,module,exports) {
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen
"use strict";
var asn = require("373dc11d39ac511a");
var Time = asn.define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
var RDNSequence = asn.define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
var Name = asn.define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
var Validity = asn.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
var Extension = asn.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
var TBSCertificate = asn.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
var X509Certificate = asn.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
module.exports = X509Certificate;

},{"373dc11d39ac511a":"iV1JX"}],"bvb6u":[function(require,module,exports) {
module.exports = JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}');

},{}],"bNDUb":[function(require,module,exports) {
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = require("482ca5fecee84bd1");
var ciphers = require("5e77b1b6b79a5d20");
var Buffer = require("fcf1038e6a690508").Buffer;
module.exports = function(okey, password) {
    var key = okey.toString();
    var match = key.match(findProc);
    var decrypted;
    if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        var suite = "aes" + match[1];
        var iv = Buffer.from(match[2], "hex");
        var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
    }
    var tag = key.match(startRegex)[1];
    return {
        tag: tag,
        data: decrypted
    };
};

},{"482ca5fecee84bd1":"1rd4d","5e77b1b6b79a5d20":"hnlHj","fcf1038e6a690508":"eW7r9"}],"iadQk":[function(require,module,exports) {
module.exports = JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}');

},{}],"vbFso":[function(require,module,exports) {
"use strict";
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require("c893e8283afd176a").Buffer;
var BN = require("18576d045784617e");
var EC = require("9429de8047bf329a").ec;
var parseKeys = require("88de5f3d7e6f8c00");
var curves = require("69d69f2e18a199ce");
function verify(sig, hash, key, signType, tag) {
    var pub = parseKeys(key);
    if (pub.type === "ec") {
        // rsa keys can be interpreted as ecdsa ones in openssl
        if (signType !== "ecdsa" && signType !== "ecdsa/rsa") throw new Error("wrong public key type");
        return ecVerify(sig, hash, pub);
    } else if (pub.type === "dsa") {
        if (signType !== "dsa") throw new Error("wrong public key type");
        return dsaVerify(sig, hash, pub);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") throw new Error("wrong public key type");
    hash = Buffer.concat([
        tag,
        hash
    ]);
    var len = pub.modulus.byteLength();
    var pad = [
        1
    ];
    var padNum = 0;
    while(hash.length + pad.length + 2 < len){
        pad.push(0xff);
        padNum += 1;
    }
    pad.push(0x00);
    var i = -1;
    while(++i < hash.length)pad.push(hash[i]);
    pad = Buffer.from(pad);
    var red = BN.mont(pub.modulus);
    sig = new BN(sig).toRed(red);
    sig = sig.redPow(new BN(pub.publicExponent));
    sig = Buffer.from(sig.fromRed().toArray());
    var out = padNum < 8 ? 1 : 0;
    len = Math.min(sig.length, pad.length);
    if (sig.length !== pad.length) out = 1;
    i = -1;
    while(++i < len)out |= sig[i] ^ pad[i];
    return out === 0;
}
function ecVerify(sig, hash, pub) {
    var curveId = curves[pub.data.algorithm.curve.join(".")];
    if (!curveId) throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
    var curve = new EC(curveId);
    var pubkey = pub.data.subjectPrivateKey.data;
    return curve.verify(hash, sig, pubkey);
}
function dsaVerify(sig, hash, pub) {
    var p = pub.data.p;
    var q = pub.data.q;
    var g = pub.data.g;
    var y = pub.data.pub_key;
    var unpacked = parseKeys.signature.decode(sig, "der");
    var s = unpacked.s;
    var r = unpacked.r;
    checkValue(s, q);
    checkValue(r, q);
    var montp = BN.mont(p);
    var w = s.invm(q);
    var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
    return v.cmp(r) === 0;
}
function checkValue(b, q) {
    if (b.cmpn(0) <= 0) throw new Error("invalid sig");
    if (b.cmp(q) >= 0) throw new Error("invalid sig");
}
module.exports = verify;

},{"c893e8283afd176a":"eW7r9","18576d045784617e":"dkoZR","9429de8047bf329a":"1NKsH","88de5f3d7e6f8c00":"4Szbv","69d69f2e18a199ce":"iadQk"}],"9Rcg1":[function(require,module,exports) {
var Buffer = require("59d8fd0d64d5aa42").Buffer;
var elliptic = require("a6b1ec3b8e72335c");
var BN = require("8c5a992927812eef");
module.exports = function createECDH(curve) {
    return new ECDH(curve);
};
var aliases = {
    secp256k1: {
        name: "secp256k1",
        byteLength: 32
    },
    secp224r1: {
        name: "p224",
        byteLength: 28
    },
    prime256v1: {
        name: "p256",
        byteLength: 32
    },
    prime192v1: {
        name: "p192",
        byteLength: 24
    },
    ed25519: {
        name: "ed25519",
        byteLength: 32
    },
    secp384r1: {
        name: "p384",
        byteLength: 48
    },
    secp521r1: {
        name: "p521",
        byteLength: 66
    }
};
aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;
function ECDH(curve) {
    this.curveType = aliases[curve];
    if (!this.curveType) this.curveType = {
        name: curve
    };
    this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
    ;
    this.keys = void 0;
}
ECDH.prototype.generateKeys = function(enc, format) {
    this.keys = this.curve.genKeyPair();
    return this.getPublicKey(enc, format);
};
ECDH.prototype.computeSecret = function(other, inenc, enc) {
    inenc = inenc || "utf8";
    if (!Buffer.isBuffer(other)) other = new Buffer(other, inenc);
    var otherPub = this.curve.keyFromPublic(other).getPublic();
    var out = otherPub.mul(this.keys.getPrivate()).getX();
    return formatReturnValue(out, enc, this.curveType.byteLength);
};
ECDH.prototype.getPublicKey = function(enc, format) {
    var key = this.keys.getPublic(format === "compressed", true);
    if (format === "hybrid") {
        if (key[key.length - 1] % 2) key[0] = 7;
        else key[0] = 6;
    }
    return formatReturnValue(key, enc);
};
ECDH.prototype.getPrivateKey = function(enc) {
    return formatReturnValue(this.keys.getPrivate(), enc);
};
ECDH.prototype.setPublicKey = function(pub, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub)) pub = new Buffer(pub, enc);
    this.keys._importPublic(pub);
    return this;
};
ECDH.prototype.setPrivateKey = function(priv, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv)) priv = new Buffer(priv, enc);
    var _priv = new BN(priv);
    _priv = _priv.toString(16);
    this.keys = this.curve.genKeyPair();
    this.keys._importPrivate(_priv);
    return this;
};
function formatReturnValue(bn, enc, len) {
    if (!Array.isArray(bn)) bn = bn.toArray();
    var buf = new Buffer(bn);
    if (len && buf.length < len) {
        var zeros = new Buffer(len - buf.length);
        zeros.fill(0);
        buf = Buffer.concat([
            zeros,
            buf
        ]);
    }
    if (!enc) return buf;
    else return buf.toString(enc);
}

},{"59d8fd0d64d5aa42":"fCgem","a6b1ec3b8e72335c":"1NKsH","8c5a992927812eef":"VopIn"}],"h9Rdh":[function(require,module,exports) {
exports.publicEncrypt = require("d84cba4f52311cc8");
exports.privateDecrypt = require("f9c6d8fbe09b61c");
exports.privateEncrypt = function privateEncrypt(key, buf) {
    return exports.publicEncrypt(key, buf, true);
};
exports.publicDecrypt = function publicDecrypt(key, buf) {
    return exports.privateDecrypt(key, buf, true);
};

},{"d84cba4f52311cc8":"e6nSQ","f9c6d8fbe09b61c":"jIkKI"}],"e6nSQ":[function(require,module,exports) {
var parseKeys = require("ca2697dbde558d1");
var randomBytes = require("4704ad09aa96a56b");
var createHash = require("b8a92fd1d9e43252");
var mgf = require("469be15a31031bba");
var xor = require("f9f3694c0f7388b6");
var BN = require("cb7a38ec1a0039d7");
var withPublic = require("969e1e2dd90e2fbe");
var crt = require("9022efe01867a612");
var Buffer = require("d610bb618706f42f").Buffer;
module.exports = function publicEncrypt(publicKey, msg, reverse) {
    var padding;
    if (publicKey.padding) padding = publicKey.padding;
    else if (reverse) padding = 1;
    else padding = 4;
    var key = parseKeys(publicKey);
    var paddedMsg;
    if (padding === 4) paddedMsg = oaep(key, msg);
    else if (padding === 1) paddedMsg = pkcs1(key, msg, reverse);
    else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) throw new Error("data too long for modulus");
    } else throw new Error("unknown padding");
    if (reverse) return crt(paddedMsg, key);
    else return withPublic(paddedMsg, key);
};
function oaep(key, msg) {
    var k = key.modulus.byteLength();
    var mLen = msg.length;
    var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    var hLen = iHash.length;
    var hLen2 = 2 * hLen;
    if (mLen > k - hLen2 - 2) throw new Error("message too long");
    var ps = Buffer.alloc(k - mLen - hLen2 - 2);
    var dblen = k - hLen - 1;
    var seed = randomBytes(hLen);
    var maskedDb = xor(Buffer.concat([
        iHash,
        ps,
        Buffer.alloc(1, 1),
        msg
    ], dblen), mgf(seed, dblen));
    var maskedSeed = xor(seed, mgf(maskedDb, hLen));
    return new BN(Buffer.concat([
        Buffer.alloc(1),
        maskedSeed,
        maskedDb
    ], k));
}
function pkcs1(key, msg, reverse) {
    var mLen = msg.length;
    var k = key.modulus.byteLength();
    if (mLen > k - 11) throw new Error("message too long");
    var ps;
    if (reverse) ps = Buffer.alloc(k - mLen - 3, 0xff);
    else ps = nonZero(k - mLen - 3);
    return new BN(Buffer.concat([
        Buffer.from([
            0,
            reverse ? 1 : 2
        ]),
        ps,
        Buffer.alloc(1),
        msg
    ], k));
}
function nonZero(len) {
    var out = Buffer.allocUnsafe(len);
    var i = 0;
    var cache = randomBytes(len * 2);
    var cur = 0;
    var num;
    while(i < len){
        if (cur === cache.length) {
            cache = randomBytes(len * 2);
            cur = 0;
        }
        num = cache[cur++];
        if (num) out[i++] = num;
    }
    return out;
}

},{"ca2697dbde558d1":"4Szbv","4704ad09aa96a56b":"8hjhE","b8a92fd1d9e43252":"2WyL8","469be15a31031bba":"e2JgG","f9f3694c0f7388b6":"iaxu0","cb7a38ec1a0039d7":"VopIn","969e1e2dd90e2fbe":"fFkPV","9022efe01867a612":"e594P","d610bb618706f42f":"eW7r9"}],"e2JgG":[function(require,module,exports) {
var createHash = require("b36bb21196daa39");
var Buffer = require("cfa1ea60eac1ebfa").Buffer;
module.exports = function(seed, len) {
    var t = Buffer.alloc(0);
    var i = 0;
    var c;
    while(t.length < len){
        c = i2ops(i++);
        t = Buffer.concat([
            t,
            createHash("sha1").update(seed).update(c).digest()
        ]);
    }
    return t.slice(0, len);
};
function i2ops(c) {
    var out = Buffer.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
}

},{"b36bb21196daa39":"2WyL8","cfa1ea60eac1ebfa":"eW7r9"}],"iaxu0":[function(require,module,exports) {
module.exports = function xor(a, b) {
    var len = a.length;
    var i = -1;
    while(++i < len)a[i] ^= b[i];
    return a;
};

},{}],"fFkPV":[function(require,module,exports) {
var BN = require("94162e508c4195c3");
var Buffer = require("1bab2adfd8072b94").Buffer;
function withPublic(paddedMsg, key) {
    return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
module.exports = withPublic;

},{"94162e508c4195c3":"VopIn","1bab2adfd8072b94":"eW7r9"}],"jIkKI":[function(require,module,exports) {
var parseKeys = require("6c46b1d8bb7eae7b");
var mgf = require("9e51003323ea065d");
var xor = require("637b57d34a8dda25");
var BN = require("3927561f39566b29");
var crt = require("521cbc4ce6042d5b");
var createHash = require("95282d7c0e66f364");
var withPublic = require("1bc2f92e3c398dbe");
var Buffer = require("802d086fb6d63368").Buffer;
module.exports = function privateDecrypt(privateKey, enc, reverse) {
    var padding;
    if (privateKey.padding) padding = privateKey.padding;
    else if (reverse) padding = 1;
    else padding = 4;
    var key = parseKeys(privateKey);
    var k = key.modulus.byteLength();
    if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) throw new Error("decryption error");
    var msg;
    if (reverse) msg = withPublic(new BN(enc), key);
    else msg = crt(enc, key);
    var zBuffer = Buffer.alloc(k - msg.length);
    msg = Buffer.concat([
        zBuffer,
        msg
    ], k);
    if (padding === 4) return oaep(key, msg);
    else if (padding === 1) return pkcs1(key, msg, reverse);
    else if (padding === 3) return msg;
    else throw new Error("unknown padding");
};
function oaep(key, msg) {
    var k = key.modulus.byteLength();
    var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    var hLen = iHash.length;
    if (msg[0] !== 0) throw new Error("decryption error");
    var maskedSeed = msg.slice(1, hLen + 1);
    var maskedDb = msg.slice(hLen + 1);
    var seed = xor(maskedSeed, mgf(maskedDb, hLen));
    var db = xor(maskedDb, mgf(seed, k - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) throw new Error("decryption error");
    var i = hLen;
    while(db[i] === 0)i++;
    if (db[i++] !== 1) throw new Error("decryption error");
    return db.slice(i);
}
function pkcs1(key, msg, reverse) {
    var p1 = msg.slice(0, 2);
    var i = 2;
    var status = 0;
    while(msg[i++] !== 0)if (i >= msg.length) {
        status++;
        break;
    }
    var ps = msg.slice(2, i - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) status++;
    if (ps.length < 8) status++;
    if (status) throw new Error("decryption error");
    return msg.slice(i);
}
function compare(a, b) {
    a = Buffer.from(a);
    b = Buffer.from(b);
    var dif = 0;
    var len = a.length;
    if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
    }
    var i = -1;
    while(++i < len)dif += a[i] ^ b[i];
    return dif;
}

},{"6c46b1d8bb7eae7b":"4Szbv","9e51003323ea065d":"e2JgG","637b57d34a8dda25":"iaxu0","3927561f39566b29":"VopIn","521cbc4ce6042d5b":"e594P","95282d7c0e66f364":"2WyL8","1bc2f92e3c398dbe":"fFkPV","802d086fb6d63368":"eW7r9"}],"k3tsT":[function(require,module,exports) {
var global = arguments[3];
var process = require("e52c82591caff1d7");
"use strict";
function oldBrowser() {
    throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
}
var safeBuffer = require("954d667c0302f12c");
var randombytes = require("7041a0e993c249ef");
var Buffer = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto = global.crypto || global.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(offset, length) {
    if (typeof offset !== "number" || offset !== offset) throw new TypeError("offset must be a number");
    if (offset > kMaxUint32 || offset < 0) throw new TypeError("offset must be a uint32");
    if (offset > kBufferMaxLength || offset > length) throw new RangeError("offset out of range");
}
function assertSize(size, offset, length) {
    if (typeof size !== "number" || size !== size) throw new TypeError("size must be a number");
    if (size > kMaxUint32 || size < 0) throw new TypeError("size must be a uint32");
    if (size + offset > length || size > kBufferMaxLength) throw new RangeError("buffer too small");
}
if (crypto && crypto.getRandomValues || false) {
    exports.randomFill = randomFill;
    exports.randomFillSync = randomFillSync;
} else {
    exports.randomFill = oldBrowser;
    exports.randomFillSync = oldBrowser;
}
function randomFill(buf, offset, size, cb) {
    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
    } else if (typeof size === "function") {
        cb = size;
        size = buf.length - offset;
    } else if (typeof cb !== "function") throw new TypeError('"cb" argument must be a function');
    assertOffset(offset, buf.length);
    assertSize(size, offset, buf.length);
    return actualFill(buf, offset, size, cb);
}
function actualFill(buf, offset, size, cb) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto.getRandomValues(uint);
    if (cb) {
        process.nextTick(function() {
            cb(null, buf);
        });
        return;
    }
    return buf;
    if (cb) {
        randombytes(size, function(err, bytes) {
            if (err) return cb(err);
            bytes.copy(buf, offset);
            cb(null, buf);
        });
        return;
    }
    var bytes = randombytes(size);
    bytes.copy(buf, offset);
    return buf;
}
function randomFillSync(buf, offset, size) {
    if (typeof offset === "undefined") offset = 0;
    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    assertOffset(offset, buf.length);
    if (size === undefined) size = buf.length - offset;
    assertSize(size, offset, buf.length);
    return actualFill(buf, offset, size);
}

},{"e52c82591caff1d7":"d5jf4","954d667c0302f12c":"eW7r9","7041a0e993c249ef":"8hjhE"}],"jxSHd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultSocketOptions", ()=>defaultSocketOptions);
var _mergeOptions = require("merge-options");
var _mergeOptionsDefault = parcelHelpers.interopDefault(_mergeOptions);
function defaultSocketOptions(options) {
    return (0, _mergeOptionsDefault.default)(options ?? {}, {
        type: "udp4",
        broadcast: {
            address: "239.255.255.250",
            port: 1900
        },
        bind: {
            address: "0.0.0.0",
            port: 1900
        },
        maxHops: 4
    });
}

},{"merge-options":"l45Gy","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jqVYe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "discover", ()=>discover);
function discover(ssdp, serviceType) {
    serviceType = serviceType ?? "ssdp:all";
    ssdp.emit("ssdp:send-message", "M-SEARCH * HTTP/1.1", {
        ST: serviceType,
        MAN: "ssdp:discover",
        MX: 0
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"86Dqm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "searchResponse", ()=>searchResponse);
var _resolveServiceJs = require("../commands/resolve-service.js");
function searchResponse(ssdp, message) {
    (0, _resolveServiceJs.resolveService)(ssdp, message.USN, message.ST, message.LOCATION, message.ttl()).catch((err)=>{
        ssdp.emit("error", err);
    });
}

},{"../commands/resolve-service.js":"ep6Kz","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"e8LTb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseSsdpMessage", ()=>parseSsdpMessage);
const SEARCH_RESPONSE = "SEARCH-RESPONSE";
function parseSsdpMessage(ssdp, buffer, remote) {
    const lines = buffer.toString("utf8").trim().split(/\r?\n/);
    let type = lines.shift();
    if (type == null) return;
    const message = {
        remote: ()=>remote
    };
    if (type.endsWith("* HTTP/1.1")) type = type.split(" ")[0];
    else if (type === "HTTP/1.1 200 OK") type = SEARCH_RESPONSE;
    else return;
    lines.forEach(function(line) {
        const colon = line.indexOf(":");
        let key = line.substring(0, colon).toUpperCase();
        key = key.trim();
        let value = line.substring(colon + 1);
        value = value.trim();
        message[key] = unwrap(value);
        if (key === "CACHE-CONTROL") {
            const ttl = parseInt(value.toLowerCase().split("max-age=")[1], 10);
            message.ttl = ()=>ttl * 1000;
        }
    });
    type = type.toLowerCase();
    if (![
        "m-search",
        "notify",
        "search-response"
    ].includes(type)) // TODO: remove this
    throw new Error(`unknown ssdp message type ${type}`);
    // @ts-expect-error cannot infer message type
    ssdp.emit(`ssdp:${type}`, message, remote);
}
function unwrap(string) {
    const length = string.length;
    if (string.substring(0, 1) === '"' && string.substring(length - 1) === '"') string = string.substring(1, length - 1);
    const asNumber = parseFloat(string);
    if (!isNaN(asNumber) && asNumber.toString() === string) return asNumber;
    return string.trim();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kGTyT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sendSsdpMessage", ()=>sendSsdpMessage);
var Buffer = require("1d360ec8d869b64b").Buffer;
function isIpv4Address(address) {
    const parts = address.trim().split(".");
    if (parts.length !== 4) return false;
    for(let i = 0; i < parts.length; i++){
        const octet = parseInt(parts[i], 10);
        if (octet < 0 || octet > 255) return false;
    }
    return true;
}
const addressFamilyMismatch = (remote, socket)=>{
    return !(socket.type === "udp4" && isIpv4Address(remote.address));
};
function sendSsdpMessage(ssdp, status, headers, remote) {
    Promise.all(ssdp.sockets.map(async (socket)=>{
        await new Promise((resolve, reject)=>{
            if (socket.closed) {
                resolve();
                return;
            }
            const recipient = remote ?? socket.options.broadcast;
            // don't send messages over udp6 sockets and expect them to reach upd4 recipients
            if (recipient != null && addressFamilyMismatch(recipient, socket)) {
                resolve();
                return;
            }
            if (headers.LOCATION != null) // @ts-expect-error wat
            headers.LOCATION = headers.LOCATION[socket.type];
            const message = [
                status
            ];
            if (!status.startsWith("HTTP/1.1")) // not a response so insert the host header
            message.push(`HOST: ${socket.options.broadcast.address}:${socket.options.broadcast.port}`);
            Object.keys(headers).forEach(function(header) {
                message.push(`${header}: ${headers[header]}`);
            });
            message.push("\r\n");
            const buffer = Buffer.from(message.join("\r\n"));
            ssdp.emit("transport:outgoing-message", socket, buffer, recipient);
            socket.send(buffer, 0, buffer.length, recipient.port, recipient.address, (error)=>{
                if (error != null) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    })).catch((err)=>{
        ssdp.emit("error", err);
    });
}

},{"1d360ec8d869b64b":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"11pUD":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Return the first value in an (async)iterable
 *
 * @example
 *
 * ```javascript
 * import first from 'it-first'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * const res = first(values)
 *
 * console.info(res) // 0
 * ```
 *
 * Async sources must be awaited:
 *
 * ```javascript
 * import first from 'it-first'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const res = await first(values())
 *
 * console.info(res) // 0
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function first(source) {
    if (isAsyncIterable(source)) return (async ()=>{
        for await (const entry of source)return entry;
        return undefined;
    })();
    for (const entry of source)return entry;
    return undefined;
}
exports.default = first;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"CnTks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PMPClient", ()=>PMPClient);
var _dgram = require("dgram");
var _events = require("events");
var _logger = require("@libp2p/logger");
var _errCode = require("err-code");
var _errCodeDefault = parcelHelpers.interopDefault(_errCode);
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var Buffer = require("c6818aa061226e5d").Buffer;
const debug = (0, _logger.logger)("nat-port-mapper:pmp");
// Ports defined by draft
const CLIENT_PORT = 5350;
const SERVER_PORT = 5351;
// Opcodes
const OP_EXTERNAL_IP = 0;
const OP_MAP_UDP = 1;
const OP_MAP_TCP = 2;
const SERVER_DELTA = 128;
// Resulit codes
const RESULT_CODES = {
    0: "Success",
    1: "Unsupported Version",
    2: "Not Authorized/Refused (gateway may have NAT-PMP disabled)",
    3: "Network Failure (gateway may have not obtained a DHCP lease)",
    4: "Out of Resources (no ports left)",
    5: "Unsupported opcode"
};
class PMPClient extends (0, _events.EventEmitter) {
    socket;
    queue;
    connecting;
    listening;
    req;
    reqActive;
    discoverGateway;
    gateway;
    cancelGatewayDiscovery;
    static createClient(discoverGateway) {
        return new PMPClient(discoverGateway);
    }
    constructor(discoverGateway){
        super();
        if (discoverGateway == null) throw new Error("discoverGateway is not defined");
        this.discoverGateway = discoverGateway;
        this.queue = [];
        this.connecting = false;
        this.listening = false;
        this.req = null;
        this.reqActive = false;
        // Create socket
        this.socket = (0, _dgram.createSocket)({
            type: "udp4",
            reuseAddr: true
        });
        this.socket.on("listening", ()=>{
            this.onListening();
        });
        this.socket.on("message", (msg, rinfo)=>{
            this.onMessage(msg, rinfo);
        });
        this.socket.on("close", ()=>{
            this.onClose();
        });
        this.socket.on("error", (err)=>{
            this.onError(err);
        });
        // Try to connect
        this.connect();
    }
    connect() {
        debug("Client#connect()");
        if (this.connecting) return;
        this.connecting = true;
        this.socket.bind(CLIENT_PORT);
    }
    async map(opts) {
        debug("Client#portMapping()");
        let opcode;
        switch(String(opts.protocol ?? "tcp").toLowerCase()){
            case "tcp":
                opcode = OP_MAP_TCP;
                break;
            case "udp":
                opcode = OP_MAP_UDP;
                break;
            default:
                throw new Error('"type" must be either "tcp" or "udp"');
        }
        const discoverGateway = this.discoverGateway();
        this.cancelGatewayDiscovery = discoverGateway.cancel;
        const gateway = await discoverGateway.gateway();
        this.cancelGatewayDiscovery = undefined;
        this.gateway = new URL(gateway.location).host;
        const deferred = (0, _pDeferDefault.default)();
        this.request(opcode, opts, deferred);
        await deferred.promise;
    }
    async unmap(opts) {
        debug("Client#portUnmapping()");
        await this.map({
            ...opts,
            description: "",
            localAddress: "",
            ttl: 0
        });
    }
    async externalIp() {
        debug("Client#externalIp()");
        const discoverGateway = this.discoverGateway();
        this.cancelGatewayDiscovery = discoverGateway.cancel;
        const gateway = await discoverGateway.gateway();
        this.cancelGatewayDiscovery = undefined;
        this.gateway = new URL(gateway.location).host;
        const deferred = (0, _pDeferDefault.default)();
        this.request(OP_EXTERNAL_IP, {}, deferred);
        return deferred.promise;
    }
    async close() {
        debug("Client#close()");
        if (this.socket != null) this.socket.close();
        this.queue = [];
        this.connecting = false;
        this.listening = false;
        this.req = null;
        this.reqActive = false;
        if (this.cancelGatewayDiscovery != null) await this.cancelGatewayDiscovery();
    }
    /**
     * Queues a UDP request to be send to the gateway device.
     */ request(op, obj, deferred) {
        debug("Client#request()", [
            op,
            obj
        ]);
        let buf;
        let size;
        let pos = 0;
        let internal;
        let external;
        let ttl;
        switch(op){
            case OP_MAP_UDP:
            case OP_MAP_TCP:
                if (obj == null) throw new Error('mapping a port requires an "options" object');
                internal = Number(obj.private ?? obj.internal ?? 0);
                if ((internal !== (internal | 0)) ?? internal < 0) throw new Error('the "private" port must be a whole integer >= 0');
                external = Number(obj.public ?? obj.external ?? 0);
                if ((external !== (external | 0)) ?? external < 0) throw new Error('the "public" port must be a whole integer >= 0');
                ttl = Number(obj.ttl ?? 0);
                if (ttl !== (ttl | 0)) // The RECOMMENDED Port Mapping Lifetime is 7200 seconds (two hours)
                ttl = 7200;
                size = 12;
                buf = Buffer.alloc(size);
                buf.writeUInt8(0, pos);
                pos++; // Vers = 0
                buf.writeUInt8(op, pos);
                pos++; // OP = x
                buf.writeUInt16BE(0, pos);
                pos += 2; // Reserved (MUST be zero)
                buf.writeUInt16BE(internal, pos);
                pos += 2; // Internal Port
                buf.writeUInt16BE(external, pos);
                pos += 2; // Requested External Port
                buf.writeUInt32BE(ttl, pos);
                pos += 4; // Requested Port Mapping Lifetime in Seconds
                break;
            case OP_EXTERNAL_IP:
                size = 2;
                buf = Buffer.alloc(size);
                // Vers = 0
                buf.writeUInt8(0, 0);
                pos++;
                // OP = x
                buf.writeUInt8(op, 1);
                pos++;
                break;
            default:
                throw new Error(`Invalid opcode: ${op}`);
        }
        // assert.equal(pos, size, 'buffer not fully written!')
        // Add it to queue
        this.queue.push({
            op,
            buf,
            deferred
        });
        // Try to send next message
        this._next();
    }
    /**
     * Processes the next request if the socket is listening.
     */ _next() {
        debug("Client#_next()");
        const req = this.queue[0];
        if (req == null) {
            debug("_next: nothing to process");
            return;
        }
        if (this.socket == null) {
            debug("_next: client is closed");
            return;
        }
        if (!this.listening) {
            debug('_next: not "listening" yet, cannot send out request yet');
            if (!this.connecting) this.connect();
            return;
        }
        if (this.reqActive) {
            debug("_next: already an active request so wait...");
            return;
        }
        this.reqActive = true;
        this.req = req;
        const buf = req.buf;
        debug("_next: sending request", buf, this.gateway);
        this.socket.send(buf, 0, buf.length, SERVER_PORT, this.gateway);
    }
    onListening() {
        debug("Client#onListening()");
        this.listening = true;
        this.connecting = false;
        // Try to send next message
        this._next();
    }
    onMessage(msg, rinfo) {
        // Ignore message if we're not expecting it
        if (this.queue.length === 0) return;
        debug("Client#onMessage()", [
            msg,
            rinfo
        ]);
        const cb = (err, parsed)=>{
            this.req = null;
            this.reqActive = false;
            if (err != null) {
                if (req.deferred != null) req.deferred.reject(err);
                else this.emit("error", err);
            } else if (req.deferred != null) req.deferred.resolve(parsed);
            // Try to send next message
            this._next();
        };
        const req = this.queue[0];
        const parsed = {
            msg
        };
        parsed.vers = msg.readUInt8(0);
        parsed.op = msg.readUInt8(1);
        if (parsed.op - SERVER_DELTA !== req.op) {
            debug("WARN: ignoring unexpected message opcode", parsed.op);
            return;
        }
        // if we got here, then we're gonna invoke the request's callback,
        // so shift this request off of the queue.
        debug('removing "req" off of the queue');
        this.queue.shift();
        if (parsed.vers !== 0) {
            cb(new Error(`"vers" must be 0. Got: ${parsed.vers}`)); // eslint-disable-line @typescript-eslint/restrict-template-expressions
            return;
        }
        // Common fields
        parsed.resultCode = msg.readUInt16BE(2);
        parsed.resultMessage = RESULT_CODES[parsed.resultCode];
        parsed.epoch = msg.readUInt32BE(4);
        // Error
        if (parsed.resultCode !== 0) {
            cb((0, _errCodeDefault.default)(new Error(parsed.resultMessage), parsed.resultCode));
            return;
        }
        // Success
        switch(req.op){
            case OP_MAP_UDP:
            case OP_MAP_TCP:
                parsed.private = parsed.internal = msg.readUInt16BE(8);
                parsed.public = parsed.external = msg.readUInt16BE(10);
                parsed.ttl = msg.readUInt32BE(12);
                parsed.type = req.op === OP_MAP_UDP ? "udp" : "tcp";
                break;
            case OP_EXTERNAL_IP:
                parsed.ip = [];
                parsed.ip.push(msg.readUInt8(8));
                parsed.ip.push(msg.readUInt8(9));
                parsed.ip.push(msg.readUInt8(10));
                parsed.ip.push(msg.readUInt8(11));
                break;
            default:
                cb(new Error(`Unknown opcode: ${req.op}`));
                return;
        }
        cb(undefined, parsed);
    }
    onClose() {
        debug("Client#onClose()");
        this.listening = false;
        this.connecting = false;
    }
    onError(err) {
        debug("Client#onError()", [
            err
        ]);
        if (this.req?.cb != null) this.req.cb(err);
        else this.emit("error", err);
        if (this.socket != null) {
            this.socket.close();
            // Force close - close() does not guarantee to trigger onClose()
            this.onClose();
        }
    }
}

},{"c6818aa061226e5d":"fCgem","dgram":"bXKEI","events":"1VQLm","@libp2p/logger":"aeh5U","err-code":"dUrrM","p-defer":"cWx93","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"fLVvs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UPNPClient", ()=>UPNPClient);
var _logger = require("@libp2p/logger");
var _deviceJs = require("./device.js");
const log = (0, _logger.logger)("nat-port-mapper:upnp");
class UPNPClient {
    closed;
    discoverGateway;
    cancelGatewayDiscovery;
    abortController;
    static createClient(discoverGateway) {
        return new UPNPClient(discoverGateway);
    }
    constructor(discoverGateway){
        this.discoverGateway = discoverGateway;
        this.closed = false;
        // used to terminate network operations on shutdown
        this.abortController = new AbortController();
    }
    async map(options) {
        if (this.closed) throw new Error("client is closed");
        const gateway = await this.findGateway();
        const description = options.description ?? "node:nat:upnp";
        const protocol = options.protocol === "TCP" ? options.protocol : "UDP";
        let ttl = 1800;
        if (typeof options.ttl === "number") ttl = options.ttl;
        if (typeof options.ttl === "string" && !isNaN(options.ttl)) ttl = Number(options.ttl);
        log("Mapping local port %d to public port %d", options.localPort, options.publicPort);
        await gateway.run("AddPortMapping", [
            [
                "NewExternalPort",
                options.publicPort
            ],
            [
                "NewProtocol",
                protocol
            ],
            [
                "NewInternalPort",
                options.localPort
            ],
            [
                "NewInternalClient",
                options.localAddress
            ],
            [
                "NewEnabled",
                1
            ],
            [
                "NewPortMappingDescription",
                description
            ],
            [
                "NewLeaseDuration",
                ttl
            ],
            [
                "NewProtocol",
                options.protocol
            ]
        ], this.abortController.signal);
    }
    async unmap(options) {
        if (this.closed) throw new Error("client is closed");
        const gateway = await this.findGateway();
        await gateway.run("DeletePortMapping", [
            [
                "NewExternalPort",
                options.publicPort
            ],
            [
                "NewProtocol",
                options.protocol
            ]
        ], this.abortController.signal);
    }
    async externalIp() {
        if (this.closed) throw new Error("client is closed");
        log("Discover external IP address");
        const gateway = await this.findGateway();
        const data = await gateway.run("GetExternalIPAddress", [], this.abortController.signal);
        let key = null;
        Object.keys(data).some(function(k) {
            if (!/:GetExternalIPAddressResponse$/.test(k)) return false;
            key = k;
            return true;
        });
        if (key == null) throw new Error("Incorrect response");
        log("Discovered external IP address %s", data[key].NewExternalIPAddress);
        return data[key].NewExternalIPAddress;
    }
    async findGateway() {
        if (this.closed) throw new Error("client is closed");
        const discovery = this.discoverGateway();
        this.cancelGatewayDiscovery = discovery.cancel;
        const service = await discovery.gateway();
        this.cancelGatewayDiscovery = undefined;
        return new (0, _deviceJs.Device)(service);
    }
    async close() {
        this.closed = true;
        this.abortController.abort();
        if (this.cancelGatewayDiscovery != null) await this.cancelGatewayDiscovery();
    }
}

},{"@libp2p/logger":"aeh5U","./device.js":"2etnQ","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2etnQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Device", ()=>Device);
var _logger = require("@libp2p/logger");
var _xml2Js = require("xml2js");
var _xml2JsDefault = parcelHelpers.interopDefault(_xml2Js);
var _fetchJs = require("./fetch.js");
const log = (0, _logger.logger)("nat-port-mapper:upnp:device");
class Device {
    service;
    services;
    constructor(service){
        this.service = service;
        this.services = [
            "urn:schemas-upnp-org:service:WANIPConnection:1",
            "urn:schemas-upnp-org:service:WANIPConnection:2",
            "urn:schemas-upnp-org:service:WANPPPConnection:1"
        ];
    }
    async run(action, args, signal) {
        const info = this.getService(this.services);
        const requestBody = `<?xml version="1.0"?>
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
  <s:Body>
    <u:${action} xmlns:u="${info.service}">${args.map((args)=>`
      <${args[0]}>${args[1] != null ? args[1] : ""}</${args[0]}>`).join("")}
    </u:${action}>
  </s:Body>
</s:Envelope>`;
        log.trace("-> POST", info.controlURL);
        log.trace("->", requestBody);
        const text = await (0, _fetchJs.fetchXML)(new URL(info.controlURL), {
            method: "POST",
            headers: {
                "Content-Type": "text/xml",
                "Content-Length": requestBody.length.toString(),
                SOAPAction: JSON.stringify(info.service + "#" + action)
            },
            body: requestBody,
            signal
        });
        log.trace("<-", text);
        const parser = new (0, _xml2JsDefault.default).Parser({
            explicitRoot: false,
            explicitArray: false,
            attrkey: "@"
        });
        const responseBody = await parser.parseStringPromise(text);
        const soapns = this.getNamespace(responseBody, "http://schemas.xmlsoap.org/soap/envelope/");
        return responseBody[soapns + "Body"];
    }
    getService(types) {
        const [service] = this.parseDescription(this.service.details).services.filter(function(service) {
            return types.includes(service.serviceType);
        });
        // Use the first available service
        if (service == null || service.controlURL == null || service.SCPDURL == null) throw new Error("Service not found");
        const base = new URL(this.service.location);
        function addPrefix(u) {
            let uri;
            try {
                uri = new URL(u);
            } catch (err) {
                // Is only the path of the URL
                uri = new URL(u, base.href);
            }
            uri.host = uri.host ?? base.host;
            uri.protocol = uri.protocol ?? base.protocol;
            return uri.toString();
        }
        return {
            service: service.serviceType,
            SCPDURL: addPrefix(service.SCPDURL),
            controlURL: addPrefix(service.controlURL)
        };
    }
    parseDescription(info) {
        const services = [];
        const devices = [];
        function toArray(item) {
            return Array.isArray(item) ? item : [
                item
            ];
        }
        function traverseServices(service) {
            if (service == null) return;
            services.push(service);
        }
        function traverseDevices(device) {
            if (device == null) return;
            devices.push(device);
            if (device.deviceList?.device != null) toArray(device.deviceList.device).forEach(traverseDevices);
            if (device.serviceList?.service != null) toArray(device.serviceList.service).forEach(traverseServices);
        }
        traverseDevices(info.device);
        return {
            services,
            devices
        };
    }
    getNamespace(data, uri) {
        let ns;
        if (data["@"] != null) Object.keys(data["@"]).some(function(key) {
            if (!/^xmlns:/.test(key)) return false;
            if (data["@"][key] !== uri) return false;
            ns = key.replace(/^xmlns:/, "");
            return true;
        });
        return ns != null ? `${ns}:` : "";
    }
}

},{"@libp2p/logger":"aeh5U","xml2js":"7fkbn","./fetch.js":"8mtK2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8mtK2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fetchXML", ()=>fetchXML);
var _http = require("http");
var _httpDefault = parcelHelpers.interopDefault(_http);
var _https = require("https");
var _httpsDefault = parcelHelpers.interopDefault(_https);
var _logger = require("@libp2p/logger");
const log = (0, _logger.logger)("nat-port-mapper:upnp:fetch");
function initRequest(url, init) {
    if (url.protocol === "http:") return (0, _httpDefault.default).request(url, {
        method: init.method,
        headers: init.headers,
        signal: init.signal
    });
    else if (url.protocol === "https:") return (0, _httpsDefault.default).request(url, {
        method: init.method,
        headers: init.headers,
        rejectUnauthorized: false,
        signal: init.signal
    });
    else throw new Error("Invalid protocol " + url.protocol);
}
async function fetchXML(url, init) {
    return new Promise((resolve, reject)=>{
        const request = initRequest(url, init);
        if (init.body != null) request.write(init.body);
        request.end();
        request.on("error", (err)=>{
            reject(err);
        });
        request.on("response", (response)=>{
            if (response.statusCode === 302 && response.headers.location != null) {
                log("Redirecting to %s", response.headers.location);
                fetchXML(new URL(response.headers.location), init).then(resolve, reject);
                return;
            }
            if (response.statusCode !== 200) throw new Error(`Request failed: ${response.statusCode}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
            if (response.headers["content-type"] != null && !response.headers["content-type"].includes("/xml")) {
                reject(new Error("Bad content type " + response.headers["content-type"]));
                return;
            }
            let body = "";
            response.on("data", (chunk)=>{
                body += chunk.toString();
            });
            response.on("end", ()=>{
                resolve(body);
            });
            response.on("error", (err)=>{
                reject(err);
            });
        });
    });
}

},{"http":"5y8Jo","https":"djrPu","@libp2p/logger":"aeh5U","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"7GUaQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if a given multiaddr is a loopback address.
 */ parcelHelpers.export(exports, "isLoopback", ()=>isLoopback);
var _isLoopbackAddr = require("is-loopback-addr");
function isLoopback(ma) {
    const { address } = ma.nodeAddress();
    return (0, _isLoopbackAddr.isLoopbackAddr)(address);
}

},{"is-loopback-addr":"372iC","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"372iC":[function(require,module,exports) {
/**
 * Check if a given ip address is a loopback address
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isLoopbackAddr", ()=>isLoopbackAddr);
function isLoopbackAddr(ip) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iDsuH":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Use the `autoNATService` function to add support for the [AutoNAT protocol](https://docs.libp2p.io/concepts/nat/autonat/)
 * to libp2p.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { autoNAT } from '@libp2p/autonat'
 *
 * const node = await createLibp2p({
 *   // ...other options
 *   services: {
 *     autoNAT: autoNAT()
 *   }
 * })
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "autoNAT", ()=>autoNAT);
var _autonatJs = require("./autonat.js");
function autoNAT(init = {}) {
    return (components)=>{
        return new (0, _autonatJs.AutoNATService)(components, init);
    };
}

},{"./autonat.js":"kS1Yg","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kS1Yg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AutoNATService", ()=>AutoNATService);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _peerIdFactory = require("@libp2p/peer-id-factory");
var _privateIp = require("@libp2p/utils/private-ip");
var _multiaddr = require("@multiformats/multiaddr");
var _itFirst = require("it-first");
var _itFirstDefault = parcelHelpers.interopDefault(_itFirst);
var _itLengthPrefixed = require("it-length-prefixed");
var _itMap = require("it-map");
var _itMapDefault = parcelHelpers.interopDefault(_itMap);
var _itParallel = require("it-parallel");
var _itParallelDefault = parcelHelpers.interopDefault(_itParallel);
var _itPipe = require("it-pipe");
var _constantsJs = require("./constants.js");
var _indexJs = require("./pb/index.js");
// if more than 3 peers manage to dial us on what we believe to be our external
// IP then we are convinced that it is, in fact, our external IP
// https://github.com/libp2p/specs/blob/master/autonat/README.md#autonat-protocol
const REQUIRED_SUCCESSFUL_DIALS = 4;
class AutoNATService {
    components;
    startupDelay;
    refreshInterval;
    protocol;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    verifyAddressTimeout;
    started;
    log;
    constructor(components, init){
        this.components = components;
        this.log = components.logger.forComponent("libp2p:autonat");
        this.started = false;
        this.protocol = `/${init.protocolPrefix ?? (0, _constantsJs.PROTOCOL_PREFIX)}/${0, _constantsJs.PROTOCOL_NAME}/${0, _constantsJs.PROTOCOL_VERSION}`;
        this.timeout = init.timeout ?? (0, _constantsJs.TIMEOUT);
        this.maxInboundStreams = init.maxInboundStreams ?? (0, _constantsJs.MAX_INBOUND_STREAMS);
        this.maxOutboundStreams = init.maxOutboundStreams ?? (0, _constantsJs.MAX_OUTBOUND_STREAMS);
        this.startupDelay = init.startupDelay ?? (0, _constantsJs.STARTUP_DELAY);
        this.refreshInterval = init.refreshInterval ?? (0, _constantsJs.REFRESH_INTERVAL);
        this._verifyExternalAddresses = this._verifyExternalAddresses.bind(this);
    }
    isStarted() {
        return this.started;
    }
    async start() {
        if (this.started) return;
        await this.components.registrar.handle(this.protocol, (data)=>{
            this.handleIncomingAutonatStream(data).catch((err)=>{
                this.log.error("error handling incoming autonat stream", err);
            });
        }, {
            maxInboundStreams: this.maxInboundStreams,
            maxOutboundStreams: this.maxOutboundStreams
        });
        this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.startupDelay);
        this.started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(this.protocol);
        clearTimeout(this.verifyAddressTimeout);
        this.started = false;
    }
    /**
     * Handle an incoming AutoNAT request
     */ async handleIncomingAutonatStream(data) {
        const signal = AbortSignal.timeout(this.timeout);
        const onAbort = ()=>{
            data.stream.abort(new (0, _interface.CodeError)("handleIncomingAutonatStream timeout", (0, _interface.ERR_TIMEOUT)));
        };
        signal.addEventListener("abort", onAbort, {
            once: true
        });
        // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning
        // appearing in the console
        (0, _interface.setMaxListeners)(Infinity, signal);
        const ourHosts = this.components.addressManager.getAddresses().map((ma)=>ma.toOptions().host);
        try {
            const self = this;
            await (0, _itPipe.pipe)(data.stream, (source)=>_itLengthPrefixed.decode(source), async function*(stream) {
                const buf = await (0, _itFirstDefault.default)(stream);
                if (buf == null) {
                    self.log("no message received");
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "No message was sent"
                        }
                    });
                    return;
                }
                let request;
                try {
                    request = (0, _indexJs.Message).decode(buf);
                } catch (err) {
                    self.log.error("could not decode message", err);
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "Could not decode message"
                        }
                    });
                    return;
                }
                const dialRequest = request.dial;
                if (dialRequest == null) {
                    self.log.error("dial was missing from message");
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "No Dial message found in message"
                        }
                    });
                    return;
                }
                let peerId;
                const peer = dialRequest.peer;
                if (peer == null || peer.id == null) {
                    self.log.error("PeerId missing from message");
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "missing peer info"
                        }
                    });
                    return;
                }
                try {
                    peerId = (0, _peerId.peerIdFromBytes)(peer.id);
                } catch (err) {
                    self.log.error("invalid PeerId", err);
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "bad peer id"
                        }
                    });
                    return;
                }
                self.log("incoming request from %p", peerId);
                // reject any dial requests that arrive via relays
                if (!data.connection.remotePeer.equals(peerId)) {
                    self.log("target peer %p did not equal sending peer %p", peerId, data.connection.remotePeer);
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST,
                            statusText: "peer id mismatch"
                        }
                    });
                    return;
                }
                // get a list of multiaddrs to dial
                const multiaddrs = peer.addrs.map((buf)=>(0, _multiaddr.multiaddr)(buf)).filter((ma)=>{
                    const isFromSameHost = ma.toOptions().host === data.connection.remoteAddr.toOptions().host;
                    self.log.trace("request to dial %a was sent from %a is same host %s", ma, data.connection.remoteAddr, isFromSameHost);
                    // skip any Multiaddrs where the target node's IP does not match the sending node's IP
                    return isFromSameHost;
                }).filter((ma)=>{
                    const host = ma.toOptions().host;
                    const isPublicIp = !((0, _privateIp.isPrivateIp)(host) ?? false);
                    self.log.trace("host %s was public %s", host, isPublicIp);
                    // don't try to dial private addresses
                    return isPublicIp;
                }).filter((ma)=>{
                    const host = ma.toOptions().host;
                    const isNotOurHost = !ourHosts.includes(host);
                    self.log.trace("host %s was not our host %s", host, isNotOurHost);
                    // don't try to dial nodes on the same host as us
                    return isNotOurHost;
                }).filter((ma)=>{
                    const isSupportedTransport = Boolean(self.components.transportManager.transportForMultiaddr(ma));
                    self.log.trace("transport for %a is supported %s", ma, isSupportedTransport);
                    // skip any Multiaddrs that have transports we do not support
                    return isSupportedTransport;
                }).map((ma)=>{
                    if (ma.getPeerId() == null) // make sure we have the PeerId as part of the Multiaddr
                    ma = ma.encapsulate(`/p2p/${peerId.toString()}`);
                    return ma;
                });
                // make sure we have something to dial
                if (multiaddrs.length === 0) {
                    self.log("no valid multiaddrs for %p in message", peerId);
                    yield (0, _indexJs.Message).encode({
                        type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                        dialResponse: {
                            status: (0, _indexJs.Message).ResponseStatus.E_DIAL_REFUSED,
                            statusText: "no dialable addresses"
                        }
                    });
                    return;
                }
                self.log("dial multiaddrs %s for peer %p", multiaddrs.map((ma)=>ma.toString()).join(", "), peerId);
                let errorMessage = "";
                let lastMultiaddr = multiaddrs[0];
                for await (const multiaddr of multiaddrs){
                    let connection;
                    lastMultiaddr = multiaddr;
                    try {
                        connection = await self.components.connectionManager.openConnection(multiaddr, {
                            signal
                        });
                        if (!connection.remoteAddr.equals(multiaddr)) {
                            self.log.error("tried to dial %a but dialed %a", multiaddr, connection.remoteAddr);
                            throw new Error("Unexpected remote address");
                        }
                        self.log("Success %p", peerId);
                        yield (0, _indexJs.Message).encode({
                            type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                            dialResponse: {
                                status: (0, _indexJs.Message).ResponseStatus.OK,
                                addr: connection.remoteAddr.decapsulateCode((0, _multiaddr.protocols)("p2p").code).bytes
                            }
                        });
                        return;
                    } catch (err) {
                        self.log("could not dial %p", peerId, err);
                        errorMessage = err.message;
                    } finally{
                        if (connection != null) await connection.close();
                    }
                }
                yield (0, _indexJs.Message).encode({
                    type: (0, _indexJs.Message).MessageType.DIAL_RESPONSE,
                    dialResponse: {
                        status: (0, _indexJs.Message).ResponseStatus.E_DIAL_ERROR,
                        statusText: errorMessage,
                        addr: lastMultiaddr.bytes
                    }
                });
            }, (source)=>_itLengthPrefixed.encode(source), data.stream);
        } catch (err) {
            this.log.error("error handling incoming autonat stream", err);
        } finally{
            signal.removeEventListener("abort", onAbort);
        }
    }
    _verifyExternalAddresses() {
        this.verifyExternalAddresses().catch((err)=>{
            this.log.error("error verifying external address", err);
        });
    }
    /**
     * Our multicodec topology noticed a new peer that supports autonat
     */ async verifyExternalAddresses() {
        clearTimeout(this.verifyAddressTimeout);
        // Do not try to push if we are not running
        if (!this.isStarted()) return;
        const addressManager = this.components.addressManager;
        const multiaddrs = addressManager.getObservedAddrs().filter((ma)=>{
            const options = ma.toOptions();
            return !((0, _privateIp.isPrivateIp)(options.host) ?? false);
        });
        if (multiaddrs.length === 0) {
            this.log("no public addresses found, not requesting verification");
            this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
            return;
        }
        const signal = AbortSignal.timeout(this.timeout);
        // this controller may be used while dialing lots of peers so prevent MaxListenersExceededWarning
        // appearing in the console
        (0, _interface.setMaxListeners)(Infinity, signal);
        const self = this;
        try {
            this.log("verify multiaddrs %s", multiaddrs.map((ma)=>ma.toString()).join(", "));
            const request = (0, _indexJs.Message).encode({
                type: (0, _indexJs.Message).MessageType.DIAL,
                dial: {
                    peer: {
                        id: this.components.peerId.toBytes(),
                        addrs: multiaddrs.map((map)=>map.bytes)
                    }
                }
            });
            // find some random peers
            const randomPeer = await (0, _peerIdFactory.createEd25519PeerId)();
            const randomCid = randomPeer.toBytes();
            const results = {};
            const networkSegments = [];
            const verifyAddress = async (peer)=>{
                let onAbort = ()=>{};
                try {
                    this.log("asking %p to verify multiaddr", peer.id);
                    const connection = await self.components.connectionManager.openConnection(peer.id, {
                        signal
                    });
                    const stream = await connection.newStream(this.protocol, {
                        signal
                    });
                    onAbort = ()=>{
                        stream.abort(new (0, _interface.CodeError)("verifyAddress timeout", (0, _interface.ERR_TIMEOUT)));
                    };
                    signal.addEventListener("abort", onAbort, {
                        once: true
                    });
                    const buf = await (0, _itPipe.pipe)([
                        request
                    ], (source)=>_itLengthPrefixed.encode(source), stream, (source)=>_itLengthPrefixed.decode(source), async (stream)=>(0, _itFirstDefault.default)(stream));
                    if (buf == null) {
                        this.log("no response received from %p", connection.remotePeer);
                        return undefined;
                    }
                    const response = (0, _indexJs.Message).decode(buf);
                    if (response.type !== (0, _indexJs.Message).MessageType.DIAL_RESPONSE || response.dialResponse == null) {
                        this.log("invalid autonat response from %p", connection.remotePeer);
                        return undefined;
                    }
                    if (response.dialResponse.status === (0, _indexJs.Message).ResponseStatus.OK) {
                        // make sure we use different network segments
                        const options = connection.remoteAddr.toOptions();
                        let segment;
                        if (options.family === 4) {
                            const octets = options.host.split(".");
                            segment = octets[0];
                        } else if (options.family === 6) {
                            const octets = options.host.split(":");
                            segment = octets[0];
                        } else {
                            this.log('remote address "%s" was not IP4 or IP6?', options.host);
                            return undefined;
                        }
                        if (networkSegments.includes(segment)) {
                            this.log("already have response from network segment %d - %s", segment, options.host);
                            return undefined;
                        }
                        networkSegments.push(segment);
                    }
                    return response.dialResponse;
                } catch (err) {
                    this.log.error("error asking remote to verify multiaddr", err);
                } finally{
                    signal.removeEventListener("abort", onAbort);
                }
            };
            for await (const dialResponse of (0, _itParallelDefault.default)((0, _itMapDefault.default)(this.components.peerRouting.getClosestPeers(randomCid, {
                signal
            }), (peer)=>async ()=>verifyAddress(peer)), {
                concurrency: REQUIRED_SUCCESSFUL_DIALS
            }))try {
                if (dialResponse == null) continue;
                // they either told us which address worked/didn't work, or we only sent them one address
                const addr = dialResponse.addr == null ? multiaddrs[0] : (0, _multiaddr.multiaddr)(dialResponse.addr);
                this.log("autonat response for %a is %s", addr, dialResponse.status);
                if (dialResponse.status === (0, _indexJs.Message).ResponseStatus.E_BAD_REQUEST) continue;
                if (dialResponse.status === (0, _indexJs.Message).ResponseStatus.E_DIAL_REFUSED) continue;
                if (dialResponse.addr == null && multiaddrs.length > 1) continue;
                if (!multiaddrs.some((ma)=>ma.equals(addr))) {
                    this.log("peer reported %a as %s but it was not in our observed address list", addr, dialResponse.status);
                    continue;
                }
                const addrStr = addr.toString();
                if (results[addrStr] == null) results[addrStr] = {
                    success: 0,
                    failure: 0
                };
                if (dialResponse.status === (0, _indexJs.Message).ResponseStatus.OK) results[addrStr].success++;
                else if (dialResponse.status === (0, _indexJs.Message).ResponseStatus.E_DIAL_ERROR) results[addrStr].failure++;
                if (results[addrStr].success === REQUIRED_SUCCESSFUL_DIALS) {
                    // we are now convinced
                    this.log("%a is externally dialable", addr);
                    addressManager.confirmObservedAddr(addr);
                    return;
                }
                if (results[addrStr].failure === REQUIRED_SUCCESSFUL_DIALS) {
                    // we are now unconvinced
                    this.log("%a is not externally dialable", addr);
                    addressManager.removeObservedAddr(addr);
                    return;
                }
            } catch (err) {
                this.log.error("could not verify external address", err);
            }
        } finally{
            this.verifyAddressTimeout = setTimeout(this._verifyExternalAddresses, this.refreshInterval);
        }
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@libp2p/peer-id-factory":"7WdjB","@libp2p/utils/private-ip":"3LaSy","@multiformats/multiaddr":"7Qpz2","it-first":"11pUD","it-length-prefixed":"lzCYq","it-map":"qLIyc","it-parallel":"dPkg2","it-pipe":"hkKTV","./constants.js":"bklMV","./pb/index.js":"jwsXL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"qLIyc":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * Convert one value from an (async)iterator into another.
 *
 * @example
 *
 * ```javascript
 * import map from 'it-map'
 *
 * // This can also be an iterator, generator, etc
 * const values = [0, 1, 2, 3, 4]
 *
 * const result = map(values, (val) => val++)
 *
 * console.info(result) // [1, 2, 3, 4, 5]
 * ```
 *
 * Async sources and transforms must be awaited:
 *
 * ```javascript
 * import map from 'it-map'
 *
 * const values = async function * () {
 *   yield * [0, 1, 2, 3, 4]
 * }
 *
 * const result = await map(values(), async (val) => val++)
 *
 * console.info(result) // [1, 2, 3, 4, 5]
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itPeekable = require("it-peekable");
var _itPeekableDefault = parcelHelpers.interopDefault(_itPeekable);
function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
}
function map(source, func) {
    if (isAsyncIterable(source)) return async function*() {
        for await (const val of source)yield func(val);
    }();
    // if mapping function returns a promise we have to return an async generator
    const peekable = (0, _itPeekableDefault.default)(source);
    const { value, done } = peekable.next();
    if (done === true) return function*() {}();
    const res = func(value);
    // @ts-expect-error .then is not present on O
    if (typeof res.then === "function") return async function*() {
        yield await res;
        for await (const val of peekable)yield func(val);
    }();
    const fn = func;
    return function*() {
        yield res;
        for (const val of peekable)yield fn(val);
    }();
}
exports.default = map;

},{"it-peekable":"2V0IL","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bklMV":[function(require,module,exports) {
/**
 * The prefix to use in the protocol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PROTOCOL_PREFIX", ()=>PROTOCOL_PREFIX);
parcelHelpers.export(exports, "PROTOCOL_NAME", ()=>PROTOCOL_NAME);
parcelHelpers.export(exports, "PROTOCOL_VERSION", ()=>PROTOCOL_VERSION);
parcelHelpers.export(exports, "TIMEOUT", ()=>TIMEOUT);
parcelHelpers.export(exports, "STARTUP_DELAY", ()=>STARTUP_DELAY);
parcelHelpers.export(exports, "REFRESH_INTERVAL", ()=>REFRESH_INTERVAL);
parcelHelpers.export(exports, "MAX_INBOUND_STREAMS", ()=>MAX_INBOUND_STREAMS);
parcelHelpers.export(exports, "MAX_OUTBOUND_STREAMS", ()=>MAX_OUTBOUND_STREAMS);
const PROTOCOL_PREFIX = "libp2p";
const PROTOCOL_NAME = "autonat";
const PROTOCOL_VERSION = "1.0.0";
const TIMEOUT = 30000;
const STARTUP_DELAY = 5000;
const REFRESH_INTERVAL = 60000;
const MAX_INBOUND_STREAMS = 1;
const MAX_OUTBOUND_STREAMS = 1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jwsXL":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Message", ()=>Message);
var _protonsRuntime = require("protons-runtime");
var Message;
(function(Message) {
    let MessageType;
    (function(MessageType) {
        MessageType["DIAL"] = "DIAL";
        MessageType["DIAL_RESPONSE"] = "DIAL_RESPONSE";
    })(MessageType = Message.MessageType || (Message.MessageType = {}));
    let __MessageTypeValues;
    (function(__MessageTypeValues) {
        __MessageTypeValues[__MessageTypeValues["DIAL"] = 0] = "DIAL";
        __MessageTypeValues[__MessageTypeValues["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
    })(__MessageTypeValues || (__MessageTypeValues = {}));
    (function(MessageType) {
        MessageType.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__MessageTypeValues);
        };
    })(MessageType = Message.MessageType || (Message.MessageType = {}));
    let ResponseStatus;
    (function(ResponseStatus) {
        ResponseStatus["OK"] = "OK";
        ResponseStatus["E_DIAL_ERROR"] = "E_DIAL_ERROR";
        ResponseStatus["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
        ResponseStatus["E_BAD_REQUEST"] = "E_BAD_REQUEST";
        ResponseStatus["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));
    let __ResponseStatusValues;
    (function(__ResponseStatusValues) {
        __ResponseStatusValues[__ResponseStatusValues["OK"] = 0] = "OK";
        __ResponseStatusValues[__ResponseStatusValues["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
        __ResponseStatusValues[__ResponseStatusValues["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
        __ResponseStatusValues[__ResponseStatusValues["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
        __ResponseStatusValues[__ResponseStatusValues["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
    })(__ResponseStatusValues || (__ResponseStatusValues = {}));
    (function(ResponseStatus) {
        ResponseStatus.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__ResponseStatusValues);
        };
    })(ResponseStatus = Message.ResponseStatus || (Message.ResponseStatus = {}));
    let PeerInfo;
    (function(PeerInfo) {
        let _codec;
        PeerInfo.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.id != null) {
                    w.uint32(10);
                    w.bytes(obj.id);
                }
                if (obj.addrs != null) for (const value of obj.addrs){
                    w.uint32(18);
                    w.bytes(value);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {
                    addrs: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.id = reader.bytes();
                            break;
                        case 2:
                            obj.addrs.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        PeerInfo.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, PeerInfo.codec());
        };
        PeerInfo.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, PeerInfo.codec());
        };
    })(PeerInfo = Message.PeerInfo || (Message.PeerInfo = {}));
    let Dial;
    (function(Dial) {
        let _codec;
        Dial.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.peer != null) {
                    w.uint32(10);
                    Message.PeerInfo.codec().encode(obj.peer, w);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.peer = Message.PeerInfo.codec().decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        Dial.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, Dial.codec());
        };
        Dial.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, Dial.codec());
        };
    })(Dial = Message.Dial || (Message.Dial = {}));
    let DialResponse;
    (function(DialResponse) {
        let _codec;
        DialResponse.codec = ()=>{
            if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
                if (opts.lengthDelimited !== false) w.fork();
                if (obj.status != null) {
                    w.uint32(8);
                    Message.ResponseStatus.codec().encode(obj.status, w);
                }
                if (obj.statusText != null) {
                    w.uint32(18);
                    w.string(obj.statusText);
                }
                if (obj.addr != null) {
                    w.uint32(26);
                    w.bytes(obj.addr);
                }
                if (opts.lengthDelimited !== false) w.ldelim();
            }, (reader, length)=>{
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while(reader.pos < end){
                    const tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            obj.status = Message.ResponseStatus.codec().decode(reader);
                            break;
                        case 2:
                            obj.statusText = reader.string();
                            break;
                        case 3:
                            obj.addr = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return obj;
            });
            return _codec;
        };
        DialResponse.encode = (obj)=>{
            return (0, _protonsRuntime.encodeMessage)(obj, DialResponse.codec());
        };
        DialResponse.decode = (buf)=>{
            return (0, _protonsRuntime.decodeMessage)(buf, DialResponse.codec());
        };
    })(DialResponse = Message.DialResponse || (Message.DialResponse = {}));
    let _codec;
    Message.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.type != null) {
                w.uint32(8);
                Message.MessageType.codec().encode(obj.type, w);
            }
            if (obj.dial != null) {
                w.uint32(18);
                Message.Dial.codec().encode(obj.dial, w);
            }
            if (obj.dialResponse != null) {
                w.uint32(26);
                Message.DialResponse.codec().encode(obj.dialResponse, w);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.type = Message.MessageType.codec().decode(reader);
                        break;
                    case 2:
                        obj.dial = Message.Dial.codec().decode(reader, reader.uint32());
                        break;
                    case 3:
                        obj.dialResponse = Message.DialResponse.codec().decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Message.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Message.codec());
    };
    Message.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Message.codec());
    };
})(Message || (Message = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"efL9w":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebRTC datachannels](https://webrtc.org/).
 *
 * @example
 *
 * ```js
 * import { createLibp2p } from 'libp2p'
 * import { noise } from '@chainsafe/libp2p-noise'
 * import { multiaddr } from '@multiformats/multiaddr'
 * import first from 'it-first'
 * import { pipe } from 'it-pipe'
 * import { fromString, toString } from 'uint8arrays'
 * import { webRTC } from '@libp2p/webrtc'
 *
 * const node = await createLibp2p({
 *   transports: [webRTC()],
 *   connectionEncryption: [noise()],
 * })
 *
 * await node.start()
 *
 * const ma =  multiaddr('/ip4/0.0.0.0/udp/56093/webrtc/certhash/uEiByaEfNSLBexWBNFZy_QB1vAKEj7JAXDizRs4_SnTflsQ')
 * const stream = await node.dialProtocol(ma, ['/my-protocol/1.0.0'])
 * const message = `Hello js-libp2p-webrtc\n`
 * const response = await pipe([fromString(message)], stream, async (source) => await first(source))
 * const responseDecoded = toString(response.slice(0, response.length))
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webRTC", ()=>webRTC);
parcelHelpers.export(exports, "webRTCDirect", ()=>webRTCDirect);
var _transportJs = require("./private-to-private/transport.js");
var _transportJs1 = require("./private-to-public/transport.js");
/**
 * @param {WebRTCTransportDirectInit} init - WebRTC direct transport configuration
 * @param init.dataChannel - DataChannel configurations
 * @param {number} init.dataChannel.maxMessageSize - Max message size that can be sent through the DataChannel. Larger messages will be chunked into smaller messages below this size (default 16kb)
 * @param {number} init.dataChannel.maxBufferedAmount - Max buffered amount a DataChannel can have (default 16mb)
 * @param {number} init.dataChannel.bufferedAmountLowEventTimeout - If max buffered amount is reached, this is the max time that is waited before the buffer is cleared (default 30 seconds)
 * @returns
 */ function webRTCDirect(init) {
    return (components)=>new (0, _transportJs1.WebRTCDirectTransport)(components, init);
}
/**
 * @param {WebRTCTransportInit} init - WebRTC transport configuration
 * @param {RTCConfiguration} init.rtcConfiguration - RTCConfiguration
 * @param init.dataChannel - DataChannel configurations
 * @param {number} init.dataChannel.maxMessageSize - Max message size that can be sent through the DataChannel. Larger messages will be chunked into smaller messages below this size (default 16kb)
 * @param {number} init.dataChannel.maxBufferedAmount - Max buffered amount a DataChannel can have (default 16mb)
 * @param {number} init.dataChannel.bufferedAmountLowEventTimeout - If max buffered amount is reached, this is the max time that is waited before the buffer is cleared (default 30 seconds)
 * @returns
 */ function webRTC(init) {
    return (components)=>new (0, _transportJs.WebRTCTransport)(components, init);
}

},{"./private-to-private/transport.js":"iEUyo","./private-to-public/transport.js":"cqpAP","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iEUyo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SIGNALING_PROTO_ID", ()=>SIGNALING_PROTO_ID);
parcelHelpers.export(exports, "WebRTCTransport", ()=>WebRTCTransport);
parcelHelpers.export(exports, "splitAddr", ()=>splitAddr);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _multiaddr = require("@multiformats/multiaddr");
var _multiaddrMatcher = require("@multiformats/multiaddr-matcher");
var _errorJs = require("../error.js");
var _maconnJs = require("../maconn.js");
var _muxerJs = require("../muxer.js");
var _indexJs = require("../webrtc/index.js");
var _initiateConnectionJs = require("./initiate-connection.js");
var _listenerJs = require("./listener.js");
var _signalingStreamHandlerJs = require("./signaling-stream-handler.js");
const WEBRTC_TRANSPORT = "/webrtc";
const CIRCUIT_RELAY_TRANSPORT = "/p2p-circuit";
const SIGNALING_PROTO_ID = "/webrtc-signaling/0.0.1";
const INBOUND_CONNECTION_TIMEOUT = 30000;
class WebRTCTransport {
    components;
    init;
    log;
    _started = false;
    metrics;
    shutdownController;
    constructor(components, init = {}){
        this.components = components;
        this.init = init;
        this.log = components.logger.forComponent("libp2p:webrtc");
        this.shutdownController = new AbortController();
        (0, _interface.setMaxListeners)(Infinity, this.shutdownController.signal);
        if (components.metrics != null) this.metrics = {
            dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
                label: "event",
                help: "Total count of WebRTC dialer events by type"
            }),
            listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
                label: "event",
                help: "Total count of WebRTC listener events by type"
            })
        };
    }
    isStarted() {
        return this._started;
    }
    async start() {
        await this.components.registrar.handle(SIGNALING_PROTO_ID, (data)=>{
            this._onProtocol(data).catch((err)=>{
                this.log.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
            });
        }, {
            runOnTransientConnection: true
        });
        this._started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(SIGNALING_PROTO_ID);
        (0, _indexJs.cleanup)();
        this._started = false;
    }
    createListener(options) {
        return new (0, _listenerJs.WebRTCPeerListener)(this.components, {
            shutdownController: this.shutdownController
        });
    }
    [Symbol.toStringTag] = "@libp2p/webrtc";
    [(0, _interface.transportSymbol)] = true;
    filter(multiaddrs) {
        return multiaddrs.filter((0, _multiaddrMatcher.WebRTC).exactMatch);
    }
    /*
     * dial connects to a remote via the circuit relay or any other protocol
     * and proceeds to upgrade to a webrtc connection.
     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
     * For a circuit relay, this will be of the form
     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
    */ async dial(ma, options) {
        this.log.trace("dialing address: %a", ma);
        const peerConnection = new (0, _indexJs.RTCPeerConnection)(this.init.rtcConfiguration);
        const muxerFactory = new (0, _muxerJs.DataChannelMuxerFactory)(this.components, {
            peerConnection,
            dataChannelOptions: this.init.dataChannel
        });
        const { remoteAddress } = await (0, _initiateConnectionJs.initiateConnection)({
            peerConnection,
            multiaddr: ma,
            dataChannelOptions: this.init.dataChannel,
            signal: options.signal,
            connectionManager: this.components.connectionManager,
            transportManager: this.components.transportManager,
            log: this.log
        });
        const webRTCConn = new (0, _maconnJs.WebRTCMultiaddrConnection)(this.components, {
            peerConnection,
            timeline: {
                open: Date.now()
            },
            remoteAddr: remoteAddress,
            metrics: this.metrics?.dialerEvents
        });
        const connection = await options.upgrader.upgradeOutbound(webRTCConn, {
            skipProtection: true,
            skipEncryption: true,
            muxerFactory
        });
        // close the connection on shut down
        this._closeOnShutdown(peerConnection, webRTCConn);
        return connection;
    }
    async _onProtocol({ connection, stream }) {
        const signal = AbortSignal.timeout(this.init.inboundConnectionTimeout ?? INBOUND_CONNECTION_TIMEOUT);
        const peerConnection = new (0, _indexJs.RTCPeerConnection)(this.init.rtcConfiguration);
        const muxerFactory = new (0, _muxerJs.DataChannelMuxerFactory)(this.components, {
            peerConnection,
            dataChannelOptions: this.init.dataChannel
        });
        try {
            const { remoteAddress } = await (0, _signalingStreamHandlerJs.handleIncomingStream)({
                peerConnection,
                connection,
                stream,
                signal,
                log: this.log
            });
            const webRTCConn = new (0, _maconnJs.WebRTCMultiaddrConnection)(this.components, {
                peerConnection,
                timeline: {
                    open: new Date().getTime()
                },
                remoteAddr: remoteAddress,
                metrics: this.metrics?.listenerEvents
            });
            // close the connection on shut down
            this._closeOnShutdown(peerConnection, webRTCConn);
            await this.components.upgrader.upgradeInbound(webRTCConn, {
                skipEncryption: true,
                skipProtection: true,
                muxerFactory
            });
            // close the stream if SDP messages have been exchanged successfully
            await stream.close({
                signal
            });
        } catch (err) {
            stream.abort(err);
            throw err;
        }
    }
    _closeOnShutdown(pc, webRTCConn) {
        // close the connection on shut down
        const shutDownListener = ()=>{
            webRTCConn.close().catch((err)=>{
                this.log.error("could not close WebRTCMultiaddrConnection", err);
            });
        };
        this.shutdownController.signal.addEventListener("abort", shutDownListener);
        pc.addEventListener("close", ()=>{
            this.shutdownController.signal.removeEventListener("abort", shutDownListener);
        });
    }
}
function splitAddr(ma) {
    const addrs = ma.toString().split(WEBRTC_TRANSPORT + "/");
    if (addrs.length !== 2) throw new (0, _interface.CodeError)("webrtc protocol was not present in multiaddr", (0, _errorJs.codes).ERR_INVALID_MULTIADDR);
    if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) throw new (0, _interface.CodeError)("p2p-circuit protocol was not present in multiaddr", (0, _errorJs.codes).ERR_INVALID_MULTIADDR);
    // look for remote peerId
    let remoteAddr = (0, _multiaddr.multiaddr)(addrs[0]);
    const destination = (0, _multiaddr.multiaddr)("/" + addrs[1]);
    const destinationIdString = destination.getPeerId();
    if (destinationIdString == null) throw new (0, _interface.CodeError)("destination peer id was missing", (0, _errorJs.codes).ERR_INVALID_MULTIADDR);
    const lastProtoInRemote = remoteAddr.protos().pop();
    if (lastProtoInRemote === undefined) throw new (0, _interface.CodeError)("invalid multiaddr", (0, _errorJs.codes).ERR_INVALID_MULTIADDR);
    if (lastProtoInRemote.name !== "p2p") remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
    return {
        baseAddr: remoteAddr,
        peerId: (0, _peerId.peerIdFromString)(destinationIdString)
    };
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@multiformats/multiaddr":"7Qpz2","@multiformats/multiaddr-matcher":"8GlCq","../error.js":"2kM5A","../maconn.js":"dRqUJ","../muxer.js":"1Rc8I","../webrtc/index.js":"6CTn2","./initiate-connection.js":"20EwX","./listener.js":"f4cfy","./signaling-stream-handler.js":"AnAO7","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2kM5A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "codes", ()=>codes);
parcelHelpers.export(exports, "WebRTCTransportError", ()=>WebRTCTransportError);
parcelHelpers.export(exports, "ConnectionClosedError", ()=>ConnectionClosedError);
parcelHelpers.export(exports, "connectionClosedError", ()=>connectionClosedError);
parcelHelpers.export(exports, "DataChannelError", ()=>DataChannelError);
parcelHelpers.export(exports, "dataChannelError", ()=>dataChannelError);
parcelHelpers.export(exports, "InappropriateMultiaddrError", ()=>InappropriateMultiaddrError);
parcelHelpers.export(exports, "inappropriateMultiaddr", ()=>inappropriateMultiaddr);
parcelHelpers.export(exports, "InvalidArgumentError", ()=>InvalidArgumentError);
parcelHelpers.export(exports, "invalidArgument", ()=>invalidArgument);
parcelHelpers.export(exports, "InvalidFingerprintError", ()=>InvalidFingerprintError);
parcelHelpers.export(exports, "invalidFingerprint", ()=>invalidFingerprint);
parcelHelpers.export(exports, "OperationAbortedError", ()=>OperationAbortedError);
parcelHelpers.export(exports, "operationAborted", ()=>operationAborted);
parcelHelpers.export(exports, "OverStreamLimitError", ()=>OverStreamLimitError);
parcelHelpers.export(exports, "overStreamLimit", ()=>overStreamLimit);
parcelHelpers.export(exports, "UnimplementedError", ()=>UnimplementedError);
parcelHelpers.export(exports, "unimplemented", ()=>unimplemented);
parcelHelpers.export(exports, "UnsupportedHashAlgorithmError", ()=>UnsupportedHashAlgorithmError);
parcelHelpers.export(exports, "unsupportedHashAlgorithm", ()=>unsupportedHashAlgorithm);
var _interface = require("@libp2p/interface");
var codes;
(function(codes) {
    codes["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
    codes["ERR_DATA_CHANNEL"] = "ERR_DATA_CHANNEL";
    codes["ERR_CONNECTION_CLOSED"] = "ERR_CONNECTION_CLOSED";
    codes["ERR_HASH_NOT_SUPPORTED"] = "ERR_HASH_NOT_SUPPORTED";
    codes["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
    codes["ERR_INVALID_FINGERPRINT"] = "ERR_INVALID_FINGERPRINT";
    codes["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
    codes["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
    codes["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
    codes["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
})(codes || (codes = {}));
class WebRTCTransportError extends (0, _interface.CodeError) {
    constructor(msg, code){
        super(`WebRTC transport error: ${msg}`, code ?? "");
        this.name = "WebRTCTransportError";
    }
}
class ConnectionClosedError extends WebRTCTransportError {
    constructor(state, msg){
        super(`peerconnection moved to state: ${state}: ${msg}`, codes.ERR_CONNECTION_CLOSED);
        this.name = "WebRTC/ConnectionClosed";
    }
}
function connectionClosedError(state, msg) {
    return new ConnectionClosedError(state, msg);
}
class DataChannelError extends WebRTCTransportError {
    constructor(streamLabel, msg){
        super(`[stream: ${streamLabel}] data channel error: ${msg}`, codes.ERR_DATA_CHANNEL);
        this.name = "WebRTC/DataChannelError";
    }
}
function dataChannelError(streamLabel, msg) {
    return new DataChannelError(streamLabel, msg);
}
class InappropriateMultiaddrError extends WebRTCTransportError {
    constructor(msg){
        super(`There was a problem with the Multiaddr which was passed in: ${msg}`, codes.ERR_INVALID_MULTIADDR);
        this.name = "WebRTC/InappropriateMultiaddrError";
    }
}
function inappropriateMultiaddr(msg) {
    return new InappropriateMultiaddrError(msg);
}
class InvalidArgumentError extends WebRTCTransportError {
    constructor(msg){
        super(`There was a problem with a provided argument: ${msg}`, codes.ERR_INVALID_PARAMETERS);
        this.name = "WebRTC/InvalidArgumentError";
    }
}
function invalidArgument(msg) {
    return new InvalidArgumentError(msg);
}
class InvalidFingerprintError extends WebRTCTransportError {
    constructor(fingerprint, source){
        super(`Invalid fingerprint "${fingerprint}" within ${source}`, codes.ERR_INVALID_FINGERPRINT);
        this.name = "WebRTC/InvalidFingerprintError";
    }
}
function invalidFingerprint(fingerprint, source) {
    return new InvalidFingerprintError(fingerprint, source);
}
class OperationAbortedError extends WebRTCTransportError {
    constructor(context, abortReason){
        super(`Signalled to abort because (${abortReason}}) ${context}`, codes.ERR_ALREADY_ABORTED);
        this.name = "WebRTC/OperationAbortedError";
    }
}
function operationAborted(context, reason) {
    return new OperationAbortedError(context, reason);
}
class OverStreamLimitError extends WebRTCTransportError {
    constructor(msg){
        const code = msg.startsWith("inbound") ? codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS : codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS;
        super(msg, code);
        this.name = "WebRTC/OverStreamLimitError";
    }
}
function overStreamLimit(dir, proto) {
    return new OverStreamLimitError(`${dir} stream limit reached for protocol - ${proto}`);
}
class UnimplementedError extends WebRTCTransportError {
    constructor(methodName){
        super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`, codes.ERR_NOT_IMPLEMENTED);
        this.name = "WebRTC/UnimplementedError";
    }
}
function unimplemented(methodName) {
    return new UnimplementedError(methodName);
}
class UnsupportedHashAlgorithmError extends WebRTCTransportError {
    constructor(algo){
        super(`unsupported hash algorithm: ${algo}`, codes.ERR_HASH_NOT_SUPPORTED);
        this.name = "WebRTC/UnsupportedHashAlgorithmError";
    }
}
function unsupportedHashAlgorithm(algorithm) {
    return new UnsupportedHashAlgorithmError(algorithm);
}

},{"@libp2p/interface":"b14bx","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"dRqUJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebRTCMultiaddrConnection", ()=>WebRTCMultiaddrConnection);
var _utilJs = require("./util.js");
class WebRTCMultiaddrConnection {
    log;
    /**
     * WebRTC Peer Connection
     */ peerConnection;
    /**
     * The multiaddr address used to communicate with the remote peer
     */ remoteAddr;
    /**
     * Holds the lifecycle times of the connection
     */ timeline;
    /**
     * Optional metrics counter group for this connection
     */ metrics;
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */ source = (0, _utilJs.nopSource)();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */ sink = (0, _utilJs.nopSink);
    constructor(components, init){
        this.log = components.logger.forComponent("libp2p:webrtc:maconn");
        this.remoteAddr = init.remoteAddr;
        this.timeline = init.timeline;
        this.peerConnection = init.peerConnection;
        const initialState = this.peerConnection.connectionState;
        this.peerConnection.onconnectionstatechange = ()=>{
            this.log.trace("peer connection state change", this.peerConnection.connectionState, "initial state", initialState);
            if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") // nothing else to do but close the connection
            this.timeline.close = Date.now();
        };
    }
    async close(options) {
        this.log.trace("closing connection");
        this.peerConnection.close();
        this.timeline.close = Date.now();
        this.metrics?.increment({
            close: true
        });
    }
    abort(err) {
        this.log.error("closing connection due to error", err);
        this.peerConnection.close();
        this.timeline.close = Date.now();
        this.metrics?.increment({
            abort: true
        });
    }
}

},{"./util.js":"azhmH","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"azhmH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFirefox", ()=>isFirefox);
parcelHelpers.export(exports, "nopSource", ()=>nopSource);
parcelHelpers.export(exports, "nopSink", ()=>nopSink);
parcelHelpers.export(exports, "DATA_CHANNEL_DRAIN_TIMEOUT", ()=>DATA_CHANNEL_DRAIN_TIMEOUT);
parcelHelpers.export(exports, "drainAndClose", ()=>drainAndClose);
var _detectBrowser = require("detect-browser");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
const browser = (0, _detectBrowser.detect)();
const isFirefox = browser != null && browser.name === "firefox";
const nopSource = async function* nop() {};
const nopSink = async (_)=>{};
const DATA_CHANNEL_DRAIN_TIMEOUT = 30000;
function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options) {
    if (channel.readyState !== "open") return;
    Promise.resolve().then(async ()=>{
        // wait for bufferedAmount to become zero
        if (channel.bufferedAmount > 0) {
            options.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
            const deferred = (0, _pDeferDefault.default)();
            let drained = false;
            channel.bufferedAmountLowThreshold = 0;
            const closeListener = ()=>{
                if (!drained) {
                    options.log("%s drain channel closed before drain", direction);
                    deferred.resolve();
                }
            };
            channel.addEventListener("close", closeListener, {
                once: true
            });
            channel.addEventListener("bufferedamountlow", ()=>{
                drained = true;
                channel.removeEventListener("close", closeListener);
                deferred.resolve();
            });
            await (0, _pTimeoutDefault.default)(deferred.promise, {
                milliseconds: drainTimeout
            });
        }
    }).then(async ()=>{
        // only close if the channel is still open
        if (channel.readyState === "open") channel.close();
    }).catch((err)=>{
        options.log.error("error closing outbound stream", err);
    });
}

},{"detect-browser":"2pU52","p-defer":"cWx93","p-timeout":"2j2Zi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2pU52":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserInfo", ()=>BrowserInfo);
parcelHelpers.export(exports, "NodeInfo", ()=>NodeInfo);
parcelHelpers.export(exports, "SearchBotDeviceInfo", ()=>SearchBotDeviceInfo);
parcelHelpers.export(exports, "BotInfo", ()=>BotInfo);
parcelHelpers.export(exports, "ReactNativeInfo", ()=>ReactNativeInfo);
parcelHelpers.export(exports, "detect", ()=>detect);
parcelHelpers.export(exports, "browserName", ()=>browserName);
parcelHelpers.export(exports, "parseUserAgent", ()=>parseUserAgent);
parcelHelpers.export(exports, "detectOS", ()=>detectOS);
parcelHelpers.export(exports, "getNodeVersion", ()=>getNodeVersion);
var process = require("333d4e2381a056a9");
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = /** @class */ function() {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = "browser";
    }
    return BrowserInfo;
}();
var NodeInfo = /** @class */ function() {
    function NodeInfo(version) {
        this.version = version;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
    }
    return NodeInfo;
}();
var SearchBotDeviceInfo = /** @class */ function() {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
    }
    return SearchBotDeviceInfo;
}();
var BotInfo = /** @class */ function() {
    function BotInfo() {
        this.type = "bot";
        this.bot = true; // NOTE: deprecated test name instead
        this.name = "bot";
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}();
var ReactNativeInfo = /** @class */ function() {
    function ReactNativeInfo() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}();
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    [
        "aol",
        /AOLShield\/([0-9\._]+)/
    ],
    [
        "edge",
        /Edge\/([0-9\._]+)/
    ],
    [
        "edge-ios",
        /EdgiOS\/([0-9\._]+)/
    ],
    [
        "yandexbrowser",
        /YaBrowser\/([0-9\._]+)/
    ],
    [
        "kakaotalk",
        /KAKAOTALK\s([0-9\.]+)/
    ],
    [
        "samsung",
        /SamsungBrowser\/([0-9\.]+)/
    ],
    [
        "silk",
        /\bSilk\/([0-9._-]+)\b/
    ],
    [
        "miui",
        /MiuiBrowser\/([0-9\.]+)$/
    ],
    [
        "beaker",
        /BeakerBrowser\/([0-9\.]+)/
    ],
    [
        "edge-chromium",
        /EdgA?\/([0-9\.]+)/
    ],
    [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "chrome",
        /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "phantomjs",
        /PhantomJS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "crios",
        /CriOS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "firefox",
        /Firefox\/([0-9\.]+)(?:\s|$)/
    ],
    [
        "fxios",
        /FxiOS\/([0-9\.]+)/
    ],
    [
        "opera-mini",
        /Opera Mini.*Version\/([0-9\.]+)/
    ],
    [
        "opera",
        /Opera\/([0-9\.]+)(?:\s|$)/
    ],
    [
        "opera",
        /OPR\/([0-9\.]+)(:?\s|$)/
    ],
    [
        "pie",
        /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/
    ],
    [
        "pie",
        /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
    ],
    [
        "netfront",
        /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/
    ],
    [
        "ie",
        /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/
    ],
    [
        "ie",
        /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/
    ],
    [
        "ie",
        /MSIE\s(7\.0)/
    ],
    [
        "bb10",
        /BB10;\sTouch.*Version\/([0-9\.]+)/
    ],
    [
        "android",
        /Android\s([0-9\.]+)/
    ],
    [
        "ios",
        /Version\/([0-9\._]+).*Mobile.*Safari.*/
    ],
    [
        "safari",
        /Version\/([0-9\._]+).*Safari/
    ],
    [
        "facebook",
        /FB[AS]V\/([0-9\.]+)/
    ],
    [
        "instagram",
        /Instagram\s([0-9\.]+)/
    ],
    [
        "ios-webview",
        /AppleWebKit\/([0-9\.]+).*Mobile/
    ],
    [
        "ios-webview",
        /AppleWebKit\/([0-9\.]+).*Gecko\)$/
    ],
    [
        "curl",
        /^curl\/([0-9\.]+)$/
    ],
    [
        "searchbot",
        SEARCHBOX_UA_REGEX
    ]
];
var operatingSystemRules = [
    [
        "iOS",
        /iP(hone|od|ad)/
    ],
    [
        "Android OS",
        /Android/
    ],
    [
        "BlackBerry OS",
        /BlackBerry|BB10/
    ],
    [
        "Windows Mobile",
        /IEMobile/
    ],
    [
        "Amazon OS",
        /Kindle/
    ],
    [
        "Windows 3.11",
        /Win16/
    ],
    [
        "Windows 95",
        /(Windows 95)|(Win95)|(Windows_95)/
    ],
    [
        "Windows 98",
        /(Windows 98)|(Win98)/
    ],
    [
        "Windows 2000",
        /(Windows NT 5.0)|(Windows 2000)/
    ],
    [
        "Windows XP",
        /(Windows NT 5.1)|(Windows XP)/
    ],
    [
        "Windows Server 2003",
        /(Windows NT 5.2)/
    ],
    [
        "Windows Vista",
        /(Windows NT 6.0)/
    ],
    [
        "Windows 7",
        /(Windows NT 6.1)/
    ],
    [
        "Windows 8",
        /(Windows NT 6.2)/
    ],
    [
        "Windows 8.1",
        /(Windows NT 6.3)/
    ],
    [
        "Windows 10",
        /(Windows NT 10.0)/
    ],
    [
        "Windows ME",
        /Windows ME/
    ],
    [
        "Windows CE",
        /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
    ],
    [
        "Open BSD",
        /OpenBSD/
    ],
    [
        "Sun OS",
        /SunOS/
    ],
    [
        "Chrome OS",
        /CrOS/
    ],
    [
        "Linux",
        /(Linux)|(X11)/
    ],
    [
        "Mac OS",
        /(Mac_PowerPC)|(Macintosh)/
    ],
    [
        "QNX",
        /QNX/
    ],
    [
        "BeOS",
        /BeOS/
    ],
    [
        "OS/2",
        /OS\/2/
    ]
];
function detect(userAgent) {
    if (!!userAgent) return parseUserAgent(userAgent);
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") return new ReactNativeInfo();
    if (typeof navigator !== "undefined") return parseUserAgent(navigator.userAgent);
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return ua !== "" && userAgentRules.reduce(function(matched, _a) {
        var browser = _a[0], regex = _a[1];
        if (matched) return matched;
        var uaMatch = regex.exec(ua);
        return !!uaMatch && [
            browser,
            uaMatch
        ];
    }, false);
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) return null;
    var name = matchedRule[0], match = matchedRule[1];
    if (name === "searchbot") return new BotInfo();
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    } else versionParts = [];
    var version = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for(var ii = 0, count = operatingSystemRules.length; ii < count; ii++){
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) return os;
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== "undefined" && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for(var ii = 0; ii < count; ii++)output.push("0");
    return output;
}

},{"333d4e2381a056a9":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1Rc8I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DataChannelMuxerFactory", ()=>DataChannelMuxerFactory);
/**
 * A libp2p data channel stream muxer
 */ parcelHelpers.export(exports, "DataChannelMuxer", ()=>DataChannelMuxer);
var _streamJs = require("./stream.js");
var _utilJs = require("./util.js");
const PROTOCOL = "/webrtc";
class DataChannelMuxerFactory {
    protocol;
    /**
     * WebRTC Peer Connection
     */ peerConnection;
    bufferedStreams = [];
    metrics;
    dataChannelOptions;
    components;
    log;
    constructor(components, init){
        this.components = components;
        this.peerConnection = init.peerConnection;
        this.metrics = init.metrics;
        this.protocol = init.protocol ?? PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        this.log = components.logger.forComponent("libp2p:webrtc:datachannelmuxerfactory");
        // store any datachannels opened before upgrade has been completed
        this.peerConnection.ondatachannel = ({ channel })=>{
            this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
            // 'init' channel is only used during connection establishment
            if (channel.label === "init") {
                this.log.trace("closing early init channel");
                channel.close();
                return;
            }
            // @ts-expect-error fields are set below
            const bufferedStream = {};
            const stream = (0, _streamJs.createStream)({
                channel,
                direction: "inbound",
                onEnd: (err)=>{
                    bufferedStream.onEnd(err);
                },
                logger: components.logger,
                ...this.dataChannelOptions
            });
            bufferedStream.stream = stream;
            bufferedStream.channel = channel;
            bufferedStream.onEnd = ()=>{
                this.bufferedStreams = this.bufferedStreams.filter((s)=>s.stream.id !== stream.id);
            };
            this.bufferedStreams.push(bufferedStream);
        };
    }
    createStreamMuxer(init) {
        return new DataChannelMuxer(this.components, {
            ...init,
            peerConnection: this.peerConnection,
            dataChannelOptions: this.dataChannelOptions,
            metrics: this.metrics,
            streams: this.bufferedStreams,
            protocol: this.protocol
        });
    }
}
class DataChannelMuxer {
    init;
    /**
     * Array of streams in the data channel
     */ streams;
    protocol;
    log;
    peerConnection;
    dataChannelOptions;
    metrics;
    logger;
    constructor(components, init){
        this.init = init;
        this.log = components.logger.forComponent("libp2p:webrtc:muxer");
        this.logger = components.logger;
        this.streams = init.streams.map((s)=>s.stream);
        this.peerConnection = init.peerConnection;
        this.protocol = init.protocol ?? PROTOCOL;
        this.metrics = init.metrics;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        /**
         * Fired when a data channel has been added to the connection has been
         * added by the remote peer.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}
         */ this.peerConnection.ondatachannel = ({ channel })=>{
            this.log.trace("incoming datachannel with channel id %d", channel.id);
            // 'init' channel is only used during connection establishment
            if (channel.label === "init") {
                this.log.trace("closing init channel");
                channel.close();
                return;
            }
            const stream = (0, _streamJs.createStream)({
                channel,
                direction: "inbound",
                onEnd: ()=>{
                    this.log("incoming channel %s ended with state %s", channel.id, channel.readyState);
                    this.#onStreamEnd(stream, channel);
                },
                logger: this.logger,
                ...this.dataChannelOptions
            });
            this.streams.push(stream);
            this.metrics?.increment({
                incoming_stream: true
            });
            init?.onIncomingStream?.(stream);
        };
        // the DataChannelMuxer constructor is called during set up of the
        // connection by the upgrader.
        //
        // If we invoke `init.onIncomingStream` immediately, the connection object
        // will not be set up yet so add a tiny delay before letting the
        // connection know about early streams
        if (this.init.streams.length > 0) queueMicrotask(()=>{
            this.init.streams.forEach((bufferedStream)=>{
                bufferedStream.onEnd = ()=>{
                    this.log("incoming early channel %s ended with state %s", bufferedStream.channel.id, bufferedStream.channel.readyState);
                    this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel);
                };
                this.metrics?.increment({
                    incoming_stream: true
                });
                this.init?.onIncomingStream?.(bufferedStream.stream);
            });
        });
    }
    #onStreamEnd(stream, channel) {
        this.log.trace("stream %s %s %s onEnd", stream.direction, stream.id, stream.protocol);
        (0, _utilJs.drainAndClose)(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
            log: this.log
        });
        this.streams = this.streams.filter((s)=>s.id !== stream.id);
        this.metrics?.increment({
            stream_end: true
        });
        this.init?.onStreamEnd?.(stream);
    }
    /**
     * Gracefully close all tracked streams and stop the muxer
     */ async close(options) {
        try {
            await Promise.all(this.streams.map(async (stream)=>stream.close(options)));
        } catch (err) {
            this.abort(err);
        }
    }
    /**
     * Abort all tracked streams and stop the muxer
     */ abort(err) {
        for (const stream of this.streams)stream.abort(err);
    }
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */ source = (0, _utilJs.nopSource)();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */ sink = (0, _utilJs.nopSink);
    newStream() {
        // The spec says the label SHOULD be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label
        const channel = this.peerConnection.createDataChannel("");
        this.log.trace("opened outgoing datachannel with channel id %s", channel.id);
        const stream = (0, _streamJs.createStream)({
            channel,
            direction: "outbound",
            onEnd: ()=>{
                this.log("outgoing channel %s ended with state %s", channel.id, channel.readyState);
                this.#onStreamEnd(stream, channel);
            },
            logger: this.logger,
            ...this.dataChannelOptions
        });
        this.streams.push(stream);
        this.metrics?.increment({
            outgoing_stream: true
        });
        return stream;
    }
}

},{"./stream.js":"cS6cO","./util.js":"azhmH","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cS6cO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_BUFFERED_AMOUNT", ()=>MAX_BUFFERED_AMOUNT);
parcelHelpers.export(exports, "BUFFERED_AMOUNT_LOW_TIMEOUT", ()=>BUFFERED_AMOUNT_LOW_TIMEOUT);
parcelHelpers.export(exports, "PROTOBUF_OVERHEAD", ()=>PROTOBUF_OVERHEAD);
parcelHelpers.export(exports, "VARINT_LENGTH", ()=>VARINT_LENGTH);
parcelHelpers.export(exports, "MAX_MESSAGE_SIZE", ()=>MAX_MESSAGE_SIZE);
parcelHelpers.export(exports, "FIN_ACK_TIMEOUT", ()=>FIN_ACK_TIMEOUT);
parcelHelpers.export(exports, "OPEN_TIMEOUT", ()=>OPEN_TIMEOUT);
parcelHelpers.export(exports, "WebRTCStream", ()=>WebRTCStream);
parcelHelpers.export(exports, "createStream", ()=>createStream);
var _interface = require("@libp2p/interface");
var _abstractStream = require("@libp2p/utils/abstract-stream");
var _itLengthPrefixed = require("it-length-prefixed");
var _itPushable = require("it-pushable");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _pEvent = require("p-event");
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
var _raceSignal = require("race-signal");
var _uint8Arraylist = require("uint8arraylist");
var _messageJs = require("./pb/message.js");
const MAX_BUFFERED_AMOUNT = 16777216;
const BUFFERED_AMOUNT_LOW_TIMEOUT = 30000;
const PROTOBUF_OVERHEAD = 5;
const VARINT_LENGTH = 2;
const MAX_MESSAGE_SIZE = 16384;
const FIN_ACK_TIMEOUT = 5000;
const OPEN_TIMEOUT = 5000;
class WebRTCStream extends (0, _abstractStream.AbstractStream) {
    /**
     * The data channel used to send and receive data
     */ channel;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */ incomingData;
    maxBufferedAmount;
    bufferedAmountLowEventTimeout;
    /**
     * The maximum size of a message in bytes
     */ maxMessageSize;
    /**
     * When this promise is resolved, the remote has sent us a FIN flag
     */ receiveFinAck;
    finAckTimeout;
    openTimeout;
    constructor(init){
        // override onEnd to send/receive FIN_ACK before closing the stream
        const originalOnEnd = init.onEnd;
        init.onEnd = (err)=>{
            this.log.trace("readable and writeable ends closed", this.status);
            Promise.resolve(async ()=>{
                if (this.timeline.abort != null || this.timeline.reset !== null) return;
                // wait for FIN_ACK if we haven't received it already
                try {
                    await (0, _pTimeoutDefault.default)(this.receiveFinAck.promise, {
                        milliseconds: this.finAckTimeout
                    });
                } catch (err) {
                    this.log.error("error receiving FIN_ACK", err);
                }
            }).then(()=>{
                // stop processing incoming messages
                this.incomingData.end();
                // final cleanup
                originalOnEnd?.(err);
            }).catch((err)=>{
                this.log.error("error ending stream", err);
            });
        };
        super(init);
        this.channel = init.channel;
        this.channel.binaryType = "arraybuffer";
        this.incomingData = (0, _itPushable.pushable)();
        this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
        this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
        this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD - VARINT_LENGTH;
        this.receiveFinAck = (0, _pDeferDefault.default)();
        this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
        this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT;
        // set up initial state
        switch(this.channel.readyState){
            case "open":
                this.timeline.open = new Date().getTime();
                break;
            case "closed":
            case "closing":
                if (this.timeline.close === undefined || this.timeline.close === 0) this.timeline.close = Date.now();
                break;
            case "connecting":
                break;
            default:
                this.log.error("unknown datachannel state %s", this.channel.readyState);
                throw new (0, _interface.CodeError)("Unknown datachannel state", "ERR_INVALID_STATE");
        }
        // handle RTCDataChannel events
        this.channel.onopen = (_evt)=>{
            this.timeline.open = new Date().getTime();
        };
        this.channel.onclose = (_evt)=>{
            // if the channel has closed we'll never receive a FIN_ACK so resolve the
            // promise so we don't try to wait later
            this.receiveFinAck.resolve();
            this.close().catch((err)=>{
                this.log.error("error closing stream after channel closed", err);
            });
        };
        this.channel.onerror = (evt)=>{
            const err = evt.error;
            this.abort(err);
        };
        this.channel.onmessage = async (event)=>{
            const { data } = event;
            if (data === null || data.byteLength === 0) return;
            this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
        };
        const self = this;
        // pipe framed protobuf messages through a length prefixed decoder, and
        // surface data from the `Message.message` field through a source.
        Promise.resolve().then(async ()=>{
            for await (const buf of _itLengthPrefixed.decode(this.incomingData)){
                const message = self.processIncomingProtobuf(buf);
                if (message != null) self.sourcePush(new (0, _uint8Arraylist.Uint8ArrayList)(message));
            }
        }).catch((err)=>{
            this.log.error("error processing incoming data channel messages", err);
        });
    }
    sendNewStream() {
    // opening new streams is handled by WebRTC so this is a noop
    }
    async _sendMessage(data, checkBuffer = true) {
        if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) try {
            this.log('channel buffer is %d, wait for "bufferedamountlow" event', this.channel.bufferedAmount);
            await (0, _pEvent.pEvent)(this.channel, "bufferedamountlow", {
                timeout: this.bufferedAmountLowEventTimeout
            });
        } catch (err) {
            if (err instanceof (0, _pEvent.TimeoutError)) throw new (0, _interface.CodeError)(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`, "ERR_BUFFER_CLEAR_TIMEOUT");
            throw err;
        }
        if (this.channel.readyState === "closed" || this.channel.readyState === "closing") throw new (0, _interface.CodeError)(`Invalid datachannel state - ${this.channel.readyState}`, "ERR_INVALID_STATE");
        if (this.channel.readyState !== "open") {
            this.log('channel state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
            await (0, _pEvent.pEvent)(this.channel, "open", {
                timeout: this.openTimeout
            });
            this.log('channel state is now "%s", sending data', this.channel.readyState);
        }
        // send message without copying data
        this.channel.send(data.subarray());
    }
    async sendData(data) {
        // sending messages is an async operation so use a copy of the list as it
        // may be changed beneath us
        data = data.sublist();
        while(data.byteLength > 0){
            const toSend = Math.min(data.byteLength, this.maxMessageSize);
            const buf = data.subarray(0, toSend);
            const msgbuf = (0, _messageJs.Message).encode({
                message: buf
            });
            const sendbuf = _itLengthPrefixed.encode.single(msgbuf);
            await this._sendMessage(sendbuf);
            data.consume(toSend);
        }
    }
    async sendReset() {
        await this._sendFlag((0, _messageJs.Message).Flag.RESET);
    }
    async sendCloseWrite(options) {
        const sent = await this._sendFlag((0, _messageJs.Message).Flag.FIN);
        if (sent) {
            this.log.trace("awaiting FIN_ACK");
            try {
                await (0, _raceSignal.raceSignal)(this.receiveFinAck.promise, options?.signal, {
                    errorMessage: "sending close-write was aborted before FIN_ACK was received",
                    errorCode: "ERR_FIN_ACK_NOT_RECEIVED"
                });
            } catch (err) {
                this.log.error("failed to await FIN_ACK", err);
            }
        } else this.log.trace("sending FIN failed, not awaiting FIN_ACK");
        // if we've attempted to receive a FIN_ACK, do not try again
        this.receiveFinAck.resolve();
    }
    async sendCloseRead() {
        await this._sendFlag((0, _messageJs.Message).Flag.STOP_SENDING);
    }
    /**
     * Handle incoming
     */ processIncomingProtobuf(buffer) {
        const message = (0, _messageJs.Message).decode(buffer);
        if (message.flag !== undefined) {
            this.log.trace('incoming flag %s, write status "%s", read status "%s"', message.flag, this.writeStatus, this.readStatus);
            if (message.flag === (0, _messageJs.Message).Flag.FIN) {
                // We should expect no more data from the remote, stop reading
                this.remoteCloseWrite();
                this.log.trace("sending FIN_ACK");
                this._sendFlag((0, _messageJs.Message).Flag.FIN_ACK).catch((err)=>{
                    this.log.error("error sending FIN_ACK immediately", err);
                });
            }
            if (message.flag === (0, _messageJs.Message).Flag.RESET) // Stop reading and writing to the stream immediately
            this.reset();
            if (message.flag === (0, _messageJs.Message).Flag.STOP_SENDING) // The remote has stopped reading
            this.remoteCloseRead();
            if (message.flag === (0, _messageJs.Message).Flag.FIN_ACK) {
                this.log.trace("received FIN_ACK");
                this.receiveFinAck.resolve();
            }
        }
        // ignore data messages if we've closed the readable end already
        if (this.readStatus === "ready") return message.message;
    }
    async _sendFlag(flag) {
        if (this.channel.readyState !== "open") {
            // flags can be sent while we or the remote are closing the datachannel so
            // if the channel isn't open, don't try to send it but return false to let
            // the caller know and act if they need to
            this.log.trace('not sending flag %s because channel is "%s" and not "open"', this.channel.readyState, flag.toString());
            return false;
        }
        this.log.trace("sending flag %s", flag.toString());
        const msgbuf = (0, _messageJs.Message).encode({
            flag
        });
        const prefixedBuf = _itLengthPrefixed.encode.single(msgbuf);
        try {
            await this._sendMessage(prefixedBuf, false);
            return true;
        } catch (err) {
            this.log.error("could not send flag %s", flag.toString(), err);
        }
        return false;
    }
}
function createStream(options) {
    const { channel, direction } = options;
    return new WebRTCStream({
        id: direction === "inbound" ? `i${channel.id}` : `r${channel.id}`,
        log: options.logger.forComponent(`libp2p:webrtc:stream:${direction}:${channel.id}`),
        ...options
    });
}

},{"@libp2p/interface":"b14bx","@libp2p/utils/abstract-stream":"haPwJ","it-length-prefixed":"lzCYq","it-pushable":"hxxEW","p-defer":"cWx93","p-event":"8j1zV","p-timeout":"2j2Zi","race-signal":"dHlMT","uint8arraylist":"1W1Ks","./pb/message.js":"81btC","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8j1zV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _pTimeout.TimeoutError));
parcelHelpers.export(exports, "pEventMultiple", ()=>pEventMultiple);
parcelHelpers.export(exports, "pEvent", ()=>pEvent);
parcelHelpers.export(exports, "pEventIterator", ()=>pEventIterator);
var _pTimeout = require("p-timeout");
var _pTimeoutDefault = parcelHelpers.interopDefault(_pTimeout);
const normalizeEmitter = (emitter)=>{
    const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
    if (!addListener || !removeListener) throw new TypeError("Emitter is not compatible");
    return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
    };
};
function pEventMultiple(emitter, event, options) {
    let cancel;
    const returnValue = new Promise((resolve, reject)=>{
        options = {
            rejectionEvents: [
                "error"
            ],
            multiArgs: false,
            resolveImmediately: false,
            ...options
        };
        if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) throw new TypeError("The `count` option should be at least 0 or more");
        options.signal?.throwIfAborted();
        // Allow multiple events
        const events = [
            event
        ].flat();
        const items = [];
        const { addListener, removeListener } = normalizeEmitter(emitter);
        const onItem = (...arguments_)=>{
            const value = options.multiArgs ? arguments_ : arguments_[0];
            // eslint-disable-next-line unicorn/no-array-callback-reference
            if (options.filter && !options.filter(value)) return;
            items.push(value);
            if (options.count === items.length) {
                cancel();
                resolve(items);
            }
        };
        const rejectHandler = (error)=>{
            cancel();
            reject(error);
        };
        cancel = ()=>{
            for (const event of events)removeListener(event, onItem);
            for (const rejectionEvent of options.rejectionEvents)removeListener(rejectionEvent, rejectHandler);
        };
        for (const event of events)addListener(event, onItem);
        for (const rejectionEvent of options.rejectionEvents)addListener(rejectionEvent, rejectHandler);
        if (options.signal) options.signal.addEventListener("abort", ()=>{
            rejectHandler(options.signal.reason);
        }, {
            once: true
        });
        if (options.resolveImmediately) resolve(items);
    });
    returnValue.cancel = cancel;
    if (typeof options.timeout === "number") {
        const timeout = (0, _pTimeoutDefault.default)(returnValue, {
            milliseconds: options.timeout
        });
        timeout.cancel = cancel;
        return timeout;
    }
    return returnValue;
}
function pEvent(emitter, event, options) {
    if (typeof options === "function") options = {
        filter: options
    };
    options = {
        ...options,
        count: 1,
        resolveImmediately: false
    };
    const arrayPromise = pEventMultiple(emitter, event, options);
    const promise = arrayPromise.then((array)=>array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
}
function pEventIterator(emitter, event, options) {
    if (typeof options === "function") options = {
        filter: options
    };
    // Allow multiple events
    const events = [
        event
    ].flat();
    options = {
        rejectionEvents: [
            "error"
        ],
        resolutionEvents: [],
        limit: Number.POSITIVE_INFINITY,
        multiArgs: false,
        ...options
    };
    const { limit } = options;
    const isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));
    if (!isValidLimit) throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
    options.signal?.throwIfAborted();
    if (limit === 0) // Return an empty async iterator to avoid any further cost
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        async next () {
            return {
                done: true,
                value: undefined
            };
        }
    };
    const { addListener, removeListener } = normalizeEmitter(emitter);
    let isDone = false;
    let error;
    let hasPendingError = false;
    const nextQueue = [];
    const valueQueue = [];
    let eventCount = 0;
    let isLimitReached = false;
    const valueHandler = (...arguments_)=>{
        eventCount++;
        isLimitReached = eventCount === limit;
        const value = options.multiArgs ? arguments_ : arguments_[0];
        if (nextQueue.length > 0) {
            const { resolve } = nextQueue.shift();
            resolve({
                done: false,
                value
            });
            if (isLimitReached) cancel();
            return;
        }
        valueQueue.push(value);
        if (isLimitReached) cancel();
    };
    const cancel = ()=>{
        isDone = true;
        for (const event of events)removeListener(event, valueHandler);
        for (const rejectionEvent of options.rejectionEvents)removeListener(rejectionEvent, rejectHandler);
        for (const resolutionEvent of options.resolutionEvents)removeListener(resolutionEvent, resolveHandler);
        while(nextQueue.length > 0){
            const { resolve } = nextQueue.shift();
            resolve({
                done: true,
                value: undefined
            });
        }
    };
    const rejectHandler = (...arguments_)=>{
        error = options.multiArgs ? arguments_ : arguments_[0];
        if (nextQueue.length > 0) {
            const { reject } = nextQueue.shift();
            reject(error);
        } else hasPendingError = true;
        cancel();
    };
    const resolveHandler = (...arguments_)=>{
        const value = options.multiArgs ? arguments_ : arguments_[0];
        // eslint-disable-next-line unicorn/no-array-callback-reference
        if (options.filter && !options.filter(value)) {
            cancel();
            return;
        }
        if (nextQueue.length > 0) {
            const { resolve } = nextQueue.shift();
            resolve({
                done: true,
                value
            });
        } else valueQueue.push(value);
        cancel();
    };
    for (const event of events)addListener(event, valueHandler);
    for (const rejectionEvent of options.rejectionEvents)addListener(rejectionEvent, rejectHandler);
    for (const resolutionEvent of options.resolutionEvents)addListener(resolutionEvent, resolveHandler);
    if (options.signal) options.signal.addEventListener("abort", ()=>{
        rejectHandler(options.signal.reason);
    }, {
        once: true
    });
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        async next () {
            if (valueQueue.length > 0) {
                const value = valueQueue.shift();
                return {
                    done: isDone && valueQueue.length === 0 && !isLimitReached,
                    value
                };
            }
            if (hasPendingError) {
                hasPendingError = false;
                throw error;
            }
            if (isDone) return {
                done: true,
                value: undefined
            };
            return new Promise((resolve, reject)=>{
                nextQueue.push({
                    resolve,
                    reject
                });
            });
        },
        async return (value) {
            cancel();
            return {
                done: isDone,
                value
            };
        }
    };
}

},{"p-timeout":"2j2Zi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"81btC":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Message", ()=>Message);
var _protonsRuntime = require("protons-runtime");
var Message;
(function(Message) {
    let Flag;
    (function(Flag) {
        Flag["FIN"] = "FIN";
        Flag["STOP_SENDING"] = "STOP_SENDING";
        Flag["RESET"] = "RESET";
        Flag["FIN_ACK"] = "FIN_ACK";
    })(Flag = Message.Flag || (Message.Flag = {}));
    let __FlagValues;
    (function(__FlagValues) {
        __FlagValues[__FlagValues["FIN"] = 0] = "FIN";
        __FlagValues[__FlagValues["STOP_SENDING"] = 1] = "STOP_SENDING";
        __FlagValues[__FlagValues["RESET"] = 2] = "RESET";
        __FlagValues[__FlagValues["FIN_ACK"] = 3] = "FIN_ACK";
    })(__FlagValues || (__FlagValues = {}));
    (function(Flag) {
        Flag.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__FlagValues);
        };
    })(Flag = Message.Flag || (Message.Flag = {}));
    let _codec;
    Message.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.flag != null) {
                w.uint32(8);
                Message.Flag.codec().encode(obj.flag, w);
            }
            if (obj.message != null) {
                w.uint32(18);
                w.bytes(obj.message);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.flag = Message.Flag.codec().decode(reader);
                        break;
                    case 2:
                        obj.message = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Message.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Message.codec());
    };
    Message.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Message.codec());
    };
})(Message || (Message = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6CTn2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RTCPeerConnection", ()=>RTCPeerConnection);
parcelHelpers.export(exports, "RTCSessionDescription", ()=>RTCSessionDescription);
parcelHelpers.export(exports, "RTCIceCandidate", ()=>RTCIceCandidate);
parcelHelpers.export(exports, "cleanup", ()=>cleanup);
const RTCPeerConnection = globalThis.RTCPeerConnection;
const RTCSessionDescription = globalThis.RTCSessionDescription;
const RTCIceCandidate = globalThis.RTCIceCandidate;
function cleanup() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"20EwX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initiateConnection", ()=>initiateConnection);
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _itProtobufStream = require("it-protobuf-stream");
var _indexJs = require("../webrtc/index.js");
var _messageJs = require("./pb/message.js");
var _transportJs = require("./transport.js");
var _utilJs = require("./util.js");
async function initiateConnection({ peerConnection, signal, metrics, multiaddr: ma, connectionManager, transportManager, log }) {
    const { baseAddr } = (0, _transportJs.splitAddr)(ma);
    metrics?.dialerEvents.increment({
        open: true
    });
    log.trace("dialing base address: %a", baseAddr);
    const relayPeer = baseAddr.getPeerId();
    if (relayPeer == null) throw new (0, _interface.CodeError)("Relay peer was missing", "ERR_INVALID_ADDRESS");
    const connections = connectionManager.getConnections((0, _peerId.peerIdFromString)(relayPeer));
    let connection;
    let shouldCloseConnection = false;
    if (connections.length === 0) {
        // use the transport manager to open a connection. Initiating a WebRTC
        // connection takes place in the context of a dial - if we use the
        // connection manager instead we can end up joining our own dial context
        connection = await transportManager.dial(baseAddr, {
            signal
        });
        // this connection is unmanaged by the connection manager so we should
        // close it when we are done
        shouldCloseConnection = true;
    } else connection = connections[0];
    try {
        const stream = await connection.newStream((0, _transportJs.SIGNALING_PROTO_ID), {
            signal,
            runOnTransientConnection: true
        });
        const messageStream = (0, _itProtobufStream.pbStream)(stream).pb((0, _messageJs.Message));
        try {
            // we create the channel so that the RTCPeerConnection has a component for
            // which to collect candidates. The label is not relevant to connection
            // initiation but can be useful for debugging
            const channel = peerConnection.createDataChannel("init");
            // setup callback to write ICE candidates to the remote peer
            peerConnection.onicecandidate = ({ candidate })=>{
                // a null candidate means end-of-candidates, an empty string candidate
                // means end-of-candidates for this generation, otherwise this should
                // be a valid candidate object
                // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent
                const data = JSON.stringify(candidate?.toJSON() ?? null);
                log.trace("initiator sending ICE candidate %s", data);
                messageStream.write({
                    type: (0, _messageJs.Message).Type.ICE_CANDIDATE,
                    data
                }, {
                    signal
                }).catch((err)=>{
                    log.error("error sending ICE candidate", err);
                });
            };
            peerConnection.onicecandidateerror = (event)=>{
                log.error("initiator ICE candidate error", event);
            };
            // create an offer
            const offerSdp = await peerConnection.createOffer().catch((err)=>{
                log.error("could not execute createOffer", err);
                throw new (0, _interface.CodeError)("Failed to set createOffer", "ERR_SDP_HANDSHAKE_FAILED");
            });
            log.trace("initiator send SDP offer %s", offerSdp.sdp);
            // write the offer to the stream
            await messageStream.write({
                type: (0, _messageJs.Message).Type.SDP_OFFER,
                data: offerSdp.sdp
            }, {
                signal
            });
            // set offer as local description
            await peerConnection.setLocalDescription(offerSdp).catch((err)=>{
                log.error("could not execute setLocalDescription", err);
                throw new (0, _interface.CodeError)("Failed to set localDescription", "ERR_SDP_HANDSHAKE_FAILED");
            });
            // read answer
            const answerMessage = await messageStream.read({
                signal
            });
            if (answerMessage.type !== (0, _messageJs.Message).Type.SDP_ANSWER) throw new (0, _interface.CodeError)("Remote should send an SDP answer", "ERR_SDP_HANDSHAKE_FAILED");
            log.trace("initiator receive SDP answer %s", answerMessage.data);
            const answerSdp = new (0, _indexJs.RTCSessionDescription)({
                type: "answer",
                sdp: answerMessage.data
            });
            await peerConnection.setRemoteDescription(answerSdp).catch((err)=>{
                log.error("could not execute setRemoteDescription", err);
                throw new (0, _interface.CodeError)("Failed to set remoteDescription", "ERR_SDP_HANDSHAKE_FAILED");
            });
            log.trace("initiator read candidates until connected");
            await (0, _utilJs.readCandidatesUntilConnected)(peerConnection, messageStream, {
                direction: "initiator",
                signal,
                log
            });
            log.trace("initiator connected, closing init channel");
            channel.close();
            log.trace("initiator closing signalling stream");
            await messageStream.unwrap().unwrap().close({
                signal
            });
            log.trace("initiator connected to remote address %s", ma);
            return {
                remoteAddress: ma
            };
        } catch (err) {
            peerConnection.close();
            stream.abort(err);
            throw err;
        } finally{
            peerConnection.onicecandidate = null;
            peerConnection.onicecandidateerror = null;
        }
    } finally{
        // if we had to open a connection to perform the SDP handshake
        // close it because it's not tracked by the connection manager
        if (shouldCloseConnection) try {
            await connection.close({
                signal
            });
        } catch (err) {
            connection.abort(err);
        }
    }
}

},{"@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","it-protobuf-stream":"gV3cl","../webrtc/index.js":"6CTn2","./pb/message.js":"4QHSO","./transport.js":"iEUyo","./util.js":"gCU17","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4QHSO":[function(require,module,exports) {
/* eslint-disable import/export */ /* eslint-disable complexity */ /* eslint-disable @typescript-eslint/no-namespace */ /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */ /* eslint-disable @typescript-eslint/no-empty-interface */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Message", ()=>Message);
var _protonsRuntime = require("protons-runtime");
var Message;
(function(Message) {
    let Type;
    (function(Type) {
        Type["SDP_OFFER"] = "SDP_OFFER";
        Type["SDP_ANSWER"] = "SDP_ANSWER";
        Type["ICE_CANDIDATE"] = "ICE_CANDIDATE";
    })(Type = Message.Type || (Message.Type = {}));
    let __TypeValues;
    (function(__TypeValues) {
        __TypeValues[__TypeValues["SDP_OFFER"] = 0] = "SDP_OFFER";
        __TypeValues[__TypeValues["SDP_ANSWER"] = 1] = "SDP_ANSWER";
        __TypeValues[__TypeValues["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type) {
        Type.codec = ()=>{
            return (0, _protonsRuntime.enumeration)(__TypeValues);
        };
    })(Type = Message.Type || (Message.Type = {}));
    let _codec;
    Message.codec = ()=>{
        if (_codec == null) _codec = (0, _protonsRuntime.message)((obj, w, opts = {})=>{
            if (opts.lengthDelimited !== false) w.fork();
            if (obj.type != null) {
                w.uint32(8);
                Message.Type.codec().encode(obj.type, w);
            }
            if (obj.data != null) {
                w.uint32(18);
                w.string(obj.data);
            }
            if (opts.lengthDelimited !== false) w.ldelim();
        }, (reader, length)=>{
            const obj = {};
            const end = length == null ? reader.len : reader.pos + length;
            while(reader.pos < end){
                const tag = reader.uint32();
                switch(tag >>> 3){
                    case 1:
                        obj.type = Message.Type.codec().decode(reader);
                        break;
                    case 2:
                        obj.data = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return obj;
        });
        return _codec;
    };
    Message.encode = (obj)=>{
        return (0, _protonsRuntime.encodeMessage)(obj, Message.codec());
    };
    Message.decode = (buf)=>{
        return (0, _protonsRuntime.decodeMessage)(buf, Message.codec());
    };
})(Message || (Message = {}));

},{"protons-runtime":"iJEgs","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gCU17":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "readCandidatesUntilConnected", ()=>readCandidatesUntilConnected);
var _interface = require("@libp2p/interface");
var _pDefer = require("p-defer");
var _pDeferDefault = parcelHelpers.interopDefault(_pDefer);
var _utilJs = require("../util.js");
var _indexJs = require("../webrtc/index.js");
var _messageJs = require("./pb/message.js");
const readCandidatesUntilConnected = async (pc, stream, options)=>{
    try {
        const connectedPromise = (0, _pDeferDefault.default)();
        resolveOnConnected(pc, connectedPromise);
        // read candidates until we are connected or we reach the end of the stream
        while(true){
            // if we connect, stop trying to read from the stream
            const message = await Promise.race([
                connectedPromise.promise,
                stream.read({
                    signal: options.signal
                })
            ]);
            // stream ended or we became connected
            if (message == null) break;
            if (message.type !== (0, _messageJs.Message).Type.ICE_CANDIDATE) throw new (0, _interface.CodeError)("ICE candidate message expected", "ERR_NOT_ICE_CANDIDATE");
            const candidateInit = JSON.parse(message.data ?? "null");
            // an empty string means this generation of candidates is complete, a null
            // candidate means candidate gathering has finished
            // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent
            if (candidateInit === "" || candidateInit === null) {
                options.log.trace("end-of-candidates received");
                continue;
            }
            const candidate = new (0, _indexJs.RTCIceCandidate)(candidateInit);
            options.log.trace("%s received new ICE candidate", options.direction, candidate);
            try {
                await pc.addIceCandidate(candidate);
            } catch (err) {
                options.log.error("%s bad candidate received", options.direction, candidateInit, err);
            }
        }
    } catch (err) {
        options.log.error("%s error parsing ICE candidate", options.direction, err);
        if (options.signal?.aborted === true) throw err;
    }
};
function getConnectionState(pc) {
    return (0, _utilJs.isFirefox) ? pc.iceConnectionState : pc.connectionState;
}
function resolveOnConnected(pc, promise) {
    pc[(0, _utilJs.isFirefox) ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_)=>{
        switch(getConnectionState(pc)){
            case "connected":
                promise.resolve();
                break;
            case "failed":
            case "disconnected":
            case "closed":
                promise.reject(new (0, _interface.CodeError)("RTCPeerConnection was closed", "ERR_CONNECTION_CLOSED_BEFORE_CONNECTED"));
                break;
            default:
                break;
        }
    };
}

},{"@libp2p/interface":"b14bx","p-defer":"cWx93","../util.js":"azhmH","../webrtc/index.js":"6CTn2","./pb/message.js":"4QHSO","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"f4cfy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebRTCPeerListener", ()=>WebRTCPeerListener);
var _interface = require("@libp2p/interface");
var _mafmt = require("@multiformats/mafmt");
class WebRTCPeerListener extends (0, _interface.TypedEventEmitter) {
    peerId;
    transportManager;
    shutdownController;
    constructor(components, init){
        super();
        this.peerId = components.peerId;
        this.transportManager = components.transportManager;
        this.shutdownController = init.shutdownController;
    }
    async listen() {
        this.safeDispatchEvent("listening", {});
    }
    getAddrs() {
        return this.transportManager.getListeners().filter((l)=>l !== this).map((l)=>l.getAddrs().filter((ma)=>(0, _mafmt.Circuit).matches(ma)).map((ma)=>{
                return ma.encapsulate(`/webrtc/p2p/${this.peerId}`);
            })).flat();
    }
    async close() {
        this.shutdownController.abort();
        this.safeDispatchEvent("close", {});
    }
}

},{"@libp2p/interface":"b14bx","@multiformats/mafmt":"djvEe","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"AnAO7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "handleIncomingStream", ()=>handleIncomingStream);
var _interface = require("@libp2p/interface");
var _multiaddr = require("@multiformats/multiaddr");
var _itProtobufStream = require("it-protobuf-stream");
var _indexJs = require("../webrtc/index.js");
var _messageJs = require("./pb/message.js");
var _utilJs = require("./util.js");
async function handleIncomingStream({ peerConnection, stream, signal, connection, log }) {
    log.trace("new inbound signaling stream");
    const messageStream = (0, _itProtobufStream.pbStream)(stream).pb((0, _messageJs.Message));
    try {
        // candidate callbacks
        peerConnection.onicecandidate = ({ candidate })=>{
            // a null candidate means end-of-candidates, an empty string candidate
            // means end-of-candidates for this generation, otherwise this should
            // be a valid candidate object
            // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent
            const data = JSON.stringify(candidate?.toJSON() ?? null);
            log.trace("recipient sending ICE candidate %s", data);
            messageStream.write({
                type: (0, _messageJs.Message).Type.ICE_CANDIDATE,
                data
            }, {
                signal
            }).catch((err)=>{
                log.error("error sending ICE candidate", err);
            });
        };
        // read an SDP offer
        const pbOffer = await messageStream.read({
            signal
        });
        if (pbOffer.type !== (0, _messageJs.Message).Type.SDP_OFFER) throw new (0, _interface.CodeError)(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `, "ERR_SDP_HANDSHAKE_FAILED");
        log.trace("recipient receive SDP offer %s", pbOffer.data);
        const offer = new (0, _indexJs.RTCSessionDescription)({
            type: "offer",
            sdp: pbOffer.data
        });
        await peerConnection.setRemoteDescription(offer).catch((err)=>{
            log.error("could not execute setRemoteDescription", err);
            throw new (0, _interface.CodeError)("Failed to set remoteDescription", "ERR_SDP_HANDSHAKE_FAILED");
        });
        // create and write an SDP answer
        const answer = await peerConnection.createAnswer().catch((err)=>{
            log.error("could not execute createAnswer", err);
            throw new (0, _interface.CodeError)("Failed to create answer", "ERR_SDP_HANDSHAKE_FAILED");
        });
        log.trace("recipient send SDP answer %s", answer.sdp);
        // write the answer to the remote
        await messageStream.write({
            type: (0, _messageJs.Message).Type.SDP_ANSWER,
            data: answer.sdp
        }, {
            signal
        });
        await peerConnection.setLocalDescription(answer).catch((err)=>{
            log.error("could not execute setLocalDescription", err);
            throw new (0, _interface.CodeError)("Failed to set localDescription", "ERR_SDP_HANDSHAKE_FAILED");
        });
        log.trace("recipient read candidates until connected");
        // wait until candidates are connected
        await (0, _utilJs.readCandidatesUntilConnected)(peerConnection, messageStream, {
            direction: "recipient",
            signal,
            log
        });
    } catch (err) {
        if (peerConnection.connectionState !== "connected") {
            log.error("error while handling signaling stream from peer %a", connection.remoteAddr, err);
            peerConnection.close();
            throw err;
        } else log("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
    const remoteAddress = (0, _multiaddr.multiaddr)(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`);
    log.trace("recipient connected to remote address %s", remoteAddress);
    return {
        remoteAddress
    };
}

},{"@libp2p/interface":"b14bx","@multiformats/multiaddr":"7Qpz2","it-protobuf-stream":"gV3cl","../webrtc/index.js":"6CTn2","./pb/message.js":"4QHSO","./util.js":"gCU17","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"cqpAP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WEBRTC_CODE", ()=>WEBRTC_CODE);
parcelHelpers.export(exports, "CERTHASH_CODE", ()=>CERTHASH_CODE);
parcelHelpers.export(exports, "WebRTCDirectTransport", ()=>WebRTCDirectTransport);
var _libp2PNoise = require("@chainsafe/libp2p-noise");
var _interface = require("@libp2p/interface");
var _peerId = require("@libp2p/peer-id");
var _multiaddr = require("@multiformats/multiaddr");
var _multiaddrMatcher = require("@multiformats/multiaddr-matcher");
var _multihashes = require("multihashes");
var _concat = require("uint8arrays/concat");
var _fromString = require("uint8arrays/from-string");
var _errorJs = require("../error.js");
var _maconnJs = require("../maconn.js");
var _muxerJs = require("../muxer.js");
var _streamJs = require("../stream.js");
var _utilJs = require("../util.js");
var _indexJs = require("../webrtc/index.js");
var _sdpJs = require("./sdp.js");
var _utilJs1 = require("./util.js");
/**
 * The time to wait, in milliseconds, for the data channel handshake to complete
 */ const HANDSHAKE_TIMEOUT_MS = 10000;
const WEBRTC_CODE = (0, _multiaddr.protocols)("webrtc-direct").code;
const CERTHASH_CODE = (0, _multiaddr.protocols)("certhash").code;
class WebRTCDirectTransport {
    log;
    metrics;
    components;
    init;
    constructor(components, init = {}){
        this.log = components.logger.forComponent("libp2p:webrtc-direct");
        this.components = components;
        this.init = init;
        if (components.metrics != null) this.metrics = {
            dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
                label: "event",
                help: "Total count of WebRTC-direct dial events by type"
            })
        };
    }
    /**
     * Dial a given multiaddr
     */ async dial(ma, options) {
        const rawConn = await this._connect(ma, options);
        this.log("dialing address: %a", ma);
        return rawConn;
    }
    /**
     * Create transport listeners no supported by browsers
     */ createListener(options) {
        throw (0, _errorJs.unimplemented)("WebRTCTransport.createListener");
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid addresses for the transport
     */ filter(multiaddrs) {
        return multiaddrs.filter((0, _multiaddrMatcher.WebRTCDirect).exactMatch);
    }
    /**
     * Implement toString() for WebRTCTransport
     */ [Symbol.toStringTag] = "@libp2p/webrtc-direct";
    /**
     * Symbol.for('@libp2p/transport')
     */ [(0, _interface.transportSymbol)] = true;
    /**
     * Connect to a peer using a multiaddr
     */ async _connect(ma, options) {
        const controller = new AbortController();
        const signal = controller.signal;
        const remotePeerString = ma.getPeerId();
        if (remotePeerString === null) throw (0, _errorJs.inappropriateMultiaddr)("we need to have the remote's PeerId");
        const theirPeerId = _peerId.peerIdFromString(remotePeerString);
        const remoteCerthash = _sdpJs.decodeCerthash(_sdpJs.certhash(ma));
        // ECDSA is preferred over RSA here. From our testing we find that P-256 elliptic
        // curve is supported by Pion, webrtc-rs, as well as Chromium (P-228 and P-384
        // was not supported in Chromium). We use the same hash function as found in the
        // multiaddr if it is supported.
        const certificate = await (0, _indexJs.RTCPeerConnection).generateCertificate({
            name: "ECDSA",
            namedCurve: "P-256",
            hash: _sdpJs.toSupportedHashFunction(remoteCerthash.name)
        });
        const peerConnection = new (0, _indexJs.RTCPeerConnection)({
            certificates: [
                certificate
            ]
        });
        try {
            // create data channel for running the noise handshake. Once the data channel is opened,
            // the remote will initiate the noise handshake. This is used to confirm the identity of
            // the peer.
            const dataChannelOpenPromise = new Promise((resolve, reject)=>{
                const handshakeDataChannel = peerConnection.createDataChannel("", {
                    negotiated: true,
                    id: 0
                });
                const handshakeTimeout = setTimeout(()=>{
                    const error = `Data channel was never opened: state: ${handshakeDataChannel.readyState}`;
                    this.log.error(error);
                    this.metrics?.dialerEvents.increment({
                        open_error: true
                    });
                    reject((0, _errorJs.dataChannelError)("data", error));
                }, HANDSHAKE_TIMEOUT_MS);
                handshakeDataChannel.onopen = (_)=>{
                    clearTimeout(handshakeTimeout);
                    resolve(handshakeDataChannel);
                };
                // ref: https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/error_event
                handshakeDataChannel.onerror = (event)=>{
                    clearTimeout(handshakeTimeout);
                    const errorTarget = event.target?.toString() ?? "not specified";
                    const error = `Error opening a data channel for handshaking: ${errorTarget}`;
                    this.log.error(error);
                    // NOTE: We use unknown error here but this could potentially be considered a reset by some standards.
                    this.metrics?.dialerEvents.increment({
                        unknown_error: true
                    });
                    reject((0, _errorJs.dataChannelError)("data", error));
                };
            });
            const ufrag = "libp2p+webrtc+v1/" + (0, _utilJs1.genUfrag)(32);
            // Create offer and munge sdp with ufrag == pwd. This allows the remote to
            // respond to STUN messages without performing an actual SDP exchange.
            // This is because it can infer the passwd field by reading the USERNAME
            // attribute of the STUN message.
            const offerSdp = await peerConnection.createOffer();
            const mungedOfferSdp = _sdpJs.munge(offerSdp, ufrag);
            await peerConnection.setLocalDescription(mungedOfferSdp);
            // construct answer sdp from multiaddr and ufrag
            const answerSdp = _sdpJs.fromMultiAddr(ma, ufrag);
            await peerConnection.setRemoteDescription(answerSdp);
            // wait for peerconnection.onopen to fire, or for the datachannel to open
            const handshakeDataChannel = await dataChannelOpenPromise;
            const myPeerId = this.components.peerId;
            // Do noise handshake.
            // Set the Noise Prologue to libp2p-webrtc-noise:<FINGERPRINTS> before starting the actual Noise handshake.
            // <FINGERPRINTS> is the concatenation of the of the two TLS fingerprints of A and B in their multihash byte representation, sorted in ascending order.
            const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma);
            // Since we use the default crypto interface and do not use a static key or early data,
            // we pass in undefined for these parameters.
            const connectionEncrypter = (0, _libp2PNoise.noise)({
                prologueBytes: fingerprintsPrologue
            })(this.components);
            const wrappedChannel = (0, _streamJs.createStream)({
                channel: handshakeDataChannel,
                direction: "inbound",
                logger: this.components.logger,
                ...this.init.dataChannel ?? {}
            });
            const wrappedDuplex = {
                ...wrappedChannel,
                sink: wrappedChannel.sink.bind(wrappedChannel),
                source: async function*() {
                    for await (const list of wrappedChannel.source)for (const buf of list)yield buf;
                }()
            };
            // Creating the connection before completion of the noise
            // handshake ensures that the stream opening callback is set up
            const maConn = new (0, _maconnJs.WebRTCMultiaddrConnection)(this.components, {
                peerConnection,
                remoteAddr: ma,
                timeline: {
                    open: Date.now()
                },
                metrics: this.metrics?.dialerEvents
            });
            const eventListeningName = (0, _utilJs.isFirefox) ? "iceconnectionstatechange" : "connectionstatechange";
            peerConnection.addEventListener(eventListeningName, ()=>{
                switch(peerConnection.connectionState){
                    case "failed":
                    case "disconnected":
                    case "closed":
                        maConn.close().catch((err)=>{
                            this.log.error("error closing connection", err);
                        }).finally(()=>{
                            // Remove the event listener once the connection is closed
                            controller.abort();
                        });
                        break;
                    default:
                        break;
                }
            }, {
                signal
            });
            // Track opened peer connection
            this.metrics?.dialerEvents.increment({
                peer_connection: true
            });
            const muxerFactory = new (0, _muxerJs.DataChannelMuxerFactory)(this.components, {
                peerConnection,
                metrics: this.metrics?.dialerEvents,
                dataChannelOptions: this.init.dataChannel
            });
            // For outbound connections, the remote is expected to start the noise handshake.
            // Therefore, we need to secure an inbound noise connection from the remote.
            await connectionEncrypter.secureInbound(myPeerId, wrappedDuplex, theirPeerId);
            return await options.upgrader.upgradeOutbound(maConn, {
                skipProtection: true,
                skipEncryption: true,
                muxerFactory
            });
        } catch (err) {
            peerConnection.close();
            throw err;
        }
    }
    /**
     * Generate a noise prologue from the peer connection's certificate.
     * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint
     */ generateNoisePrologue(pc, hashCode, ma) {
        if (pc.getConfiguration().certificates?.length === 0) throw (0, _errorJs.invalidArgument)("no local certificate");
        const localFingerprint = _sdpJs.getLocalFingerprint(pc, {
            log: this.log
        });
        if (localFingerprint == null) throw (0, _errorJs.invalidArgument)("no local fingerprint found");
        const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
        const localFpArray = (0, _fromString.fromString)(localFpString, "hex");
        const local = _multihashes.encode(localFpArray, hashCode);
        const remote = _sdpJs.mbdecoder.decode(_sdpJs.certhash(ma));
        const prefix = (0, _fromString.fromString)("libp2p-webrtc-noise:");
        return (0, _concat.concat)([
            prefix,
            local,
            remote
        ]);
    }
}

},{"@chainsafe/libp2p-noise":"eSsJA","@libp2p/interface":"b14bx","@libp2p/peer-id":"8wBUr","@multiformats/multiaddr":"7Qpz2","@multiformats/multiaddr-matcher":"8GlCq","multihashes":"33JRe","uint8arrays/concat":"byG2b","uint8arrays/from-string":"3YvUV","../error.js":"2kM5A","../maconn.js":"dRqUJ","../muxer.js":"1Rc8I","../stream.js":"cS6cO","../util.js":"azhmH","../webrtc/index.js":"6CTn2","./sdp.js":"3wAWO","./util.js":"caxeF","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"33JRe":[function(require,module,exports) {
/**
 * Multihash implementation in JavaScript.
 */ "use strict";
const multibase = require("ba1fe8f2d4304de2");
const varint = require("5e82272b03d14481");
const { names } = require("c5469be8a7e74372");
const { toString: uint8ArrayToString } = require("cc162fb37e7c0c69");
const { fromString: uint8ArrayFromString } = require("3080f1dbcbefd94c");
const { concat: uint8ArrayConcat } = require("17b03df2b64784e5");
const codes = /** @type {import('./types').CodeNameMap} */ {};
// eslint-disable-next-line guard-for-in
for(const key in names){
    const name = /** @type {HashName} */ key;
    codes[names[name]] = name;
}
Object.freeze(codes);
/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */ function toHexString(hash) {
    if (!(hash instanceof Uint8Array)) throw new Error("must be passed a Uint8Array");
    return uint8ArrayToString(hash, "base16");
}
/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Uint8Array}
 */ function fromHexString(hash) {
    return uint8ArrayFromString(hash, "base16");
}
/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */ function toB58String(hash) {
    if (!(hash instanceof Uint8Array)) throw new Error("must be passed a Uint8Array");
    return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
}
/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Uint8Array}
 */ function fromB58String(hash) {
    const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
    return multibase.decode("z" + encoded);
}
/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result
 */ function decode(bytes) {
    if (!(bytes instanceof Uint8Array)) throw new Error("multihash must be a Uint8Array");
    if (bytes.length < 2) throw new Error("multihash too short. must be > 2 bytes.");
    const code = /** @type {HashCode} */ varint.decode(bytes);
    if (!isValidCode(code)) throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
    bytes = bytes.slice(varint.decode.bytes);
    const len = varint.decode(bytes);
    if (len < 0) throw new Error(`multihash invalid length: ${len}`);
    bytes = bytes.slice(varint.decode.bytes);
    if (bytes.length !== len) throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
    return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
    };
}
/**
 * Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {HashName | HashCode} code
 * @param {number} [length]
 * @returns {Uint8Array}
 */ function encode(digest, code, length) {
    if (!digest || code === undefined) throw new Error("multihash encode requires at least two args: digest, code");
    // ensure it's a hashfunction code.
    const hashfn = coerceCode(code);
    if (!(digest instanceof Uint8Array)) throw new Error("digest should be a Uint8Array");
    if (length == null) length = digest.length;
    if (length && digest.length !== length) throw new Error("digest length should be equal to specified length.");
    const hash = varint.encode(hashfn);
    const len = varint.encode(length);
    return uint8ArrayConcat([
        hash,
        len,
        digest
    ], hash.length + len.length + digest.length);
}
/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 *
 * @param {HashName | number} name
 * @returns {number}
 */ function coerceCode(name) {
    let code = name;
    if (typeof name === "string") {
        if (names[name] === undefined) throw new Error(`Unrecognized hash function named: ${name}`);
        code = names[name];
    }
    if (typeof code !== "number") throw new Error(`Hash function code should be a number. Got: ${code}`);
    // @ts-ignore
    if (codes[code] === undefined && !isAppCode(code)) throw new Error(`Unrecognized function code: ${code}`);
    return code;
}
/**
 * Checks if a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */ function isAppCode(code) {
    return code > 0 && code < 0x10;
}
/**
 * Checks whether a multihash code is valid.
 *
 * @param {HashCode} code
 * @returns {boolean}
 */ function isValidCode(code) {
    if (isAppCode(code)) return true;
    if (codes[code]) return true;
    return false;
}
/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */ function validate(multihash) {
    decode(multihash) // throws if bad.
    ;
}
/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 * @throws {Error}
 */ function prefix(multihash) {
    validate(multihash);
    return multihash.subarray(0, 2);
}
module.exports = {
    names,
    codes,
    toHexString,
    fromHexString,
    toB58String,
    fromB58String,
    decode,
    encode,
    coerceCode,
    isAppCode,
    validate,
    prefix,
    isValidCode
} /**
 * @typedef { import("./constants").HashCode } HashCode
 * @typedef { import("./constants").HashName } HashName
 */ ;

},{"ba1fe8f2d4304de2":"g7lbk","5e82272b03d14481":"hnmVT","c5469be8a7e74372":"ctqR1","cc162fb37e7c0c69":"c1DbZ","3080f1dbcbefd94c":"56rLd","17b03df2b64784e5":"4DDcb"}],"g7lbk":[function(require,module,exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 */ "use strict";
const constants = require("4d258363c7b841da");
const { encodeText, decodeText, concat } = require("f9b19e56868ed95a");
/** @typedef {import('./base')} Base */ /** @typedef {import("./types").BaseNameOrCode} BaseNameOrCode */ /** @typedef {import("./types").BaseCode} BaseCode */ /** @typedef {import("./types").BaseName} BaseName */ /**
 * Create a new Uint8Array with the multibase varint+code.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 */ function multibase(nameOrCode, buf) {
    if (!buf) throw new Error("requires an encoded Uint8Array");
    const { name, codeBuf } = encoding(nameOrCode);
    validEncode(name, buf);
    return concat([
        codeBuf,
        buf
    ], codeBuf.length + buf.length);
}
/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */ function encode(nameOrCode, buf) {
    const enc = encoding(nameOrCode);
    const data = encodeText(enc.encode(buf));
    return concat([
        enc.codeBuf,
        data
    ], enc.codeBuf.length + data.length);
}
/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */ function decode(data) {
    if (data instanceof Uint8Array) data = decodeText(data);
    const prefix = data[0];
    // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
    if ([
        "f",
        "F",
        "v",
        "V",
        "t",
        "T",
        "b",
        "B",
        "c",
        "C",
        "h",
        "k",
        "K"
    ].includes(prefix)) data = data.toLowerCase();
    const enc = encoding(/** @type {BaseCode} */ data[0]);
    return enc.decode(data.substring(1));
}
/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 */ function isEncoded(data) {
    if (data instanceof Uint8Array) data = decodeText(data);
    // Ensure bufOrString is a string
    if (Object.prototype.toString.call(data) !== "[object String]") return false;
    try {
        const enc = encoding(/** @type {BaseCode} */ data[0]);
        return enc.name;
    } catch (err) {
        return false;
    }
}
/**
 * Validate encoded data
 *
 * @param {BaseNameOrCode} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */ function validEncode(name, buf) {
    const enc = encoding(name);
    enc.decode(decodeText(buf));
}
/**
 * Get the encoding by name or code
 *
 * @param {BaseNameOrCode} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */ function encoding(nameOrCode) {
    if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */ nameOrCode)) return constants.names[/** @type {BaseName} */ nameOrCode];
    else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */ nameOrCode)) return constants.codes[/** @type {BaseCode} */ nameOrCode];
    else throw new Error(`Unsupported encoding: ${nameOrCode}`);
}
/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */ function encodingFromData(data) {
    if (data instanceof Uint8Array) data = decodeText(data);
    return encoding(/** @type {BaseCode} */ data[0]);
}
exports = module.exports = multibase;
exports.encode = encode;
exports.decode = decode;
exports.isEncoded = isEncoded;
exports.encoding = encoding;
exports.encodingFromData = encodingFromData;
const names = Object.freeze(constants.names);
const codes = Object.freeze(constants.codes);
exports.names = names;
exports.codes = codes;

},{"4d258363c7b841da":"aP7ab","f9b19e56868ed95a":"4stKG"}],"aP7ab":[function(require,module,exports) {
"use strict";
const baseX = require("f8182b7a8afa309f");
const Base = require("55b004b26ab81b94");
const { rfc4648 } = require("e3f364f57a1dce66");
const { decodeText, encodeText } = require("6ec291a43c649923");
/** @typedef {import('./types').CodecFactory} CodecFactory */ /** @typedef {import('./types').Codec} Codec */ /** @typedef {import('./types').BaseName} BaseName */ /** @typedef {import('./types').BaseCode} BaseCode */ /** @type {CodecFactory} */ const identity = ()=>{
    return {
        encode: decodeText,
        decode: encodeText
    };
};
/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */ const constants = [
    [
        "identity",
        "\x00",
        identity,
        ""
    ],
    [
        "base2",
        "0",
        rfc4648(1),
        "01"
    ],
    [
        "base8",
        "7",
        rfc4648(3),
        "01234567"
    ],
    [
        "base10",
        "9",
        baseX,
        "0123456789"
    ],
    [
        "base16",
        "f",
        rfc4648(4),
        "0123456789abcdef"
    ],
    [
        "base16upper",
        "F",
        rfc4648(4),
        "0123456789ABCDEF"
    ],
    [
        "base32hex",
        "v",
        rfc4648(5),
        "0123456789abcdefghijklmnopqrstuv"
    ],
    [
        "base32hexupper",
        "V",
        rfc4648(5),
        "0123456789ABCDEFGHIJKLMNOPQRSTUV"
    ],
    [
        "base32hexpad",
        "t",
        rfc4648(5),
        "0123456789abcdefghijklmnopqrstuv="
    ],
    [
        "base32hexpadupper",
        "T",
        rfc4648(5),
        "0123456789ABCDEFGHIJKLMNOPQRSTUV="
    ],
    [
        "base32",
        "b",
        rfc4648(5),
        "abcdefghijklmnopqrstuvwxyz234567"
    ],
    [
        "base32upper",
        "B",
        rfc4648(5),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
    ],
    [
        "base32pad",
        "c",
        rfc4648(5),
        "abcdefghijklmnopqrstuvwxyz234567="
    ],
    [
        "base32padupper",
        "C",
        rfc4648(5),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="
    ],
    [
        "base32z",
        "h",
        rfc4648(5),
        "ybndrfg8ejkmcpqxot1uwisza345h769"
    ],
    [
        "base36",
        "k",
        baseX,
        "0123456789abcdefghijklmnopqrstuvwxyz"
    ],
    [
        "base36upper",
        "K",
        baseX,
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    ],
    [
        "base58btc",
        "z",
        baseX,
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    ],
    [
        "base58flickr",
        "Z",
        baseX,
        "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    ],
    [
        "base64",
        "m",
        rfc4648(6),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    ],
    [
        "base64pad",
        "M",
        rfc4648(6),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    ],
    [
        "base64url",
        "u",
        rfc4648(6),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
    ],
    [
        "base64urlpad",
        "U",
        rfc4648(6),
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="
    ]
];
/** @type {Record<BaseName,Base>} */ const names = constants.reduce((prev, tupple)=>{
    prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
    return prev;
}, /** @type {Record<BaseName,Base>} */ {});
/** @type {Record<BaseCode,Base>} */ const codes = constants.reduce((prev, tupple)=>{
    prev[tupple[1]] = names[tupple[0]];
    return prev;
}, /** @type {Record<BaseCode,Base>} */ {});
module.exports = {
    names,
    codes
};

},{"f8182b7a8afa309f":"44Wac","55b004b26ab81b94":"byXLI","e3f364f57a1dce66":"ibunn","6ec291a43c649923":"4stKG"}],"44Wac":[function(require,module,exports) {
"use strict";
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base(ALPHABET) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        else if (Array.isArray(source)) source = Uint8Array.from(source);
        if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (source.length === 0) return "";
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return new Uint8Array();
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === " ") return;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === " ") return;
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error("Non-base" + BASE + " character");
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;

},{}],"byXLI":[function(require,module,exports) {
"use strict";
const { encodeText } = require("f0b9b9b52500c94d");
/** @typedef {import('./types').CodecFactory} CodecFactory */ /** @typedef {import("./types").BaseName} BaseName */ /** @typedef {import("./types").BaseCode} BaseCode */ /**
 * Class to encode/decode in the supported Bases
 *
 */ class Base {
    /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */ constructor(name, code, factory, alphabet){
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
    }
    /**
   * @param {Uint8Array} buf
   * @returns {string}
   */ encode(buf) {
        return this.codec.encode(buf);
    }
    /**
   * @param {string} string
   * @returns {Uint8Array}
   */ decode(string) {
        for (const char of string){
            if (this.alphabet && this.alphabet.indexOf(char) < 0) throw new Error(`invalid character '${char}' in '${string}'`);
        }
        return this.codec.decode(string);
    }
}
module.exports = Base;

},{"f0b9b9b52500c94d":"4stKG"}],"4stKG":[function(require,module,exports) {
"use strict";
const textDecoder = new TextDecoder();
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */ const decodeText = (bytes)=>textDecoder.decode(bytes);
const textEncoder = new TextEncoder();
/**
 * @param {string} text
 * @returns {Uint8Array}
 */ const encodeText = (text)=>textEncoder.encode(text);
/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */ function concat(arrs, length) {
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrs){
        output.set(arr, offset);
        offset += arr.length;
    }
    return output;
}
module.exports = {
    decodeText,
    encodeText,
    concat
};

},{}],"ibunn":[function(require,module,exports) {
"use strict";
/** @typedef {import('./types').CodecFactory} CodecFactory */ /**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */ const decode = (string, alphabet, bitsPerChar)=>{
    // Build the character lookup table:
    /** @type {Record<string, number>} */ const codes = {};
    for(let i = 0; i < alphabet.length; ++i)codes[alphabet[i]] = i;
    // Count the padding bytes:
    let end = string.length;
    while(string[end - 1] === "=")--end;
    // Allocate the output:
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    // Parse the data:
    let bits = 0 // Number of bits currently in the buffer
    ;
    let buffer = 0 // Bits waiting to be written out, MSB first
    ;
    let written = 0 // Next byte to write
    ;
    for(let i = 0; i < end; ++i){
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) throw new SyntaxError("Invalid character " + string[i]);
        // Append the bits to the buffer:
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & buffer >> bits;
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) throw new SyntaxError("Unexpected end of data");
    return out;
};
/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */ const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0 // Number of bits currently in the buffer
    ;
    let buffer = 0 // Bits waiting to be written out, MSB first
    ;
    for(let i = 0; i < data.length; ++i){
        // Slurp data into the buffer:
        buffer = buffer << 8 | data[i];
        bits += 8;
        // Write out as much as we can:
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    // Partial character:
    if (bits) out += alphabet[mask & buffer << bitsPerChar - bits];
    // Add padding characters until we hit a byte boundary:
    if (pad) while(out.length * bitsPerChar & 7)out += "=";
    return out;
};
/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */ const rfc4648 = (bitsPerChar)=>(alphabet)=>{
        return {
            /**
     * @param {Uint8Array} input
     * @returns {string}
     */ encode (input) {
                return encode(input, alphabet, bitsPerChar);
            },
            /**
     * @param {string} input
     * @returns {Uint8Array}
     */ decode (input) {
                return decode(input, alphabet, bitsPerChar);
            }
        };
    };
module.exports = {
    rfc4648
};

},{}],"hnmVT":[function(require,module,exports) {
module.exports = {
    encode: require("affd07bf5621094b"),
    decode: require("215255c32272682e"),
    encodingLength: require("bc5d55247944fbde")
};

},{"affd07bf5621094b":"13Gtc","215255c32272682e":"gzr45","bc5d55247944fbde":"5ZBmT"}],"13Gtc":[function(require,module,exports) {
module.exports = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}

},{}],"gzr45":[function(require,module,exports) {
module.exports = read;
var MSB = 0x80, REST = 0x7F;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB);
    read.bytes = counter - offset;
    return res;
}

},{}],"5ZBmT":[function(require,module,exports) {
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};

},{}],"ctqR1":[function(require,module,exports) {
/* eslint quote-props: off */ "use strict";
/**
 * Names for all available hashes
 *
 * @typedef { "identity" | "sha1" | "sha2-256" | "sha2-512" | "sha3-512" | "sha3-384" | "sha3-256" | "sha3-224" | "shake-128" | "shake-256" | "keccak-224" | "keccak-256" | "keccak-384" | "keccak-512" | "blake3" | "murmur3-128" | "murmur3-32" | "dbl-sha2-256" | "md4" | "md5" | "bmt" | "sha2-256-trunc254-padded" | "ripemd-128" | "ripemd-160" | "ripemd-256" | "ripemd-320" | "x11" | "kangarootwelve" | "sm3-256" | "blake2b-8" | "blake2b-16" | "blake2b-24" | "blake2b-32" | "blake2b-40" | "blake2b-48" | "blake2b-56" | "blake2b-64" | "blake2b-72" | "blake2b-80" | "blake2b-88" | "blake2b-96" | "blake2b-104" | "blake2b-112" | "blake2b-120" | "blake2b-128" | "blake2b-136" | "blake2b-144" | "blake2b-152" | "blake2b-160" | "blake2b-168" | "blake2b-176" | "blake2b-184" | "blake2b-192" | "blake2b-200" | "blake2b-208" | "blake2b-216" | "blake2b-224" | "blake2b-232" | "blake2b-240" | "blake2b-248" | "blake2b-256" | "blake2b-264" | "blake2b-272" | "blake2b-280" | "blake2b-288" | "blake2b-296" | "blake2b-304" | "blake2b-312" | "blake2b-320" | "blake2b-328" | "blake2b-336" | "blake2b-344" | "blake2b-352" | "blake2b-360" | "blake2b-368" | "blake2b-376" | "blake2b-384" | "blake2b-392" | "blake2b-400" | "blake2b-408" | "blake2b-416" | "blake2b-424" | "blake2b-432" | "blake2b-440" | "blake2b-448" | "blake2b-456" | "blake2b-464" | "blake2b-472" | "blake2b-480" | "blake2b-488" | "blake2b-496" | "blake2b-504" | "blake2b-512" | "blake2s-8" | "blake2s-16" | "blake2s-24" | "blake2s-32" | "blake2s-40" | "blake2s-48" | "blake2s-56" | "blake2s-64" | "blake2s-72" | "blake2s-80" | "blake2s-88" | "blake2s-96" | "blake2s-104" | "blake2s-112" | "blake2s-120" | "blake2s-128" | "blake2s-136" | "blake2s-144" | "blake2s-152" | "blake2s-160" | "blake2s-168" | "blake2s-176" | "blake2s-184" | "blake2s-192" | "blake2s-200" | "blake2s-208" | "blake2s-216" | "blake2s-224" | "blake2s-232" | "blake2s-240" | "blake2s-248" | "blake2s-256" | "skein256-8" | "skein256-16" | "skein256-24" | "skein256-32" | "skein256-40" | "skein256-48" | "skein256-56" | "skein256-64" | "skein256-72" | "skein256-80" | "skein256-88" | "skein256-96" | "skein256-104" | "skein256-112" | "skein256-120" | "skein256-128" | "skein256-136" | "skein256-144" | "skein256-152" | "skein256-160" | "skein256-168" | "skein256-176" | "skein256-184" | "skein256-192" | "skein256-200" | "skein256-208" | "skein256-216" | "skein256-224" | "skein256-232" | "skein256-240" | "skein256-248" | "skein256-256" | "skein512-8" | "skein512-16" | "skein512-24" | "skein512-32" | "skein512-40" | "skein512-48" | "skein512-56" | "skein512-64" | "skein512-72" | "skein512-80" | "skein512-88" | "skein512-96" | "skein512-104" | "skein512-112" | "skein512-120" | "skein512-128" | "skein512-136" | "skein512-144" | "skein512-152" | "skein512-160" | "skein512-168" | "skein512-176" | "skein512-184" | "skein512-192" | "skein512-200" | "skein512-208" | "skein512-216" | "skein512-224" | "skein512-232" | "skein512-240" | "skein512-248" | "skein512-256" | "skein512-264" | "skein512-272" | "skein512-280" | "skein512-288" | "skein512-296" | "skein512-304" | "skein512-312" | "skein512-320" | "skein512-328" | "skein512-336" | "skein512-344" | "skein512-352" | "skein512-360" | "skein512-368" | "skein512-376" | "skein512-384" | "skein512-392" | "skein512-400" | "skein512-408" | "skein512-416" | "skein512-424" | "skein512-432" | "skein512-440" | "skein512-448" | "skein512-456" | "skein512-464" | "skein512-472" | "skein512-480" | "skein512-488" | "skein512-496" | "skein512-504" | "skein512-512" | "skein1024-8" | "skein1024-16" | "skein1024-24" | "skein1024-32" | "skein1024-40" | "skein1024-48" | "skein1024-56" | "skein1024-64" | "skein1024-72" | "skein1024-80" | "skein1024-88" | "skein1024-96" | "skein1024-104" | "skein1024-112" | "skein1024-120" | "skein1024-128" | "skein1024-136" | "skein1024-144" | "skein1024-152" | "skein1024-160" | "skein1024-168" | "skein1024-176" | "skein1024-184" | "skein1024-192" | "skein1024-200" | "skein1024-208" | "skein1024-216" | "skein1024-224" | "skein1024-232" | "skein1024-240" | "skein1024-248" | "skein1024-256" | "skein1024-264" | "skein1024-272" | "skein1024-280" | "skein1024-288" | "skein1024-296" | "skein1024-304" | "skein1024-312" | "skein1024-320" | "skein1024-328" | "skein1024-336" | "skein1024-344" | "skein1024-352" | "skein1024-360" | "skein1024-368" | "skein1024-376" | "skein1024-384" | "skein1024-392" | "skein1024-400" | "skein1024-408" | "skein1024-416" | "skein1024-424" | "skein1024-432" | "skein1024-440" | "skein1024-448" | "skein1024-456" | "skein1024-464" | "skein1024-472" | "skein1024-480" | "skein1024-488" | "skein1024-496" | "skein1024-504" | "skein1024-512" | "skein1024-520" | "skein1024-528" | "skein1024-536" | "skein1024-544" | "skein1024-552" | "skein1024-560" | "skein1024-568" | "skein1024-576" | "skein1024-584" | "skein1024-592" | "skein1024-600" | "skein1024-608" | "skein1024-616" | "skein1024-624" | "skein1024-632" | "skein1024-640" | "skein1024-648" | "skein1024-656" | "skein1024-664" | "skein1024-672" | "skein1024-680" | "skein1024-688" | "skein1024-696" | "skein1024-704" | "skein1024-712" | "skein1024-720" | "skein1024-728" | "skein1024-736" | "skein1024-744" | "skein1024-752" | "skein1024-760" | "skein1024-768" | "skein1024-776" | "skein1024-784" | "skein1024-792" | "skein1024-800" | "skein1024-808" | "skein1024-816" | "skein1024-824" | "skein1024-832" | "skein1024-840" | "skein1024-848" | "skein1024-856" | "skein1024-864" | "skein1024-872" | "skein1024-880" | "skein1024-888" | "skein1024-896" | "skein1024-904" | "skein1024-912" | "skein1024-920" | "skein1024-928" | "skein1024-936" | "skein1024-944" | "skein1024-952" | "skein1024-960" | "skein1024-968" | "skein1024-976" | "skein1024-984" | "skein1024-992" | "skein1024-1000" | "skein1024-1008" | "skein1024-1016" | "skein1024-1024" | "poseidon-bls12_381-a2-fc1" | "poseidon-bls12_381-a2-fc1-sc" } HashName
 */ /**
 * Codes for all available hashes
 *
 * @typedef { 0x00 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x22 | 0x23 | 0x56 | 0xd4 | 0xd5 | 0xd6 | 0x1012 | 0x1052 | 0x1053 | 0x1054 | 0x1055 | 0x1100 | 0x1d01 | 0x534d | 0xb201 | 0xb202 | 0xb203 | 0xb204 | 0xb205 | 0xb206 | 0xb207 | 0xb208 | 0xb209 | 0xb20a | 0xb20b | 0xb20c | 0xb20d | 0xb20e | 0xb20f | 0xb210 | 0xb211 | 0xb212 | 0xb213 | 0xb214 | 0xb215 | 0xb216 | 0xb217 | 0xb218 | 0xb219 | 0xb21a | 0xb21b | 0xb21c | 0xb21d | 0xb21e | 0xb21f | 0xb220 | 0xb221 | 0xb222 | 0xb223 | 0xb224 | 0xb225 | 0xb226 | 0xb227 | 0xb228 | 0xb229 | 0xb22a | 0xb22b | 0xb22c | 0xb22d | 0xb22e | 0xb22f | 0xb230 | 0xb231 | 0xb232 | 0xb233 | 0xb234 | 0xb235 | 0xb236 | 0xb237 | 0xb238 | 0xb239 | 0xb23a | 0xb23b | 0xb23c | 0xb23d | 0xb23e | 0xb23f | 0xb240 | 0xb241 | 0xb242 | 0xb243 | 0xb244 | 0xb245 | 0xb246 | 0xb247 | 0xb248 | 0xb249 | 0xb24a | 0xb24b | 0xb24c | 0xb24d | 0xb24e | 0xb24f | 0xb250 | 0xb251 | 0xb252 | 0xb253 | 0xb254 | 0xb255 | 0xb256 | 0xb257 | 0xb258 | 0xb259 | 0xb25a | 0xb25b | 0xb25c | 0xb25d | 0xb25e | 0xb25f | 0xb260 | 0xb301 | 0xb302 | 0xb303 | 0xb304 | 0xb305 | 0xb306 | 0xb307 | 0xb308 | 0xb309 | 0xb30a | 0xb30b | 0xb30c | 0xb30d | 0xb30e | 0xb30f | 0xb310 | 0xb311 | 0xb312 | 0xb313 | 0xb314 | 0xb315 | 0xb316 | 0xb317 | 0xb318 | 0xb319 | 0xb31a | 0xb31b | 0xb31c | 0xb31d | 0xb31e | 0xb31f | 0xb320 | 0xb321 | 0xb322 | 0xb323 | 0xb324 | 0xb325 | 0xb326 | 0xb327 | 0xb328 | 0xb329 | 0xb32a | 0xb32b | 0xb32c | 0xb32d | 0xb32e | 0xb32f | 0xb330 | 0xb331 | 0xb332 | 0xb333 | 0xb334 | 0xb335 | 0xb336 | 0xb337 | 0xb338 | 0xb339 | 0xb33a | 0xb33b | 0xb33c | 0xb33d | 0xb33e | 0xb33f | 0xb340 | 0xb341 | 0xb342 | 0xb343 | 0xb344 | 0xb345 | 0xb346 | 0xb347 | 0xb348 | 0xb349 | 0xb34a | 0xb34b | 0xb34c | 0xb34d | 0xb34e | 0xb34f | 0xb350 | 0xb351 | 0xb352 | 0xb353 | 0xb354 | 0xb355 | 0xb356 | 0xb357 | 0xb358 | 0xb359 | 0xb35a | 0xb35b | 0xb35c | 0xb35d | 0xb35e | 0xb35f | 0xb360 | 0xb361 | 0xb362 | 0xb363 | 0xb364 | 0xb365 | 0xb366 | 0xb367 | 0xb368 | 0xb369 | 0xb36a | 0xb36b | 0xb36c | 0xb36d | 0xb36e | 0xb36f | 0xb370 | 0xb371 | 0xb372 | 0xb373 | 0xb374 | 0xb375 | 0xb376 | 0xb377 | 0xb378 | 0xb379 | 0xb37a | 0xb37b | 0xb37c | 0xb37d | 0xb37e | 0xb37f | 0xb380 | 0xb381 | 0xb382 | 0xb383 | 0xb384 | 0xb385 | 0xb386 | 0xb387 | 0xb388 | 0xb389 | 0xb38a | 0xb38b | 0xb38c | 0xb38d | 0xb38e | 0xb38f | 0xb390 | 0xb391 | 0xb392 | 0xb393 | 0xb394 | 0xb395 | 0xb396 | 0xb397 | 0xb398 | 0xb399 | 0xb39a | 0xb39b | 0xb39c | 0xb39d | 0xb39e | 0xb39f | 0xb3a0 | 0xb3a1 | 0xb3a2 | 0xb3a3 | 0xb3a4 | 0xb3a5 | 0xb3a6 | 0xb3a7 | 0xb3a8 | 0xb3a9 | 0xb3aa | 0xb3ab | 0xb3ac | 0xb3ad | 0xb3ae | 0xb3af | 0xb3b0 | 0xb3b1 | 0xb3b2 | 0xb3b3 | 0xb3b4 | 0xb3b5 | 0xb3b6 | 0xb3b7 | 0xb3b8 | 0xb3b9 | 0xb3ba | 0xb3bb | 0xb3bc | 0xb3bd | 0xb3be | 0xb3bf | 0xb3c0 | 0xb3c1 | 0xb3c2 | 0xb3c3 | 0xb3c4 | 0xb3c5 | 0xb3c6 | 0xb3c7 | 0xb3c8 | 0xb3c9 | 0xb3ca | 0xb3cb | 0xb3cc | 0xb3cd | 0xb3ce | 0xb3cf | 0xb3d0 | 0xb3d1 | 0xb3d2 | 0xb3d3 | 0xb3d4 | 0xb3d5 | 0xb3d6 | 0xb3d7 | 0xb3d8 | 0xb3d9 | 0xb3da | 0xb3db | 0xb3dc | 0xb3dd | 0xb3de | 0xb3df | 0xb3e0 | 0xb401 | 0xb402 } HashCode
 */ /**
 * @type { Record<HashName,HashCode> }
 */ const names = Object.freeze({
    "identity": 0x00,
    "sha1": 0x11,
    "sha2-256": 0x12,
    "sha2-512": 0x13,
    "sha3-512": 0x14,
    "sha3-384": 0x15,
    "sha3-256": 0x16,
    "sha3-224": 0x17,
    "shake-128": 0x18,
    "shake-256": 0x19,
    "keccak-224": 0x1a,
    "keccak-256": 0x1b,
    "keccak-384": 0x1c,
    "keccak-512": 0x1d,
    "blake3": 0x1e,
    "murmur3-128": 0x22,
    "murmur3-32": 0x23,
    "dbl-sha2-256": 0x56,
    "md4": 0xd4,
    "md5": 0xd5,
    "bmt": 0xd6,
    "sha2-256-trunc254-padded": 0x1012,
    "ripemd-128": 0x1052,
    "ripemd-160": 0x1053,
    "ripemd-256": 0x1054,
    "ripemd-320": 0x1055,
    "x11": 0x1100,
    "kangarootwelve": 0x1d01,
    "sm3-256": 0x534d,
    "blake2b-8": 0xb201,
    "blake2b-16": 0xb202,
    "blake2b-24": 0xb203,
    "blake2b-32": 0xb204,
    "blake2b-40": 0xb205,
    "blake2b-48": 0xb206,
    "blake2b-56": 0xb207,
    "blake2b-64": 0xb208,
    "blake2b-72": 0xb209,
    "blake2b-80": 0xb20a,
    "blake2b-88": 0xb20b,
    "blake2b-96": 0xb20c,
    "blake2b-104": 0xb20d,
    "blake2b-112": 0xb20e,
    "blake2b-120": 0xb20f,
    "blake2b-128": 0xb210,
    "blake2b-136": 0xb211,
    "blake2b-144": 0xb212,
    "blake2b-152": 0xb213,
    "blake2b-160": 0xb214,
    "blake2b-168": 0xb215,
    "blake2b-176": 0xb216,
    "blake2b-184": 0xb217,
    "blake2b-192": 0xb218,
    "blake2b-200": 0xb219,
    "blake2b-208": 0xb21a,
    "blake2b-216": 0xb21b,
    "blake2b-224": 0xb21c,
    "blake2b-232": 0xb21d,
    "blake2b-240": 0xb21e,
    "blake2b-248": 0xb21f,
    "blake2b-256": 0xb220,
    "blake2b-264": 0xb221,
    "blake2b-272": 0xb222,
    "blake2b-280": 0xb223,
    "blake2b-288": 0xb224,
    "blake2b-296": 0xb225,
    "blake2b-304": 0xb226,
    "blake2b-312": 0xb227,
    "blake2b-320": 0xb228,
    "blake2b-328": 0xb229,
    "blake2b-336": 0xb22a,
    "blake2b-344": 0xb22b,
    "blake2b-352": 0xb22c,
    "blake2b-360": 0xb22d,
    "blake2b-368": 0xb22e,
    "blake2b-376": 0xb22f,
    "blake2b-384": 0xb230,
    "blake2b-392": 0xb231,
    "blake2b-400": 0xb232,
    "blake2b-408": 0xb233,
    "blake2b-416": 0xb234,
    "blake2b-424": 0xb235,
    "blake2b-432": 0xb236,
    "blake2b-440": 0xb237,
    "blake2b-448": 0xb238,
    "blake2b-456": 0xb239,
    "blake2b-464": 0xb23a,
    "blake2b-472": 0xb23b,
    "blake2b-480": 0xb23c,
    "blake2b-488": 0xb23d,
    "blake2b-496": 0xb23e,
    "blake2b-504": 0xb23f,
    "blake2b-512": 0xb240,
    "blake2s-8": 0xb241,
    "blake2s-16": 0xb242,
    "blake2s-24": 0xb243,
    "blake2s-32": 0xb244,
    "blake2s-40": 0xb245,
    "blake2s-48": 0xb246,
    "blake2s-56": 0xb247,
    "blake2s-64": 0xb248,
    "blake2s-72": 0xb249,
    "blake2s-80": 0xb24a,
    "blake2s-88": 0xb24b,
    "blake2s-96": 0xb24c,
    "blake2s-104": 0xb24d,
    "blake2s-112": 0xb24e,
    "blake2s-120": 0xb24f,
    "blake2s-128": 0xb250,
    "blake2s-136": 0xb251,
    "blake2s-144": 0xb252,
    "blake2s-152": 0xb253,
    "blake2s-160": 0xb254,
    "blake2s-168": 0xb255,
    "blake2s-176": 0xb256,
    "blake2s-184": 0xb257,
    "blake2s-192": 0xb258,
    "blake2s-200": 0xb259,
    "blake2s-208": 0xb25a,
    "blake2s-216": 0xb25b,
    "blake2s-224": 0xb25c,
    "blake2s-232": 0xb25d,
    "blake2s-240": 0xb25e,
    "blake2s-248": 0xb25f,
    "blake2s-256": 0xb260,
    "skein256-8": 0xb301,
    "skein256-16": 0xb302,
    "skein256-24": 0xb303,
    "skein256-32": 0xb304,
    "skein256-40": 0xb305,
    "skein256-48": 0xb306,
    "skein256-56": 0xb307,
    "skein256-64": 0xb308,
    "skein256-72": 0xb309,
    "skein256-80": 0xb30a,
    "skein256-88": 0xb30b,
    "skein256-96": 0xb30c,
    "skein256-104": 0xb30d,
    "skein256-112": 0xb30e,
    "skein256-120": 0xb30f,
    "skein256-128": 0xb310,
    "skein256-136": 0xb311,
    "skein256-144": 0xb312,
    "skein256-152": 0xb313,
    "skein256-160": 0xb314,
    "skein256-168": 0xb315,
    "skein256-176": 0xb316,
    "skein256-184": 0xb317,
    "skein256-192": 0xb318,
    "skein256-200": 0xb319,
    "skein256-208": 0xb31a,
    "skein256-216": 0xb31b,
    "skein256-224": 0xb31c,
    "skein256-232": 0xb31d,
    "skein256-240": 0xb31e,
    "skein256-248": 0xb31f,
    "skein256-256": 0xb320,
    "skein512-8": 0xb321,
    "skein512-16": 0xb322,
    "skein512-24": 0xb323,
    "skein512-32": 0xb324,
    "skein512-40": 0xb325,
    "skein512-48": 0xb326,
    "skein512-56": 0xb327,
    "skein512-64": 0xb328,
    "skein512-72": 0xb329,
    "skein512-80": 0xb32a,
    "skein512-88": 0xb32b,
    "skein512-96": 0xb32c,
    "skein512-104": 0xb32d,
    "skein512-112": 0xb32e,
    "skein512-120": 0xb32f,
    "skein512-128": 0xb330,
    "skein512-136": 0xb331,
    "skein512-144": 0xb332,
    "skein512-152": 0xb333,
    "skein512-160": 0xb334,
    "skein512-168": 0xb335,
    "skein512-176": 0xb336,
    "skein512-184": 0xb337,
    "skein512-192": 0xb338,
    "skein512-200": 0xb339,
    "skein512-208": 0xb33a,
    "skein512-216": 0xb33b,
    "skein512-224": 0xb33c,
    "skein512-232": 0xb33d,
    "skein512-240": 0xb33e,
    "skein512-248": 0xb33f,
    "skein512-256": 0xb340,
    "skein512-264": 0xb341,
    "skein512-272": 0xb342,
    "skein512-280": 0xb343,
    "skein512-288": 0xb344,
    "skein512-296": 0xb345,
    "skein512-304": 0xb346,
    "skein512-312": 0xb347,
    "skein512-320": 0xb348,
    "skein512-328": 0xb349,
    "skein512-336": 0xb34a,
    "skein512-344": 0xb34b,
    "skein512-352": 0xb34c,
    "skein512-360": 0xb34d,
    "skein512-368": 0xb34e,
    "skein512-376": 0xb34f,
    "skein512-384": 0xb350,
    "skein512-392": 0xb351,
    "skein512-400": 0xb352,
    "skein512-408": 0xb353,
    "skein512-416": 0xb354,
    "skein512-424": 0xb355,
    "skein512-432": 0xb356,
    "skein512-440": 0xb357,
    "skein512-448": 0xb358,
    "skein512-456": 0xb359,
    "skein512-464": 0xb35a,
    "skein512-472": 0xb35b,
    "skein512-480": 0xb35c,
    "skein512-488": 0xb35d,
    "skein512-496": 0xb35e,
    "skein512-504": 0xb35f,
    "skein512-512": 0xb360,
    "skein1024-8": 0xb361,
    "skein1024-16": 0xb362,
    "skein1024-24": 0xb363,
    "skein1024-32": 0xb364,
    "skein1024-40": 0xb365,
    "skein1024-48": 0xb366,
    "skein1024-56": 0xb367,
    "skein1024-64": 0xb368,
    "skein1024-72": 0xb369,
    "skein1024-80": 0xb36a,
    "skein1024-88": 0xb36b,
    "skein1024-96": 0xb36c,
    "skein1024-104": 0xb36d,
    "skein1024-112": 0xb36e,
    "skein1024-120": 0xb36f,
    "skein1024-128": 0xb370,
    "skein1024-136": 0xb371,
    "skein1024-144": 0xb372,
    "skein1024-152": 0xb373,
    "skein1024-160": 0xb374,
    "skein1024-168": 0xb375,
    "skein1024-176": 0xb376,
    "skein1024-184": 0xb377,
    "skein1024-192": 0xb378,
    "skein1024-200": 0xb379,
    "skein1024-208": 0xb37a,
    "skein1024-216": 0xb37b,
    "skein1024-224": 0xb37c,
    "skein1024-232": 0xb37d,
    "skein1024-240": 0xb37e,
    "skein1024-248": 0xb37f,
    "skein1024-256": 0xb380,
    "skein1024-264": 0xb381,
    "skein1024-272": 0xb382,
    "skein1024-280": 0xb383,
    "skein1024-288": 0xb384,
    "skein1024-296": 0xb385,
    "skein1024-304": 0xb386,
    "skein1024-312": 0xb387,
    "skein1024-320": 0xb388,
    "skein1024-328": 0xb389,
    "skein1024-336": 0xb38a,
    "skein1024-344": 0xb38b,
    "skein1024-352": 0xb38c,
    "skein1024-360": 0xb38d,
    "skein1024-368": 0xb38e,
    "skein1024-376": 0xb38f,
    "skein1024-384": 0xb390,
    "skein1024-392": 0xb391,
    "skein1024-400": 0xb392,
    "skein1024-408": 0xb393,
    "skein1024-416": 0xb394,
    "skein1024-424": 0xb395,
    "skein1024-432": 0xb396,
    "skein1024-440": 0xb397,
    "skein1024-448": 0xb398,
    "skein1024-456": 0xb399,
    "skein1024-464": 0xb39a,
    "skein1024-472": 0xb39b,
    "skein1024-480": 0xb39c,
    "skein1024-488": 0xb39d,
    "skein1024-496": 0xb39e,
    "skein1024-504": 0xb39f,
    "skein1024-512": 0xb3a0,
    "skein1024-520": 0xb3a1,
    "skein1024-528": 0xb3a2,
    "skein1024-536": 0xb3a3,
    "skein1024-544": 0xb3a4,
    "skein1024-552": 0xb3a5,
    "skein1024-560": 0xb3a6,
    "skein1024-568": 0xb3a7,
    "skein1024-576": 0xb3a8,
    "skein1024-584": 0xb3a9,
    "skein1024-592": 0xb3aa,
    "skein1024-600": 0xb3ab,
    "skein1024-608": 0xb3ac,
    "skein1024-616": 0xb3ad,
    "skein1024-624": 0xb3ae,
    "skein1024-632": 0xb3af,
    "skein1024-640": 0xb3b0,
    "skein1024-648": 0xb3b1,
    "skein1024-656": 0xb3b2,
    "skein1024-664": 0xb3b3,
    "skein1024-672": 0xb3b4,
    "skein1024-680": 0xb3b5,
    "skein1024-688": 0xb3b6,
    "skein1024-696": 0xb3b7,
    "skein1024-704": 0xb3b8,
    "skein1024-712": 0xb3b9,
    "skein1024-720": 0xb3ba,
    "skein1024-728": 0xb3bb,
    "skein1024-736": 0xb3bc,
    "skein1024-744": 0xb3bd,
    "skein1024-752": 0xb3be,
    "skein1024-760": 0xb3bf,
    "skein1024-768": 0xb3c0,
    "skein1024-776": 0xb3c1,
    "skein1024-784": 0xb3c2,
    "skein1024-792": 0xb3c3,
    "skein1024-800": 0xb3c4,
    "skein1024-808": 0xb3c5,
    "skein1024-816": 0xb3c6,
    "skein1024-824": 0xb3c7,
    "skein1024-832": 0xb3c8,
    "skein1024-840": 0xb3c9,
    "skein1024-848": 0xb3ca,
    "skein1024-856": 0xb3cb,
    "skein1024-864": 0xb3cc,
    "skein1024-872": 0xb3cd,
    "skein1024-880": 0xb3ce,
    "skein1024-888": 0xb3cf,
    "skein1024-896": 0xb3d0,
    "skein1024-904": 0xb3d1,
    "skein1024-912": 0xb3d2,
    "skein1024-920": 0xb3d3,
    "skein1024-928": 0xb3d4,
    "skein1024-936": 0xb3d5,
    "skein1024-944": 0xb3d6,
    "skein1024-952": 0xb3d7,
    "skein1024-960": 0xb3d8,
    "skein1024-968": 0xb3d9,
    "skein1024-976": 0xb3da,
    "skein1024-984": 0xb3db,
    "skein1024-992": 0xb3dc,
    "skein1024-1000": 0xb3dd,
    "skein1024-1008": 0xb3de,
    "skein1024-1016": 0xb3df,
    "skein1024-1024": 0xb3e0,
    "poseidon-bls12_381-a2-fc1": 0xb401,
    "poseidon-bls12_381-a2-fc1-sc": 0xb402
});
module.exports = {
    names
};

},{}],"c1DbZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toString", ()=>toString);
var _basesJs = require("./util/bases.js");
var _basesJsDefault = parcelHelpers.interopDefault(_basesJs);
function toString(array, encoding = "utf8") {
    const base = (0, _basesJsDefault.default)[encoding];
    if (!base) throw new Error(`Unsupported encoding "${encoding}"`);
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
    return base.encoder.encode(array).substring(1);
}

},{"./util/bases.js":"b9FIp","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"b9FIp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basics = require("multiformats/basics");
var _allocJs = require("../alloc.js");
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec("utf8", "u", (buf)=>{
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf)=>{
    let string = "a";
    for(let i = 0; i < buf.length; i++)string += String.fromCharCode(buf[i]);
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, _allocJs.allocUnsafe)(str.length);
    for(let i = 0; i < str.length; i++)buf[i] = str.charCodeAt(i);
    return buf;
});
const BASES = {
    utf8: string,
    "utf-8": string,
    hex: (0, _basics.bases).base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...(0, _basics.bases)
};
exports.default = BASES;

},{"multiformats/basics":"gn2Yh","../alloc.js":"jsgEk","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"gn2Yh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CID", ()=>(0, _indexJs.CID));
parcelHelpers.export(exports, "hasher", ()=>(0, _indexJs.hasher));
parcelHelpers.export(exports, "digest", ()=>(0, _indexJs.digest));
parcelHelpers.export(exports, "varint", ()=>(0, _indexJs.varint));
parcelHelpers.export(exports, "bytes", ()=>(0, _indexJs.bytes));
parcelHelpers.export(exports, "hashes", ()=>hashes);
parcelHelpers.export(exports, "bases", ()=>bases);
parcelHelpers.export(exports, "codecs", ()=>codecs);
var _identityJs = require("./bases/identity.js");
var _base2Js = require("./bases/base2.js");
var _base8Js = require("./bases/base8.js");
var _base10Js = require("./bases/base10.js");
var _base16Js = require("./bases/base16.js");
var _base32Js = require("./bases/base32.js");
var _base36Js = require("./bases/base36.js");
var _base58Js = require("./bases/base58.js");
var _base64Js = require("./bases/base64.js");
var _base256EmojiJs = require("./bases/base256emoji.js");
var _sha2Js = require("./hashes/sha2.js");
var _identityJs1 = require("./hashes/identity.js");
var _rawJs = require("./codecs/raw.js");
var _jsonJs = require("./codecs/json.js");
var _indexJs = require("./index.js");
const bases = {
    ..._identityJs,
    ..._base2Js,
    ..._base8Js,
    ..._base10Js,
    ..._base16Js,
    ..._base32Js,
    ..._base36Js,
    ..._base58Js,
    ..._base64Js,
    ..._base256EmojiJs
};
const hashes = {
    ..._sha2Js,
    ..._identityJs1
};
const codecs = {
    raw: _rawJs,
    json: _jsonJs
};

},{"./bases/identity.js":"kF9cZ","./bases/base2.js":"iHDpF","./bases/base8.js":"73Eus","./bases/base10.js":"lUZso","./bases/base16.js":"juEFo","./bases/base32.js":"kGzpo","./bases/base36.js":"6xtk9","./bases/base58.js":"8bnqs","./bases/base64.js":"1Ugfr","./bases/base256emoji.js":"8lL7L","./hashes/sha2.js":"81259","./hashes/identity.js":"953ed","./codecs/raw.js":"ekFP8","./codecs/json.js":"d59re","./index.js":"8WYrI","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kF9cZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
var _baseJs = require("./base.js");
var _bytesJs = require("../bytes.js");
const identity = (0, _baseJs.from)({
    prefix: "\x00",
    name: "identity",
    encode: (buf)=>(0, _bytesJs.toString)(buf),
    decode: (str)=>(0, _bytesJs.fromString)(str)
});

},{"./base.js":"afkwi","../bytes.js":"bcEhf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"afkwi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "or", ()=>or);
parcelHelpers.export(exports, "Codec", ()=>Codec);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "baseX", ()=>baseX);
parcelHelpers.export(exports, "rfc4648", ()=>rfc4648);
var _baseXJs = require("../../vendor/base-x.js");
var _baseXJsDefault = parcelHelpers.interopDefault(_baseXJs);
var _bytesJs = require("../bytes.js");
class Encoder {
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) return `${this.prefix}${this.baseEncode(bytes)}`;
        else throw Error("Unknown type, must be binary type");
    }
}
class Decoder {
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === undefined) throw new Error("Invalid prefix character");
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(text.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) return decoder.decode(input);
        else throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
}
const or = (left, right)=>new ComposedDecoder({
        ...left.decoders || {
            [left.prefix]: left
        },
        ...right.decoders || {
            [right.prefix]: right
        }
    });
class Codec {
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
const from = ({ name, prefix, encode, decode })=>new Codec(name, prefix, encode, decode);
const baseX = ({ prefix, name, alphabet })=>{
    const { encode, decode } = (0, _baseXJsDefault.default)(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>(0, _bytesJs.coerce)(decode(text))
    });
};
const decode = (string, alphabet, bitsPerChar, name)=>{
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i)codes[alphabet[i]] = i;
    let end = string.length;
    while(string[end - 1] === "=")--end;
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for(let i = 0; i < end; ++i){
        const value = codes[string[i]];
        if (value === undefined) throw new SyntaxError(`Non-${name} character`);
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
        }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) throw new SyntaxError("Unexpected end of data");
    return out;
};
const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for(let i = 0; i < data.length; ++i){
        buffer = buffer << 8 | data[i];
        bits += 8;
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    if (bits) out += alphabet[mask & buffer << bitsPerChar - bits];
    if (pad) while(out.length * bitsPerChar & 7)out += "=";
    return out;
};
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet })=>{
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
};

},{"../../vendor/base-x.js":"J3rUa","../bytes.js":"bcEhf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"J3rUa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        else if (Array.isArray(source)) source = Uint8Array.from(source);
        if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (source.length === 0) return "";
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while(pbegin !== pend){
            var carry = source[pbegin];
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return new Uint8Array();
        var psz = 0;
        if (source[psz] === " ") return;
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while(source[psz]){
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        if (source[psz] === " ") return;
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
exports.default = _brrp__multiformats_scope_baseX;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bcEhf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "isBinary", ()=>isBinary);
parcelHelpers.export(exports, "fromHex", ()=>fromHex);
parcelHelpers.export(exports, "toHex", ()=>toHex);
parcelHelpers.export(exports, "fromString", ()=>fromString);
parcelHelpers.export(exports, "toString", ()=>toString);
parcelHelpers.export(exports, "empty", ()=>empty);
const empty = new Uint8Array(0);
const toHex = (d)=>d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, "0"), "");
const fromHex = (hex)=>{
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
};
const equals = (aa, bb)=>{
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) return false;
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) return false;
    }
    return true;
};
const coerce = (o)=>{
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    throw new Error("Unknown type, must be binary type");
};
const isBinary = (o)=>o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = (str)=>new TextEncoder().encode(str);
const toString = (b)=>new TextDecoder().decode(b);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iHDpF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base2", ()=>base2);
var _baseJs = require("./base.js");
const base2 = (0, _baseJs.rfc4648)({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"73Eus":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base8", ()=>base8);
var _baseJs = require("./base.js");
const base8 = (0, _baseJs.rfc4648)({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"lUZso":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base10", ()=>base10);
var _baseJs = require("./base.js");
const base10 = (0, _baseJs.baseX)({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"juEFo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base16", ()=>base16);
parcelHelpers.export(exports, "base16upper", ()=>base16upper);
var _baseJs = require("./base.js");
const base16 = (0, _baseJs.rfc4648)({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
});
const base16upper = (0, _baseJs.rfc4648)({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kGzpo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base32", ()=>base32);
parcelHelpers.export(exports, "base32upper", ()=>base32upper);
parcelHelpers.export(exports, "base32pad", ()=>base32pad);
parcelHelpers.export(exports, "base32padupper", ()=>base32padupper);
parcelHelpers.export(exports, "base32hex", ()=>base32hex);
parcelHelpers.export(exports, "base32hexupper", ()=>base32hexupper);
parcelHelpers.export(exports, "base32hexpad", ()=>base32hexpad);
parcelHelpers.export(exports, "base32hexpadupper", ()=>base32hexpadupper);
parcelHelpers.export(exports, "base32z", ()=>base32z);
var _baseJs = require("./base.js");
const base32 = (0, _baseJs.rfc4648)({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
});
const base32upper = (0, _baseJs.rfc4648)({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
});
const base32pad = (0, _baseJs.rfc4648)({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
});
const base32padupper = (0, _baseJs.rfc4648)({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
});
const base32hex = (0, _baseJs.rfc4648)({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
});
const base32hexupper = (0, _baseJs.rfc4648)({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
});
const base32hexpad = (0, _baseJs.rfc4648)({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
});
const base32hexpadupper = (0, _baseJs.rfc4648)({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
});
const base32z = (0, _baseJs.rfc4648)({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"6xtk9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base36", ()=>base36);
parcelHelpers.export(exports, "base36upper", ()=>base36upper);
var _baseJs = require("./base.js");
const base36 = (0, _baseJs.baseX)({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = (0, _baseJs.baseX)({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8bnqs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base58btc", ()=>base58btc);
parcelHelpers.export(exports, "base58flickr", ()=>base58flickr);
var _baseJs = require("./base.js");
const base58btc = (0, _baseJs.baseX)({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = (0, _baseJs.baseX)({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1Ugfr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64", ()=>base64);
parcelHelpers.export(exports, "base64pad", ()=>base64pad);
parcelHelpers.export(exports, "base64url", ()=>base64url);
parcelHelpers.export(exports, "base64urlpad", ()=>base64urlpad);
var _baseJs = require("./base.js");
const base64 = (0, _baseJs.rfc4648)({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
});
const base64pad = (0, _baseJs.rfc4648)({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
});
const base64url = (0, _baseJs.rfc4648)({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
});
const base64urlpad = (0, _baseJs.rfc4648)({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8lL7L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base256emoji", ()=>base256emoji);
var _baseJs = require("./base.js");
const alphabet = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    p[c.codePointAt(0)] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, "");
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) throw new Error(`Non-base256emoji character: ${char}`);
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0, _baseJs.from)({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode,
    decode
});

},{"./base.js":"afkwi","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"81259":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha512", ()=>sha512);
var _hasherJs = require("./hasher.js");
const sha = (name)=>async (data)=>new Uint8Array(await crypto.subtle.digest(name, data));
const sha256 = (0, _hasherJs.from)({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
});
const sha512 = (0, _hasherJs.from)({
    name: "sha2-512",
    code: 19,
    encode: sha("SHA-512")
});

},{"./hasher.js":"8bFGT","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8bFGT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "Hasher", ()=>Hasher);
var _digestJs = require("./digest.js");
const from = ({ name, code, encode })=>new Hasher(name, code, encode);
class Hasher {
    constructor(name, code, encode){
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? _digestJs.create(this.code, result) : result.then((digest)=>_digestJs.create(this.code, digest));
        } else throw Error("Unknown type, must be binary type");
    }
}

},{"./digest.js":"1NYq0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"1NYq0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "Digest", ()=>Digest);
var _bytesJs = require("../bytes.js");
var _varintJs = require("../varint.js");
const create = (code, digest)=>{
    const size = digest.byteLength;
    const sizeOffset = _varintJs.encodingLength(code);
    const digestOffset = sizeOffset + _varintJs.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    _varintJs.encodeTo(code, bytes, 0);
    _varintJs.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
};
const decode = (multihash)=>{
    const bytes = (0, _bytesJs.coerce)(multihash);
    const [code, sizeOffset] = _varintJs.decode(bytes);
    const [size, digestOffset] = _varintJs.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) throw new Error("Incorrect length");
    return new Digest(code, size, digest, bytes);
};
const equals = (a, b)=>{
    if (a === b) return true;
    else return a.code === b.code && a.size === b.size && (0, _bytesJs.equals)(a.bytes, b.bytes);
};
class Digest {
    constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}

},{"../bytes.js":"bcEhf","../varint.js":"iIlxc","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iIlxc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encodeTo", ()=>encodeTo);
parcelHelpers.export(exports, "encodingLength", ()=>encodingLength);
var _varintJs = require("../vendor/varint.js");
var _varintJsDefault = parcelHelpers.interopDefault(_varintJs);
const decode = (data, offset = 0)=>{
    const code = (0, _varintJsDefault.default).decode(data, offset);
    return [
        code,
        (0, _varintJsDefault.default).decode.bytes
    ];
};
const encodeTo = (int, target, offset = 0)=>{
    (0, _varintJsDefault.default).encode(int, target, offset);
    return target;
};
const encodingLength = (int)=>{
    return (0, _varintJsDefault.default).encodingLength(int);
};

},{"../vendor/varint.js":"bPkON","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"bPkON":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var encode_1 = encode;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 255 | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
exports.default = _brrp_varint;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"953ed":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
var _bytesJs = require("../bytes.js");
var _digestJs = require("./digest.js");
const code = 0;
const name = "identity";
const encode = (0, _bytesJs.coerce);
const digest = (input)=>_digestJs.create(code, encode(input));
const identity = {
    code,
    name,
    encode,
    digest
};

},{"../bytes.js":"bcEhf","./digest.js":"1NYq0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"ekFP8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "name", ()=>name);
parcelHelpers.export(exports, "code", ()=>code);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _bytesJs = require("../bytes.js");
const name = "raw";
const code = 85;
const encode = (node)=>(0, _bytesJs.coerce)(node);
const decode = (data)=>(0, _bytesJs.coerce)(data);

},{"../bytes.js":"bcEhf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"d59re":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "name", ()=>name);
parcelHelpers.export(exports, "code", ()=>code);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = "json";
const code = 512;
const encode = (node)=>textEncoder.encode(JSON.stringify(node));
const decode = (data)=>JSON.parse(textDecoder.decode(data));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"8WYrI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CID", ()=>(0, _cidJs.CID));
parcelHelpers.export(exports, "hasher", ()=>_hasherJs);
parcelHelpers.export(exports, "digest", ()=>_digestJs);
parcelHelpers.export(exports, "varint", ()=>_varintJs);
parcelHelpers.export(exports, "bytes", ()=>_bytesJs);
var _cidJs = require("./cid.js");
var _varintJs = require("./varint.js");
var _bytesJs = require("./bytes.js");
var _hasherJs = require("./hashes/hasher.js");
var _digestJs = require("./hashes/digest.js");

},{"./cid.js":"eSGPf","./varint.js":"iIlxc","./bytes.js":"bcEhf","./hashes/hasher.js":"8bFGT","./hashes/digest.js":"1NYq0","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"eSGPf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CID", ()=>CID);
var _varintJs = require("./varint.js");
var _digestJs = require("./hashes/digest.js");
var _base58Js = require("./bases/base58.js");
var _base32Js = require("./bases/base32.js");
var _bytesJs = require("./bytes.js");
class CID {
    constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = new Map();
        Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
        });
    }
    toV0() {
        switch(this.version){
            case 0:
                return this;
            default:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                    if (multihash.code !== SHA_256_CODE) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                    return CID.createV0(multihash);
                }
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = _digestJs.create(code, digest);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                return this;
            default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
    }
    equals(other) {
        return other && this.code === other.code && this.version === other.version && _digestJs.equals(this.multihash, other.multihash);
    }
    toString(base) {
        const { bytes, version, _baseCache } = this;
        switch(version){
            case 0:
                return toStringV0(bytes, _baseCache, base || (0, _base58Js.base58btc).encoder);
            default:
                return toStringV1(bytes, _baseCache, base || (0, _base32Js.base32).encoder);
        }
    }
    toJSON() {
        return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
        };
    }
    get [Symbol.toStringTag]() {
        return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
    }
    get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
    }
    get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
        throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
        if (value instanceof CID) return value;
        else if (value != null && value.asCID === value) {
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
            const { version, multihash, code } = value;
            const digest = _digestJs.decode(multihash);
            return CID.create(version, code, digest);
        } else return null;
    }
    static create(version, code, digest) {
        if (typeof code !== "number") throw new Error("String codecs are no longer supported");
        switch(version){
            case 0:
                if (code !== DAG_PB_CODE) throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                else return new CID(version, code, digest, digest.bytes);
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                throw new Error("Invalid version");
        }
    }
    static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) throw new Error("Incorrect length");
        return cid;
    }
    static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0, _bytesJs.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) throw new Error("Incorrect length");
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new _digestJs.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
            cid,
            bytes.subarray(specs.size)
        ];
    }
    static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = _varintJs.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            version = 0;
            offset = 0;
        } else if (version === 1) codec = next();
        if (version !== 0 && version !== 1) throw new RangeError(`Invalid CID version ${version}`);
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
    }
}
const parseCIDtoBytes = (source, base)=>{
    switch(source[0]){
        case "Q":
            {
                const decoder = base || (0, _base58Js.base58btc);
                return [
                    (0, _base58Js.base58btc).prefix,
                    decoder.decode(`${(0, _base58Js.base58btc).prefix}${source}`)
                ];
            }
        case (0, _base58Js.base58btc).prefix:
            {
                const decoder = base || (0, _base58Js.base58btc);
                return [
                    (0, _base58Js.base58btc).prefix,
                    decoder.decode(source)
                ];
            }
        case (0, _base32Js.base32).prefix:
            {
                const decoder = base || (0, _base32Js.base32);
                return [
                    (0, _base32Js.base32).prefix,
                    decoder.decode(source)
                ];
            }
        default:
            if (base == null) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            return [
                source[0],
                base.decode(source)
            ];
    }
};
const toStringV0 = (bytes, cache, base)=>{
    const { prefix } = base;
    if (prefix !== (0, _base58Js.base58btc).prefix) throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else return cid;
};
const toStringV1 = (bytes, cache, base)=>{
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else return cid;
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash)=>{
    const codeOffset = _varintJs.encodingLength(version);
    const hashOffset = codeOffset + _varintJs.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    _varintJs.encodeTo(version, bytes, 0);
    _varintJs.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const readonly = {
    writable: false,
    configurable: false,
    enumerable: true
};
const hidden = {
    writable: false,
    enumerable: false,
    configurable: false
};
const version = "0.0.0-dev";
const deprecate = (range, message)=>{
    if (range.test(version)) console.warn(message);
    else throw new Error(message);
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

},{"./varint.js":"iIlxc","./hashes/digest.js":"1NYq0","./bases/base58.js":"8bnqs","./bases/base32.js":"kGzpo","./bytes.js":"bcEhf","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"jsgEk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alloc", ()=>alloc);
parcelHelpers.export(exports, "allocUnsafe", ()=>allocUnsafe);
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function alloc(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.alloc(size));
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.allocUnsafe(size));
    return new Uint8Array(size);
}

},{"./util/as-uint8array.js":"iX9t1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iX9t1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asUint8Array", ()=>asUint8Array);
function asUint8Array(buf) {
    if (globalThis.Buffer != null) return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    return buf;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"56rLd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromString", ()=>fromString);
var _basesJs = require("./util/bases.js");
var _basesJsDefault = parcelHelpers.interopDefault(_basesJs);
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function fromString(string, encoding = "utf8") {
    const base = (0, _basesJsDefault.default)[encoding];
    if (!base) throw new Error(`Unsupported encoding "${encoding}"`);
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) return (0, _asUint8ArrayJs.asUint8Array)(globalThis.Buffer.from(string, "utf-8"));
    return base.decoder.decode(`${base.prefix}${string}`);
}

},{"./util/bases.js":"b9FIp","./util/as-uint8array.js":"iX9t1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"4DDcb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
var _allocJs = require("./alloc.js");
var _asUint8ArrayJs = require("./util/as-uint8array.js");
function concat(arrays, length) {
    if (!length) length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    const output = (0, _allocJs.allocUnsafe)(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, _asUint8ArrayJs.asUint8Array)(output);
}

},{"./alloc.js":"jsgEk","./util/as-uint8array.js":"iX9t1","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"3wAWO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mbdecoder", ()=>mbdecoder);
parcelHelpers.export(exports, "getLocalFingerprint", ()=>getLocalFingerprint);
parcelHelpers.export(exports, "getFingerprintFromSdp", ()=>getFingerprintFromSdp);
// Extract the certhash from a multiaddr
parcelHelpers.export(exports, "certhash", ()=>certhash);
/**
 * Convert a certhash into a multihash
 */ parcelHelpers.export(exports, "decodeCerthash", ()=>decodeCerthash);
/**
 * Extract the fingerprint from a multiaddr
 */ parcelHelpers.export(exports, "ma2Fingerprint", ()=>ma2Fingerprint);
/**
 * Normalize the hash name from a given multihash has name
 */ parcelHelpers.export(exports, "toSupportedHashFunction", ()=>toSupportedHashFunction);
/**
 * Create an answer SDP from a multiaddr
 */ parcelHelpers.export(exports, "fromMultiAddr", ()=>fromMultiAddr);
/**
 * Replace (munge) the ufrag and password values in a SDP
 */ parcelHelpers.export(exports, "munge", ()=>munge);
var _basics = require("multiformats/basics");
var _multihashes = require("multihashes");
var _errorJs = require("../error.js");
var _transportJs = require("./transport.js");
const mbdecoder = Object.values((0, _basics.bases)).map((b)=>b.decoder).reduce((d, b)=>d.or(b));
function getLocalFingerprint(pc, options) {
    // try to fetch fingerprint from local certificate
    const localCert = pc.getConfiguration().certificates?.at(0);
    if (localCert == null || localCert.getFingerprints == null) {
        options.log.trace("fetching fingerprint from local SDP");
        const localDescription = pc.localDescription;
        if (localDescription == null) return undefined;
        return getFingerprintFromSdp(localDescription.sdp);
    }
    options.log.trace("fetching fingerprint from local certificate");
    if (localCert.getFingerprints().length === 0) return undefined;
    const fingerprint = localCert.getFingerprints()[0].value;
    if (fingerprint == null) throw (0, _errorJs.invalidFingerprint)("", "no fingerprint on local certificate");
    return fingerprint;
}
const fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
    const searchResult = sdp.match(fingerprintRegex);
    return searchResult?.groups?.fingerprint;
}
/**
 * Get base2 | identity decoders
 */ function ipv(ma) {
    for (const proto of ma.protoNames()){
        if (proto.startsWith("ip")) return proto.toUpperCase();
    }
    return "IP6";
}
function certhash(ma) {
    const tups = ma.stringTuples();
    const certhash = tups.filter((tup)=>tup[0] === (0, _transportJs.CERTHASH_CODE)).map((tup)=>tup[1])[0];
    if (certhash === undefined || certhash === "") throw (0, _errorJs.inappropriateMultiaddr)(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
    return certhash;
}
function decodeCerthash(certhash) {
    const mbdecoded = mbdecoder.decode(certhash);
    return _multihashes.decode(mbdecoded);
}
function ma2Fingerprint(ma) {
    const mhdecoded = decodeCerthash(certhash(ma));
    const prefix = toSupportedHashFunction(mhdecoded.name);
    const fingerprint = mhdecoded.digest.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0"), "");
    const sdp = fingerprint.match(/.{1,2}/g);
    if (sdp == null) throw (0, _errorJs.invalidFingerprint)(fingerprint, ma.toString());
    return [
        `${prefix.toUpperCase()} ${sdp.join(":").toUpperCase()}`,
        fingerprint
    ];
}
function toSupportedHashFunction(name) {
    switch(name){
        case "sha1":
            return "sha-1";
        case "sha2-256":
            return "sha-256";
        case "sha2-512":
            return "sha-512";
        default:
            throw (0, _errorJs.unsupportedHashAlgorithm)(name);
    }
}
/**
 * Convert a multiaddr into a SDP
 */ function ma2sdp(ma, ufrag) {
    const { host, port } = ma.toOptions();
    const ipVersion = ipv(ma);
    const [CERTFP] = ma2Fingerprint(ma);
    return `v=0
o=- 0 0 IN ${ipVersion} ${host}
s=-
c=IN ${ipVersion} ${host}
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${CERTFP}
a=sctp-port:5000
a=max-message-size:16384
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\r\n`;
}
function fromMultiAddr(ma, ufrag) {
    return {
        type: "answer",
        sdp: ma2sdp(ma, ufrag)
    };
}
function munge(desc, ufrag) {
    if (desc.sdp === undefined) throw (0, _errorJs.invalidArgument)("Can't munge a missing SDP");
    desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + "\n").replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + "\n");
    return desc;
}

},{"multiformats/basics":"W6yRG","multihashes":"33JRe","../error.js":"2kM5A","./transport.js":"cqpAP","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"caxeF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "genUfrag", ()=>genUfrag);
const charset = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
const genUfrag = (len)=>[
        ...Array(len)
    ].map(()=>charset.at(Math.floor(Math.random() * charset.length))).join("");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"aE1n7":[function(require,module,exports) {
/**
 * @packageDocumentation
 *
 * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on the TCP networking stack.
 *
 * @example
 *
 * ```TypeScript
 * import { tcp } from '@libp2p/tcp'
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { pipe } from 'it-pipe'
 * import all from 'it-all'
 *
 * // A simple upgrader that just returns the MultiaddrConnection
 * const upgrader = {
 *   upgradeInbound: async maConn => maConn,
 *   upgradeOutbound: async maConn => maConn
 * }
 *
 * const transport = tcp()()
 *
 * const listener = transport.createListener({
 *   upgrader,
 *   handler: (socket) => {
 *     console.log('new connection opened')
 *     pipe(
 *       ['hello', ' ', 'World!'],
 *       socket
 *     )
 *   }
 * })
 *
 * const addr = multiaddr('/ip4/127.0.0.1/tcp/9090')
 * await listener.listen(addr)
 * console.log('listening')
 *
 * const socket = await transport.dial(addr, { upgrader })
 * const values = await pipe(
 *   socket,
 *   all
 * )
 * console.log(`Value: ${values.toString()}`)
 *
 * // Close connection after reading
 * await listener.close()
 * ```
 *
 * Outputs:
 *
 * ```sh
 * listening
 * new connection opened
 * Value: hello World!
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tcp", ()=>tcp);
var _net = require("net");
var _netDefault = parcelHelpers.interopDefault(_net);
var _interface = require("@libp2p/interface");
var _mafmt = require("@multiformats/mafmt");
var _constantsJs = require("./constants.js");
var _listenerJs = require("./listener.js");
var _socketToConnJs = require("./socket-to-conn.js");
var _utilsJs = require("./utils.js");
class TCP {
    opts;
    metrics;
    components;
    log;
    constructor(components, options = {}){
        this.log = components.logger.forComponent("libp2p:tcp");
        this.opts = options;
        this.components = components;
        if (components.metrics != null) this.metrics = {
            dialerEvents: components.metrics.registerCounterGroup("libp2p_tcp_dialer_events_total", {
                label: "event",
                help: "Total count of TCP dialer events by type"
            })
        };
    }
    [(0, _interface.transportSymbol)] = true;
    [Symbol.toStringTag] = "@libp2p/tcp";
    async dial(ma, options) {
        options.keepAlive = options.keepAlive ?? true;
        options.noDelay = options.noDelay ?? true;
        // options.signal destroys the socket before 'connect' event
        const socket = await this._connect(ma, options);
        // Avoid uncaught errors caused by unstable connections
        socket.on("error", (err)=>{
            this.log("socket error", err);
        });
        const maConn = (0, _socketToConnJs.toMultiaddrConnection)(socket, {
            remoteAddr: ma,
            socketInactivityTimeout: this.opts.outboundSocketInactivityTimeout,
            socketCloseTimeout: this.opts.socketCloseTimeout,
            metrics: this.metrics?.dialerEvents,
            logger: this.components.logger
        });
        const onAbort = ()=>{
            maConn.close().catch((err)=>{
                this.log.error("Error closing maConn after abort", err);
            });
        };
        options.signal?.addEventListener("abort", onAbort, {
            once: true
        });
        this.log("new outbound connection %s", maConn.remoteAddr);
        const conn = await options.upgrader.upgradeOutbound(maConn);
        this.log("outbound connection %s upgraded", maConn.remoteAddr);
        options.signal?.removeEventListener("abort", onAbort);
        if (options.signal?.aborted === true) {
            conn.close().catch((err)=>{
                this.log.error("Error closing conn after abort", err);
            });
            throw new (0, _interface.AbortError)();
        }
        return conn;
    }
    async _connect(ma, options) {
        if (options.signal?.aborted === true) throw new (0, _interface.AbortError)();
        return new Promise((resolve, reject)=>{
            const start = Date.now();
            const cOpts = (0, _utilsJs.multiaddrToNetConfig)(ma, {
                ...this.opts.dialOpts ?? {},
                ...options
            });
            this.log("dialing %a", ma);
            const rawSocket = (0, _netDefault.default).connect(cOpts);
            const onError = (err)=>{
                const cOptsStr = cOpts.path ?? `${cOpts.host ?? ""}:${cOpts.port}`;
                err.message = `connection error ${cOptsStr}: ${err.message}`;
                this.metrics?.dialerEvents.increment({
                    error: true
                });
                done(err);
            };
            const onTimeout = ()=>{
                this.log("connection timeout %a", ma);
                this.metrics?.dialerEvents.increment({
                    timeout: true
                });
                const err = new (0, _interface.CodeError)(`connection timeout after ${Date.now() - start}ms`, "ERR_CONNECT_TIMEOUT");
                // Note: this will result in onError() being called
                rawSocket.emit("error", err);
            };
            const onConnect = ()=>{
                this.log("connection opened %a", ma);
                this.metrics?.dialerEvents.increment({
                    connect: true
                });
                done();
            };
            const onAbort = ()=>{
                this.log("connection aborted %a", ma);
                this.metrics?.dialerEvents.increment({
                    abort: true
                });
                rawSocket.destroy();
                done(new (0, _interface.AbortError)());
            };
            const done = (err)=>{
                rawSocket.removeListener("error", onError);
                rawSocket.removeListener("timeout", onTimeout);
                rawSocket.removeListener("connect", onConnect);
                if (options.signal != null) options.signal.removeEventListener("abort", onAbort);
                if (err != null) {
                    reject(err);
                    return;
                }
                resolve(rawSocket);
            };
            rawSocket.on("error", onError);
            rawSocket.on("timeout", onTimeout);
            rawSocket.on("connect", onConnect);
            if (options.signal != null) options.signal.addEventListener("abort", onAbort);
        });
    }
    /**
     * Creates a TCP listener. The provided `handler` function will be called
     * anytime a new incoming Connection has been successfully upgraded via
     * `upgrader.upgradeInbound`.
     */ createListener(options) {
        return new (0, _listenerJs.TCPListener)({
            ...this.opts.listenOpts ?? {},
            ...options,
            maxConnections: this.opts.maxConnections,
            backlog: this.opts.backlog,
            closeServerOnMaxConnections: this.opts.closeServerOnMaxConnections,
            socketInactivityTimeout: this.opts.inboundSocketInactivityTimeout,
            socketCloseTimeout: this.opts.socketCloseTimeout,
            metrics: this.components.metrics,
            logger: this.components.logger
        });
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid TCP addresses
     */ filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [
            multiaddrs
        ];
        return multiaddrs.filter((ma)=>{
            if (ma.protoCodes().includes((0, _constantsJs.CODE_CIRCUIT))) return false;
            if (ma.protoCodes().includes((0, _constantsJs.CODE_UNIX))) return true;
            return _mafmt.TCP.matches(ma.decapsulateCode((0, _constantsJs.CODE_P2P)));
        });
    }
}
function tcp(init = {}) {
    return (components)=>{
        return new TCP(components, init);
    };
}

},{"net":"bXKEI","@libp2p/interface":"b14bx","@multiformats/mafmt":"djvEe","./constants.js":"iXcJi","./listener.js":"kMUVQ","./socket-to-conn.js":"23NBN","./utils.js":"ixvqo","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"iXcJi":[function(require,module,exports) {
// p2p multi-address code
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CODE_P2P", ()=>CODE_P2P);
parcelHelpers.export(exports, "CODE_CIRCUIT", ()=>CODE_CIRCUIT);
parcelHelpers.export(exports, "CODE_UNIX", ()=>CODE_UNIX);
parcelHelpers.export(exports, "CLOSE_TIMEOUT", ()=>CLOSE_TIMEOUT);
parcelHelpers.export(exports, "SOCKET_TIMEOUT", ()=>SOCKET_TIMEOUT);
const CODE_P2P = 421;
const CODE_CIRCUIT = 290;
const CODE_UNIX = 400;
const CLOSE_TIMEOUT = 500;
const SOCKET_TIMEOUT = 300000; // 5 mins

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"kMUVQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TCPListener", ()=>TCPListener);
var _net = require("net");
var _netDefault = parcelHelpers.interopDefault(_net);
var _interface = require("@libp2p/interface");
var _constantsJs = require("./constants.js");
var _socketToConnJs = require("./socket-to-conn.js");
var _utilsJs = require("./utils.js");
/**
 * Attempts to close the given maConn. If a failure occurs, it will be logged
 */ async function attemptClose(maConn, options) {
    try {
        await maConn.close();
    } catch (err) {
        options.log.error("an error occurred closing the connection", err);
    }
}
var TCPListenerStatusCode;
(function(TCPListenerStatusCode) {
    /**
     * When server object is initialized but we don't know the listening address yet or
     * the server object is stopped manually, can be resumed only by calling listen()
     **/ TCPListenerStatusCode[TCPListenerStatusCode["INACTIVE"] = 0] = "INACTIVE";
    TCPListenerStatusCode[TCPListenerStatusCode["ACTIVE"] = 1] = "ACTIVE";
    /* During the connection limits */ TCPListenerStatusCode[TCPListenerStatusCode["PAUSED"] = 2] = "PAUSED";
})(TCPListenerStatusCode || (TCPListenerStatusCode = {}));
class TCPListener extends (0, _interface.TypedEventEmitter) {
    context;
    server;
    /** Keep track of open connections to destroy in case of timeout */ connections = new Set();
    status = {
        code: TCPListenerStatusCode.INACTIVE
    };
    metrics;
    addr;
    log;
    constructor(context){
        super();
        this.context = context;
        context.keepAlive = context.keepAlive ?? true;
        context.noDelay = context.noDelay ?? true;
        this.log = context.logger.forComponent("libp2p:tcp:listener");
        this.addr = "unknown";
        this.server = (0, _netDefault.default).createServer(context, this.onSocket.bind(this));
        // https://nodejs.org/api/net.html#servermaxconnections
        // If set reject connections when the server's connection count gets high
        // Useful to prevent too resource exhaustion via many open connections on high bursts of activity
        if (context.maxConnections !== undefined) this.server.maxConnections = context.maxConnections;
        if (context.closeServerOnMaxConnections != null) {
            // Sanity check options
            if (context.closeServerOnMaxConnections.closeAbove < context.closeServerOnMaxConnections.listenBelow) throw new (0, _interface.CodeError)("closeAbove must be >= listenBelow", "ERROR_CONNECTION_LIMITS");
        }
        this.server.on("listening", ()=>{
            if (context.metrics != null) {
                // we are listening, register metrics for our port
                const address = this.server.address();
                if (address == null) this.addr = "unknown";
                else if (typeof address === "string") // unix socket
                this.addr = address;
                else this.addr = `${address.address}:${address.port}`;
                context.metrics?.registerMetricGroup("libp2p_tcp_inbound_connections_total", {
                    label: "address",
                    help: "Current active connections in TCP listener",
                    calculate: ()=>{
                        return {
                            [this.addr]: this.connections.size
                        };
                    }
                });
                this.metrics = {
                    status: context.metrics.registerMetricGroup("libp2p_tcp_listener_status_info", {
                        label: "address",
                        help: "Current status of the TCP listener socket"
                    }),
                    errors: context.metrics.registerMetricGroup("libp2p_tcp_listener_errors_total", {
                        label: "address",
                        help: "Total count of TCP listener errors by type"
                    }),
                    events: context.metrics.registerMetricGroup("libp2p_tcp_listener_events_total", {
                        label: "address",
                        help: "Total count of TCP listener events by type"
                    })
                };
                this.metrics?.status.update({
                    [this.addr]: TCPListenerStatusCode.ACTIVE
                });
            }
            this.dispatchEvent(new (0, _interface.CustomEvent)("listening"));
        }).on("error", (err)=>{
            this.metrics?.errors.increment({
                [`${this.addr} listen_error`]: true
            });
            this.dispatchEvent(new (0, _interface.CustomEvent)("error", {
                detail: err
            }));
        }).on("close", ()=>{
            this.metrics?.status.update({
                [this.addr]: this.status.code
            });
            // If this event is emitted, the transport manager will remove the listener from it's cache
            // in the meanwhile if the connections are dropped then listener will start listening again
            // and the transport manager will not be able to close the server
            if (this.status.code !== TCPListenerStatusCode.PAUSED) this.dispatchEvent(new (0, _interface.CustomEvent)("close"));
        });
    }
    onSocket(socket) {
        if (this.status.code !== TCPListenerStatusCode.ACTIVE) throw new (0, _interface.CodeError)("Server is is not listening yet", "ERR_SERVER_NOT_RUNNING");
        // Avoid uncaught errors caused by unstable connections
        socket.on("error", (err)=>{
            this.log("socket error", err);
            this.metrics?.events.increment({
                [`${this.addr} error`]: true
            });
        });
        let maConn;
        try {
            maConn = (0, _socketToConnJs.toMultiaddrConnection)(socket, {
                listeningAddr: this.status.listeningAddr,
                socketInactivityTimeout: this.context.socketInactivityTimeout,
                socketCloseTimeout: this.context.socketCloseTimeout,
                metrics: this.metrics?.events,
                metricPrefix: `${this.addr} `,
                logger: this.context.logger
            });
        } catch (err) {
            this.log.error("inbound connection failed", err);
            this.metrics?.errors.increment({
                [`${this.addr} inbound_to_connection`]: true
            });
            return;
        }
        this.log("new inbound connection %s", maConn.remoteAddr);
        try {
            this.context.upgrader.upgradeInbound(maConn).then((conn)=>{
                this.log("inbound connection upgraded %s", maConn.remoteAddr);
                this.connections.add(maConn);
                socket.once("close", ()=>{
                    this.connections.delete(maConn);
                    if (this.context.closeServerOnMaxConnections != null && this.connections.size < this.context.closeServerOnMaxConnections.listenBelow) // The most likely case of error is if the port taken by this application is binded by
                    // another process during the time the server if closed. In that case there's not much
                    // we can do. resume() will be called again every time a connection is dropped, which
                    // acts as an eventual retry mechanism. onListenError allows the consumer act on this.
                    this.resume().catch((e)=>{
                        this.log.error("error attempting to listen server once connection count under limit", e);
                        this.context.closeServerOnMaxConnections?.onListenError?.(e);
                    });
                });
                if (this.context.handler != null) this.context.handler(conn);
                if (this.context.closeServerOnMaxConnections != null && this.connections.size >= this.context.closeServerOnMaxConnections.closeAbove) this.pause(false).catch((e)=>{
                    this.log.error("error attempting to close server once connection count over limit", e);
                });
                this.dispatchEvent(new (0, _interface.CustomEvent)("connection", {
                    detail: conn
                }));
            }).catch(async (err)=>{
                this.log.error("inbound connection failed", err);
                this.metrics?.errors.increment({
                    [`${this.addr} inbound_upgrade`]: true
                });
                await attemptClose(maConn, {
                    log: this.log
                });
            }).catch((err)=>{
                this.log.error("closing inbound connection failed", err);
            });
        } catch (err) {
            this.log.error("inbound connection failed", err);
            attemptClose(maConn, {
                log: this.log
            }).catch((err)=>{
                this.log.error("closing inbound connection failed", err);
                this.metrics?.errors.increment({
                    [`${this.addr} inbound_closing_failed`]: true
                });
            });
        }
    }
    getAddrs() {
        if (this.status.code === TCPListenerStatusCode.INACTIVE) return [];
        let addrs = [];
        const address = this.server.address();
        const { listeningAddr, peerId } = this.status;
        if (address == null) return [];
        if (typeof address === "string") addrs = [
            listeningAddr
        ];
        else try {
            // Because TCP will only return the IPv6 version
            // we need to capture from the passed multiaddr
            if (listeningAddr.toString().startsWith("/ip4")) addrs = addrs.concat((0, _utilsJs.getMultiaddrs)("ip4", address.address, address.port));
            else if (address.family === "IPv6") addrs = addrs.concat((0, _utilsJs.getMultiaddrs)("ip6", address.address, address.port));
        } catch (err) {
            this.log.error("could not turn %s:%s into multiaddr", address.address, address.port, err);
        }
        return addrs.map((ma)=>peerId != null ? ma.encapsulate(`/p2p/${peerId}`) : ma);
    }
    async listen(ma) {
        if (this.status.code === TCPListenerStatusCode.ACTIVE || this.status.code === TCPListenerStatusCode.PAUSED) throw new (0, _interface.CodeError)("server is already listening", "ERR_SERVER_ALREADY_LISTENING");
        const peerId = ma.getPeerId();
        const listeningAddr = peerId == null ? ma.decapsulateCode((0, _constantsJs.CODE_P2P)) : ma;
        const { backlog } = this.context;
        try {
            this.status = {
                code: TCPListenerStatusCode.ACTIVE,
                listeningAddr,
                peerId,
                netConfig: (0, _utilsJs.multiaddrToNetConfig)(listeningAddr, {
                    backlog
                })
            };
            await this.resume();
        } catch (err) {
            this.status = {
                code: TCPListenerStatusCode.INACTIVE
            };
            throw err;
        }
    }
    async close() {
        // Close connections and server the same time to avoid any race condition
        await Promise.all([
            Promise.all(Array.from(this.connections.values()).map(async (maConn)=>attemptClose(maConn, {
                    log: this.log
                }))),
            this.pause(true).catch((e)=>{
                this.log.error("error attempting to close server once connection count over limit", e);
            })
        ]);
    }
    /**
     * Can resume a stopped or start an inert server
     */ async resume() {
        if (this.server.listening || this.status.code === TCPListenerStatusCode.INACTIVE) return;
        const netConfig = this.status.netConfig;
        await new Promise((resolve, reject)=>{
            // NOTE: 'listening' event is only fired on success. Any error such as port already binded, is emitted via 'error'
            this.server.once("error", reject);
            this.server.listen(netConfig, resolve);
        });
        this.status = {
            ...this.status,
            code: TCPListenerStatusCode.ACTIVE
        };
        this.log("Listening on %s", this.server.address());
    }
    async pause(permanent) {
        if (!this.server.listening && this.status.code === TCPListenerStatusCode.PAUSED && permanent) {
            this.status = {
                code: TCPListenerStatusCode.INACTIVE
            };
            return;
        }
        if (!this.server.listening || this.status.code !== TCPListenerStatusCode.ACTIVE) return;
        this.log("Closing server on %s", this.server.address());
        // NodeJS implementation tracks listening status with `this._handle` property.
        // - Server.close() sets this._handle to null immediately. If this._handle is null, ERR_SERVER_NOT_RUNNING is thrown
        // - Server.listening returns `this._handle !== null` https://github.com/nodejs/node/blob/386d761943bb1b217fba27d6b80b658c23009e60/lib/net.js#L1675
        // - Server.listen() if `this._handle !== null` throws ERR_SERVER_ALREADY_LISTEN
        //
        // NOTE: Both listen and close are technically not async actions, so it's not necessary to track
        // states 'pending-close' or 'pending-listen'
        // From docs https://nodejs.org/api/net.html#serverclosecallback
        // Stops the server from accepting new connections and keeps existing connections.
        // 'close' event is emitted only emitted when all connections are ended.
        // The optional callback will be called once the 'close' event occurs.
        // We need to set this status before closing server, so other procedures are aware
        // during the time the server is closing
        this.status = permanent ? {
            code: TCPListenerStatusCode.INACTIVE
        } : {
            ...this.status,
            code: TCPListenerStatusCode.PAUSED
        };
        await new Promise((resolve, reject)=>{
            this.server.close((err)=>{
                err != null ? reject(err) : resolve();
            });
        });
    }
}

},{"net":"bXKEI","@libp2p/interface":"b14bx","./constants.js":"iXcJi","./socket-to-conn.js":"23NBN","./utils.js":"ixvqo","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"23NBN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toMultiaddrConnection", ()=>toMultiaddrConnection);
var _interface = require("@libp2p/interface");
var _ipPortToMultiaddr = require("@libp2p/utils/ip-port-to-multiaddr");
// @ts-expect-error no types
var _streamToIt = require("stream-to-it");
var _streamToItDefault = parcelHelpers.interopDefault(_streamToIt);
var _constantsJs = require("./constants.js");
var _utilsJs = require("./utils.js");
const toMultiaddrConnection = (socket, options)=>{
    const log = options.logger.forComponent("libp2p:tcp:socket");
    const metrics = options.metrics;
    const metricPrefix = options.metricPrefix ?? "";
    const inactivityTimeout = options.socketInactivityTimeout ?? (0, _constantsJs.SOCKET_TIMEOUT);
    const closeTimeout = options.socketCloseTimeout ?? (0, _constantsJs.CLOSE_TIMEOUT);
    // Check if we are connected on a unix path
    if (options.listeningAddr?.getPath() != null) options.remoteAddr = options.listeningAddr;
    if (options.remoteAddr?.getPath() != null) options.localAddr = options.remoteAddr;
    let remoteAddr;
    if (options.remoteAddr != null) remoteAddr = options.remoteAddr;
    else {
        if (socket.remoteAddress == null || socket.remotePort == null) // this can be undefined if the socket is destroyed (for example, if the client disconnected)
        // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#socketremoteaddress
        throw new (0, _interface.CodeError)("Could not determine remote address or port", "ERR_NO_REMOTE_ADDRESS");
        remoteAddr = (0, _ipPortToMultiaddr.ipPortToMultiaddr)(socket.remoteAddress, socket.remotePort);
    }
    const lOpts = (0, _utilsJs.multiaddrToNetConfig)(remoteAddr);
    const lOptsStr = lOpts.path ?? `${lOpts.host ?? ""}:${lOpts.port ?? ""}`;
    const { sink, source } = (0, _streamToItDefault.default).duplex(socket);
    // by default there is no timeout
    // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#socketsettimeouttimeout-callback
    socket.setTimeout(inactivityTimeout, ()=>{
        log("%s socket read timeout", lOptsStr);
        metrics?.increment({
            [`${metricPrefix}timeout`]: true
        });
        // only destroy with an error if the remote has not sent the FIN message
        let err;
        if (socket.readable) err = new (0, _interface.CodeError)("Socket read timeout", "ERR_SOCKET_READ_TIMEOUT");
        // if the socket times out due to inactivity we must manually close the connection
        // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#event-timeout
        socket.destroy(err);
    });
    socket.once("close", ()=>{
        log("%s socket close", lOptsStr);
        metrics?.increment({
            [`${metricPrefix}close`]: true
        });
        // In instances where `close` was not explicitly called,
        // such as an iterable stream ending, ensure we have set the close
        // timeline
        if (maConn.timeline.close == null) maConn.timeline.close = Date.now();
    });
    socket.once("end", ()=>{
        // the remote sent a FIN packet which means no more data will be sent
        // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#event-end
        log("%s socket end", lOptsStr);
        metrics?.increment({
            [`${metricPrefix}end`]: true
        });
    });
    const maConn = {
        async sink (source) {
            try {
                await sink(async function*() {
                    for await (const buf of source)if (buf instanceof Uint8Array) yield buf;
                    else yield buf.subarray();
                }());
            } catch (err) {
                // If aborted we can safely ignore
                if (err.type !== "aborted") // If the source errored the socket will already have been destroyed by
                // toIterable.duplex(). If the socket errored it will already be
                // destroyed. There's nothing to do here except log the error & return.
                log.error("%s error in sink", lOptsStr, err);
            }
            // we have finished writing, send the FIN message
            socket.end();
        },
        source,
        // If the remote address was passed, use it - it may have the peer ID encapsulated
        remoteAddr,
        timeline: {
            open: Date.now()
        },
        async close (options = {}) {
            if (socket.destroyed) {
                log("%s socket was already destroyed when trying to close", lOptsStr);
                return;
            }
            if (options.signal == null) {
                const signal = AbortSignal.timeout(closeTimeout);
                options = {
                    ...options,
                    signal
                };
            }
            try {
                log("%s closing socket", lOptsStr);
                await new Promise((resolve, reject)=>{
                    socket.once("close", ()=>{
                        // socket completely closed
                        log("%s socket closed", lOptsStr);
                        resolve();
                    });
                    socket.once("error", (err)=>{
                        log("%s socket error", lOptsStr, err);
                        // error closing socket
                        if (maConn.timeline.close == null) maConn.timeline.close = Date.now();
                        reject(err);
                    });
                    // shorten inactivity timeout
                    socket.setTimeout(closeTimeout);
                    // close writable end of the socket
                    socket.end();
                    if (socket.writableLength > 0) // there are outgoing bytes waiting to be sent
                    socket.once("drain", ()=>{
                        log("%s socket drained", lOptsStr);
                        // all bytes have been sent we can destroy the socket (maybe) before the timeout
                        socket.destroy();
                    });
                    else // nothing to send, destroy immediately, no need for the timeout
                    socket.destroy();
                });
            } catch (err) {
                this.abort(err);
            }
        },
        abort: (err)=>{
            log("%s socket abort due to error", lOptsStr, err);
            socket.destroy(err);
        },
        log
    };
    return maConn;
};

},{"@libp2p/interface":"b14bx","@libp2p/utils/ip-port-to-multiaddr":"i0hZ1","stream-to-it":"2BMc7","./constants.js":"iXcJi","./utils.js":"ixvqo","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"i0hZ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Errors", ()=>Errors);
/**
 * Transform an IP, Port pair into a multiaddr
 */ parcelHelpers.export(exports, "ipPortToMultiaddr", ()=>ipPortToMultiaddr);
var _isIp = require("@chainsafe/is-ip");
var _interface = require("@libp2p/interface");
var _multiaddr = require("@multiformats/multiaddr");
const Errors = {
    ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
    ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
    ERR_INVALID_IP: "ERR_INVALID_IP"
};
function ipPortToMultiaddr(ip, port) {
    if (typeof ip !== "string") throw new (0, _interface.CodeError)(`invalid ip provided: ${ip}`, Errors.ERR_INVALID_IP_PARAMETER); // eslint-disable-line @typescript-eslint/restrict-template-expressions
    if (typeof port === "string") port = parseInt(port);
    if (isNaN(port)) throw new (0, _interface.CodeError)(`invalid port provided: ${port}`, Errors.ERR_INVALID_PORT_PARAMETER);
    if ((0, _isIp.isIPv4)(ip)) return (0, _multiaddr.multiaddr)(`/ip4/${ip}/tcp/${port}`);
    if ((0, _isIp.isIPv6)(ip)) return (0, _multiaddr.multiaddr)(`/ip6/${ip}/tcp/${port}`);
    throw new (0, _interface.CodeError)(`invalid ip:port for creating a multiaddr: ${ip}:${port}`, Errors.ERR_INVALID_IP);
}

},{"@chainsafe/is-ip":"aTlfV","@libp2p/interface":"b14bx","@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}],"2BMc7":[function(require,module,exports) {
module.exports = require("e37e1107deed12a1");
module.exports.source = require("e37e1107deed12a1");
module.exports.sink = require("8a3763c4ecd996cf");
module.exports.transform = require("104d3a2235ae6119");
module.exports.duplex = require("a060aea4017d9f3f");

},{"e37e1107deed12a1":"h0rMn","8a3763c4ecd996cf":"bCENC","104d3a2235ae6119":"legES","a060aea4017d9f3f":"8yP1F"}],"h0rMn":[function(require,module,exports) {
module.exports = (readable)=>{
    // Node.js stream
    if (readable[Symbol.asyncIterator]) return readable;
    // Browser ReadableStream
    if (readable.getReader) return async function*() {
        const reader = readable.getReader();
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) return;
                yield value;
            }
        } finally{
            reader.releaseLock();
        }
    }();
    throw new Error("unknown stream");
};

},{}],"bCENC":[function(require,module,exports) {
const getIterator = require("c7812fed53e2da0d");
module.exports = (writable)=>async (source)=>{
        source = getIterator(source);
        const maybeEndSource = (source)=>{
            if (typeof source.return === "function") source.return();
        };
        let error = null;
        let errCb = null;
        const errorHandler = (err)=>{
            error = err;
            if (errCb) errCb(err);
            // When the writable errors, try to end the source to exit iteration early
            maybeEndSource(source);
        };
        let closeCb = null;
        let closed = false;
        const closeHandler = ()=>{
            closed = true;
            if (closeCb) closeCb();
        };
        let finishCb = null;
        let finished = false;
        const finishHandler = ()=>{
            finished = true;
            if (finishCb) finishCb();
        };
        let drainCb = null;
        const drainHandler = ()=>{
            if (drainCb) drainCb();
        };
        const waitForDrainOrClose = ()=>{
            return new Promise((resolve, reject)=>{
                closeCb = drainCb = resolve;
                errCb = reject;
                writable.once("drain", drainHandler);
            });
        };
        const waitForDone = ()=>{
            // Immediately try to end the source
            maybeEndSource(source);
            return new Promise((resolve, reject)=>{
                if (closed || finished || error) return resolve();
                finishCb = closeCb = resolve;
                errCb = reject;
            });
        };
        const cleanup = ()=>{
            writable.removeListener("error", errorHandler);
            writable.removeListener("close", closeHandler);
            writable.removeListener("finish", finishHandler);
            writable.removeListener("drain", drainHandler);
        };
        writable.once("error", errorHandler);
        writable.once("close", closeHandler);
        writable.once("finish", finishHandler);
        try {
            for await (const value of source){
                if (!writable.writable || writable.destroyed || error) break;
                if (writable.write(value) === false) await waitForDrainOrClose();
            }
        } catch (err) {
            // error is set by stream error handler so only destroy stream if source threw
            if (!error) writable.destroy();
            // could we be obscuring an error here?
            error = err;
        }
        try {
            // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)
            if (writable.writable) writable.end();
            // Wait until we close or finish. This supports halfClosed streams
            await waitForDone();
            // Notify the user an error occurred
            if (error) throw error;
        } finally{
            // Clean up listeners
            cleanup();
        }
    };

},{"c7812fed53e2da0d":"3doXZ"}],"3doXZ":[function(require,module,exports) {
// If the passed object is an (async) iterable, then get the iterator
// If it's probably an iterator already (i.e. has next function) return it
// else throw
module.exports = function getIterator(obj) {
    if (obj) {
        if (typeof obj[Symbol.iterator] === "function") return obj[Symbol.iterator]();
        if (typeof obj[Symbol.asyncIterator] === "function") return obj[Symbol.asyncIterator]();
        if (typeof obj.next === "function") return obj // probably an iterator
        ;
    }
    throw new Error("argument is not an iterator or iterable");
};

},{}],"legES":[function(require,module,exports) {
const toDuplex = require("a0fd1ead083b12a6");
module.exports = (transform)=>async function*(source) {
        const duplex = toDuplex(transform);
        // In a transform the sink and source are connected, an error in the sink
        // will be thrown in the source also. Catch the sink error to avoid unhandled
        // rejections and yield from the source.
        let sinkError;
        duplex.sink(source).catch((err)=>{
            sinkError = err;
        });
        yield* duplex.source;
        if (sinkError) throw sinkError;
    };

},{"a0fd1ead083b12a6":"8yP1F"}],"8yP1F":[function(require,module,exports) {
const toSink = require("d428cfcaddcfdc64");
const toSource = require("7512a22d9c7015e3");
module.exports = (duplex)=>({
        sink: toSink(duplex),
        source: toSource(duplex)
    });

},{"d428cfcaddcfdc64":"bCENC","7512a22d9c7015e3":"h0rMn"}],"ixvqo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multiaddrToNetConfig", ()=>multiaddrToNetConfig);
parcelHelpers.export(exports, "getMultiaddrs", ()=>getMultiaddrs);
parcelHelpers.export(exports, "isAnyAddr", ()=>isAnyAddr);
var _os = require("os");
var _osDefault = parcelHelpers.interopDefault(_os);
var _path = require("path");
var _pathDefault = parcelHelpers.interopDefault(_path);
var _multiaddr = require("@multiformats/multiaddr");
const ProtoFamily = {
    ip4: "IPv4",
    ip6: "IPv6"
};
function multiaddrToNetConfig(addr, config = {}) {
    const listenPath = addr.getPath();
    // unix socket listening
    if (listenPath != null) {
        if ((0, _osDefault.default).platform() === "win32") // Use named pipes on Windows systems.
        return {
            path: (0, _pathDefault.default).join("\\\\.\\pipe\\", listenPath)
        };
        else return {
            path: listenPath
        };
    }
    // tcp listening
    return {
        ...config,
        ...addr.toOptions()
    };
}
function getMultiaddrs(proto, ip, port) {
    const toMa = (ip)=>(0, _multiaddr.multiaddr)(`/${proto}/${ip}/tcp/${port}`);
    return (isAnyAddr(ip) ? getNetworkAddrs(ProtoFamily[proto]) : [
        ip
    ]).map(toMa);
}
function isAnyAddr(ip) {
    return [
        "0.0.0.0",
        "::"
    ].includes(ip);
}
const networks = (0, _osDefault.default).networkInterfaces();
function getNetworkAddrs(family) {
    const addresses = [];
    for (const [, netAddrs] of Object.entries(networks))if (netAddrs != null) {
        for (const netAddr of netAddrs)if (netAddr.family === family) addresses.push(netAddr.address);
    }
    return addresses;
}

},{"os":"6yyXu","path":"loE3o","@multiformats/multiaddr":"7Qpz2","@parcel/transformer-js/src/esmodule-helpers.js":"fD7H8"}]},["agbMw","judLg"], "judLg", "parcelRequire94c2")

//# sourceMappingURL=NormalAgent.js.map
